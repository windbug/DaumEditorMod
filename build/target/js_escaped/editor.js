
window.txEval = function(source, target){
	if (typeof source == "function") {
		return source.call(target || this);
	} else if (typeof source == "string") {
		return (target) ? target.eval(source) : this.eval(source);
	}
};
(function(){
try {
    EditorJSLoader.readyState = 'loading';
} catch(e) {
}
/**
 * Application scope variable
 *  
 */
var _DOC = document,
	_WIN = window,
	_DOC_EL = _DOC.documentElement,
	_FALSE = false,
	_TRUE = true,
	_NULL = null,
	_UNDEFINED;
/*
 json2.js
 2013-05-26

 Public Domain.

 NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

 See http://www.JSON.org/js.html


 This code should be minified before deployment.
 See http://javascript.crockford.com/jsmin.html

 USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
 NOT CONTROL.


 This file creates a global JSON object containing two methods: stringify
 and parse.

 JSON.stringify(value, replacer, space)
 value       any JavaScript value, usually an object or array.

 replacer    an optional parameter that determines how object
 values are stringified for objects. It can be a
 function or an array of strings.

 space       an optional parameter that specifies the indentation
 of nested structures. If it is omitted, the text will
 be packed without extra whitespace. If it is a number,
 it will specify the number of spaces to indent at each
 level. If it is a string (such as '\t' or '&nbsp;'),
 it contains the characters used to indent at each level.

 This method produces a JSON text from a JavaScript value.

 When an object value is found, if the object contains a toJSON
 method, its toJSON method will be called and the result will be
 stringified. A toJSON method does not serialize: it returns the
 value represented by the name/value pair that should be serialized,
 or undefined if nothing should be serialized. The toJSON method
 will be passed the key associated with the value, and this will be
 bound to the value

 For example, this would serialize Dates as ISO strings.

 Date.prototype.toJSON = function (key) {
 function f(n) {
 // Format integers to have at least two digits.
 return n < 10 ? '0' + n : n;
 }

 return this.getUTCFullYear()   + '-' +
 f(this.getUTCMonth() + 1) + '-' +
 f(this.getUTCDate())      + 'T' +
 f(this.getUTCHours())     + ':' +
 f(this.getUTCMinutes())   + ':' +
 f(this.getUTCSeconds())   + 'Z';
 };

 You can provide an optional replacer method. It will be passed the
 key and value of each member, with this bound to the containing
 object. The value that is returned from your method will be
 serialized. If your method returns undefined, then the member will
 be excluded from the serialization.

 If the replacer parameter is an array of strings, then it will be
 used to select the members to be serialized. It filters the results
 such that only members with keys listed in the replacer array are
 stringified.

 Values that do not have JSON representations, such as undefined or
 functions, will not be serialized. Such values in objects will be
 dropped; in arrays they will be replaced with null. You can use
 a replacer function to replace those with JSON values.
 JSON.stringify(undefined) returns undefined.

 The optional space parameter produces a stringification of the
 value that is filled with line breaks and indentation to make it
 easier to read.

 If the space parameter is a non-empty string, then that string will
 be used for indentation. If the space parameter is a number, then
 the indentation will be that many spaces.

 Example:

 text = JSON.stringify(['e', {pluribus: 'unum'}]);
 // text is '["e",{"pluribus":"unum"}]'


 text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
 // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

 text = JSON.stringify([new Date()], function (key, value) {
 return this[key] instanceof Date ?
 'Date(' + this[key] + ')' : value;
 });
 // text is '["Date(---current time---)"]'


 JSON.parse(text, reviver)
 This method parses a JSON text to produce an object or array.
 It can throw a SyntaxError exception.

 The optional reviver parameter is a function that can filter and
 transform the results. It receives each of the keys and values,
 and its return value is used instead of the original value.
 If it returns what it received, then the structure is not modified.
 If it returns undefined then the member is deleted.

 Example:

 // Parse the text. Values that look like ISO date strings will
 // be converted to Date objects.

 myData = JSON.parse(text, function (key, value) {
 var a;
 if (typeof value === 'string') {
 a =
 /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
 if (a) {
 return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
 +a[5], +a[6]));
 }
 }
 return value;
 });

 myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
 var d;
 if (typeof value === 'string' &&
 value.slice(0, 5) === 'Date(' &&
 value.slice(-1) === ')') {
 d = new Date(value.slice(5, -1));
 if (d) {
 return d;
 }
 }
 return value;
 });


 This is a reference implementation. You are free to copy, modify, or
 redistribute.
 */

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
 call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
 getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
 lastIndex, length, parse, prototype, push, replace, slice, stringify,
 test, toJSON, toString, valueOf
 */


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (typeof JSON !== 'object') {
	JSON = {};
}

(function () {
	'use strict';

	function f(n) {
		// Format integers to have at least two digits.
		return n < 10 ? '0' + n : n;
	}

	if (typeof Date.prototype.toJSON !== 'function') {

		Date.prototype.toJSON = function () {

			return isFinite(this.valueOf())
				? this.getUTCFullYear()     + '-' +
				f(this.getUTCMonth() + 1) + '-' +
				f(this.getUTCDate())      + 'T' +
				f(this.getUTCHours())     + ':' +
				f(this.getUTCMinutes())   + ':' +
				f(this.getUTCSeconds())   + 'Z'
				: null;
		};

		String.prototype.toJSON      =
			Number.prototype.toJSON  =
				Boolean.prototype.toJSON = function () {
					return this.valueOf();
				};
	}

	var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
		escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
		gap,
		indent,
		meta = {    // table of character substitutions
			'\b': '\\b',
			'\t': '\\t',
			'\n': '\\n',
			'\f': '\\f',
			'\r': '\\r',
			'"' : '\\"',
			'\\': '\\\\'
		},
		rep;


	function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

		escapable.lastIndex = 0;
		return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
			var c = meta[a];
			return typeof c === 'string'
				? c
				: '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
		}) + '"' : '"' + string + '"';
	}


	function str(key, holder) {

// Produce a string from holder[key].

		var i,          // The loop counter.
			k,          // The member key.
			v,          // The member value.
			length,
			mind = gap,
			partial,
			value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

		if (value && typeof value === 'object' &&
			typeof value.toJSON === 'function') {
			value = value.toJSON(key);
		}

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

		if (typeof rep === 'function') {
			value = rep.call(holder, key, value);
		}

// What happens next depends on the value's type.

		switch (typeof value) {
			case 'string':
				return quote(value);

			case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

				return isFinite(value) ? String(value) : 'null';

			case 'boolean':
			case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

				return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

			case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

				if (!value) {
					return 'null';
				}

// Make an array to hold the partial results of stringifying this object value.

				gap += indent;
				partial = [];

// Is the value an array?

				if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

					length = value.length;
					for (i = 0; i < length; i += 1) {
						partial[i] = str(i, value) || 'null';
					}

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

					v = partial.length === 0
						? '[]'
						: gap
						? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
						: '[' + partial.join(',') + ']';
					gap = mind;
					return v;
				}

// If the replacer is an array, use it to select the members to be stringified.

				if (rep && typeof rep === 'object') {
					length = rep.length;
					for (i = 0; i < length; i += 1) {
						if (typeof rep[i] === 'string') {
							k = rep[i];
							v = str(k, value);
							if (v) {
								partial.push(quote(k) + (gap ? ': ' : ':') + v);
							}
						}
					}
				} else {

// Otherwise, iterate through all of the keys in the object.

					for (k in value) {
						if (Object.prototype.hasOwnProperty.call(value, k)) {
							v = str(k, value);
							if (v) {
								partial.push(quote(k) + (gap ? ': ' : ':') + v);
							}
						}
					}
				}

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

				v = partial.length === 0
					? '{}'
					: gap
					? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
					: '{' + partial.join(',') + '}';
				gap = mind;
				return v;
		}
	}

// If the JSON object does not yet have a stringify method, give it one.

	if (typeof JSON.stringify !== 'function') {
		JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

			var i;
			gap = '';
			indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

			if (typeof space === 'number') {
				for (i = 0; i < space; i += 1) {
					indent += ' ';
				}

// If the space parameter is a string, it will be used as the indent string.

			} else if (typeof space === 'string') {
				indent = space;
			}

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

			rep = replacer;
			if (replacer && typeof replacer !== 'function' &&
				(typeof replacer !== 'object' ||
					typeof replacer.length !== 'number')) {
				throw new Error('JSON.stringify');
			}

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

			return str('', {'': value});
		};
	}


// If the JSON object does not yet have a parse method, give it one.

	if (typeof JSON.parse !== 'function') {
		JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

			var j;

			function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

				var k, v, value = holder[key];
				if (value && typeof value === 'object') {
					for (k in value) {
						if (Object.prototype.hasOwnProperty.call(value, k)) {
							v = walk(value, k);
							if (v !== undefined) {
								value[k] = v;
							} else {
								delete value[k];
							}
						}
					}
				}
				return reviver.call(holder, key, value);
			}


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

			text = String(text);
			cx.lastIndex = 0;
			if (cx.test(text)) {
				text = text.replace(cx, function (a) {
					return '\\u' +
						('0000' + a.charCodeAt(0).toString(16)).slice(-4);
				});
			}

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

			if (/^[\],:{}\s]*$/
				.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
					.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
					.replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

				j = txEval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

				return typeof reviver === 'function'
					? walk({'': j}, '')
					: j;
			}

// If the text is not JSON parseable, then a SyntaxError is thrown.

			throw new SyntaxError('JSON.parse');
		};
	}
}());

/** @namespace */
var $tx = {}; 
(function() {
	/**
	 * @function
	 */
	Object.extend = function(destination, source) {
		for (var property in source) {
			destination[property] = source[property];
		}
		return destination;
	};
	
	_WIN.Class = {
		create: function() {
			return function() {
				this.initialize.apply(this, arguments);
			};
		}
	};
	/**
	 * @class
	 */
	_WIN.$break = {};
	/**
	 * \ud568\uc218(=\uba54\uc18c\ub4dc) \uc18c\uc720\uc790 \uac1d\uccb4\ub85c \ubbf8\ub9ac \ubb36\ub294 \ud568\uc218\uc758 \uc778\uc2a4\ud134\uc2a4\ub97c \ubc18\ud658. \ubc18\ud658\ub41c \ud568\uc218\ub294 \uc6d0\ub798\uc758 \uac83\uacfc \uac19\uc740 \uc778\uc790\ub97c \uac00\uc9c8 \uac83\uc774\ub2e4.
	 * @function
	 */
	Function.prototype.bind = function() {
		var __method = this, args = $A(arguments), object = args.shift();
		return function() {
			return __method.apply(object, args.concat($A(arguments)));
		};
	};
	/**
	 * \uc720\ud558\ub294 \uac1d\uccb4 \ud568\uc218(=\uba54\uc18c\ub4dc) \uc18c\uc720\uc790 \uac1d\uccb4\ub85c \ubbf8\ub9ac \ubb36\ub294 \ud568\uc218\uc758 \uc778\uc2a4\ud134\uc2a4\ub97c \ubc18\ud658. \ubc18\ud658\ub41c \ud568\uc218\ub294 \uc774\uac83\uc758 \uc778\uc790\ub85c \ud604\uc7ac \uc774\ubca4\ud2b8 \uac1d\uccb4\ub97c \uac00\uc9c8\uac83\uc774\ub2e4.
	 * @function
	 */
	Function.prototype.bindAsEventListener = function() {
		var __method = this, args = $A(arguments), object = args.shift();
		return function(event) {
			return __method.apply(object, [event || _WIN.event].concat(args));
		};
	};

	var txlib = function(element) {
		var args = arguments;
		if (args.length > 1) {
			for (var i = 0, elements = [], length = args.length; i < length; i++) 
				elements.push($tx(args[i]));
			return elements;
		}
		if (typeof element == 'string') {
			element = _DOC.getElementById(element);
		}
		return element;
	};
	$tx = txlib;

    var dateNow = Date.now || function() { return new Date().getTime(); };
    Object.extend($tx, {
        throttle: function(func, wait, options) {
            var context, args, result;
            var timeout = null;
            var previous = 0;
            options || (options = {});
            var later = function() {
                previous = options.leading === false ? 0 : dateNow();
                timeout = null;
                result = func.apply(context, args);
                context = args = null;
            };
            return function() {
                var now = dateNow();
                if (!previous && options.leading === false) previous = now;
                var remaining = wait - (now - previous);
                context = this;
                args = arguments;
                if (remaining <= 0) {
                    clearTimeout(timeout);
                    timeout = null;
                    previous = now;
                    result = func.apply(context, args);
                    context = args = null;
                } else if (!timeout && options.trailing !== false) {
                    timeout = setTimeout(later, remaining);
                }
                return result;
            };
        },
        debounce: function(func, wait, immediate) {
            var timeout, args, context, timestamp = 0, result;

            var later = function() {
                var last = dateNow() - timestamp;

                if (last < wait && last >= 0) {
                    timeout = setTimeout(later, wait - last);
                } else {
                    timeout = null;
                    if (!immediate) {
                        result = func.apply(context, args);
                        if (!timeout) context = args = null;
                    }
                }
            };

            return function() {
                context = this;
                args = arguments;
                timestamp = dateNow();
                var callNow = immediate && !timeout;
                if (!timeout) timeout = setTimeout(later, wait);
                if (callNow) {
                    result = func.apply(context, args);
                    context = args = null;
                }

                return result;
            };
        }
    });

	var txua = navigator.userAgent.toLowerCase();
	var isExistAgentString = function(str){
		return txua.indexOf(str)!=-1;
	};
    var isExistAgentStringByRegx = function(regx){
        return regx.test(txua);
    };
    /**
     * goog \ucf54\ub4dc \ud638\ucd9c
     * type \ud655\uc778 \ud568\uc218
     */
    Object.extend($tx, {
        isArray: function(v){ return goog.isArray(v)},
        isArrayLike: function(v){ return goog.isArrayLike(v)},
        isString:function(v){ return goog.isString(v)},
        isBoolean: function(v){ return goog.isBoolean(v)},
        isNumber: function(v){ return goog.isNumber(v)},
        isFunction: function(v){ return goog.isFunction(v)},
        isObject: function(v){ return goog.isObject(v)}
    });

	Object.extend($tx, /** @lends $tx */{
		/**
		 * Chrome browser \uc774\uba74 true
		 * @field
		 */
		chrome: isExistAgentString("chrome"),
		/**
		 * safari browser \uc774\uba74 true 
		 * @field
		 */
		safari: isExistAgentString("safari") && isExistAgentString("chrome") == _FALSE,
		/**
		 * Firefox browser \uc774\uba74 true 
		 * @field
		 */
		gecko: isExistAgentString("firefox"),
		/**
		 * Firefox browser\uc758 \ubc84\uc804 
		 * @field
		 */
		gecko_ver: isExistAgentString("firefox")?parseFloat(txua.replace(/.*firefox\/([\d\.]+).*/g,"$1")):0,
		/**
		 * MS IE \uc774\uba74 true
         * IE7 \uc774\ud558\ub294 msie\ub85c \uad6c\ubd84
         * IE8 \uc774\uc0c1\uc740 trident\ub85c \uad6c\ubd84
		 * @field
		 */
        msie: isExistAgentString("msie") || isExistAgentString("trident"),
		/**
		 * MS IE browser \ubc84\uc804 a.match(/rv:(\d+)\.\d+/)
         * IE7 \uc774\ud558\ub294 msie\ub85c \uad6c\ubd84
         * IE8 \uc774\uc0c1\uc740 trident & rv:x\ub85c \uad6c\ubd84
		 * @field
		 */
        msie_ver: isExistAgentString("msie") || isExistAgentString("trident")?(function(){
            return isExistAgentString("msie") ? parseFloat(txua.split("msie")[1]) : parseFloat(txua.split("rv:")[1]);
        })():0,
        /**
         * MS IE document mode \ubc84\uc804
         * @field
         */
        msie_docmode: _DOC.documentMode || 0,
		/**
		 * AppleWebKit browser \uc774\uba74 true 
		 * @field
		 */
		webkit: isExistAgentString("applewebkit"),
		/**
		 * AppleWebKit \ubc84\uc804
		 * @field
		 */
		webkit_ver: isExistAgentString("applewebkit")?parseFloat(txua.replace(/.*safari\//g,"")):0,
		/**
		 * Opera \uc774\uba74 true 
		 * @field
		 */
		opera: isExistAgentString("opera"),
		 /**  
 	      * Presto browser \uc774\uba74 true   
		  * @field  
		  */
		presto: isExistAgentString("presto"),
		os_win: isExistAgentString("win"),
        os_win7: isExistAgentString('windows nt 6.1'),
        os_win8: isExistAgentString('windows nt 6.2'),
        os_win8_1: isExistAgentString('windows nt 6.3'),
		os_mac: isExistAgentString("mac"),
		/**
		 * iPhone \uc774\uba74 true 
		 * @field
		 */
		iphone: isExistAgentString("iphone"),
		/**
		 * iPod \uc774\uba74 true 
		 * @field
		 */
		ipod: isExistAgentString("ipod"),
		/**
		 * iPad \uc774\uba74 true 
		 * @field
		 */
		ipad: isExistAgentString("ipad"),
		/**
		 * iPhone, iPod Touch, iPad \uc774\uba74 true (\uc560\ud50c \ubaa8\ubc14\uc77c OS)
		 */
		ios: isExistAgentString("like mac os x") && isExistAgentString("mobile"),
		/**
		 * iPhone, iPod Touch, iPad \uc758 iOS \ubc84\uc804
		 */
		ios_ver: (isExistAgentString("like mac os x") && isExistAgentString("mobile")) ? parseFloat(txua.replace(/^.*os (\d+)([_\d]*) .*$/g, "$1.$2").replace(/_/g, "")) : 0,
		/**
		 * Android \uc774\uba74 true
		 */
		android: isExistAgentString("android"),
		/**
		 * Android OS \ubc84\uc804
		 */
		android_ver: isExistAgentString("android") ? parseFloat(txua.replace(/.*android[\s]*([\d\.]+).*/g, "$1")) : 0,
		/**
		 *  BlackBerry \uc774\uba74 true
		 */
		blackberry: isExistAgentString("blackberry"),
		/**
		 *  Windows Phone OS \uc774\uba74 true
		 */
		winphone: isExistAgentString("windows phone os"),
		/**
		 *  Windows CE \uc774\uba74 true
		 */
		wince: isExistAgentString("windows ce")
	});

    Object.extend($tx, /** @lends $tx */{
        //msie11above: (isExistAgentString("trident") && isExistAgentStringByRegx(/rv:\d+\.\d+/)),//@Deprecated $tx.msie11above
        msie_std: ($tx.msie && !_DOC.selection),
        msie_nonstd: ($tx.msie && !!_DOC.selection),
        msie6: ($tx.msie && 6 <= $tx.msie_ver && $tx.msie_ver < 7),
        msie8under: ($tx.msie && $tx.msie_ver <= 8),
        msie10under: ($tx.msie && $tx.msie_ver <= 10),
        msie_quirks: (function(){
            try {
                return $tx.msie && _WIN.top.document.compatMode !== 'CSS1Compat'
            } catch(e) {
                try {
                    return _DOC.compatMode !== 'CSS1Compat'
                } catch(e) {
                    return _FALSE;
                }
            }
        })()
    });

	Object.extend($tx, /** @lends $tx */{
		extend: Object.extend,
		/**
		 * browser\uc758 \uc774\ub984 \ub9ac\ud134
		 * @function
		 */
		browser: function() {
			if($tx.msie) {
				return 'msie';
			} else if($tx.gecko) {
				return 'firefox';
			} else if($tx.chrome) {
				return 'chrome';
			} else if($tx.webkit) {
				return 'safari';
			} else if($tx.opera) {
				return 'opera';
			} else {
				return "";
			}
		}()
	});
	
	/**
	 * @function
	 */
	_WIN.$must = function(id, className) {
		var _el = $tx(id);
		if (!_el) {
			throw new Error("[Exception] " + className + ": cannot find element: id='" + id + "'");
		}
		return _el;
	};
	
	//expose
	_WIN.txlib = txlib;
})();

(function() {
	/**
	 * template
	 * @deprecated
	(function() {
		window.Template = Class.create();
		Template.Pattern = /(^|.|\r|\n)(#\{(.*?)\}|#%7B(.*?)%7D)/;
		Template.prototype = {
			initialize: function(template, pattern) {
				this.template = template.toString();
				this.pattern = pattern || Template.Pattern;
			},
			evaluate: function(object) {
				return this.template.gsub(this.pattern, function(match) {
					var before = match[1];
					if (before == '\\')
						return match[2];
					return before + String.interpret(object[match[3] || match[4]]);
				});
			}
		};
	})();
	*/

	$tx.extend($tx, /** @lends $tx */{
		/**
		 * \uc8fc\uc5b4\uc9c4 element\uc640 \uad00\ub828\ub41c CSS \ud074\ub798\uc2a4\uba85\uc744 \ud45c\uc2dc\ud558\ub294 Element.ClassNames \uac1d\uccb4\ub97c \ubc18\ud658
		 * @function
		 */
		classNames: function(el) {
			return el.className.split(' ');
		},
		/**
		 * \uc694\uc18c\uac00 class\uba85\uc911\uc5d0 \ud558\ub098\ub85c \uc8fc\uc5b4\uc9c4 class\uba85\uc744 \uac00\uc9c4\ub2e4\uba74 true\ub97c \ubc18\ud658
		 * @function
		 */
		hasClassName: function(el, className) {
            if (className && el.className) {
                var classNames = el.className.split(/\s+/);
                return classNames.contains(className);
            }
            return _FALSE;
        },
		/**
		 * \uc8fc\uc5b4\uc9c4 class\uba85\uc744 \uc694\uc18c\uc758 class\uba85\uc73c\ub85c \ucd94\uac00
		 * @function
		 */
		addClassName: function(el, c) {
			if (!this.hasClassName(el, c)) {
				el.className += ' ' + c;
            }
		},
		/**
		 * \uc694\uc18c\uc758 class\uba85\uc73c\ub85c \ubd80\ud130 \uc8fc\uc5b4\uc9c4 class\uba85\uc744 \uc81c\uac70
		 * @function
		 */
		removeClassName: function(el, className) {
			var classNames = el.className.split(/\s+/);
            el.className = classNames.without(className)
                                     .compact()
                                     .join(' ');
		},
		/**
		 * \uc694\uc18c\uac00 \ub208\uc5d0 \ubcf4\uc774\ub294\uc9c0 \ud45c\uc2dc\ud558\ub294 Boolean\uac12\uc744 \ubc18\ud658
		 * @function
		 */
		visible: function(element) {
			//return $tx(element).style.display != 'none';
			return $tx.getStyle(element, "display" ) != 'none';
		},
		/**
		 * \uac01\uac01\uc758 \uc804\ub2ec\ub41c \uc694\uc18c\uc758 \uac00\uc2dc\uc131(visibility)\uc744 \ud1a0\uae00(toggle)\ud55c\ub2e4.
		 * @function
		 */
		toggle: function(element) {
			element = $tx(element);
			$tx[$tx.visible(element) ? 'hide' : 'show'](element);
			return element;
		},
		/**
		 * style.display\ub97c 'block'\ub85c \uc14b\ud305\ud558\uc5ec \uac01\uac01\uc758 \uc694\uc18c\ub97c \ubcf4\uc5ec\uc900\ub2e4.
		 * @function
		 */
		show: function(element) {
			$tx(element).style.display = 'block';
			return element;
		},
		/**
		 * style.display\ub97c 'none'\ub85c \uc14b\ud305\ud558\uc5ec \uac01\uac01\uc758 \uc694\uc18c\ub97c \uc228\uae34\ub2e4.
		 * @function
		 */
		hide: function(element) {
			$tx(element).style.display = 'none';
			return element;
		}
	});
})();

$tx.extend($tx, /** @lends $tx */{
    /**
     * \uc778\uc790\ub85c \ub118\uaca8 \ubc1b\uc740 Element\uc758 style \uc18d\uc131\uac12\uc744 \ub9ac\ud134\ud55c\ub2e4.
     * @function
     * @param {HTMLElement} element
     * @param {string} style property name
     */
    getStyle: function(element, style) {
        element = $tx(element);
        style = style == 'float' ? 'cssFloat' : style.camelize();
        var value = element.style[style];
        if (!value) {
            var css = _DOC.defaultView.getComputedStyle(element, _NULL);
            value = css ? css[style] : _NULL;
        }
        if (style == 'opacity')
            return value ? parseFloat(value) : 1.0;
        return value == 'auto' ? _NULL : value;
    },

    /**
     * \uc694\uc18c\uc758 style \uc18d\uc131\uc744 \uc14b\ud305\ud55c\ub2e4.
     * @function
     */
    setStyle: function(element, styles, camelized) {
        element = $tx(element);
        var elementStyle = element.style;
        for (var property in styles) {
            if (styles.hasOwnProperty(property)) {
                if (property === 'opacity') {
                    $tx.setOpacity(element, styles[property]);
                } else {
                    // TODO What the...
                    elementStyle[(property === 'float' || property === 'cssFloat') ? (elementStyle.styleFloat === _UNDEFINED ? 'cssFloat' : 'styleFloat') : (camelized ? property : property.camelize())] = styles[property];
                }
            }
        }
        // TODO is it necessary?
        return element;
    },

    setStyleProperty: function(element, styles) {
        var isCamelizedPropertyName = _TRUE;
        this.setStyle(element, styles, isCamelizedPropertyName);
    },

    /**
     * \uc694\uc18c\uc758 style\uc18d\uc131 \uc911 opacity \uac12\uc744 \ub9ac\ud134\ud55c\ub2e4.
     * @function
     */
    getOpacity: function(element) {
        return $tx(element).getStyle('opacity');
    },

    /**
     * \uc694\uc18c\uc758 opacity style \uc18d\uc131\uc744 \uc14b\ud305\ud55c\ub2e4.
     * @function
     */
    setOpacity: function(element, value) {
        element = $tx(element);
        element.style.opacity = (value == 1 || value === '') ? '' : (value < 0.00001) ? 0 : value;
        return element;
    },

    applyCSSText: function(targetDocument, cssText) {
        var styleElement = targetDocument.createElement('style');
        styleElement.setAttribute("type", "text/css");
        if (styleElement.styleSheet) { // IE
            styleElement.styleSheet.cssText = cssText;
        } else { // the other
            styleElement.textContent = cssText;
        }
        targetDocument.getElementsByTagName('head')[0].appendChild(styleElement);
    }

});
(function() {

	if ($tx.msie8under) {
        $tx.getStyle = function (element, style) {
            element = $tx(element);
            style = (style == 'float' || style == 'cssFloat') ? 'styleFloat' : style.camelize();
            var value = element.style[style];
            if (!value && element.currentStyle)
                value = element.currentStyle[style];
            if (style == 'opacity') {
                if (value = ($tx.getStyle(element, 'filter') || '').match(/alpha\(opacity=(.*)\)/))
                    if (value[1])
                        return parseFloat(value[1]) / 100;
                return 1.0;
            }
            if (value == 'auto') {
                if ((style == 'width' || style == 'height') && ($tx.getStyle(element, 'display') != 'none')) {
                    return element['offset' + style.capitalize()] + 'px';
                }
                return _NULL;
            }
            return value;
        };
    }

    if ($tx.msie8under) {
        $tx.setOpacity = function (element, value) {
            element = $tx(element);
            var filter = $tx.getStyle(element, 'filter'), style = element.style;
            if (value == 1 || value === '') {
                style.filter = filter.replace(/alpha\([^\)]*\)/gi, '');
                return element;
            } else if (value < 0.00001)
                value = 0;
            style.filter = filter.replace(/alpha\([^\)]*\)/gi, '') +
                    'alpha(opacity=' +
                    (value * 100) +
                    ')';
            return element;
        };
    }

    if ($tx.gecko) {
		$tx.extend($tx, {
			setOpacity: function(element, value) {
				element = $tx(element);
				element.style.opacity = (value == 1) ? 0.999999 : (value === '') ? '' : (value < 0.00001) ? 0 : value;
				return element;
			}
		});
	}


    // json2.js helper functions
    $tx.JSONHelper = {
        /**
         * JSON.stringify \uc2dc\uc5d0 \ubb38\uc790\uc5f4\uc744 encodeURIComponent \ucc98\ub9ac \ud558\uc5ec\uc900\ub2e4.
         * @example JSON.stringify(object, $tx.JSONHelper.encodeURIComponentReplacer);
         */
        encodeURIComponentReplacer: function (key, value) {
            if (typeof value === 'string') {
                if (!isStringifiedArray(value)) {
                    return encodeURIComponent(value);
                }
            }
            return value;
        },
        /**
         * JSON.parse \uc2dc\uc5d0 \ubb38\uc790\uc5f4\uc744 decodeURIComponent \ucc98\ub9ac \ud558\uc5ec\uc900\ub2e4.
         * @example JSON.parse(object, $tx.JSONHelper.decodeURIComponentReviver);
         */
        decodeURIComponentReviver: function (key, value) {
            if (typeof value === 'string') {
                if (!isStringifiedArray(value)) {
                    return decodeURIComponent(value);
                } else {
                    // "{ \"string\": \"[1,2,3]\" }" \uc758 \uacbd\uc6b0 => { "string": [1, 2, 3] } \uc73c\ub85c \ud30c\uc2f1\ub41c\ub2e4.
                    // WHY???
                    try {
                        // "[\ub9d0\uba38\ub9ac]" \uc640 \uac19\uc740 \uac12\uc740 \ud30c\uc2f1 \uc911 \uc624\ub958\uac00 \ubc1c\uc0dd\ud55c\ub2e4. \uc774\ub7f0 \uacbd\uc6b0\ub294 \ubb34\uc2dc\ud558\uace0 value\ub97c \uadf8\ub300\ub85c \ubc18\ud658\ud558\ub3c4\ub85d \ud55c\ub2e4. #FTDUEDTR-1432
                        return JSON.parse(value, arguments.callee);
                    } catch(ignore) {}
                }
            }
            return value;
        }
    };

    // \uc774 \ubb38\uc790\uc5f4\uc774 "[1, 3, 4]" \uc640 \uac19\uc774 \ubc30\uc5f4\uc744 Stringify \ud55c \uac83\uc778\uc9c0 \ud655\uc778\ud55c\ub2e4
    var isStringifiedArray = function (str) {
        if (str.charAt(0) == "[" && str.charAt(str.length - 1) == "]") {
            try{
                JSON.parse(str);
                return true;
            }catch (ignore) {}
        }
        return false;
    };
})();

//position
(function() {
	$tx.extend($tx, /** @lends $tx */ {
		/**
		 * \uc694\uc18c\uc758 \ucd5c\uc0c1\uc704 \uc694\uc18c\uae4c\uc9c0\uc758 offset position \uc744 \ub354\ud55c \uac12\uc744 \ub9ac\ud134\ud55c\ub2e4.
		 * @function
		 */
		cumulativeOffset: function(element) {
			var valueT = 0, valueL = 0;
			do {
				valueT += element.offsetTop || 0;
				valueL += element.offsetLeft || 0;
				element = element.offsetParent;
			} while (element);
			return [valueL, valueT];
		},
		/**
		 * \uc694\uc18c\uc758 \ucd5c\uc0c1\uc704 \uc694\uc18c\uae4c\uc9c0\uc758 offset position \uc744 \ub354\ud55c \uac12\uc744 \ub9ac\ud134\ud55c\ub2e4.
		 * \uc0c1\uc704 \uc694\uc18c\uac00 body\uc774\uac70\ub098 position\uc774 relative \ub610\ub294 absolute \uc778 \uacbd\uc6b0 \uacc4\uc0b0\uc744 \uc911\uc9c0\ud55c\ub2e4.
		 * @function
		 */
		positionedOffset: function(element) {
			var valueT = 0, valueL = 0;
			do {
				valueT += element.offsetTop || 0;
				valueL += element.offsetLeft || 0;
				element = element.offsetParent;
				if (element) {
					if (element.tagName == 'BODY') 
						break;
					var p = $tx.getStyle(element, 'position');
					if (p == 'relative' || p == 'absolute') 
						break;
				}
			} while (element);
			return [valueL, valueT];
		},
		/**
		 * element\uc758 \uba74\uc801(dimensions)\uc744 \ubc18\ud658. \ubc18\ud658\ub41c \uac12\uc740 \ub450\uac1c\uc758 \ud504\ub77c\ud37c\ud2f0(height \uc640 width)\ub97c \uac00\uc9c0\ub294 \uac1d\uccb4\uc774\ub2e4. 
		 * @function
		 */
		getDimensions: function(element) {
		    var display = $tx.getStyle(element, 'display');
		    if (display != 'none' && display != _NULL) // Safari bug
		      return {width: element.offsetWidth, height: element.offsetHeight};
		
		    // All *Width and *Height properties give 0 on elements with display none,
		    // so enable the element temporarily
		    var els = element.style;
		    var originalVisibility = els.visibility;
		    var originalPosition = els.position;
		    var originalDisplay = els.display;
		    els.visibility = 'hidden';
		    els.position = 'absolute';
		    els.display = 'block';
		    var originalWidth = element.clientWidth;
		    var originalHeight = element.clientHeight;
		    els.display = originalDisplay;
		    els.position = originalPosition;
		    els.visibility = originalVisibility;
		    return {width: originalWidth, height: originalHeight};
		},
	 
	   /**
	   * \uc694\uc18c\uc758 \ucd5c\uc0c1\uc704 \uc694\uc18c\uae4c\uc9c0\uc758 offset position \uc744 \ub354\ud55c \uac12\uc744 \ub9ac\ud134\ud55c\ub2e4.
	   * \uc0c1\uc704 \uc694\uc18c\uac00 body\uc774\uac70\ub098 position\uc774 relative \ub610\ub294 absolute \uc778 \uacbd\uc6b0 \uacc4\uc0b0\uc744 \uc911\uc9c0\ud55c\ub2e4.
	   * left, top, right, bottom \uac12\uc744 \ub9ac\ud134\ud55c\ub2e4.
	   * @function
	   */ 
		getCoords : function(e, useOffset) {
			var uo = useOffset || false;
			var	w = e.offsetWidth;
			var	h = e.offsetHeight;
			var	coords = { "left": 0, "top": 0, "right": 0, "bottom": 0 };
			var	p;
			while(e){
				coords.left += e.offsetLeft || 0;
				coords.top += e.offsetTop || 0;
				e = e.offsetParent;
				if(uo){
					if(e){
						if(e.tagName == "BODY"){break;}
						p = $tx.getStyle(e, "position");
						if(p !== "static"){break;}
					}
				}
			}
			coords.right = coords.left + w;
			coords.bottom = coords.top + h;
			return coords;
		},
	 
		getCoordsTarget: function(element){
			return this.getCoords(element, _TRUE);
		},
        /**
         * \ud5a5\uc0c1\ub41c getCoord Jquery \ucc38\uace0
         */
        getOffset: function(node){
            var doc = node.ownerDocument;
            if ("getBoundingClientRect" in doc.documentElement) {
                var docElem = doc.documentElement;
                var win = doc.defaultView || doc.parentWindow;
                var box = node.getBoundingClientRect();
                var ot = (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop||0);
                var or = (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft||0);
                return {
                    'top': box.top + ot,
                    'bottom': box.bottom + ot,
                    'left': box.left + or,
                    'right': box.right + or
                }
            }else {
                return $tx.getCoordsTarget(node);
            }
        }
	 
	});


	
	// Safari returns margins on body which is incorrect if the child is absolutely
	// positioned.  For performance reasons, redefine Position.cumulativeOffset for
	// KHTML/WebKit only.
	if ($tx.webkit) {
		$tx.cumulativeOffset = function(element) {
			var valueT = 0, valueL = 0;
			do {
				valueT += element.offsetTop || 0;
				valueL += element.offsetLeft || 0;
				if (element.offsetParent == _DOC.body) 
					if ($tx.getStyle(element, 'position') == 'absolute') 
						break;
				element = element.offsetParent;
			} while (element);
			return [valueL, valueT];
		};
	}
	
})();

//events
(function () /** @lends $tx */ {
	$tx.extend($tx, {
		/** @field backspace key */
		KEY_BACKSPACE: 8,
		/** @field tab key */
		KEY_TAB: 9,
		/** @field return key */
		KEY_RETURN: 13,
		/** @field esc key */
		KEY_ESC: 27,
		/** @field left key */
		KEY_LEFT: 37,
		/** @field up key */
		KEY_UP: 38,
		/** @field right key */
		KEY_RIGHT: 39,
		/** @field down key */
		KEY_DOWN: 40,
		/** @field delete key */
		KEY_DELETE: 46,
		/** @field home key */
		KEY_HOME: 36,
		/** @field end key */
		KEY_END: 35,
		/** @field pageup key */
		KEY_PAGEUP: 33,
		/** @field pagedown key */
		KEY_PAGEDOWN: 34,
		/**
		 * \uc774\ubca4\ud2b8\uc758 target \ub610\ub294 srcElement \ub97c \ubc18\ud658
		 * @function
		 */
		element: function(event) {
			return $tx(event.target || event.srcElement);
		},
		/**
		 * \ub9c8\uc6b0\uc2a4 \uc67c\ucabd \ubc84\ud2bc\uc744 \ud074\ub9ad\uc2dc true\uac12 \ubc18\ud658
		 * @function
		 */
		isLeftClick: function(event) {
			return (((event.which) && (event.which == 1)) ||
			((event.button) && (event.button == 1)));
		},
		/**
		 * \ud398\uc774\uc9c0\uc5d0\uc11c \ub9c8\uc6b0\uc2a4 \ud3ec\uc778\ud130\uc758 x\uce21 \uc88c\ud45c\uac12 \ubc18\ud658
		 * @function
		 */
		pointerX: function(event) {
            var eventDoc = $tx.element(event).ownerDocument||_DOC;
            var doc = eventDoc.documentElement;
            var body = eventDoc.body;
            return event.pageX || (event.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 ));
		},
		/**
		 * \ud398\uc774\uc9c0\uc5d0\uc11c \ub9c8\uc6b0\uc2a4 \ud3ec\uc778\ud130\uc758 y\uce21 \uc88c\ud45c\uac12 \ubc18\ud658
		 * @function
		 */
		pointerY: function(event) {
            var eventDoc = $tx.element(event).ownerDocument||_DOC;
            var doc = eventDoc.documentElement;
            var body = eventDoc.body;
            return event.pageY || (event.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 ));
		},
		/**
		 * \uc774\ubca4\ud2b8\uc758 \ub514\ud3f4\ud2b8 \ud589\uc704\ub97c \ucde8\uc18c\ud558\uace0 \uc704\uc784\uc744 \uc5f0\uae30\ud558\uae30 \uc704\ud574 \uc774 \ud568\uc218\ub97c \uc0ac\uc6a9
		 * @function
		 */
		stop: function(event){
			this.stopPropagation(event);
			this.preventDefault(event);
		},
		/**
		 * \uc774\ubca4\ud2b8\uc758 \ubc84\ube14\ub9c1\uc744 \ub9c9\uc744 \ub54c \uc774 \ud568\uc218\ub97c \uc0ac\uc6a9
		 * @function
		 */
		stopPropagation: function(event) {
			if(event.stopPropagation){
				event.stopPropagation();
			}else {
				event.cancelBubble = _TRUE;
			}
		},
		/**
		 * \uc774\ubca4\ud2b8 \ub514\ud3f4\ud2b8 \uc2e4\ud589 \ubc29\uc9c0\ub97c \uc704\ud574 \uc774 \ud568\uc218\ub97c \uc0ac\uc6a9
		 * @function
		 */
		preventDefault: function(event){
			if(event.preventDefault){
				event.preventDefault();
			}else{
				event.returnValue = _FALSE;
			}
		},
		/**
		 * \uc774\ubca4\ud2b8\uac00 \uc2dc\uc791\ub41c \ub178\ub4dc\ub85c\ubd80\ud130 \uc0c1\uc704\ub85c \uc21c\ud68c\ud558\uba70 \uc8fc\uc5b4\uc9c4 \ud0dc\uadf8\uc774\ub984\uc744 \uac16\ub294 \uccab\ubc88\uc9f8 \ub178\ub4dc\ub97c \ucc3e\ub294\ub2e4.
		 * find the first node with the given tagName, starting from the
		 * node the event was triggered on; traverses the DOM upwards
		 * @function
		 */
		findElement: function(event, tagName) {
			var element = $tx.element(event);
			while (element.parentNode &&  
			(!element.tagName || !element.tagName.toUpperCase ||
			(element.tagName.toUpperCase() != tagName.toUpperCase()))) 
				element = element.parentNode;
			return element;
		},
		observers: _FALSE,
		_observeAndCache: function(element, name, observer, useCapture) {
			if (!this.observers) 
				this.observers = [];
			if (($tx.msie_ver >= 11||name!='resizestart' && name!='resizeend') && element.addEventListener) {
				this.observers.push([element, name, observer, useCapture]);
				element.addEventListener(name, observer, useCapture);
			} else if (element.attachEvent) {
				this.observers.push([element, name, observer, useCapture]);
				element.attachEvent('on' + name, observer);
			}
		},

        simulateEvent: function(elem, eventName, event) {
            var observers = $tx.observers;
            if (!observers) {
				return;
            }
			for (var i = 0, length = observers.length; i < length; i++) {
                var observer = observers[i];
                if (observer && observer[1] === eventName && observer[0] === elem) {
//                if (observer && observer[1] === eventName && $tom.include(observer[0], elem)) {
                    observer[2](event);
                }
			}
        },

		unloadCache: function() {
			if (!$tx.observers) 
				return;
			for (var i = 0, length = $tx.observers.length; i < length; i++) {
				$tx.stopObserving.apply(this, $tx.observers[i]);
				$tx.observers[i][0] = _NULL;
			}
			$tx.observers = _FALSE;
		},
		/**
		 * \uc774\ubca4\ud2b8\ub97c \uc704\ud55c \uc774\ubca4\ud2b8 \ud578\ub4e4\ub7ec \ud568\uc218\ub97c \ucd94\uac00
		 * @function
		 * @param {Object} element \uc694\uc18c\uac1d\uccb4 \ub610\ub294 \uc544\uc774\ub514
		 * @param {String} name \uc774\ubca4\ud2b8 \uba85
		 * @param {Function} observer \uc774\ubca4\ud2b8\ub97c \ub2e4\ub8e8\ub294 \ud568\uc218
		 * @param {Boolean} useCapture true\ub77c\uba74, capture\ub0b4 \uc774\ubca4\ud2b8\ub97c \ub2e4\ub8e8\uace0 false\ub77c\uba74 bubbling \ub0b4 \uc774\ubca4\ud2b8\ub97c \ub2e4\ub8ec\ub2e4.
		 */
		observe: function(element, name, observer, useCapture) {
			element = $tx(element);
			useCapture = useCapture || _FALSE;
			if (name == 'keypress' /*&& ($tx.webkit || element.attachEvent)*/) {
				name = 'keydown';
			}
			$tx._observeAndCache(element, name, observer, useCapture);
		},
		/**
		 * \uc774\ubca4\ud2b8\ub85c\ubd80\ud130 \uc774\ubca4\ud2b8 \ud578\ub4e4\ub7ec\ub97c \uc81c\uac70
		 * @function
		 * @param {Object} element \uc694\uc18c\uac1d\uccb4 \ub610\ub294 \uc544\uc774\ub514
		 * @param {String} name \uc774\ubca4\ud2b8 \uba85
		 * @param {Function} observer \uc774\ubca4\ud2b8\ub97c \ub2e4\ub8e8\ub294 \ud568\uc218
		 * @param {Boolean} useCapture true\ub77c\uba74, capture\ub0b4 \uc774\ubca4\ud2b8\ub97c \ub2e4\ub8e8\uace0 false\ub77c\uba74 bubbling \ub0b4 \uc774\ubca4\ud2b8\ub97c \ub2e4\ub8ec\ub2e4.
		 */
		stopObserving: function(element, name, observer, useCapture) {
			element = $tx(element);
			useCapture = useCapture || _FALSE;
			if (name == 'keypress' /*&&
			($tx.webkit || element.attachEvent)*/)
				name = 'keydown';
			if (element.removeEventListener) {
				element.removeEventListener(name, observer, useCapture);
			} else if (element.detachEvent) {
				try {
					element.detachEvent('on' + name, observer);
				} catch (e) {
				}
			}
		}
	});
	//  prevent memory leaks in IE 
	if ($tx.msie) {
		$tx.observe(window, 'unload', $tx.unloadCache, _FALSE);
	}
})();

(function()  {
	$tx.extend(Object, /** @lends Object */ {
		/**
		 * object \ub97c \ubcf5\uc0ac
		 * @function
		 */
		clone: function(object) {
			return Object.extend({}, object);
		}
	});
	
	$tx.extend($tx, {
		isPrimitiveType: function(data) {
			var primitiveTypes = new $tx.Set("string", "number", "boolean", "date", "function");
			return primitiveTypes.contains(typeof data);
		},
		deepcopy: function(preset, service) {
			var _dest = preset;
			if(!service) {
				return _dest;
			}
			for(var _name in service) {
				switch(typeof(service[_name])) {
					case 'string':
					case 'number':
					case 'boolean': 
					case 'date':
					case 'function':
						_dest[_name] = service[_name];
						break;
					default:
						if (service[_name]) {
							if (service[_name].constructor == Array) {
								_dest[_name] = [].concat(service[_name]);
							} else {
								_dest[_name] = _dest[_name] || {};
								this.deepcopy(_dest[_name], service[_name]);
							}
						} else {
							_dest[_name] = _NULL;
						}
						break;
				}
			}
			return _dest;
		},
		defaults: function(dest, source){
			for(var name in source){
				if(dest[name] === _UNDEFINED){
					dest[name] = source[name];
				}
			}
		}
	});
})();

(function () {
	$tx.extend(String, /** @lends String */{
		/**
		 * value \ub97c \ubb38\uc790\uc5f4\ub85c \ub9cc\ub4e4\uc5b4 \ubc18\ud658\ud55c\ub2e4. value \uac00 null \uc774\uba74 \ube48\ubb38\uc790\uc5f4\uc744 \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		interpret: function(value) {
			return value == _NULL ? '' : String(value);
		},
		/**
		 * @field
		 */
		specialChar: {
			'\b': '\\b',
			'\t': '\\t',
			'\n': '\\n',
			'\f': '\\f',
			'\r': '\\r',
			'\\': '\\\\'
		}
	});
	$tx.extend(String.prototype, /** @lends String.prototype */{
		/**
		 * \ud604\uc7ac \ubb38\uc790\uc5f4\uc5d0\uc11c \ud328\ud134 \ubb38\uc790\uc5f4\uc744 \ucc3e\uc740 \uacb0\uacfc\uc758 \ubb38\uc790\uc5f4\uc744 \ubc18\ud658\ud558\uace0 \ub300\uccb4 \ubb38\uc790\uc5f4\uc774\ub098 \ud328\ud134\uc5d0 \uc77c\uce58\ud558\ub294 \ubb38\uc790\uc5f4\uc744 \uac00\uc9c4 \ubc30\uc5f4\uc744 \uc804\ub2ec\ud558\ub294 \ub300\uccb4\ud568\uc218\ub97c \ud638\ucd9c\ud55c \uacb0\uacfc\ub85c \ub300\uccb4\ud55c\ub2e4. 
		 * \ub300\uccb4\ubb3c\uc774 \ubb38\uc790\uc5f4\uc77c\ub54c, #{n}\uacfc \uac19\uc740 \ud2b9\ubcc4\ud55c \ud15c\ud50c\ub9bf \ud615\ud0dc\uc758 \ud1a0\ud070\uc744 \ud3ec\ud568\ud560\uc218 \uc788\ub2e4. 
		 * \uc5ec\uae30\uc11c n\uc774\ub77c\ub294 \uac12\uc740 \uc815\uaddc\ud45c\ud604\uc2dd \uadf8\ub8f9\uc758 \uc778\ub371\uc2a4\uc774\ub2e4.
		 * #{0}\ub294 \uc644\uc804\ud788 \uc77c\uce58\ud558\uba74 \ub300\uccb4\ub420\uac83\uc774\uace0 #{1}\ub294 \uccab\ubc88\uc9f8 \uadf8\ub8f9, #{2}\ub294 \ub450\ubc88\uc9f8\uc774\ub2e4.
		 * @function
		 */
		gsub: function(pattern, replacement) {
			var result = '', source = this, match;
			replacement = arguments.callee.prepareReplacement(replacement);
			while (source.length > 0) {
				if (match = source.match(pattern)) {
					result += source.slice(0, match.index);
					result += String.interpret(replacement(match));
					source = source.slice(match.index + match[0].length);
				} else {
					result += source, source = '';
				}
			}
			return result;
		},
		/**
		 * \ubb38\uc790\uc5f4 \uc55e,\ub4a4\uc758 \uacf5\ubc31\uc744 \uc81c\uac70
		 * @function
		 */
		strip: function() {
			return this.replace(/^\s+/, '').replace(/\s+$/, '');
		},
		/**
		 * \ubb38\uc790\uc5f4 \uc911 \ud0dc\uadf8 <tag> \ub97c \uc0ad\uc81c
		 * @function
		 */
		stripTags: function() {
			return this.replace(/<\/?[^>]+>/gi, '');
		},
		/**
		 * url query string \uc744 json \uc73c\ub85c \ub9cc\ub4e4\uc5b4 \ubc18\ud658\ud55c\ub2e4. separator \ub97c & \ub300\uc2e0 \ub2e4\ub978 \uac12\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4.
		 * @function
		 */
		toQueryParams: function(separator) {
			var match = this.strip().match(/([^?#]*)(#.*)?$/);
		    if (!match) return {};
		
			var _hash = {};
			var _lastkey = _NULL;
		    match[1].split(separator || '&').each(function(pair) {
				var _key = _NULL, _value = _NULL;
				var _matches = pair.match(/([\w_]+)=(.*)/);
				if(_matches) {
					_lastkey = _key = decodeURIComponent(_matches[1]);
					if(_matches[2]) {
						_value = decodeURIComponent(_matches[2]);
					}
				} else if(_lastkey) {
					_key = _lastkey;
					_value = _hash[_key];
					_value += '&' + decodeURIComponent(pair);
				} else {
					return;
				}
				if (_key in _hash) {
					if (_hash[_key].constructor != Array) 
						_hash[_key] = [_hash[_key]];
					_hash[_key].push(_value);
				} else {
					_hash[_key] = _value;
				}
			});
			return _hash;
		},
		/**
		 * \ubb38\uc790\uc5f4\uc744 \ubc30\uc5f4\ub85c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		toArray: function() {
			return this.split('');
		},
		/**
		 * count \ub9cc\ud07c \ubb38\uc790\uc5f4\uc744 \ubc18\ubcf5\ud558\uc5ec \uc774\uc5b4 \ubd99\uc778\ub2e4.
		 * @function
		 */
		times: function(count) {
			var result = '';
			for (var i = 0; i < count; i++) 
				result += this;
			return result;
		},
		/**
		 * -(\ud558\uc774\ud508)\uc73c\ub85c \ubd84\ub9ac\ub41c \ubb38\uc790\uc5f4\uc744 camelCaseString\uc73c\ub85c \ubcc0\ud658
		 * @function
		 */
		camelize: function() {
			var parts = this.split('-'), len = parts.length;
			if (len == 1) 
				return parts[0];
			var camelized = this.charAt(0) == '-' ? parts[0].charAt(0).toUpperCase() + parts[0].substring(1) : parts[0];
			for (var i = 1; i < len; i++) 
				camelized += parts[i].charAt(0).toUpperCase() + parts[i].substring(1);
			return camelized;
		},
		/**
		 * \uccab\ubc88\uc9f8 \uae00\uc790\ub97c \ub300\ubb38\uc790\ub85c \ubcc0\ud658
		 * @function
		 */
		capitalize: function() {
			return this.charAt(0).toUpperCase() + this.substring(1).toLowerCase();
		},
		/**
		 * \ubb38\uc790\uc5f4\uc774 \uc8fc\uc5b4\uc9c4 \ud328\ud134\uc744 \ud3ec\ud568\ud558\uba74 true
		 * @function
		 */
		include: function(pattern) {
			return this.indexOf(pattern) > -1;
		},
		/**
		 * \ube48\ubb38\uc790\uc5f4\uc774\uba74 true
		 * @function
		 */
		empty: function() {
			return this == '';
		},
		/**
		 * \uacf5\ubc31\ubb38\uc790\uc5f4\uc774\uba74 true
		 * @function
		 */
		blank: function() {
			return /^\s*$/.test(this);
		}
	});
	String.prototype.gsub.prepareReplacement = function(replacement) {
		if (typeof replacement == 'function') 
			return replacement;
		var template = new Template(replacement);
		return function(match) {
			return template.evaluate(match);
		};
	};
	//////
    if (!String.prototype.trim) {
        /**
         * \ubb38\uc790\uc5f4 \uc55e,\ub4a4\uc758 \uacf5\ubc31\uc744 \uc81c\uac70
         * @function
         */
        String.prototype.trim = function() {
			return this.replace(/(^\s*)|(\s*$)/g, "");
		}
    }
	$tx.extend(String.prototype, /** @lends String.prototype */{
		/**
		 * \uc815\uaddc\ud45c\ud604\uc2dd\uc5d0\uc11c \uc0ac\uc6a9\ub418\ub294 \uba54\ud0c0\ubb38\uc790\ub97c \uc774\uc2a4\ucf00\uc774\ud504\ud574\uc11c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		getRegExp: function() {
			return this.replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\//g, "\\/").replace(/\?/g, "\\?").replace(/\^/g, "\\^").replace(/\)/g, "\\)").replace(/\(/g, "\\(").replace(/\]/g, "\\]").replace(/\[/g, "\\[").replace(/\$/g, "\\$").replace(/\+/g, "\\+").replace(/\|/g, "\\|").replace(/&/g, "(&|&amp;)");
		},
		/**
		 * \ubb38\uc790\uc5f4\uc744 \uc815\uc218\ud615\uc73c\ub85c \ubc18\ud658\ud55c\ub2e4. \uc22b\uc790\uac00 \uc544\ub2cc \ubb38\uc790\uc5f4\uc740 0
		 * @function
		 */
		toNumber: function() {
			return (isNaN(this) ? 0 : parseInt(this, 10));
		},
		/**
		 * \ubb38\uc790\uc5f4\uc744 \ubd80\ub3d9\uc18c\uc218\uc810 \ud615\ud0dc\ub85c \ubc18\ud658\ud55c\ub2e4. \uc22b\uc790\uac00 \uc544\ub2cc \ubb38\uc790\uc5f4\uc740 0
		 * @function
		 */
		toFloat: function() {
			return (isNaN(this) ? 0 : parseFloat(this));
		},
		/**
		 * \ubb38\uc790\uc5f4\uc758 \uae38\uc774\ub97c \ubc18\ud658
		 * @function
		 */
		getRealLength: function() {
			var str = this;
			var idx = 0;
			for (var i = 0; i < str.length; i++) {
				idx += (escape(str.charAt(i)).charAt(1) == "u") ? 2 : 1;
			}
			return idx;
		},
		/**
		 * \ubb38\uc790\uc5f4\uc774 \uc8fc\uc5b4\uc9c4 \uae38\uc774\ubcf4\ub2e4 \uae38\uba74 \uc790\ub974\uace0 \ub9c8\uc9c0\ub9c9\uc5d0 ... \ub97c \ubd99\uc778\ub2e4.
		 * @function
		 */
		cutRealLength: function(length) {
			var str = this;
			var idx = 0;
			for (var i = 0; i < str.length; i++) {
				idx += (escape(str.charAt(i)).charAt(1) == "u") ? 2 : 1;
				if (idx > length) {
					return str.substring(0, i - 3).concat("...");
				}
			}
			return str;
		},
		/**
		 * @deprecated
		 */
		getCut: function(length) {
			return this.cutRealLength(length);
		},
		/**
		 * \ubb38\uc790\uc5f4\uc5d0 px \uac00 \uc788\uc73c\uba74 \uc798\ub77c\ub0b4\uace0 \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		parsePx: function() {
			if (this == _NULL || this.length == 0) 
				return 0;
			else if (this.indexOf("px") > -1) 
				return this.substring(0, this.indexOf("px")).toNumber();
			else 
				return this.toNumber();
		},
		/**
		 * \ubb38\uc790\uc5f4\uc5d0 px \ub97c \ubd99\uc5ec\uc11c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		toPx: function() {
			if (this.indexOf("px") > -1) {
				return this + "";
			} else {
				return this + "px";
			}
		},
		/**
		 * \ud53d\uc140\uac12\uc73c\ub85c \uc0ac\uc6a9 \uac00\ub2a5\ud55c \ubb38\uc790\uc5f4\uc778\uc9c0 boolean \uc73c\ub85c \ubc18\ud658 ( \uacf5\ubc31 \ud5c8\uc6a9\uc548\ud568 )
		 * @function
		 */
		isPx: function(){
			var str = this;
			if ( str.trim() == "" ){
				return false;
			} else if( str.indexOf("px") != -1 ){
				str = this.parsePx();
			}  
			return !isNaN(str);
		},
        isPercent: function(){
            var str = this.trim();
            return parseInt(str, 10)+'%' === str;
        },
		/**
		 * \ubc14\uc774\ud2b8\ub97c \uacc4\uc0b0\ud558\uc5ec \ub2e8\uc704\ub97c(KB, MB) \ubd99\uc5ec\uc11c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		toByteUnit: function() {
			return this.toNumber().toByteUnit();
		},
		/**
		 * \uc22b\uc790\ub85c\ub41c \ubb38\uc790\uc5f4\uc744 \ucc9c\ub2e8\uc704\ub85c \uc27c\ud45c(,)\ub97c \ubd99\uc778\ub2e4.
		 * @function
		 */
		toCurrency: function() {
			var amount = this;
			for (var i = 0; i < Math.floor((amount.length - (1 + i)) / 3); i++) {
				amount = amount.substring(0, amount.length - (4 * i + 3)) + "," + amount.substring(amount.length - (4 * i + 3));
			}
			return amount;
		},
		/**
		 * source\ub97c \ubb38\uc790\uc5f4 \ub05d\uae4c\uc9c0 \ucc3e\uc544\uc11c target\uc73c\ub85c \uce58\ud658\ud55c\ub2e4. 
		 * @function
		 */
		replaceAll: function(source, target) {
			source = source.replace(new RegExp("(\\W)", "g"), "\\$1");
			target = target.replace(new RegExp("\\$", "g"), "$$$$");
			return this.replace(new RegExp(source, "gm"), target);
		},
        underscore :function () {
        return this.replace(/::/g, '/')
            .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
            .replace(/([a-z\d])([A-Z])/g, '$1_$2')
            .replace(/-/g, '_')
            .toLowerCase();
        }
	});
})();

(function() {
	/**
	 * @name Number
	 * @class
	 */
	$tx.extend(Number.prototype, /** @lends Number.prototype */{
		/**
		 * \uc22b\uc790\ub85c\ub41c \ubb38\uc790\uc5f4\uc774 \uc8fc\uc5b4\uc9c4 \uae38\uc774\ubcf4\ub2e4 \uc9e7\uc73c\uba74 \uc55e\ubd80\ubd84\uc5d0 0 \uc73c\ub85c \ucc44\uc6cc\ub123\uc5b4\uc11c \ubc18\ud658\ud55c\ub2e4.
		 * @function 
		 * @param {Number} length \ubc18\ud658\ub418\ub294 \ubb38\uc790\uc5f4\uc758 \ucd5c\uc18c \uae38\uc774
		 * @param {Number} radix \ud45c\uae30\ub420 \uc9c4\uc218. optional. \uae30\ubcf8 10\uc9c4\uc218
		 */
		toPaddedString: function(length, radix) {
			var string = this.toString(radix || 10);
			return '0'.times(length - string.length) + string;
		},
		/**
		 * 
		 * @function
		 */
		toTime: function() {
			return Math.floor(this / 60).toString().toPaddedString(2) + ":" + (this % 60).toString().toPaddedString(2);
		},
		/**
		 * \ubc14\uc774\ud2b8\ub97c \uacc4\uc0b0\ud558\uc5ec \ub2e8\uc704\ub97c(KB, MB) \ubd99\uc5ec\uc11c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		toByteUnit: function() {
			var number;
			var units = ['GB', 'MB', 'KB'];
			if (this == 0) {
				return "0" + units[2];
			}
			for (var i = 0; i < units.length; i++) {
				number = this / Math.pow(1024, 3 - i);
				if (number < 1) {
					continue;
				}
				return (Math.round(number * 10) / 10) + units[i];
			}
			return "1" + units[2];
		},
		/**
		 * px\ub97c \ubd99\uc778\ub2e4.
		 * @function
		 */
		toPx: function() {
			return this.toString() + "px";
		},
		/**
		 * \uadf8\ub300\ub85c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		parsePx: function() {
			return this + 0;
		},
		/**
		 * \uc22b\uc790\ud615\uc740 \ubb34\uc870\uac74 px\ub85c \uc0ac\uc6a9 \uac00\ub2a5\ud558\ub2e4.
		 */
		isPx: function(){
			return _TRUE;
		},
		/**
		 * \ubb38\uc790\uc5f4\uc744 \uc815\uc218\ud615\uc73c\ub85c \ubc18\ud658\ud55c\ub2e4. \uc22b\uc790\uac00 \uc544\ub2cc \ubb38\uc790\uc5f4\uc740 0
		 * @function
		 */
		toNumber: function() {
			return this + 0;
		},
		/**
		 * \ucc9c\ub2e8\uc704\ub85c \uc27c\ud45c(,)\ub97c \ubd99\uc778\ub2e4.
		 * @function
		 */
		toCurrency: function() {
			return this.toString().toCurrency();
		},
		/**
		 * \uc815\uaddc\ud45c\ud604\uc2dd\uc5d0\uc11c \uc0ac\uc6a9\ub418\ub294 \uba54\ud0c0\ubb38\uc790\ub97c \uc774\uc2a4\ucf00\uc774\ud504\ud574\uc11c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		getRegExp: function() {
			return this.toString().getRegExp();
		}
	});
})();

(function() {
	$tx.extend(Array.prototype, /** @lends Array.prototype */{
		each: function(iterator) {
            if (_WIN['DEBUG']) {
                for (var i = 0, length = this.length; i < length; i++) {
                    iterator(this[i], i);
                }
            } else {
                try {
                    for (var i = 0, length = this.length; i < length; i++) {
                        iterator(this[i], i);
                    }
                } catch (e) {
                    if (e != $break) {
                        throw e;
                    }
                }
            }

			return this;
		},
        indexOf: function(value) {
            for (var i = 0; i < this.length; i++) {
                if (this[i] == value) {
                    return i;
                }
            }
            return -1;
        },
        map: function(f) {
            for (var b = [], i = 0, n = this.length; i < n; ++i) {
                b[i] = f(this[i]);
            }
            return b;
        },
		/**
		 * @deprecated use contains()
		 */
		include: function(object) {
            return this.contains(object);
		},
        contains: function(item) {
            return this.indexOf(item) >= 0;
        },
        /**
		 * \uc9d1\ud569\uc758 \uac01\uac01\uc758 \uc694\uc18c\ub0b4 propertyName\uc5d0 \uc758\ud574 \uba85\uc2dc\ub41c \ud504\ub77c\ud37c\ud2f0\uc5d0 \uac12\uc744 \uac00\uc838\uac00\uace0 Array\uac1d\uccb4\ub85c \uacb0\uacfc\ub97c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		pluck: function(property) {
			var results = [];
			this.each(function(value) {
				results.push(value[property]);
			});
			return results;
		},
        /**
         * \ubc30\uc5f4 \ub0b4\uc5d0\uc11c \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uccab\ubc88\uc9f8 \uc694\uc18c\ub97c \ub9ac\ud134\ud55c\ub2e4.
         * @function
         * @param {function} filterFn \uc870\uac74 \ud568\uc218. \uc870\uac74\uc5d0 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 true \ub9ac\ud134, \uc544\ub2cc \uacbd\uc6b0 false\ub97c \ub9ac\ud134\ud55c\ub2e4.
         * @return {object}
         */
        find: function(filterFn) {
            for (var i = 0, len = this.length; i < len; i++) {
                var value = this[i];
                if (filterFn(value, i)) {
                    return value;
                }
            }
            return _NULL;
        },
        /**
		 * \ubc30\uc5f4 \ub0b4\uc5d0\uc11c \uc870\uac74\uc5d0 \ub9cc\uc871\ud558\ub294 \uc694\uc18c\ub4e4\uc744 \ucd94\ucd9c\ud55c\ub2e4.
		 * @function
         * @param {function} filterFn \uc870\uac74 \ud568\uc218. \uc870\uac74\uc5d0 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 true \ub9ac\ud134, \uc544\ub2cc \uacbd\uc6b0 false\ub97c \ub9ac\ud134\ud55c\ub2e4.
         * @return {Array}
		 */
		findAll: function(filterFn) {
			var results = [];
            for (var i = 0, len = this.length; i < len; i++) {
                var value = this[i];
                if (filterFn(value, i)) {
                    results.push(value);
                }
            }
			return results;
		},
        /**
		 * iterator\ud568\uc218\ub97c \uc0ac\uc6a9\ud558\uc5ec \uc9d1\ud569\uc758 \ubaa8\ub4e0 \uc694\uc18c\ub97c \uc870\ud569\ud55c\ub2e4.
		 * \ud638\ucd9c\ub41c iterator\ub294 accumulator\uc778\uc790\uc5d0\uc11c \uc774\uc804 \ubc18\ubcf5\uc758 \uacb0\uacfc\ub97c \uc804\ub2ec\ud55c\ub2e4.
		 * \uccab\ubc88\uc9f8 \ubc18\ubcf5\uc740 accumulator\uc778\uc790\ub0b4 initialValue\ub97c \uac00\uc9c4\ub2e4. \ub9c8\uc9c0\ub9c9 \uacb0\uacfc\ub294 \ub9c8\uc9c0\ub9c9 \ubc18\ud658\uac12\uc774\ub2e4.
		 * @function
		 */
		inject: function(array, iterator) {
            for (var i = 0, len = this.length; i < len; i++) {
                var value = this[i];
                array = iterator(array, value, i);
            }
			return array;
		},
        /**
		 * \uc778\uc790\uc758 \ub9ac\uc2a4\ud2b8\uc5d0 \ud3ec\ud568\ub41c \uc694\uc18c\ub97c \uc81c\uc678\ud55c \ubc30\uc5f4\uc744 \ubc18\ud658. \uc774 \uba54\uc18c\ub4dc\ub294 \ubc30\uc5f4 \uc790\uccb4\ub97c \ubcc0\uacbd\ud558\uc9c0\ub294 \uc54a\ub294\ub2e4.
		 * @function
		 */
		without: function() {
			var values = $A(arguments);
			return this.findAll(function(value) {
				return !values.include(value);
			});
		},
        /**
		 * \ubc30\uc5f4\uc758 \ub9c8\uc9c0\ub9c9 \uc694\uc18c\ub97c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		last: function() {
			return this[this.length - 1];
		},
        /**
		 * \uae30\ubcf5\uc774 \uc5c6\uace0, 1\ucc28\uc6d0\uc758 \ubc30\uc5f4\uc744 \ubc18\ud658\ud55c\ub2e4. \uc774 \ud568\uc218\ub294 \ubc30\uc5f4\uc774\uace0 \ubc18\ud658\ub41c \ubc30\uc5f4\ub0b4 \uc694\uc18c\ub97c \ud3ec\ud568\ud558\ub294 \ubc30\uc5f4\uc758 \uac01 \uc694\uc18c\ub97c \ucc3e\uc74c\uc73c\ub85c\uc368 \uc218\ud589\ub41c\ub2e4.
		 * @function
		 */
		flatten: function() {
			return this.inject([], function(array, value) {
				return array.concat(value && value.constructor == Array ? value.flatten() : [value]);
			});
		},
		/**
		 * \ubc30\uc5f4\uc758 \uc694\uc18c\uac00 null \uc774\ub098 \ube48\ubb38\uc790\uc5f4\uc774\uba74 \uc81c\uac70\ud55c\ub2e4. 
		 * @function
		 */
		compact: function() {
			return this.findAll(function(value) {
				return (value != _NULL) && (value != '');
			});
		},
		/**
		 * \ubc30\uc5f4\uc758 \uc694\uc18c\uc758 \uac12 \uc911 \uc911\ubcf5\ub418\ub294 \uac12\uc740 \uc81c\uac70\ud55c\ub2e4.
		 * @function
		 */
		uniq: function(sorted) {
		    return this.inject([], function(array, value, index) {
				if (0 == index || (sorted ? array.last() != value : !array.contains(value)))
					array.push(value);
				return array;
			});
		},
		/**
		 * \ubc30\uc5f4\uc758 \ud2b9\uc815\uc694\uc18c\uac12\uc744 \ucd94\ucd9c\ud558\uc5ec json\uac1d\uccb4(map)\uc744 \ub9cc\ub4e0\ub2e4.
		 * @function
		 */
		toMap: function(property) {
			var results = {};
			this.each(function(value) {
				results[value[property]] = value;
			});
			return results;
		}
	});
	/**
	 * @deprecated use Array.prototype.findAll
	 */
	Array.prototype.select = Array.prototype.findAll;
    /**
	 * @deprecated use Array.prototype.find
	 */
	Array.prototype.detect = Array.prototype.find;

	/** 
	 * array like object(length\uc640 index\ub97c \uc774\uc6a9\ud55c \uc694\uc18c \uc811\uadfc\uc774 \uac00\ub2a5)\ub97c Array object\ub85c \ubcc0\ud658\ud55c\ub2e4.
	 * @example
	 *  var arrayLikeObject = document.getElementsByTagName('img');
	 *  var arrayObject = $A(arrayLikeObject);
	 */
	_WIN.$A = function(arrayLikeObject) {
		if (!arrayLikeObject) {
            return [];
        }
        if (typeof arrayLikeObject.toArray === "function") {
			return arrayLikeObject.toArray();
		} else {
            var array = [];
            for (var i = 0, len = arrayLikeObject.length; i < len; i++) {
                array.push(arrayLikeObject[i]);
            }
            return array;
        }
    };

    $tx.Set = function (/* comma seperated elements */) {
    	var args = arguments;
        for (var i = 0, len = args.length; i < len; i++) {
            this[args[i]] = _TRUE;
        }
    };
    $tx.Set.prototype.contains = function (element) {
        return element in this;
    };

    $tx.objectToQueryString = function(obj) {
        var queryString = [];
        for (var key in obj) if (obj.hasOwnProperty(key)) {
            var value = obj[key];
            if (value === _NULL || value === _UNDEFINED) { // \ub2e4\ub978 falsy value \ub4e4\uc740 \uac12\uc73c\ub85c \ucd9c\ub825\ub418\uc5b4\uc57c \ud55c\ub2e4.
                value = "";
            }
            queryString.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
        }
        return queryString.join("&");
    };
})();

// crossbrowser
(function() {
	if (typeof(HTMLElement) != _UNDEFINED+'') {
//		HTMLElement.prototype.innerText;
		var hElementProto = HTMLElement.prototype;
		var hElementGrandProto = hElementProto.__proto__ = {
			__proto__: hElementProto.__proto__
		};
		if (HTMLElement.prototype.__defineSetter__) {
			hElementGrandProto.__defineSetter__("innerText", function(sText) {
				this.textContent = sText;
			});
		}
		if (HTMLElement.prototype.__defineGetter__) {
			hElementGrandProto.__defineGetter__("innerText", function() {
				return this.textContent;
			});
		}
	}
	
	if (typeof(XMLDocument) != _UNDEFINED+'') {
		var XMLDoc = XMLDocument;
		if (XMLDoc.prototype.__defineGetter__) {
			XMLDoc.prototype.__defineGetter__("xml", function() {
				return (new XMLSerializer()).serializeToString(this);
			});
		}
	}
	if (typeof(Node) != _UNDEFINED+'') {
		if (Node.prototype && Node.prototype.__defineGetter__) {
			Node.prototype.__defineGetter__("xml", function() {
				return (new XMLSerializer()).serializeToString(this);
			});
		}
	}
	//	Simple Implementation of 
	//		setProperty() and selectNodes() and selectSingleNode() 
	//		for FireFox [Mozilla]
	if (typeof(_DOC.implementation) != _UNDEFINED+'') {
		if (_DOC.implementation.hasFeature("XPath", "3.0")) {
			if (typeof(XMLDoc) != _UNDEFINED+'') {
				XMLDoc.prototype.selectNodes = function(cXPathString, xNode) {
					if (!xNode) {
						xNode = this;
					}
					var defaultNS = this.defaultNS;
					var aItems = this.evaluate(cXPathString, xNode, {
						normalResolver: this.createNSResolver(this.documentElement),
						lookupNamespaceURI: function(prefix) {
							switch (prefix) {
								case "dflt":
									return defaultNS;
								default:
									return this.normalResolver.lookupNamespaceURI(prefix);
							}
						}
					}, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, _NULL);
					var aResult = [];
					for (var i = 0; i < aItems.snapshotLength; i++) {
						aResult[i] = aItems.snapshotItem(i);
					}
					return aResult;
				};
				XMLDoc.prototype.setProperty = function(p, v) {
					if (p == "SelectionNamespaces" && v.indexOf("xmlns:dflt") == 0) {
						this.defaultNS = v.replace(/^.*=\'(.+)\'/, "$1");
					}
				};
				XMLDoc.prototype.defaultNS;
				// prototying the XMLDocument 
				XMLDoc.prototype.selectSingleNode = function(cXPathString, xNode) {
					if (!xNode) {
						xNode = this;
					}
					var xItems = this.selectNodes(cXPathString, xNode);
					if (xItems.length > 0) {
						return xItems[0];
					} else {
						return _NULL;
					}
				};
				XMLDoc.prototype.createNode = function(nNodeType, sNodeName, sNameSpace) {
					if (nNodeType == 1) 
						return this.createElementNS(sNameSpace, sNodeName);
					else //Etc Not Use
 
						return _NULL;
				};
			}
			if (typeof(Element) != _UNDEFINED+'') {
				Element.prototype.selectNodes = function(cXPathString) {
					if (this.ownerDocument.selectNodes) {
						return this.ownerDocument.selectNodes(cXPathString, this);
					} else {
						throw "For XML Elements Only";
					}
				};
				// prototying the Element 
				Element.prototype.selectSingleNode = function(cXPathString) {
					if (this.ownerDocument.selectSingleNode) {
						return this.ownerDocument.selectSingleNode(cXPathString, this);
					} else {
						throw "For XML Elements Only";
					}
				};
				Element.prototype.text;
				var elementProto = Element.prototype;
				var elementGrandProto = elementProto.__proto__ = {
					__proto__: elementProto.__proto__
				};
				if (Element.prototype.__defineSetter__) {
					elementGrandProto.__defineSetter__("text", function(text) {
						this.textContent = text;
					});
				}
				if (Element.prototype.__defineGetter__) {
					elementGrandProto.__defineGetter__("text", function() {
						return this.textContent;
					});
				}
				
				if ( _WIN.origElement ) {
					_WIN.origElement.prototype.selectNodes = Element.prototype.selectNodes;
					_WIN.origElement.prototype.selectSingleNode = Element.prototype.selectSingleNode;
				}
			}
		}
	}
})();


_WIN.$tx = $tx;
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Bootstrap for the Google JS Library (Closure).
 *
 * In uncompiled mode base.js will write out Closure's deps file, unless the
 * global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to
 * include their own deps file(s) from different locations.
 *
 */

/**
 * Base namespace for the Closure library.  Checks to see goog is
 * already defined in the current scope before assigning to prevent
 * clobbering if base.js is loaded more than once.
 *
 * @const
 */
var goog = _WIN.goog = _WIN.goog || {};


/**
 * Reference to the global context.  In most cases this will be 'window'.
 */
goog.global = _WIN;


/**
 * @define {string} LOCALE defines the locale being used for compilation. It is
 * used to select locale specific data to be compiled in js binary. BUILD rule
 * can specify this value by "--define goog.LOCALE=<locale_name>" as JSCompiler
 * option.
 *
 * Take into account that the locale code format is important. You should use
 * the canonical Unicode format with hyphen as a delimiter. Language must be
 * lowercase, Language Script - Capitalized, Region - UPPERCASE.
 * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.
 *
 * See more info about locale codes here:
 * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
 *
 * For language codes you should use values defined by ISO 693-1. See it here
 * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from
 * this rule: the Hebrew language. For legacy reasons the old code (iw) should
 * be used instead of the new code (he), see http://wiki/Main/IIISynonyms.
 */
goog.LOCALE = 'en';  // default to en


/**
 * Creates object stubs for a namespace. When present in a file, goog.provide
 * also indicates that the file defines the indicated object. Calls to
 * goog.provide are resolved by the compiler if --closure_pass is set.
 * @param {string} name name of the object that this file defines.
 */
goog.provide = function(name) {
  goog.exportPath_(name);
};


/**
 * Builds an object structure for the provided namespace path,
 * ensuring that names that already exist are not overwritten. For
 * example:
 * "a.b.c" -> a = {};a.b={};a.b.c={};
 * Used by goog.provide and goog.exportSymbol.
 * @param {string} name name of the object that this file defines.
 * @param {*=} opt_object the object to expose at the end of the path.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is |goog.global|.
 * @private
 */
goog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {
  var parts = name.split('.');
  var cur = opt_objectToExportTo || goog.global;

  // Internet Explorer exhibits strange behavior when throwing errors from
  // methods externed in this manner.  See the testExportSymbolExceptions in
  // base_test.html for an example.
  if (!(parts[0] in cur) && cur.execScript) {
    cur.execScript('var ' + parts[0]);
  }

  // Certain browsers cannot parse code in the form for((a in b); c;);
  // This pattern is produced by the JSCompiler when it collapses the
  // statement above into the conditional loop below. To prevent this from
  // happening, use a for-loop and reserve the init logic as below.

  // Parentheses added to eliminate strict JS warning in Firefox.
  for (var part; parts.length && (part = parts.shift());) {
    if (!parts.length && goog.isDef(opt_object)) {
      // last part and we have an object; use it
      cur[part] = opt_object;
    } else if (cur[part]) {
      cur = cur[part];
    } else {
      cur = cur[part] = {};
    }
  }
};


/**
 * When defining a class Foo with an abstract method bar(), you can do:
 *
 * Foo.prototype.bar = goog.abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error
 * will be thrown when bar() is invoked.
 *
 * Note: This does not take the name of the function to override as
 * an argument because that would make it more difficult to obfuscate
 * our JavaScript code.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be
 *   overridden.
 */
goog.abstractMethod = function() {
  throw Error('unimplemented abstract method');
};


//==============================================================================
// Language Enhancements
//==============================================================================


/**
 * This is a "fixed" version of the typeof operator.  It differs from the typeof
 * operator in such a way that null returns 'null' and arrays return 'array'.
 * @param {*} value The value to get the type of.
 * @return {string} The name of the type.
 */
goog.typeOf = function(value) {
  var s = typeof value;
  if (s == 'object') {
    if (value) {
      // Check these first, so we can avoid calling Object.prototype.toString if
      // possible.
      //
      // IE improperly marshals tyepof across execution contexts, but a
      // cross-context object will still return _FALSE for "instanceof Object".
      if (value instanceof Array) {
        return 'array';
      } else if (value instanceof Object) {
        return s;
      }

      // HACK: In order to use an Object prototype method on the arbitrary
      //   value, the compiler requires the value be cast to type Object,
      //   even though the ECMA spec explicitly allows it.
      var className = Object.prototype.toString.call(
          /** @type {Object} */ (value));
      // In Firefox 3.6, attempting to access iframe window objects' length
      // property throws an NS_ERROR_FAILURE, so we need to special-case it
      // here.
      if (className == '[object Window]') {
        return 'object';
      }

      // We cannot always use constructor == Array or instanceof Array because
      // different frames have different Array objects. In IE6, if the iframe
      // where the array was created is destroyed, the array loses its
      // prototype. Then dereferencing val.splice here throws an exception, so
      // we can't use goog.isFunction. Calling typeof directly returns 'unknown'
      // so that will work. In this case, this function will return _FALSE and
      // most array functions will still work because the array is still
      // array-like (supports length and []) even though it has lost its
      // prototype.
      // Mark Miller noticed that Object.prototype.toString
      // allows access to the unforgeable [[Class]] property.
      //  15.2.4.2 Object.prototype.toString ( )
      //  When the toString method is called, the following steps are taken:
      //      1. Get the [[Class]] property of this object.
      //      2. Compute a string value by concatenating the three strings
      //         "[object ", Result(1), and "]".
      //      3. Return Result(2).
      // and this behavior survives the destruction of the execution context.
      if ((className == '[object Array]' ||
           // In IE all non value types are wrapped as objects across window
           // boundaries (not iframe though) so we have to do object detection
           // for this edge case
           typeof value.length == 'number' &&
           typeof value.splice != _UNDEFINED+'' &&
           typeof value.propertyIsEnumerable != _UNDEFINED+'' &&
           !value.propertyIsEnumerable('splice')

          )) {
        return 'array';
      }
      // HACK: There is still an array case that fails.
      //     function ArrayImpostor() {}
      //     ArrayImpostor.prototype = [];
      //     var impostor = new ArrayImpostor;
      // this can be fixed by getting rid of the fast path
      // (value instanceof Array) and solely relying on
      // (value && Object.prototype.toString.vall(value) === '[object Array]')
      // but that would require many more function calls and is not warranted
      // unless closure code is receiving objects from untrusted sources.

      // IE in cross-window calls does not correctly marshal the function type
      // (it appears just as an object) so we cannot use just typeof val ==
      // 'function'. However, if the object has a call property, it is a
      // function.
      if ((className == '[object Function]' ||
          typeof value.call != _UNDEFINED+'' &&
          typeof value.propertyIsEnumerable != _UNDEFINED+'' &&
          !value.propertyIsEnumerable('call'))) {
        return 'function';
      }


    } else {
      return _NULL+'';
    }

  } else if (s == 'function' && typeof value.call == _UNDEFINED+'') {
    // In Safari typeof nodeList returns 'function', and on Firefox
    // typeof behaves similarly for HTML{Applet,Embed,Object}Elements
    // and RegExps.  We would like to return object for those and we can
    // detect an invalid function by making sure that the function
    // object has a call method.
    return 'object';
  }
  return s;
};


/**
 * Returns true if the specified value is not |undefined|.
 * WARNING: Do not use this to test if an object has a property. Use the in
 * operator instead.  Additionally, this function assumes that the global
 * undefined variable has not been redefined.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
goog.isDef = function(val) {
  return val !== _UNDEFINED;
};


/**
 * Returns true if the specified value is |null|
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is null.
 */
goog.isNull = function(val) {
  return val === _NULL;
};


/**
 * Returns true if the specified value is defined and not null
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is defined and not null.
 */
goog.isDefAndNotNull = function(val) {
  // Note that undefined == null.
  return val != _NULL;
};


/**
 * Returns true if the specified value is an array
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArray = function(val) {
  return goog.typeOf(val) == 'array';
};


/**
 * Returns true if the object looks like an array. To qualify as array like
 * the value needs to be either a NodeList or an object with a Number length
 * property.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArrayLike = function(val) {
  var type = goog.typeOf(val);
  return type == 'array' || type == 'object' && typeof val.length == 'number';
};


/**
 * Returns true if the object looks like a Date. To qualify as Date-like
 * the value needs to be an object and have a getFullYear() function.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is a like a Date.
 */
goog.isDateLike = function(val) {
  return goog.isObject(val) && typeof val.getFullYear == 'function';
};


/**
 * Returns true if the specified value is a string
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is a string.
 */
goog.isString = function(val) {
  return typeof val == 'string';
};


/**
 * Returns true if the specified value is a boolean
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
goog.isBoolean = function(val) {
  return typeof val == 'boolean';
};


/**
 * Returns true if the specified value is a number
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
goog.isNumber = function(val) {
  return typeof val == 'number';
};


/**
 * Returns true if the specified value is a function
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
goog.isFunction = function(val) {
  return goog.typeOf(val) == 'function';
};


/**
 * Returns true if the specified value is an object.  This includes arrays
 * and functions.
 * @param {*} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
goog.isObject = function(val) {
  var type = goog.typeOf(val);
  return type == 'object' || type == 'array' || type == 'function';
};


/**
 * Gets a unique ID for an object. This mutates the object so that further
 * calls with the same object as a parameter returns the same value. The unique
 * ID is guaranteed to be unique across the current session amongst objects that
 * are passed into {@code getUid}. There is no guarantee that the ID is unique
 * or consistent across sessions. It is unsafe to generate unique ID for
 * function prototypes.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
goog.getUid = function(obj) {
  // TODO(user): Make the type stricter, do not accept null.

  // In Opera window.hasOwnProperty exists but always returns _FALSE so we avoid
  // using it. As a consequence the unique ID generated for BaseClass.prototype
  // and SubClass.prototype will be the same.
  return obj[goog.UID_PROPERTY_] ||
      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};


/**
 * Name for unique ID property. Initialized in a way to help avoid collisions
 * with other closure javascript on the same page.
 * @type {string}
 * @private
 */
goog.UID_PROPERTY_ = 'closure_uid_' +
    Math.floor(Math.random() * 2147483648).toString(36);


/**
 * Counter for UID.
 * @type {number}
 * @private
 */
goog.uidCounter_ = 0;


/**
 * Forward declaration for the clone method. This is necessary until the
 * compiler can better support duck-typing constructs as used in
 * goog.cloneObject.
 *
 * TODO(user): Remove once the JSCompiler can infer that the check for
 * proto.clone is safe in goog.cloneObject.
 *
 * @type {Function}
 */
Object.prototype.clone;


/**
 * A native implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which |this| should
 *     point to when the function is run. If the value is null or undefined, it
 *     will default to the global object.
 * @param {...*} var_args Additional arguments that are partially
 *     applied to the function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 * @suppress {deprecated} The compiler thinks that Function.prototype.bind
 *     is deprecated because some people have declared a pure-JS version.
 *     Only the pure-JS version is truly deprecated.
 */
goog.bindNative_ = function(fn, selfObj, var_args) {
  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));
};


/**
 * A pure-JS implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which |this| should
 *     point to when the function is run. If the value is null or undefined, it
 *     will default to the global object.
 * @param {...*} var_args Additional arguments that are partially
 *     applied to the function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 */
goog.bindJs_ = function(fn, selfObj, var_args) {
  var context = selfObj || goog.global;

  if (arguments.length > 2) {
    var boundArgs = Array.prototype.slice.call(arguments, 2);
    return function() {
      // Prepend the bound arguments to the current arguments.
      var newArgs = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(newArgs, boundArgs);
      return fn.apply(context, newArgs);
    };

  } else {
    return function() {
      return fn.apply(context, arguments);
    };
  }
};


/**
 * Partially applies this function to a particular 'this object' and zero or
 * more arguments. The result is a new function with some arguments of the first
 * function pre-filled and the value of |this| 'pre-specified'.<br><br>
 *
 * Remaining arguments specified at call-time are appended to the pre-
 * specified ones.<br><br>
 *
 * Also see: {@link #partial}.<br><br>
 *
 * Usage:
 * <pre>var barMethBound = bind(myFunction, myObj, 'arg1', 'arg2');
 * barMethBound('arg3', 'arg4');</pre>
 *
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which |this| should
 *     point to when the function is run. If the value is null or undefined, it
 *     will default to the global object.
 * @param {...*} var_args Additional arguments that are partially
 *     applied to the function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @suppress {deprecated} See above.
 */
goog.bind = function(fn, selfObj, var_args) {
  // TODO(nicksantos): narrow the type signature.
  if (Function.prototype.bind &&
      // NOTE(nicksantos): Somebody pulled base.js into the default
      // Chrome extension environment. This means that for Chrome extensions,
      // they get the implementation of Function.prototype.bind that
      // calls goog.bind instead of the native one. Even worse, we don't want
      // to introduce a circular dependency between goog.bind and
      // Function.prototype.bind, so we have to hack this to make sure it
      // works correctly.
      Function.prototype.bind.toString().indexOf('native code') != -1) {
    goog.bind = goog.bindNative_;
  } else {
    goog.bind = goog.bindJs_;
  }
  return goog.bind.apply(_NULL, arguments);
};


/**
 * Like bind(), except that a 'this object' is not required. Useful when the
 * target function is already bound.
 *
 * Usage:
 * var g = partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially
 *     applied to fn.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 */
goog.partial = function(fn, var_args) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    // Prepend the bound arguments to the current arguments.
    var newArgs = Array.prototype.slice.call(arguments);
    newArgs.unshift.apply(newArgs, args);
    return fn.apply(this, newArgs);
  };
};


/**
 * @return {number} An integer value representing the number of milliseconds
 *     between midnight, January 1, 1970 and the current time.
 */
goog.now = Date.now || (function() {
  // Unary plus operator converts its operand to a number which in the case of
  // a date is done by calling getTime().
  return +new Date();
});


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 * <pre>
 * function ParentClass(a, b) { }
 * ParentClass.prototype.foo = function(a) { }
 *
 * function ChildClass(a, b, c) {
 *   ParentClass.call(this, a, b);
 * }
 *
 * goog.inherits(ChildClass, ParentClass);
 *
 * var child = new ChildClass('a', 'b', 'see');
 * child.foo(); // works
 * </pre>
 *
 * In addition, a superclass' implementation of a method can be invoked
 * as follows:
 *
 * <pre>
 * ChildClass.prototype.foo = function(a) {
 *   ChildClass.superClass_.foo.call(this, a);
 *   // other code
 * };
 * </pre>
 *
 * @param {Function} childCtor Child class.
 * @param {Function} parentCtor Parent class.
 */
goog.inherits = function(childCtor, parentCtor) {
  /** @constructor */
  function tempCtor() {};
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor();
  childCtor.prototype.constructor = childCtor;
};


/**
 * Call up to the superclass.
 *
 * If this is called from a constructor, then this calls the superclass
 * contructor with arguments 1-N.
 *
 * If this is called from a prototype method, then you must pass
 * the name of the method as the second argument to this function. If
 * you do not, you will get a runtime error. This calls the superclass'
 * method with arguments 2-N.
 *
 * This function only works if you use goog.inherits to express
 * inheritance relationships between your classes.
 *
 * This function is a compiler primitive. At compile-time, the
 * compiler will do macro expansion to remove a lot of
 * the extra overhead that this function introduces. The compiler
 * will also enforce a lot of the assumptions that this function
 * makes, and treat it as a compiler error if you break them.
 *
 * @param {!Object} me Should always be "this".
 * @param {*=} opt_methodName The method name if calling a super method.
 * @param {...*} var_args The rest of the arguments.
 * @return {*} The return value of the superclass method.
 */
goog.base = function(me, opt_methodName, var_args) {
  var caller = arguments.callee.caller;
  if (caller.superClass_) {
    // This is a constructor. Call the superclass constructor.
    return caller.superClass_.constructor.apply(
        me, Array.prototype.slice.call(arguments, 1));
  }

  var args = Array.prototype.slice.call(arguments, 2);
  var foundCaller = _FALSE;
  for (var ctor = me.constructor;
       ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
    if (ctor.prototype[opt_methodName] === caller) {
      foundCaller = _TRUE;
    } else if (foundCaller) {
      return ctor.prototype[opt_methodName].apply(me, args);
    }
  }

  // If we did not find the caller in the prototype chain,
  // then one of two things happened:
  // 1) The caller is an instance method.
  // 2) This method was not called by the right caller.
  if (me[opt_methodName] === caller) {
    return me.constructor.prototype[opt_methodName].apply(me, args);
  } else {
    throw Error(
        'goog.base called from a method of one name ' +
        'to a method of a different name');
  }
};


// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for string manipulation.
 */


/**
 * Namespace for string utilities
 */
goog.provide('goog.string');
goog.provide('goog.string.Unicode');


/**
 * Common Unicode string characters.
 * @enum {string}
 */
goog.string.Unicode = {
  NBSP: '\xa0'
};

/**
 * Fast prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix A string to look for at the start of {@code str}.
 * @return {boolean} True if {@code str} begins with {@code prefix}.
 */
goog.string.startsWith = function(str, prefix) {
  return str.lastIndexOf(prefix, 0) == 0;
};

/**
 * Checks if a string is empty or contains only whitespaces.
 * @param {string} str The string to check.
 * @return {boolean} True if {@code str} is empty or whitespace only.
 */
goog.string.isEmpty = function(str) {
  // testing length == 0 first is actually slower in all browsers (about the
  // same in Opera).
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return /^[\s\xa0]*$/.test(str);
};


/**
 * Takes a string and replaces newlines with a space. Multiple lines are
 * replaced with a single space.
 * @param {string} str The string from which to strip newlines.
 * @return {string} A copy of {@code str} stripped of newlines.
 */
// FTDUEDTR-1183
goog.string.stripNewlines = function(str) {
  return str.replace(/ ?(\r\n|\r|\n)+/g, ' ');
};


/**
 * Replaces Windows and Mac new lines with unix style: \r or \r\n with \n.
 * @param {string} str The string to in which to canonicalize newlines.
 * @return {string} {@code str} A copy of {@code} with canonicalized newlines.
 */
goog.string.canonicalizeNewlines = function(str) {
  return str.replace(/(\r\n|\r|\n)/g, '\n');
};


/**
 * Trims white spaces to the left and right of a string.
 * @param {string} str The string to trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trim = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
};

/**
 * Escape double quote '"' characters in addition to '&', '<', and '>' so that a
 * string can be included in an HTML tag attribute value within double quotes.
 *
 * It should be noted that > doesn't need to be escaped for the HTML or XML to
 * be valid, but it has been decided to escape it for consistency with other
 * implementations.
 *
 * NOTE(user):
 * HtmlEscape is often called during the generation of large blocks of HTML.
 * Using statics for the regular expressions and strings is an optimization
 * that can more than half the amount of time IE spends in this function for
 * large apps, since strings and regexes both contribute to GC allocations.
 *
 * Testing for the presence of a character before escaping increases the number
 * of function calls, but actually provides a speed increase for the average
 * case -- since the average case often doesn't require the escaping of all 4
 * characters and indexOf() is much cheaper than replace().
 * The worst case does suffer slightly from the additional calls, therefore the
 * opt_isLikelyToContainHtmlChars option has been included for situations
 * where all 4 HTML entities are very likely to be present and need escaping.
 *
 * Some benchmarks (times tended to fluctuate +-0.05ms):
 *                                     FireFox                     IE6
 * (no chars / average (mix of cases) / all 4 chars)
 * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80
 * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84
 * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85
 *
 * An additional advantage of checking if replace actually needs to be called
 * is a reduction in the number of object allocations, so as the size of the
 * application grows the difference between the various methods would increase.
 *
 * @param {string} str string to be escaped.
 * @param {boolean=} opt_isLikelyToContainHtmlChars Don't perform a check to see
 *     if the character needs replacing - use this option if you expect each of
 *     the characters to appear often. Leave _FALSE if you expect few html
 *     characters to occur in your strings, such as if you are escaping HTML.
 * @return {string} An escaped copy of {@code str}.
 */
goog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {

  if (opt_isLikelyToContainHtmlChars) {
    return str.replace(goog.string.amperRe_, '&amp;')
          .replace(goog.string.ltRe_, '&lt;')
          .replace(goog.string.gtRe_, '&gt;')
          .replace(goog.string.quotRe_, '&quot;');

  } else {
    // quick test helps in the case when there are no chars to replace, in
    // worst case this makes barely a difference to the time taken
    if (!goog.string.allRe_.test(str)) return str;

    // str.indexOf is faster than regex.test in this case
    if (str.indexOf('&') != -1) {
      str = str.replace(goog.string.amperRe_, '&amp;');
    }
    if (str.indexOf('<') != -1) {
      str = str.replace(goog.string.ltRe_, '&lt;');
    }
    if (str.indexOf('>') != -1) {
      str = str.replace(goog.string.gtRe_, '&gt;');
    }
    if (str.indexOf('"') != -1) {
      str = str.replace(goog.string.quotRe_, '&quot;');
    }
    return str;
  }
};


/**
 * Regular expression that matches an ampersand, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.amperRe_ = /&/g;


/**
 * Regular expression that matches a less than sign, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.ltRe_ = /</g;


/**
 * Regular expression that matches a greater than sign, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.gtRe_ = />/g;


/**
 * Regular expression that matches a double quote, for use in escaping.
 * @type {RegExp}
 * @private
 */
goog.string.quotRe_ = /\"/g;


/**
 * Regular expression that matches any character that needs to be escaped.
 * @type {RegExp}
 * @private
 */
goog.string.allRe_ = /[&<>\"]/;


/**
 * Checks whether a string contains a given character.
 * @param {string} s The string to test.
 * @param {string} ss The substring to test for.
 * @return {boolean} True if {@code s} contains {@code ss}.
 */
goog.string.contains = function(s, ss) {
  return s.indexOf(ss) != -1;
};

/**
 * Concatenates string expressions. This is useful
 * since some browsers are very inefficient when it comes to using plus to
 * concat strings. Be careful when using null and undefined here since
 * these will not be included in the result. If you need to represent these
 * be sure to cast the argument to a String first.
 * For example:
 * <pre>buildString('a', 'b', 'c', 'd') -> 'abcd'
 * buildString(null, undefined) -> ''
 * </pre>
 * @param {...*} var_args A list of strings to concatenate. If not a string,
 *     it will be casted to one.
 * @return {string} The concatenation of {@code var_args}.
 */
goog.string.buildString = function(var_args) {
  return Array.prototype.join.call(arguments, '');
};


/**
 * Compares two version numbers.
 *
 * @param {string|number} version1 Version of first item.
 * @param {string|number} version2 Version of second item.
 *
 * @return {number}  1 if {@code version1} is higher.
 *                   0 if arguments are equal.
 *                  -1 if {@code version2} is higher.
 */
goog.string.compareVersions = function(version1, version2) {
  var order = 0;
  // Trim leading and trailing whitespace and split the versions into
  // subversions.
  var v1Subs = goog.string.trim(String(version1)).split('.');
  var v2Subs = goog.string.trim(String(version2)).split('.');
  var subCount = Math.max(v1Subs.length, v2Subs.length);

  // Iterate over the subversions, as long as they appear to be equivalent.
  for (var subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {
    var v1Sub = v1Subs[subIdx] || '';
    var v2Sub = v2Subs[subIdx] || '';

    // Split the subversions into pairs of numbers and qualifiers (like 'b').
    // Two different RegExp objects are needed because they are both using
    // the 'g' flag.
    var v1CompParser = new RegExp('(\\d*)(\\D*)', 'g');
    var v2CompParser = new RegExp('(\\d*)(\\D*)', 'g');
    do {
      var v1Comp = v1CompParser.exec(v1Sub) || ['', '', ''];
      var v2Comp = v2CompParser.exec(v2Sub) || ['', '', ''];
      // Break if there are no more matches.
      if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {
        break;
      }

      // Parse the numeric part of the subversion. A missing number is
      // equivalent to 0.
      var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);
      var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);

      // Compare the subversion components. The number has the highest
      // precedence. Next, if the numbers are equal, a subversion without any
      // qualifier is always higher than a subversion with any qualifier. Next,
      // the qualifiers are compared as strings.
      order = goog.string.compareElements_(v1CompNum, v2CompNum) ||
          goog.string.compareElements_(v1Comp[2].length == 0,
              v2Comp[2].length == 0) ||
          goog.string.compareElements_(v1Comp[2], v2Comp[2]);
      // Stop as soon as an inequality is discovered.
    } while (order == 0);
  }

  return order;
};


/**
 * Compares elements of a version number.
 *
 * @param {string|number|boolean} left An element from a version number.
 * @param {string|number|boolean} right An element from a version number.
 *
 * @return {number}  1 if {@code left} is higher.
 *                   0 if arguments are equal.
 *                  -1 if {@code right} is higher.
 * @private
 */
goog.string.compareElements_ = function(left, right) {
  if (left < right) {
    return -1;
  } else if (left > right) {
    return 1;
  }
  return 0;
};


/**
 * The most recent unique ID. |0 is equivalent to Math.floor in this case.
 * @type {number}
 * @private
 */
goog.string.uniqueStringCounter_ = Math.random() * 0x80000000 | 0;


/**
 * Generates and returns a string which is unique in the current document.
 * This is useful, for example, to create unique IDs for DOM elements.
 * @return {string} A unique id.
 */
goog.string.createUniqueString = function() {
  return 'goog_' + goog.string.uniqueStringCounter_++;
};

// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Rendering engine detection.
 * @see <a href="http://www.useragentstring.com/">User agent strings</a>
 * For information on the browser brand (such as Safari versus Chrome), see
 * goog.userAgent.product.
 * @see ../demos/useragent.html
 */

goog.provide('goog.userAgent');

//goog.require('goog.string');


/**
 * @define {boolean} Whether we know at compile-time that the browser is IE.
 */
goog.userAgent.ASSUME_IE = _FALSE;


/**
 * @define {boolean} Whether we know at compile-time that the browser is GECKO.
 */
goog.userAgent.ASSUME_GECKO = _FALSE;


/**
 * @define {boolean} Whether we know at compile-time that the browser is WEBKIT.
 */
goog.userAgent.ASSUME_WEBKIT = _FALSE;


/**
 * @define {boolean} Whether we know at compile-time that the browser is a
 *     mobile device running WebKit e.g. iPhone or Android.
 */
goog.userAgent.ASSUME_MOBILE_WEBKIT = _FALSE;


/**
 * @define {boolean} Whether we know at compile-time that the browser is OPERA.
 */
goog.userAgent.ASSUME_OPERA = _FALSE;


/**
 * @define {boolean} Whether the
 *     {@code goog.userAgent.isVersionOrHigher}
 *     function will return true for any version.
 */
goog.userAgent.ASSUME_ANY_VERSION = _FALSE;


/**
 * Whether we know the browser engine at compile-time.
 * @type {boolean}
 * @private
 */
goog.userAgent.BROWSER_KNOWN_ =
    goog.userAgent.ASSUME_IE ||
    goog.userAgent.ASSUME_GECKO ||
    goog.userAgent.ASSUME_MOBILE_WEBKIT ||
    goog.userAgent.ASSUME_WEBKIT ||
    goog.userAgent.ASSUME_OPERA;


/**
 * Returns the userAgent string for the current browser.
 * Some user agents (I'm thinking of you, Gears WorkerPool) do not expose a
 * navigator object off the global scope.  In that case we return null.
 *
 * @return {?string} The userAgent string or null if there is none.
 */
goog.userAgent.getUserAgentString = function() {
  return goog.global['navigator'] ? goog.global['navigator'].userAgent : _NULL;
};


/**
 * @return {Object} The native navigator object.
 */
goog.userAgent.getNavigator = function() {
  // Need a local navigator reference instead of using the global one,
  // to avoid the rare case where they reference different objects.
  // (goog.gears.FakeWorkerPool, for example).
  return goog.global['navigator'];
};


/**
 * Initializer for goog.userAgent.
 *
 * This is a named function so that it can be stripped via the jscompiler
 * option for stripping types.
 * @private
 */
goog.userAgent.init_ = function() {
  /**
   * Whether the user agent string denotes Opera.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedOpera_ = _FALSE;

  /**
   * Whether the user agent string denotes Internet Explorer. This includes
   * other browsers using Trident as its rendering engine. For example AOL
   * and Netscape 8
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedIe_ = _FALSE;

  /**
   * Whether the user agent string denotes WebKit. WebKit is the rendering
   * engine that Safari, Android and others use.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedWebkit_ = _FALSE;

  /**
   * Whether the user agent string denotes a mobile device.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedMobile_ = _FALSE;

  /**
   * Whether the user agent string denotes Gecko. Gecko is the rendering
   * engine used by Mozilla, Mozilla Firefox, Camino and many more.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedGecko_ = _FALSE;

  var ua;
  if (!goog.userAgent.BROWSER_KNOWN_ &&
      (ua = goog.userAgent.getUserAgentString())) {
      var navigator = goog.userAgent.getNavigator();
      goog.userAgent.detectedOpera_ = goog.string.startsWith(ua, 'Opera');
      goog.userAgent.detectedIe_ = !goog.userAgent.detectedOpera_ &&
          (goog.string.contains(ua, 'MSIE') ||
              goog.string.contains(ua, 'Trident'));
      goog.userAgent.detectedWebkit_ = !goog.userAgent.detectedOpera_ &&
          goog.string.contains(ua, 'WebKit');
      // WebKit also gives navigator.product string equal to 'Gecko'.
      goog.userAgent.detectedMobile_ = goog.userAgent.detectedWebkit_ &&
          goog.string.contains(ua, 'Mobile');
      goog.userAgent.detectedGecko_ = !goog.userAgent.detectedOpera_ &&
          !goog.userAgent.detectedWebkit_ && !goog.userAgent.detectedIe_ &&
          navigator.product == 'Gecko';
  }
};


if (!goog.userAgent.BROWSER_KNOWN_) {
  goog.userAgent.init_();
}


/**
 * Whether the user agent is Opera.
 * @type {boolean}
 */
goog.userAgent.OPERA = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_OPERA : goog.userAgent.detectedOpera_;


/**
 * Whether the user agent is Internet Explorer. This includes other browsers
 * using Trident as its rendering engine. For example AOL and Netscape 8
 * @type {boolean}
 */
goog.userAgent.IE = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_IE : goog.userAgent.detectedIe_;


/**
 * Whether the user agent is Gecko. Gecko is the rendering engine used by
 * Mozilla, Mozilla Firefox, Camino and many more.
 * @type {boolean}
 */
goog.userAgent.GECKO = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_GECKO :
    goog.userAgent.detectedGecko_;


/**
 * Whether the user agent is WebKit. WebKit is the rendering engine that
 * Safari, Android and others use.
 * @type {boolean}
 */
goog.userAgent.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT :
    goog.userAgent.detectedWebkit_;


/**
 * Whether the user agent is running on a mobile device.
 * @type {boolean}
 */
goog.userAgent.MOBILE = goog.userAgent.ASSUME_MOBILE_WEBKIT ||
                        goog.userAgent.detectedMobile_;


/**
 * Used while transitioning code to use WEBKIT instead.
 * @type {boolean}
 * @deprecated Use {@link goog.userAgent.product.SAFARI} instead.
 * TODO(nicksantos): Delete this from goog.userAgent.
 */
goog.userAgent.SAFARI = goog.userAgent.WEBKIT;


/**
 * @return {string} the platform (operating system) the user agent is running
 *     on. Default to empty string because navigator.platform may not be defined
 *     (on Rhino, for example).
 * @private
 */
goog.userAgent.determinePlatform_ = function() {
  var navigator = goog.userAgent.getNavigator();
  return navigator && navigator.platform || '';
};


/**
 * The platform (operating system) the user agent is running on. Default to
 * empty string because navigator.platform may not be defined (on Rhino, for
 * example).
 * @type {string}
 */
goog.userAgent.PLATFORM = goog.userAgent.determinePlatform_();


/**
 * @define {boolean} Whether the user agent is running on a Macintosh operating
 *     system.
 */
goog.userAgent.ASSUME_MAC = _FALSE;


/**
 * @define {boolean} Whether the user agent is running on a Windows operating
 *     system.
 */
goog.userAgent.ASSUME_WINDOWS = _FALSE;


/**
 * @define {boolean} Whether the user agent is running on a Linux operating
 *     system.
 */
goog.userAgent.ASSUME_LINUX = _FALSE;


/**
 * @define {boolean} Whether the user agent is running on a X11 windowing
 *     system.
 */
goog.userAgent.ASSUME_X11 = _FALSE;


/**
 * @type {boolean}
 * @private
 */
goog.userAgent.PLATFORM_KNOWN_ =
    goog.userAgent.ASSUME_MAC ||
    goog.userAgent.ASSUME_WINDOWS ||
    goog.userAgent.ASSUME_LINUX ||
    goog.userAgent.ASSUME_X11;


/**
 * Initialize the goog.userAgent constants that define which platform the user
 * agent is running on.
 * @private
 */
goog.userAgent.initPlatform_ = function() {
  /**
   * Whether the user agent is running on a Macintosh operating system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedMac_ =goog.string.contains(goog.userAgent.PLATFORM,
      'Mac');

  /**
   * Whether the user agent is running on a Windows operating system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedWindows_ = goog.string.contains(
      goog.userAgent.PLATFORM, 'Win');

  /**
   * Whether the user agent is running on a Linux operating system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedLinux_ = goog.string.contains(goog.userAgent.PLATFORM,
      'Linux');

  /**
   * Whether the user agent is running on a X11 windowing system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedX11_ = !!goog.userAgent.getNavigator() &&
      goog.string.contains(goog.userAgent.getNavigator()['appVersion'] || '',
          'X11');
};


if (!goog.userAgent.PLATFORM_KNOWN_) {
  goog.userAgent.initPlatform_();
}


/**
 * Whether the user agent is running on a Macintosh operating system.
 * @type {boolean}
 */
goog.userAgent.MAC = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_MAC : goog.userAgent.detectedMac_;


/**
 * Whether the user agent is running on a Windows operating system.
 * @type {boolean}
 */
goog.userAgent.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_WINDOWS : goog.userAgent.detectedWindows_;


/**
 * Whether the user agent is running on a Linux operating system.
 * @type {boolean}
 */
goog.userAgent.LINUX = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_LINUX : goog.userAgent.detectedLinux_;


/**
 * Whether the user agent is running on a X11 windowing system.
 * @type {boolean}
 */
goog.userAgent.X11 = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_X11 : goog.userAgent.detectedX11_;


/**
 * @return {string} The string that describes the version number of the user
 *     agent.
 * @private
 */
goog.userAgent.determineVersion_ = function() {
  // All browsers have different ways to detect the version and they all have
  // different naming schemes.

  // version is a string rather than a number because it may contain 'b', 'a',
  // and so on.
  var version = '', re;

  if (goog.userAgent.OPERA && goog.global['opera']) {
    var operaVersion = goog.global['opera'].version;
    version = typeof operaVersion == 'function' ? operaVersion() : operaVersion;
  } else {
    if (goog.userAgent.GECKO) {
      re = /rv\:([^\);]+)(\)|;)/;
    } else if (goog.userAgent.IE) {
      re = /MSIE\s+([^\);]+)(\)|;)/;
    } else if (goog.userAgent.WEBKIT) {
      // WebKit/125.4
      re = /WebKit\/(\S+)/;
    }
    if (re) {
      var arr = re.exec(goog.userAgent.getUserAgentString());
      version = arr ? arr[1] : '';
    }
  }
  if (goog.userAgent.IE) {
    // IE9 can be in document mode 9 but be reporting an inconsistent user agent
    // version.  If it is identifying as a version lower than 9 we take the
    // documentMode as the version instead.  IE8 has similar behavior.
    // It is recommended to set the X-UA-Compatible header to ensure that IE9
    // uses documentMode 9.
    var docMode = goog.userAgent.getDocumentMode_();
    if (docMode > parseFloat(version)) {
      return String(docMode);
    }
  }
  return version;
};


/**
 * @return {number|undefined} Returns the document mode (for testing).
 * @private
 */
goog.userAgent.getDocumentMode_ = function() {
  // NOTE(user): goog.userAgent may be used in context where there is no DOM.
  var doc = goog.global['document'];
  return doc ? doc['documentMode'] : _UNDEFINED;
};


/**
 * The version of the user agent. This is a string because it might contain
 * 'b' (as in beta) as well as multiple dots.
 * @type {string}
 */
goog.userAgent.VERSION = goog.userAgent.determineVersion_();


/**
 * Compares two version numbers.
 *
 * @param {string} v1 Version of first item.
 * @param {string} v2 Version of second item.
 *
 * @return {number}  1 if first argument is higher
 *                   0 if arguments are equal
 *                  -1 if second argument is higher.
 * @deprecated Use goog.string.compareVersions.
 */
goog.userAgent.compare = function(v1, v2) {
    return goog.string.compareVersions(v1, v2);
};


/**
 * Cache for {@link goog.userAgent.isVersion}. Calls to compareVersions are
 * surprisingly expensive and as a browsers version number is unlikely to change
 * during a session we cache the results.
 * @type {Object}
 * @private
 */
goog.userAgent.isVersionOrHigherCache_ = {};

/**
 * Whether the user agent version is higher or the same as the given version.
 * NOTE: When checking the version numbers for Firefox and Safari, be sure to
 * use the engine's version, not the browser's version number.  For example,
 * Firefox 3.0 corresponds to Gecko 1.9 and Safari 3.0 to Webkit 522.11.
 * Opera and Internet Explorer versions match the product release number.<br>
 * @see <a href="http://en.wikipedia.org/wiki/Safari_version_history">
 *     Webkit</a>
 * @see <a href="http://en.wikipedia.org/wiki/Gecko_engine">Gecko</a>
 *
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the user agent version is higher or the same as
 *     the given version.
 */
goog.userAgent.isVersionOrHigher = function(version) {
    return goog.userAgent.ASSUME_ANY_VERSION ||
        goog.userAgent.isVersionOrHigherCache_[version] ||
        (goog.userAgent.isVersionOrHigherCache_[version] =
            goog.string.compareVersions(goog.userAgent.VERSION, version) >= 0);
};


/**
 * Deprecated alias to {@code goog.userAgent.isVersionOrHigher}.
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the user agent version is higher or the same as
 *     the given version.
 * @deprecated Use goog.userAgent.isVersionOrHigher().
 */
goog.userAgent.isVersion = goog.userAgent.isVersionOrHigher;

/**
 * Cache for {@link goog.userAgent.isDocumentMode}.
 * Browsers document mode version number is unlikely to change during a session
 * we cache the results.
 * @type {Object}
 * @private
 */
goog.userAgent.isDocumentModeCache_ = {};


/**
 * Whether the IE effective document mode is higher or the same as the given
 * document mode version.
 * NOTE: Only for IE, return false for another browser.
 *
 * @param {number} documentMode The document mode version to check.
 * @return {boolean} Whether the IE effective document mode is higher or the
 *     same as the given version.
 */
goog.userAgent.isDocumentModeOrHigher = function(documentMode) {
    return goog.userAgent.IE && goog.userAgent.DOCUMENT_MODE >= documentMode;
};


/**
 * Deprecated alias to {@code goog.userAgent.isDocumentModeOrHigher}.
 * @param {number} version The version to check.
 * @return {boolean} Whether the IE effective document mode is higher or the
 *      same as the given version.
 * @deprecated Use goog.userAgent.isDocumentModeOrHigher().
 */
goog.userAgent.isDocumentMode = goog.userAgent.isDocumentModeOrHigher;


/**
 * For IE version < 7, documentMode is undefined, so attempt to use the
 * CSS1Compat property to see if we are in standards mode. If we are in
 * standards mode, treat the browser version as the document mode. Otherwise,
 * IE is emulating version 5.
 * @type {number|undefined}
 * @const
 */
goog.userAgent.DOCUMENT_MODE = (function() {
    var doc = goog.global['document'];
    if (!doc || !goog.userAgent.IE) {
        return undefined;
    }
    var mode = goog.userAgent.getDocumentMode_();
    return mode || (doc['compatMode'] == 'CSS1Compat' ?
        parseInt(goog.userAgent.VERSION, 10) : 5);
})();

// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating arrays.
 *
 */


goog.provide('goog.array');
goog.provide('goog.array.ArrayLike');

/**
 * @define {boolean} NATIVE_ARRAY_PROTOTYPES indicates whether the code should
 * rely on Array.prototype functions, if available.
 *
 * The Array.prototype functions can be defined by external libraries like
 * Prototype and setting this flag to _FALSE forces closure to use its own
 * goog.array implementation.
 *
 * If your javascript can be loaded by a third party site and you are wary about
 * relying on the prototype functions, specify
 * "--define goog.NATIVE_ARRAY_PROTOTYPES=_FALSE" to the JSCompiler.
 */
goog.NATIVE_ARRAY_PROTOTYPES = _TRUE;


/**
 * @typedef {Array|NodeList|Arguments|{length: number}}
 */
goog.array.ArrayLike;


/**
 * Returns the last element in an array without removing it.
 * @param {goog.array.ArrayLike} array The array.
 * @return {*} Last item in array.
 */
goog.array.peek = function(array) {
  return array[array.length - 1];
};


/**
 * Reference to the original {@code Array.prototype}.
 * @private
 */
goog.array.ARRAY_PROTOTYPE_ = Array.prototype;


// NOTE(user): Since most of the array functions are generic it allows you to
// pass an array-like object. Strings have a length and are considered array-
// like. However, the 'in' operator does not work on strings so we cannot just
// use the array path even if the browser supports indexing into strings. We
// therefore end up splitting the string.


/**
 * Returns the index of the first element of an array with a specified
 * value, or -1 if the element is not present in the array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-indexof}
 *
 * @param {goog.array.ArrayLike} arr The array to be searched.
 * @param {*} obj The object for which we are searching.
 * @param {number=} opt_fromIndex The index at which to start the search. If
 *     omitted the search starts at index 0.
 * @return {number} The index of the first matching array element.
 */
goog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
                     goog.array.ARRAY_PROTOTYPE_.indexOf ?
    function(arr, obj, opt_fromIndex) {
      return goog.array.ARRAY_PROTOTYPE_.indexOf.call(arr, obj, opt_fromIndex);
    } :
    function(arr, obj, opt_fromIndex) {
      var fromIndex = opt_fromIndex == _NULL ?
          0 : (opt_fromIndex < 0 ?
               Math.max(0, arr.length + opt_fromIndex) : opt_fromIndex);

      if (goog.isString(arr)) {
        // Array.prototype.indexOf uses === so only strings should be found.
        if (!goog.isString(obj) || obj.length != 1) {
          return -1;
        }
        return arr.indexOf(obj, fromIndex);
      }

      for (var i = fromIndex; i < arr.length; i++) {
        if (i in arr && arr[i] === obj)
          return i;
      }
      return -1;
    };

/**
 * Calls a function for each element in an array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-foreach}
 *
 * @param {goog.array.ArrayLike} arr Array or array like object over
 *     which to iterate.
 * @param {Function} f The function to call for every element. This function
 *     takes 3 arguments (the element, the index and the array). The return
 *     value is ignored. The function is called only for indexes of the array
 *     which have assigned values; it is not called for indexes which have
 *     been deleted or which have never been assigned values.
 *
 * @param {Object=} opt_obj The object to be used as the value of 'this'
 *     within f.
 */
goog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES &&
                     goog.array.ARRAY_PROTOTYPE_.forEach ?
    function(arr, f, opt_obj) {
      goog.array.ARRAY_PROTOTYPE_.forEach.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          f.call(opt_obj, arr2[i], i, arr);
        }
      }
    };


/**
 * Calls a function for each element in an array, starting from the last
 * element rather than the first.
 *
 * @param {goog.array.ArrayLike} arr The array over which to iterate.
 * @param {Function} f The function to call for every element. This function
 *     takes 3 arguments (the element, the index and the array). The return
 *     value is ignored.
 * @param {Object=} opt_obj The object to be used as the value of 'this'
 *     within f.
 */
goog.array.forEachRight = function(arr, f, opt_obj) {
  var l = arr.length;  // must be fixed during loop... see docs
  var arr2 = goog.isString(arr) ? arr.split('') : arr;
  for (var i = l - 1; i >= 0; --i) {
    if (i in arr2) {
      f.call(opt_obj, arr2[i], i, arr);
    }
  }
};


/**
 * Calls a function for each element in an array, and if the function returns
 * true adds the element to a new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-filter}
 *
 * @param {goog.array.ArrayLike} arr The array over which to iterate.
 * @param {Function} f The function to call for every element. This function
 *     takes 3 arguments (the element, the index and the array) and must
 *     return a Boolean. If the return value is true the element is added to the
 *     result array. If it is _FALSE the element is not included.
 * @param {Object=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {!Array} a new array in which only elements that passed the test are
 *     present.
 */
goog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES &&
                    goog.array.ARRAY_PROTOTYPE_.filter ?
    function(arr, f, opt_obj) {
      return goog.array.ARRAY_PROTOTYPE_.filter.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var res = [];
      var resLength = 0;
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          var val = arr2[i];  // in case f mutates arr2
          if (f.call(opt_obj, val, i, arr)) {
            res[resLength++] = val;
          }
        }
      }
      return res;
    };


/**
 * Calls a function for each element in an array and inserts the result into a
 * new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-map}
 *
 * @param {goog.array.ArrayLike} arr The array over which to iterate.
 * @param {Function} f The function to call for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return something. The result will be inserted into a new array.
 * @param {Object=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {!Array} a new array with the results from f.
 */
goog.array.map = goog.NATIVE_ARRAY_PROTOTYPES &&
                 goog.array.ARRAY_PROTOTYPE_.map ?
    function(arr, f, opt_obj) {
      return goog.array.ARRAY_PROTOTYPE_.map.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var res = new Array(l);
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          res[i] = f.call(opt_obj, arr2[i], i, arr);
        }
      }
      return res;
    };


/**
 * Calls f for each element of an array. If any call returns true, some()
 * returns true (without checking the remaining elements). If all calls
 * return _FALSE, some() returns _FALSE.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-some}
 *
 * @param {goog.array.ArrayLike} arr The array to check.
 * @param {Function} f The function to call for every element. This function
 *     takes 3 arguments (the element, the index and the array) and must
 *     return a Boolean.
 * @param {Object=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} true if any element passes the test.
 */
goog.array.some = goog.NATIVE_ARRAY_PROTOTYPES &&
                  goog.array.ARRAY_PROTOTYPE_.some ?
    function(arr, f, opt_obj) {
      return goog.array.ARRAY_PROTOTYPE_.some.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
          return _TRUE;
        }
      }
      return _FALSE;
    };


/**
 * Call f for each element of an array. If all calls return true, every()
 * returns true. If any call returns _FALSE, every() returns _FALSE and
 * does not continue to check the remaining elements.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-every}
 *
 * @param {goog.array.ArrayLike} arr The array to check.
 * @param {Function} f The function to call for every element. This function
 *     takes 3 arguments (the element, the index and the array) and must
 *     return a Boolean.
 * @param {Object=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} _FALSE if any element fails the test.
 */
goog.array.every = goog.NATIVE_ARRAY_PROTOTYPES &&
                   goog.array.ARRAY_PROTOTYPE_.every ?
    function(arr, f, opt_obj) {
      return goog.array.ARRAY_PROTOTYPE_.every.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2 && !f.call(opt_obj, arr2[i], i, arr)) {
          return _FALSE;
        }
      }
      return _TRUE;
    };


/**
 * Whether the array contains the given object.
 * @param {goog.array.ArrayLike} arr The array to test for the presence of the
 *     element.
 * @param {*} obj The object for which to test.
 * @return {boolean} true if obj is present.
 */
goog.array.contains = function(arr, obj) {
  return goog.array.indexOf(arr, obj) >= 0;
};


/**
 * Whether the array is empty.
 * @param {goog.array.ArrayLike} arr The array to test.
 * @return {boolean} true if empty.
 */
goog.array.isEmpty = function(arr) {
  return arr.length == 0;
};


/**
 * Clears the array.
 * @param {goog.array.ArrayLike} arr Array or array like object to clear.
 */
goog.array.clear = function(arr) {
  // For non real arrays we don't have the magic length so we delete the
  // indices.
  if (!goog.isArray(arr)) {
    for (var i = arr.length - 1; i >= 0; i--) {
      delete arr[i];
    }
  }
  arr.length = 0;
};


/**
 * Inserts an object at the given index of the array.
 * @param {goog.array.ArrayLike} arr The array to modify.
 * @param {*} obj The object to insert.
 * @param {number=} opt_i The index at which to insert the object. If omitted,
 *      treated as 0. A negative index is counted from the end of the array.
 */
goog.array.insertAt = function(arr, obj, opt_i) {
  goog.array.splice(arr, opt_i, 0, obj);
};


/**
 * Removes the first occurrence of a particular value from an array.
 * @param {goog.array.ArrayLike} arr Array from which to remove value.
 * @param {*} obj Object to remove.
 * @return {boolean} True if an element was removed.
 */
goog.array.remove = function(arr, obj) {
  var i = goog.array.indexOf(arr, obj);
  var rv;
  if ((rv = i >= 0)) {
    goog.array.removeAt(arr, i);
  }
  return rv;
};


/**
 * Removes from an array the element at index i
 * @param {goog.array.ArrayLike} arr Array or array like object from which to
 *     remove value.
 * @param {number} i The index to remove.
 * @return {boolean} True if an element was removed.
 */
goog.array.removeAt = function(arr, i) {
  // use generic form of splice
  // splice returns the removed items and if successful the length of that
  // will be 1
  return goog.array.ARRAY_PROTOTYPE_.splice.call(arr, i, 1).length == 1;
};


/**
 * Returns a new array that is the result of joining the arguments.  If arrays
 * are passed then their items are added, however, if non-arrays are passed they
 * will be added to the return array as is.
 *
 * Note that ArrayLike objects will be added as is, rather than having their
 * items added.
 *
 * goog.array.concat([1, 2], [3, 4]) -> [1, 2, 3, 4]
 * goog.array.concat(0, [1, 2]) -> [0, 1, 2]
 * goog.array.concat([1, 2], null) -> [1, 2, null]
 *
 * There is bug in all current versions of IE (6, 7 and 8) where arrays created
 * in an iframe become corrupted soon (not immediately) after the iframe is
 * destroyed. This is common if loading data via goog.net.IframeIo, for example.
 * This corruption only affects the concat method which will start throwing
 * Catastrophic Errors (#-2147418113).
 *
 * See http://endoflow.com/scratch/corrupted-arrays.html for a test case.
 *
 * Internally goog.array should use this, so that all methods will continue to
 * work on these broken array objects.
 *
 * @param {...*} var_args Items to concatenate.  Arrays will have each item
 *     added, while primitives and objects will be added as is.
 * @return {!Array} The new resultant array.
 */
goog.array.concat = function(var_args) {
  return goog.array.ARRAY_PROTOTYPE_.concat.apply(
      goog.array.ARRAY_PROTOTYPE_, arguments);
};


/**
 * Does a shallow copy of an array.
 * @param {goog.array.ArrayLike} arr  Array or array-like object to clone.
 * @return {!Array} Clone of the input array.
 */
goog.array.clone = function(arr) {
  if (goog.isArray(arr)) {
    return goog.array.concat(/** @type {!Array} */ (arr));
  } else { // array like
    // Concat does not work with non arrays.
    var rv = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      rv[i] = arr[i];
    }
    return rv;
  }
};


/**
 * Converts an object to an array.
 * @param {goog.array.ArrayLike} object  The object to convert to an array.
 * @return {!Array} The object converted into an array. If object has a
 *     length property, every property indexed with a non-negative number
 *     less than length will be included in the result. If object does not
 *     have a length property, an empty array will be returned.
 */
goog.array.toArray = function(object) {
  if (goog.isArray(object)) {
    // This fixes the JS compiler warning and forces the Object to an Array type
    return goog.array.concat(/** @type {!Array} */ (object));
  }
  // Clone what we hope to be an array-like object to an array.
  // We could check isArrayLike() first, but no check we perform would be as
  // reliable as simply making the call.
  return goog.array.clone(/** @type {Array} */ (object));
};


/**
 * Adds or removes elements from an array. This is a generic version of Array
 * splice. This means that it might work on other objects similar to arrays,
 * such as the arguments object.
 *
 * @param {goog.array.ArrayLike} arr The array to modify.
 * @param {number|undefined} index The index at which to start changing the
 *     array. If not defined, treated as 0.
 * @param {number} howMany How many elements to remove (0 means no removal. A
 *     value below 0 is treated as zero and so is any other non number. Numbers
 *     are floored).
 * @param {...*} var_args Optional, additional elements to insert into the
 *     array.
 * @return {!Array} the removed elements.
 */
goog.array.splice = function(arr, index, howMany, var_args) {
  return goog.array.ARRAY_PROTOTYPE_.splice.apply(
      arr, goog.array.slice(arguments, 1));
};


/**
 * Returns a new array from a segment of an array. This is a generic version of
 * Array slice. This means that it might work on other objects similar to
 * arrays, such as the arguments object.
 *
 * @param {goog.array.ArrayLike} arr The array from which to copy a segment.
 * @param {number} start The index of the first element to copy.
 * @param {number=} opt_end The index after the last element to copy.
 * @return {!Array} A new array containing the specified segment of the original
 *     array.
 */
goog.array.slice = function(arr, start, opt_end) {
  // passing 1 arg to slice is not the same as passing 2 where the second is
  // null or undefined (in that case the second argument is treated as 0).
  // we could use slice on the arguments object and then use apply instead of
  // testing the length
  if (arguments.length <= 2) {
    return goog.array.ARRAY_PROTOTYPE_.slice.call(arr, start);
  } else {
    return goog.array.ARRAY_PROTOTYPE_.slice.call(arr, start, opt_end);
  }
};


/**
 * Sorts the specified array into ascending order.  If no opt_compareFn is
 * specified, elements are compared using
 * <code>goog.array.defaultCompare</code>, which compares the elements using
 * the built in < and > operators.  This will produce the expected behavior
 * for homogeneous arrays of String(s) and Number(s), unlike the native sort,
 * but will give unpredictable results for heterogenous lists of strings and
 * numbers with different numbers of digits.
 *
 * This sort is not guaranteed to be stable.
 *
 * Runtime: Same as <code>Array.prototype.sort</code>
 *
 * @param {Array} arr The array to be sorted.
 * @param {Function=} opt_compareFn Optional comparison function by which the
 *     array is to be ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 */
goog.array.sort = function(arr, opt_compareFn) {
  // TODO(user): Update type annotation since null is not accepted.
  goog.array.ARRAY_PROTOTYPE_.sort.call(
      arr, opt_compareFn || goog.array.defaultCompare);
};


/**
 * Compares two arrays for equality. Two arrays are considered equal if they
 * have the same length and their corresponding elements are equal according to
 * the comparison function.
 *
 * @param {goog.array.ArrayLike} arr1 The first array to compare.
 * @param {goog.array.ArrayLike} arr2 The second array to compare.
 * @param {Function=} opt_equalsFn Optional comparison function.
 *     Should take 2 arguments to compare, and return true if the arguments
 *     are equal. Defaults to {@link goog.array.defaultCompareEquality} which
 *     compares the elements using the built-in '===' operator.
 * @return {boolean} Whether the two arrays are equal.
 */
goog.array.equals = function(arr1, arr2, opt_equalsFn) {
  if (!goog.isArrayLike(arr1) || !goog.isArrayLike(arr2) ||
      arr1.length != arr2.length) {
    return _FALSE;
  }
  var l = arr1.length;
  var equalsFn = opt_equalsFn || goog.array.defaultCompareEquality;
  for (var i = 0; i < l; i++) {
    if (!equalsFn(arr1[i], arr2[i])) {
      return _FALSE;
    }
  }
  return _TRUE;
};


/**
 * @deprecated Use {@link goog.array.equals}.
 * @param {goog.array.ArrayLike} arr1 See {@link goog.array.equals}.
 * @param {goog.array.ArrayLike} arr2 See {@link goog.array.equals}.
 * @param {Function=} opt_equalsFn See {@link goog.array.equals}.
 * @return {boolean} See {@link goog.array.equals}.
 */
goog.array.compare = function(arr1, arr2, opt_equalsFn) {
  return goog.array.equals(arr1, arr2, opt_equalsFn);
};


/**
 * Compares its two arguments for order, using the built in < and >
 * operators.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
goog.array.defaultCompare = function(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
};


/**
 * Compares its two arguments for equality, using the built in === operator.
 * @param {*} a The first object to compare.
 * @param {*} b The second object to compare.
 * @return {boolean} True if the two arguments are equal, _FALSE otherwise.
 */
goog.array.defaultCompareEquality = function(a, b) {
  return a === b;
};


/**
 * Returns an array consisting of the given value repeated N times.
 *
 * @param {*} value The value to repeat.
 * @param {number} n The repeat count.
 * @return {!Array.<*>} An array with the repeated value.
 */
goog.array.repeat = function(value, n) {
  var array = [];
  for (var i = 0; i < n; i++) {
    array[i] = value;
  }
  return array;
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for adding, removing and setting classes.
 *
 */


goog.provide('goog.dom.classes');

//goog.require('goog.array');
/**
 * Gets an array of class names on an element
 * @param {Node} element DOM node to get class of.
 * @return {Array} Class names on {@code element}.
 */
goog.dom.classes.get = function(element) {
  var className = element.className;
  // Some types of elements don't have a className in IE (e.g. iframes).
  // Furthermore, in Firefox, className is not a string when the element is
  // an SVG element.
  return className && typeof className.split == 'function' ?
      className.split(/\s+/) : [];
};


/**
 * Adds a class or classes to an element. Does not add multiples of class names.
 * @param {Node} element DOM node to add class to.
 * @param {...string} var_args Class names to add.
 * @return {boolean} Whether class was added (or all classes were added).
 */
goog.dom.classes.add = function(element, var_args) {
  var classes = goog.dom.classes.get(element);
  var args = goog.array.slice(arguments, 1);

  var b = goog.dom.classes.add_(classes, args);
  element.className = classes.join(' ');

  return b;
};


/**
 * Helper method for {@link goog.dom.classes.add} and
 * {@link goog.dom.classes.addRemove}. Adds one or more classes to the supplied
 * classes array.
 * @param {Array.<string>} classes All class names for the element, will be
 *     updated to have the classes supplied in {@code args} added.
 * @param {Array.<string>} args Class names to add.
 * @return {boolean} Whether all classes in were added.
 * @private
 */
goog.dom.classes.add_ = function(classes, args) {
  var rv = 0;
  for (var i = 0; i < args.length; i++) {
    if (!goog.array.contains(classes, args[i])) {
      classes.push(args[i]);
      rv++;
    }
  }
  return rv == args.length;
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating objects/maps/hashes.
 */

goog.provide('goog.object');


/**
 * Calls a function for each element in an object/map/hash.
 *
 * @param {Object} obj The object over which to iterate.
 * @param {Function} f The function to call for every element. This function
 *     takes 3 arguments (the element, the index and the object)
 *     and the return value is irrelevant.
 * @param {Object=} opt_obj This is used as the 'this' object within f.
 */
goog.object.forEach = function(obj, f, opt_obj) {
  for (var key in obj) {
    f.call(opt_obj, obj[key], key, obj);
  }
};


/**
 * Calls a function for each element in an object/map/hash. If that call returns
 * true, adds the element to a new object.
 *
 * @param {Object} obj The object over which to iterate.
 * @param {Function} f The function to call for every element. This
 *     function takes 3 arguments (the element, the index and the object)
 *     and should return a boolean. If the return value is true the
 *     element is added to the result object. If it is _FALSE the
 *     element is not included.
 * @param {Object=} opt_obj This is used as the 'this' object within f.
 * @return {!Object} a new object in which only elements that passed the test
 *     are present.
 */
goog.object.filter = function(obj, f, opt_obj) {
  var res = {};
  for (var key in obj) {
    if (f.call(opt_obj, obj[key], key, obj)) {
      res[key] = obj[key];
    }
  }
  return res;
};


/**
 * For every element in an object/map/hash calls a function and inserts the
 * result into a new object.
 *
 * @param {Object} obj The object over which to iterate.
 * @param {Function} f The function to call for every element. This function
 *     takes 3 arguments (the element, the index and the object)
 *     and should return something. The result will be inserted
 *     into a new object.
 * @param {Object=} opt_obj This is used as the 'this' object within f.
 * @return {!Object} a new object with the results from f.
 */
goog.object.map = function(obj, f, opt_obj) {
  var res = {};
  for (var key in obj) {
    res[key] = f.call(opt_obj, obj[key], key, obj);
  }
  return res;
};


/**
 * Calls a function for each element in an object/map/hash. If
 * all calls return true, returns true. If any call returns _FALSE, returns
 * _FALSE at this point and does not continue to check the remaining elements.
 *
 * @param {Object} obj The object to check.
 * @param {Function} f The function to call for every element. This function
 *     takes 3 arguments (the element, the index and the object) and should
 *     return a boolean.
 * @param {Object=} opt_obj This is used as the 'this' object within f.
 * @return {boolean} _FALSE if any element fails the test.
 */
goog.object.every = function(obj, f, opt_obj) {
  for (var key in obj) {
    if (!f.call(opt_obj, obj[key], key, obj)) {
      return _FALSE;
    }
  }
  return _TRUE;
};


/**
 * Returns the number of key-value pairs in the object map.
 *
 * @param {Object} obj The object for which to get the number of key-value
 *     pairs.
 * @return {number} The number of key-value pairs in the object map.
 */
goog.object.getCount = function(obj) {
  // JS1.5 has __count__ but it has been deprecated so it raises a warning...
  // in other words do not use. Also __count__ only includes the fields on the
  // actual object and not in the prototype chain.
  var rv = 0;
  for (var key in obj) {
    rv++;
  }
  return rv;
};


/**
 * Whether the object/hash/map contains the given object as a value.
 * An alias for goog.object.containsValue(obj, val).
 *
 * @param {Object} obj The object in which to look for val.
 * @param {*} val The object for which to check.
 * @return {boolean} true if val is present.
 */
goog.object.contains = function(obj, val) {
  return goog.object.containsValue(obj, val);
};


/**
 * Returns the values of the object/map/hash.
 *
 * @param {Object} obj The object from which to get the values.
 * @return {!Array} The values in the object/map/hash.
 */
goog.object.getValues = function(obj) {
  var res = [];
  var i = 0;
  for (var key in obj) {
    res[i++] = obj[key];
  }
  return res;
};


/**
 * Returns the keys of the object/map/hash.
 *
 * @param {Object} obj The object from which to get the keys.
 * @return {!Array.<string>} Array of property keys.
 */
goog.object.getKeys = function(obj) {
  var res = [];
  var i = 0;
  for (var key in obj) {
    res[i++] = key;
  }
  return res;
};


/**
 * Whether the object/map/hash contains the given value. This is O(n).
 *
 * @param {Object} obj The object in which to look for val.
 * @param {*} val The value for which to check.
 * @return {boolean} true If the map contains the value.
 */
goog.object.containsValue = function(obj, val) {
  for (var key in obj) {
    if (obj[key] == val) {
      return _TRUE;
    }
  }
  return _FALSE;
};


/**
 * Whether the object/map/hash is empty.
 *
 * @param {Object} obj The object to test.
 * @return {boolean} true if obj is empty.
 */
goog.object.isEmpty = function(obj) {
  for (var key in obj) {
    return _FALSE;
  }
  return _TRUE;
};


/**
 * Removes all key value pairs from the object/map/hash.
 *
 * @param {Object} obj The object to clear.
 */
goog.object.clear = function(obj) {
  for (var i in obj) {
    delete obj[i];
  }
};


/**
 * Removes a key-value pair based on the key.
 *
 * @param {Object} obj The object from which to remove the key.
 * @param {*} key The key to remove.
 * @return {boolean} Whether an element was removed.
 */
goog.object.remove = function(obj, key) {
  var rv;
  if ((rv = key in obj)) {
    delete obj[key];
  }
  return rv;
};


/**
 * Adds a key-value pair to the object. Throws an exception if the key is
 * already in use. Use set if you want to change an existing pair.
 *
 * @param {Object} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {*} val The value to add.
 */
goog.object.add = function(obj, key, val) {
  if (key in obj) {
    throw Error('The object already contains the key "' + key + '"');
  }
  goog.object.set(obj, key, val);
};


/**
 * Returns the value for the given key.
 *
 * @param {Object} obj The object from which to get the value.
 * @param {string} key The key for which to get the value.
 * @param {*=} opt_val The value to return if no item is found for the given
 *     key (default is undefined).
 * @return {*} The value for the given key.
 */
goog.object.get = function(obj, key, opt_val) {
  if (key in obj) {
    return obj[key];
  }
  return opt_val;
};


/**
 * Adds a key-value pair to the object/map/hash.
 *
 * @param {Object} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {*} value The value to add.
 */
goog.object.set = function(obj, key, value) {
  obj[key] = value;
};


/**
 * Does a flat clone of the object.
 *
 * @param {Object} obj Object to clone.
 * @return {!Object} Clone of the input object.
 */
goog.object.clone = function(obj) {
  // We cannot use the prototype trick because a lot of methods depend on where
  // the actual key is set.

  var res = {};
  for (var key in obj) {
    res[key] = obj[key];
  }
  return res;
  // We could also use goog.mixin but I wanted this to be independent from that.
};


/**
 * The names of the fields that are defined on Object.prototype.
 * @type {Array.<string>}
 * @private
 */
goog.object.PROTOTYPE_FIELDS_ = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/**
 * Extends an object with another object.
 * This operates 'in-place'; it does not create a new Object.
 *
 * Example:
 * var o = {};
 * goog.object.extend(o, {a: 0, b: 1});
 * o; // {a: 0, b: 1}
 * goog.object.extend(o, {c: 2});
 * o; // {a: 0, b: 1, c: 2}
 *
 * @param {Object} target  The object to modify.
 * @param {...Object} var_args The objects from which values will be copied.
 */
goog.object.extend = function(target, var_args) {
  var key, source;
  for (var i = 1; i < arguments.length; i++) {
    source = arguments[i];
    for (key in source) {
      target[key] = source[key];
    }

    // For IE the for-in-loop does not contain any properties that are not
    // enumerable on the prototype object (for example isPrototypeOf from
    // Object.prototype) and it will also not include 'replace' on objects that
    // extend String and change 'replace' (not that it is common for anyone to
    // extend anything except Object).

    for (var j = 0; j < goog.object.PROTOTYPE_FIELDS_.length; j++) {
      key = goog.object.PROTOTYPE_FIELDS_[j];
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
};


/**
 * Creates a new object built from the key-value pairs provided as arguments.
 * @param {...*} var_args If only one argument is provided and it is an array
 *     then this is used as the arguments,  otherwise even arguments are used as
 *     the property names and odd arguments are used as the property values.
 * @return {!Object} The new object.
 * @throws {Error} If there are uneven number of arguments or there is only one
 *     non array argument.
 */
goog.object.create = function(var_args) {
  var argLength = arguments.length;
  if (argLength == 1 && goog.isArray(arguments[0])) {
    return goog.object.create.apply(_NULL, arguments[0]);
  }

  if (argLength % 2) {
    throw Error('Uneven number of arguments');
  }

  var rv = {};
  for (var i = 0; i < argLength; i += 2) {
    rv[arguments[i]] = arguments[i + 1];
  }
  return rv;
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines the goog.dom.TagName enum.  This enumerates
 * all html tag names specified by the W3C HTML 4.01 Specification.
 * Reference http://www.w3.org/TR/html401/index/elements.html.
 */
goog.provide('goog.dom.TagName');


/**
 * Enum of all html tag names specified by the W3C HTML 4.01 Specification.
 * Reference http://www.w3.org/TR/html401/index/elements.html
 * @enum {string}
 */
goog.dom.TagName = {
  A: 'A',
  ABBR: 'ABBR',
  ACRONYM: 'ACRONYM',
  ADDRESS: 'ADDRESS',
  APPLET: 'APPLET',
  AREA: 'AREA',
  B: 'B',
  BASE: 'BASE',
  BASEFONT: 'BASEFONT',
  BDO: 'BDO',
  BIG: 'BIG',
  BLOCKQUOTE: 'BLOCKQUOTE',
  BODY: 'BODY',
  BR: 'BR',
  BUTTON: 'BUTTON',
  CANVAS: 'CANVAS',
  CAPTION: 'CAPTION',
  CENTER: 'CENTER',
  CITE: 'CITE',
  CODE: 'CODE',
  COL: 'COL',
  COLGROUP: 'COLGROUP',
  DD: 'DD',
  DEL: 'DEL',
  DFN: 'DFN',
  DIR: 'DIR',
  DIV: 'DIV',
  DL: 'DL',
  DT: 'DT',
  EM: 'EM',
  FIELDSET: 'FIELDSET',
  FONT: 'FONT',
  FORM: 'FORM',
  FRAME: 'FRAME',
  FRAMESET: 'FRAMESET',
  H1: 'H1',
  H2: 'H2',
  H3: 'H3',
  H4: 'H4',
  H5: 'H5',
  H6: 'H6',
  HEAD: 'HEAD',
  HR: 'HR',
  HTML: 'HTML',
  I: 'I',
  IFRAME: 'IFRAME',
  IMG: 'IMG',
  INPUT: 'INPUT',
  INS: 'INS',
  ISINDEX: 'ISINDEX',
  KBD: 'KBD',
  LABEL: 'LABEL',
  LEGEND: 'LEGEND',
  LI: 'LI',
  LINK: 'LINK',
  MAP: 'MAP',
  MENU: 'MENU',
  META: 'META',
  NOFRAMES: 'NOFRAMES',
  NOSCRIPT: 'NOSCRIPT',
  OBJECT: 'OBJECT',
  OL: 'OL',
  OPTGROUP: 'OPTGROUP',
  OPTION: 'OPTION',
  P: 'P',
  PARAM: 'PARAM',
  PRE: 'PRE',
  Q: 'Q',
  S: 'S',
  SAMP: 'SAMP',
  SCRIPT: 'SCRIPT',
  SELECT: 'SELECT',
  SMALL: 'SMALL',
  SPAN: 'SPAN',
  STRIKE: 'STRIKE',
  STRONG: 'STRONG',
  STYLE: 'STYLE',
  SUB: 'SUB',
  SUP: 'SUP',
  TABLE: 'TABLE',
  TBODY: 'TBODY',
  TD: 'TD',
  TEXTAREA: 'TEXTAREA',
  TFOOT: 'TFOOT',
  TH: 'TH',
  THEAD: 'THEAD',
  TITLE: 'TITLE',
  TR: 'TR',
  TT: 'TT',
  U: 'U',
  UL: 'UL',
  VAR: 'VAR'
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A utility class for representing two-dimensional sizes.
 */


goog.provide('goog.math.Size');



/**
 * Class for representing sizes consisting of a width and height. Undefined
 * width and height support is deprecated and results in compiler warning.
 * @param {number} width Width.
 * @param {number} height Height.
 * @constructor
 */
goog.math.Size = function(width, height) {
  /**
   * Width
   * @type {number}
   */
  this.width = width;

  /**
   * Height
   * @type {number}
   */
  this.height = height;
};


/**
 * Compares sizes for equality.
 * @param {goog.math.Size} a A Size.
 * @param {goog.math.Size} b A Size.
 * @return {boolean} True iff the sizes have equal widths and equal
 *     heights, or if both are null.
 */
goog.math.Size.equals = function(a, b) {
  if (a == b) {
    return _TRUE;
  }
  if (!a || !b) {
    return _FALSE;
  }
  return a.width == b.width && a.height == b.height;
};


/**
 * @return {!goog.math.Size} A new copy of the Size.
 */
goog.math.Size.prototype.clone = function() {
  return new goog.math.Size(this.width, this.height);
};


/**
 * @return {number} The area of the size (width * height).
 */
goog.math.Size.prototype.area = function() {
  return this.width * this.height;
};


/**
 * @return {boolean} True if the size has zero area, _FALSE if both dimensions
 *     are non-zero numbers.
 */
goog.math.Size.prototype.isEmpty = function() {
  return !this.area();
};
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Browser capability checks for the dom package.
 *
 */


goog.provide('goog.dom.BrowserFeature');

//goog.require('goog.userAgent');


/**
 * Enum of browser capabilities.
 * @enum {boolean}
 */
goog.dom.BrowserFeature = {
  /**
   * Whether attributes 'name' and 'type' can be added to an element after it's
   * created. _FALSE in Internet Explorer prior to version 9.
   */
  CAN_ADD_NAME_OR_TYPE_ATTRIBUTES: !goog.userAgent.IE ||
      goog.userAgent.isVersion('9'),

  /**
   * Whether we can use element.children to access an element's Element
   * children. Available since Gecko 1.9.1, IE 9. (IE<9 also includes comment
   * nodes in the collection.)
   */
  CAN_USE_CHILDREN_ATTRIBUTE: !goog.userAgent.GECKO && !goog.userAgent.IE ||
      goog.userAgent.IE && goog.userAgent.isVersion('9') ||
      goog.userAgent.GECKO && goog.userAgent.isVersion('1.9.1'),

  /**
   * Opera, Safari 3, and Internet Explorer 9 all support innerText but they
   * include text nodes in script and style tags.
   */
  CAN_USE_INNER_TEXT: goog.userAgent.IE && !goog.userAgent.isVersion('9'),

  /**
   * Whether NoScope elements need a scoped element written before them in
   * innerHTML.
   * MSDN: http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx#1
   */
  INNER_HTML_NEEDS_SCOPED_ELEMENT: goog.userAgent.IE
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A utility class for representing two-dimensional positions.
 */


goog.provide('goog.math.Coordinate');



/**
 * Class for representing coordinates and positions.
 * @param {number=} opt_x Left, defaults to 0.
 * @param {number=} opt_y Top, defaults to 0.
 * @constructor
 */
goog.math.Coordinate = function(opt_x, opt_y) {
  /**
   * X-value
   * @type {number}
   */
  this.x = goog.isDef(opt_x) ? opt_x : 0;

  /**
   * Y-value
   * @type {number}
   */
  this.y = goog.isDef(opt_y) ? opt_y : 0;
};


/**
 * Returns a new copy of the coordinate.
 * @return {!goog.math.Coordinate} A clone of this coordinate.
 */
goog.math.Coordinate.prototype.clone = function() {
  return new goog.math.Coordinate(this.x, this.y);
};


/**
 * Compares coordinates for equality.
 * @param {goog.math.Coordinate} a A Coordinate.
 * @param {goog.math.Coordinate} b A Coordinate.
 * @return {boolean} True iff the coordinates are equal, or if both are null.
 */
goog.math.Coordinate.equals = function(a, b) {
  if (a == b) {
    return _TRUE;
  }
  if (!a || !b) {
    return _FALSE;
  }
  return a.x == b.x && a.y == b.y;
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating the browser's Document Object Model
 * Inspiration taken *heavily* from mochikit (http://mochikit.com/).
 *
 * You can use {@link goog.dom.DomHelper} to create new dom helpers that refer
 * to a different document object.  This is useful if you are working with
 * frames or multiple windows.
 *
 */


// TODO(user): Rename/refactor getTextContent and getRawTextContent. The problem
// is that getTextContent should mimic the DOM3 textContent. We should add a
// getInnerText (or getText) which tries to return the visible text, innerText.


goog.provide('goog.dom');
goog.provide('goog.dom.DomHelper');
goog.provide('goog.dom.NodeType');

//goog.require('goog.array');
//goog.require('goog.dom.BrowserFeature');
//goog.require('goog.dom.TagName');
//goog.require('goog.dom.classes');
//goog.require('goog.math.Coordinate');
//goog.require('goog.math.Size');
//goog.require('goog.object');
//goog.require('goog.string');
//goog.require('goog.userAgent');


/**
 * @define {boolean} Whether we know at compile time that the browser is in
 * quirks mode.
 */
goog.dom.ASSUME_QUIRKS_MODE = _FALSE;


/**
 * @define {boolean} Whether we know at compile time that the browser is in
 * standards compliance mode.
 */
goog.dom.ASSUME_STANDARDS_MODE = _FALSE;


/**
 * Whether we know the compatibility mode at compile time.
 * @type {boolean}
 * @private
 */
goog.dom.COMPAT_MODE_KNOWN_ =
    goog.dom.ASSUME_QUIRKS_MODE || goog.dom.ASSUME_STANDARDS_MODE;


/**
 * Enumeration for DOM node types (for reference)
 * @enum {number}
 */
goog.dom.NodeType = {
  ELEMENT: 1,
  ATTRIBUTE: 2,
  TEXT: 3,
  CDATA_SECTION: 4,
  ENTITY_REFERENCE: 5,
  ENTITY: 6,
  PROCESSING_INSTRUCTION: 7,
  COMMENT: 8,
  DOCUMENT: 9,
  DOCUMENT_TYPE: 10,
  DOCUMENT_FRAGMENT: 11,
  NOTATION: 12
};


/**
 * Gets the DomHelper object for the document where the element resides.
 * @param {Node|Window=} opt_element If present, gets the DomHelper for this
 *     element.
 * @return {!goog.dom.DomHelper} The DomHelper.
 */
goog.dom.getDomHelper = function(opt_element) {
  return opt_element ?
      new goog.dom.DomHelper(goog.dom.getOwnerDocument(opt_element)) :
      (goog.dom.defaultDomHelper_ ||
          (goog.dom.defaultDomHelper_ = new goog.dom.DomHelper()));
};


/**
 * Cached default DOM helper.
 * @type {goog.dom.DomHelper}
 * @private
 */
goog.dom.defaultDomHelper_;


/**
 * Gets the document object being used by the dom library.
 * @return {!Document} Document object.
 */
goog.dom.getDocument = function() {
  return document;
};


/**
 * Alias for getElementById. If a DOM node is passed in then we just return
 * that.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 */
goog.dom.getElement = function(element) {
  return goog.isString(element) ?
      _DOC.getElementById(element) : element;
};


/**
 * Alias for getElement.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 * @deprecated Use {@link goog.dom.getElement} instead.
 */
goog.dom.$ = goog.dom.getElement;


/**
 * Looks up elements by both tag and class name, using browser native functions
 * ({@code querySelectorAll}, {@code getElementsByTagName} or
 * {@code getElementsByClassName}) where possible. This function
 * is a useful, if limited, way of collecting a list of DOM elements
 * with certain characteristics.  {@code goog.dom.query} offers a
 * more powerful and general solution which allows matching on CSS3
 * selector expressions, but at increased cost in code size. If all you
 * need is particular tags belonging to a single class, this function
 * is fast and sleek.
 *
 * @see {goog.dom.query}
 *
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {Document|Element=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 */
goog.dom.getElementsByTagNameAndClass = function(opt_tag, opt_class, opt_el) {
  return goog.dom.getElementsByTagNameAndClass_(document, opt_tag, opt_class,
                                                opt_el);
};


/**
 * Returns an array of all the elements with the provided className.
 * @see {goog.dom.query}
 * @param {!string} className the name of the class to look for.
 * @param {Document|Element=} opt_el Optional element to look in.
 * @return { {length: number} } The items found with the class name provided.
 */
goog.dom.getElementsByClass = function(className, opt_el) {
  var parent = opt_el || document;
  if (goog.dom.canUseQuerySelector_(parent)) {
    return parent.querySelectorAll('.' + className);
  } else if (parent.getElementsByClassName) {
    return parent.getElementsByClassName(className);
  }
  return goog.dom.getElementsByTagNameAndClass_(
      document, '*', className, opt_el);
};


/**
 * Returns the first element with the provided className.
 * @see {goog.dom.query}
 * @param {!string} className the name of the class to look for.
 * @param {Element|Document=} opt_el Optional element to look in.
 * @return {Element} The first item with the class name provided.
 */
goog.dom.getElementByClass = function(className, opt_el) {
  var parent = opt_el || document;
  var retVal = _NULL;
  if (goog.dom.canUseQuerySelector_(parent)) {
    retVal = parent.querySelector('.' + className);
  } else {
    retVal = goog.dom.getElementsByClass(className, opt_el)[0];
  }
  return retVal || _NULL;
};


/**
 * Prefer the standardized (http://www.w3.org/TR/selectors-api/), native and
 * fast W3C Selectors API. However, the version of WebKit that shipped with
 * Safari 3.1 and Chrome has a bug where it will not correctly match mixed-
 * case class name selectors in quirks mode.
 * @param {!Element|Document} parent The parent document object.
 * @return {boolean} whether or not we can use parent.querySelector* APIs.
 * @private
 */
goog.dom.canUseQuerySelector_ = function(parent) {
  return parent.querySelectorAll &&
         parent.querySelector &&
         (!goog.userAgent.WEBKIT || goog.dom.isCss1CompatMode_(document) ||
          goog.userAgent.isVersion('528'));
};


/**
 * Helper for {@code getElementsByTagNameAndClass}.
 * @param {!Document} doc The document to get the elements in.
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {Document|Element=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 * @private
 */
goog.dom.getElementsByTagNameAndClass_ = function(doc, opt_tag, opt_class,
                                                  opt_el) {
  var parent = opt_el || doc;
  var tagName = (opt_tag && opt_tag != '*') ? opt_tag.toUpperCase() : '';

  if (goog.dom.canUseQuerySelector_(parent) &&
      (tagName || opt_class)) {
    var query = tagName + (opt_class ? '.' + opt_class : '');
    return parent.querySelectorAll(query);
  }

  // Use the native getElementsByClassName if available, under the assumption
  // that even when the tag name is specified, there will be fewer elements to
  // filter through when going by class than by tag name
  if (opt_class && parent.getElementsByClassName) {
    var els = parent.getElementsByClassName(opt_class);

    if (tagName) {
      var arrayLike = {};
      var len = 0;

      // Filter for specific tags if requested.
      for (var i = 0, el; el = els[i]; i++) {
        if (tagName == el.nodeName) {
          arrayLike[len++] = el;
        }
      }
      arrayLike.length = len;

      return arrayLike;
    } else {
      return els;
    }
  }

  var els = parent.getElementsByTagName(tagName || '*');

  if (opt_class) {
    var arrayLike = {};
    var len = 0;
    for (var i = 0, el; el = els[i]; i++) {
      var className = el.className;
      // Check if className has a split function since SVG className does not.
      if (typeof className.split == 'function' &&
          goog.array.contains(className.split(/\s+/), opt_class)) {
        arrayLike[len++] = el;
      }
    }
    arrayLike.length = len;
    return arrayLike;
  } else {
    return els;
  }
};


/**
 * Alias for {@code getElementsByTagNameAndClass}.
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {Element=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 * @deprecated Use {@link goog.dom.getElementsByTagNameAndClass} instead.
 */
goog.dom.$$ = goog.dom.getElementsByTagNameAndClass;


/**
 * Sets multiple properties on a node.
 * @param {Element} element DOM node to set properties on.
 * @param {Object} properties Hash of property:value pairs.
 */
goog.dom.setProperties = function(element, properties) {
  goog.object.forEach(properties, function(val, key) {
    if (key == 'style') {
      element.style.cssText = val;
    } else if (key == 'class') {
      element.className = val;
    } else if (key == 'for') {
      element.htmlFor = val;
    } else if (key in goog.dom.DIRECT_ATTRIBUTE_MAP_) {
      element.setAttribute(goog.dom.DIRECT_ATTRIBUTE_MAP_[key], val);
    } else {
      element[key] = val;
    }
  });
};


/**
 * Map of attributes that should be set using
 * element.setAttribute(key, val) instead of element[key] = val.  Used
 * by goog.dom.setProperties.
 *
 * @type {Object}
 * @private
 */
goog.dom.DIRECT_ATTRIBUTE_MAP_ = {
  'cellpadding': 'cellPadding',
  'cellspacing': 'cellSpacing',
  'colspan': 'colSpan',
  'rowspan': 'rowSpan',
  'valign': 'vAlign',
  'height': 'height',
  'width': 'width',
  'usemap': 'useMap',
  'frameborder': 'frameBorder',
  'maxlength': 'maxLength',
  'type': 'type'
};


/**
 * Gets the dimensions of the viewport.
 *
 * Gecko Standards mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of body element.
 *
 * docEl.clientHeight Height of viewport excluding scrollbar.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of document.
 *
 * Gecko Backwards compatible mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight Height of document.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * IE6/7 Standards mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Undefined.
 * body.clientWidth   Width of body element.
 *
 * docEl.clientHeight Height of viewport excluding scrollbar.
 * win.innerHeight    Undefined.
 * body.clientHeight  Height of document element.
 *
 * IE5 + IE6/7 Backwards compatible mode:
 * docEl.clientWidth  0.
 * win.innerWidth     Undefined.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight 0.
 * win.innerHeight    Undefined.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * Opera 9 Standards and backwards compatible mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight Height of document.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * WebKit:
 * Safari 2
 * docEl.clientHeight Same as scrollHeight.
 * docEl.clientWidth  Same as innerWidth.
 * win.innerWidth     Width of viewport excluding scrollbar.
 * win.innerHeight    Height of the viewport including scrollbar.
 * frame.innerHeight  Height of the viewport exluding scrollbar.
 *
 * Safari 3 (tested in 522)
 *
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * docEl.clientHeight Height of viewport excluding scrollbar in strict mode.
 * body.clientHeight  Height of viewport excluding scrollbar in quirks mode.
 *
 * @param {Window=} opt_window Optional window element to test.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 */
goog.dom.getViewportSize = function(opt_window) {
  // TODO(user): This should not take an argument
  return goog.dom.getViewportSize_(opt_window || window);
};


/**
 * Helper for {@code getViewportSize}.
 * @param {Window} win The window to get the view port size for.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 * @private
 */
goog.dom.getViewportSize_ = function(win) {
  var doc = win.document;

  if (goog.userAgent.WEBKIT && !goog.userAgent.isVersion('500') &&
      !goog.userAgent.MOBILE) {
    // TODO(user): Sometimes we get something that isn't a valid window
    // object. In this case we just revert to the current window. We need to
    // figure out when this happens and find a real fix for it.
    // See the comments on goog.dom.getWindow.
    if (typeof win.innerHeight == _UNDEFINED+'') {
      win = window;
    }
    var innerHeight = win.innerHeight;
    var scrollHeight = win.document.documentElement.scrollHeight;

    if (win == win.top) {
      if (scrollHeight < innerHeight) {
        innerHeight -= 15; // Scrollbars are 15px wide on Mac
      }
    }
    return new goog.math.Size(win.innerWidth, innerHeight);
  }

  var el = goog.dom.isCss1CompatMode_(doc) ? doc.documentElement : doc.body;

  return new goog.math.Size(el.clientWidth, el.clientHeight);
};


/**
 * Gets the window object associated with the given document.
 *
 * @param {Document=} opt_doc  Document object to get window for.
 * @return {Window} The window associated with the given document.
 */
goog.dom.getWindow = function(opt_doc) {
  // TODO(user): This should not take an argument.
  return opt_doc ? goog.dom.getWindow_(opt_doc) : window;
};


/**
 * Helper for {@code getWindow}.
 *
 * @param {!Document} doc  Document object to get window for.
 * @return {!Window} The window associated with the given document.
 * @private
 */
goog.dom.getWindow_ = function(doc) {
  return doc.parentWindow || doc.defaultView;
};


/**
 * Returns a dom node with a set of attributes.  This function accepts varargs
 * for subsequent nodes to be added.  Subsequent nodes will be added to the
 * first node as childNodes.
 *
 * So:
 * <code>createDom('div', null, createDom('p'), createDom('p'));</code>
 * would return a div with two child paragraphs
 *
 * @param {string} tagName Tag to create.
 * @param {Object|Array.<string>|string=} opt_attributes If object, then a map
 *     of name-value pairs for attributes. If a string, then this is the
 *     className of the new element. If an array, the elements will be joined
 *     together as the className of the new element.
 * @param {...Object|string|Array|NodeList} var_args Further DOM nodes or
 *     strings for text nodes. If one of the var_args is an array or NodeList,i
 *     its elements will be added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 */
goog.dom.createDom = function(tagName, opt_attributes, var_args) {
  return goog.dom.createDom_(document, arguments);
};


/**
 * Helper for {@code createDom}.
 * @param {!Document} doc The document to create the DOM in.
 * @param {!Arguments} args Argument object passed from the callers. See
 *     {@code goog.dom.createDom} for details.
 * @return {!Element} Reference to a DOM node.
 * @private
 */
goog.dom.createDom_ = function(doc, args) {
  var tagName = args[0];
  var attributes = args[1];

  // Internet Explorer is dumb: http://msdn.microsoft.com/workshop/author/
  //                            dhtml/reference/properties/name_2.asp
  // Also does not allow setting of 'type' attribute on 'input' or 'button'.
  if (!goog.dom.BrowserFeature.CAN_ADD_NAME_OR_TYPE_ATTRIBUTES && attributes &&
      (attributes.name || attributes.type)) {
    var tagNameArr = ['<', tagName];
    if (attributes.name) {
      tagNameArr.push(' name="', goog.string.htmlEscape(attributes.name),
                      '"');
    }
    if (attributes.type) {
      tagNameArr.push(' type="', goog.string.htmlEscape(attributes.type),
                      '"');

      // Clone attributes map to remove 'type' without mutating the input.
      var clone = {};
      goog.object.extend(clone, attributes);
      attributes = clone;
      delete attributes.type;
    }
    tagNameArr.push('>');
    tagName = tagNameArr.join('');
  }

  var element = doc.createElement(tagName);

  if (attributes) {
    if (goog.isString(attributes)) {
      element.className = attributes;
    } else if (goog.isArray(attributes)) {
      goog.dom.classes.add.apply(_NULL, [element].concat(attributes));
    } else {
      goog.dom.setProperties(element, attributes);
    }
  }

  if (args.length > 2) {
    goog.dom.append_(doc, element, args, 2);
  }

  return element;
};


/**
 * Appends a node with text or other nodes.
 * @param {!Document} doc The document to create new nodes in.
 * @param {!Node} parent The node to append nodes to.
 * @param {!Arguments} args The values to add. See {@code goog.dom.append}.
 * @param {number} startIndex The index of the array to start from.
 * @private
 */
goog.dom.append_ = function(doc, parent, args, startIndex) {
  function childHandler(child) {
    // TODO(user): More coercion, ala MochiKit?
    if (child) {
      parent.appendChild(goog.isString(child) ?
          doc.createTextNode(child) : child);
    }
  }

  for (var i = startIndex; i < args.length; i++) {
    var arg = args[i];
    // TODO(user): Fix isArrayLike to return _FALSE for a text node.
    if (goog.isArrayLike(arg) && !goog.dom.isNodeLike(arg)) {
      // If the argument is a node list, not a real array, use a clone,
      // because forEach can't be used to mutate a NodeList.
      goog.array.forEach(goog.dom.isNodeList(arg) ?
          goog.array.clone(arg) : arg,
          childHandler);
    } else {
      childHandler(arg);
    }
  }
};


/**
 * Alias for {@code createDom}.
 * @param {string} tagName Tag to create.
 * @param {string|Object=} opt_attributes If object, then a map of name-value
 *     pairs for attributes. If a string, then this is the className of the new
 *     element.
 * @param {...Object|string|Array|NodeList} var_args Further DOM nodes or
 *     strings for text nodes. If one of the var_args is an array, its
 *     children will be added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 * @deprecated Use {@link goog.dom.createDom} instead.
 */
goog.dom.$dom = goog.dom.createDom;


/**
 * Creates a new element.
 * @param {string} name Tag name.
 * @return {!Element} The new element.
 */
goog.dom.createElement = function(name) {
  return _DOC.createElement(name);
};


/**
 * Creates a new text node.
 * @param {string} content Content.
 * @return {!Text} The new text node.
 */
goog.dom.createTextNode = function(content) {
  return _DOC.createTextNode(content);
};


/**
 * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
 * mode, _FALSE otherwise.
 * @param {Document} doc The document to check.
 * @return {boolean} True if in CSS1-compatible mode.
 * @private
 */
goog.dom.isCss1CompatMode_ = function(doc) {
  if (goog.dom.COMPAT_MODE_KNOWN_) {
    return goog.dom.ASSUME_STANDARDS_MODE;
  }

  return doc.compatMode == 'CSS1Compat';
};


/**
 * Determines if the given node can contain children, intended to be used for
 * HTML generation.
 *
 * IE natively supports node.canHaveChildren but has inconsistent behavior.
 * Prior to IE8 the base tag allows children and in IE9 all nodes return true
 * for canHaveChildren.
 *
 * In practice all non-IE browsers allow you to add children to any node, but
 * the behavior is inconsistent:
 *
 * <pre>
 *   var a = document.createElement('br');
 *   a.appendChild(document.createTextNode('foo'));
 *   a.appendChild(document.createTextNode('bar'));
 *     // 2
 *     // Chrome: "", IE9: "foobar", FF3.5: "foobar"
 * </pre>
 *
 * TODO(user): Rename shouldAllowChildren() ?
 *
 * @param {Node} node The node to check.
 * @return {boolean} Whether the node can contain children.
 */
goog.dom.canHaveChildren_OLD = function(node) {
  if (node.nodeType != goog.dom.NodeType.ELEMENT) {
    return _FALSE;
  }
  switch (node.tagName) {
    case goog.dom.TagName.APPLET:
    case goog.dom.TagName.AREA:
    case goog.dom.TagName.BASE:
    case goog.dom.TagName.BR:
    case goog.dom.TagName.COL:
    case goog.dom.TagName.FRAME:
    case goog.dom.TagName.HR:
    case goog.dom.TagName.IMG:
    case goog.dom.TagName.INPUT:
    case goog.dom.TagName.IFRAME:
    case goog.dom.TagName.ISINDEX:
    case goog.dom.TagName.LINK:
    case goog.dom.TagName.NOFRAMES:
    case goog.dom.TagName.NOSCRIPT:
    case goog.dom.TagName.META:
    case goog.dom.TagName.OBJECT:
    case goog.dom.TagName.PARAM:
    case goog.dom.TagName.SCRIPT:
    case goog.dom.TagName.STYLE:
      return _FALSE;
  }
  return _TRUE;
};

goog.dom.TAGS_CANT_HAVE_CHILDREN = {
		APPLET: _TRUE,
		AREA: _TRUE,
		BASE: _TRUE,
		BR: _TRUE,
		COL: _TRUE,
		FRAME: _TRUE,
		HR: _TRUE,
		IMG: _TRUE,
		INPUT: _TRUE,
		IFRAME: _TRUE,
		ISINDEX: _TRUE,
		LINK: _TRUE,
		NOFRAMES: _TRUE,
		NOSCRIPT: _TRUE,
		META: _TRUE,
		OBJECT: _TRUE,
		PARAM: _TRUE,
		SCRIPT: _TRUE,
		STYLE: _TRUE
};
goog.dom.canHaveChildren = function(node) {
  return node.nodeType == goog.dom.NodeType.ELEMENT &&
      !goog.dom.TAGS_CANT_HAVE_CHILDREN[node.tagName];
};

/**
 * Appends a child to a node.
 * @param {Node} parent Parent.
 * @param {Node} child Child.
 */
goog.dom.appendChild = function(parent, child) {
  parent.appendChild(child);
};


/**
 * Appends a node with text or other nodes.
 * @param {!Node} parent The node to append nodes to.
 * @param {...goog.dom.Appendable} var_args The things to append to the node.
 *     If this is a Node it is appended as is.
 *     If this is a string then a text node is appended.
 *     If this is an array like object then fields 0 to length - 1 are appended.
 */
goog.dom.append = function(parent, var_args) {
  goog.dom.append_(goog.dom.getOwnerDocument(parent), parent, arguments, 1);
};


/**
 * Removes all the child nodes on a DOM node.
 * @param {Node} node Node to remove children from.
 */
goog.dom.removeChildren = function(node) {
  // Note: Iterations over live collections can be slow, this is the fastest
  // we could find. The double parenthesis are used to prevent JsCompiler and
  // strict warnings.
  var child;
  while ((child = node.firstChild)) {
    node.removeChild(child);
  }
};


/**
 * Inserts a new node before an existing reference node (i.e. as the previous
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert before.
 */
goog.dom.insertSiblingBefore = function(newNode, refNode) {
  if (refNode.parentNode) {
    refNode.parentNode.insertBefore(newNode, refNode);
  }
};


/**
 * Inserts a new node after an existing reference node (i.e. as the next
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert after.
 */
goog.dom.insertSiblingAfter = function(newNode, refNode) {
  if (refNode.parentNode) {
    refNode.parentNode.insertBefore(newNode, refNode.nextSibling);
  }
};


/**
 * Removes a node from its parent.
 * @param {Node} node The node to remove.
 * @return {Node} The node removed if removed; else, null.
 */
goog.dom.removeNode = function(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : _NULL;
};


/**
 * Replaces a node in the DOM tree. Will do nothing if {@code oldNode} has no
 * parent.
 * @param {Node} newNode Node to insert.
 * @param {Node} oldNode Node to replace.
 */
goog.dom.replaceNode = function(newNode, oldNode) {
  var parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
};


/**
 * Flattens an element. That is, removes it and replace it with its children.
 * Does nothing if the element is not in the document.
 * @param {Element} element The element to flatten.
 * @return {Element|undefined} The original element, detached from the document
 *     tree, sans children; or undefined, if the element was not in the
 *     document to begin with.
 */
goog.dom.flattenElement = function(element) {
  var child, parent = element.parentNode;
  if (parent && parent.nodeType != goog.dom.NodeType.DOCUMENT_FRAGMENT) {
    // Use IE DOM method (supported by Opera too) if available
    if (element.removeNode) {
      return /** @type {Element} */ (element.removeNode(_FALSE));
    } else {
      // Move all children of the original node up one level.
      while ((child = element.firstChild)) {
        parent.insertBefore(child, element);
      }

      // Detach the original element.
      return /** @type {Element} */ (goog.dom.removeNode(element));
    }
  }
};


/**
 * Whether the object looks like a DOM node.
 * @param {*} obj The object being tested for node likeness.
 * @return {boolean} Whether the object looks like a DOM node.
 */
goog.dom.isNodeLike = function(obj) {
  return goog.isObject(obj) && obj.nodeType > 0;
};


/**
 * Whether a node contains another node.
 * @param {Node} parent The node that should contain the other node.
 * @param {Node} descendant The node to test presence of.
 * @return {boolean} Whether the parent node contains the descendent node.
 */
goog.dom.contains = function(parent, descendant) {
  // We use browser specific methods for this if available since it is faster
  // that way.

  // IE DOM
  if (parent.contains && descendant.nodeType == goog.dom.NodeType.ELEMENT) {
    return parent == descendant || parent.contains(descendant);
  }

  // W3C DOM Level 3
  if (typeof parent.compareDocumentPosition != _UNDEFINED+'') {
    return parent == descendant ||
        Boolean(parent.compareDocumentPosition(descendant) & 16);
  }

  // W3C DOM Level 1
  while (descendant && parent != descendant) {
    descendant = descendant.parentNode;
  }
  return descendant == parent;
};


/**
 * Compares the document order of two nodes, returning 0 if they are the same
 * node, a negative number if node1 is before node2, and a positive number if
 * node2 is before node1.  Note that we compare the order the tags appear in the
 * document so in the tree <b><i>text</i></b> the B node is considered to be
 * before the I node.
 *
 * @param {Node} node1 The first node to compare.
 * @param {Node} node2 The second node to compare.
 * @return {number} 0 if the nodes are the same node, a negative number if node1
 *     is before node2, and a positive number if node2 is before node1.
 */
goog.dom.compareNodeOrder = function(node1, node2) {
  // Fall out quickly for equality.
  if (node1 == node2) {
    return 0;
  }

  // Use compareDocumentPosition where available
  if (node1.compareDocumentPosition) {
    // 4 is the bitmask for FOLLOWS.
    return node1.compareDocumentPosition(node2) & 2 ? 1 : -1;
  }

  // Process in IE using sourceIndex - we check to see if the first node has
  // a source index or if its parent has one.
  if ('sourceIndex' in node1 ||
      (node1.parentNode && 'sourceIndex' in node1.parentNode)) {
    var isElement1 = node1.nodeType == goog.dom.NodeType.ELEMENT;
    var isElement2 = node2.nodeType == goog.dom.NodeType.ELEMENT;

    if (isElement1 && isElement2) {
      return node1.sourceIndex - node2.sourceIndex;
    } else {
      var parent1 = node1.parentNode;
      var parent2 = node2.parentNode;

      if (parent1 == parent2) {
        return goog.dom.compareSiblingOrder_(node1, node2);
      }

      if (!isElement1 && goog.dom.contains(parent1, node2)) {
        return -1 * goog.dom.compareParentsDescendantNodeIe_(node1, node2);
      }


      if (!isElement2 && goog.dom.contains(parent2, node1)) {
        return goog.dom.compareParentsDescendantNodeIe_(node2, node1);
      }

      return (isElement1 ? node1.sourceIndex : parent1.sourceIndex) -
             (isElement2 ? node2.sourceIndex : parent2.sourceIndex);
    }
  }

  // For Safari, we compare ranges.
  var doc = goog.dom.getOwnerDocument(node1);

  var range1, range2;
  range1 = doc.createRange();
  range1.selectNode(node1);
  range1.collapse(_TRUE);

  range2 = doc.createRange();
  range2.selectNode(node2);
  range2.collapse(_TRUE);

  return range1.compareBoundaryPoints(goog.global['Range'].START_TO_END,
      range2);
};


/**
 * Utility function to compare the position of two nodes, when
 * {@code textNode}'s parent is an ancestor of {@code node}.  If this entry
 * condition is not met, this function will attempt to reference a null object.
 * @param {Node} textNode The textNode to compare.
 * @param {Node} node The node to compare.
 * @return {number} -1 if node is before textNode, +1 otherwise.
 * @private
 */
goog.dom.compareParentsDescendantNodeIe_ = function(textNode, node) {
  var parent = textNode.parentNode;
  if (parent == node) {
    // If textNode is a child of node, then node comes first.
    return -1;
  }
  var sibling = node;
  while (sibling.parentNode != parent) {
    sibling = sibling.parentNode;
  }
  return goog.dom.compareSiblingOrder_(sibling, textNode);
};


/**
 * Utility function to compare the position of two nodes known to be non-equal
 * siblings.
 * @param {Node} node1 The first node to compare.
 * @param {Node} node2 The second node to compare.
 * @return {number} -1 if node1 is before node2, +1 otherwise.
 * @private
 */
goog.dom.compareSiblingOrder_ = function(node1, node2) {
  var s = node2;
  while ((s = s.previousSibling)) {
    if (s == node1) {
      // We just found node1 before node2.
      return -1;
    }
  }

  // Since we didn't find it, node1 must be after node2.
  return 1;
};


/**
 * Find the deepest common ancestor of the given nodes.
 * @param {...Node} var_args The nodes to find a common ancestor of.
 * @return {Node} The common ancestor of the nodes, or null if there is none.
 *     null will only be returned if two or more of the nodes are from different
 *     documents.
 */
goog.dom.findCommonAncestor = function(var_args) {
  var i, count = arguments.length;
  if (!count) {
    return _NULL;
  } else if (count == 1) {
    return arguments[0];
  }

  var paths = [];
  var minLength = Infinity;
  for (i = 0; i < count; i++) {
    // Compute the list of ancestors.
    var ancestors = [];
    var node = arguments[i];
    while (node) {
      ancestors.unshift(node);
      node = node.parentNode;
    }

    // Save the list for comparison.
    paths.push(ancestors);
    minLength = Math.min(minLength, ancestors.length);
  }
  var output = _NULL;
  for (i = 0; i < minLength; i++) {
    var first = paths[0][i];
    for (var j = 1; j < count; j++) {
      if (first != paths[j][i]) {
        return output;
      }
    }
    output = first;
  }
  return output;
};


/**
 * Returns the owner document for a node.
 * @param {Node|Window} node The node to get the document for.
 * @return {!Document} The document owning the node.
 */
goog.dom.getOwnerDocument = function(node) {
  // TODO(user): Remove IE5 code.
  // IE5 uses document instead of ownerDocument
  return /** @type {!Document} */ (
      node.nodeType == goog.dom.NodeType.DOCUMENT ? node :
      node.ownerDocument || node.document);
};

/**
 * Gets the outerHTML of a node, which islike innerHTML, except that it
 * actually contains the HTML of the node itself.
 * @param {Element} element The element to get the HTML of.
 * @return {string} The outerHTML of the given element.
 */
goog.dom.getOuterHtml = function(element) {
  // IE, Opera and WebKit all have outerHTML.
  if ('outerHTML' in element) {
    return element.outerHTML;
  } else {
    var doc = goog.dom.getOwnerDocument(element);
    var div = doc.createElement('div');
    div.appendChild(element.cloneNode(_TRUE));
    return div.innerHTML;
  }
};


/**
 * Map of tags whose content to ignore when calculating text length.
 * @type {Object}
 * @private
 */
goog.dom.TAGS_TO_IGNORE_ = {
  'SCRIPT': 1,
  'STYLE': 1,
  'HEAD': 1,
  'IFRAME': 1,
  'OBJECT': 1
};


/**
 * Map of tags which have predefined values with regard to whitespace.
 * @type {Object}
 * @private
 */
goog.dom.PREDEFINED_TAG_VALUES_ = {'IMG': ' ', 'BR': '\n'};


/**
 * Returns the text content of the current node, without markup and invisible
 * symbols. New lines are stripped and whitespace is collapsed,
 * such that each character would be visible.
 *
 * In browsers that support it, innerText is used.  Other browsers attempt to
 * simulate it via node traversal.  Line breaks are canonicalized in IE.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The text content.
 */
goog.dom.getTextContent = function(node) {
  var textContent;
  // Note(user): IE9, Opera, and Safara 3 support innerText but they include
  // text nodes in script tags. So we revert to use a user agent test here.
  if (goog.dom.BrowserFeature.CAN_USE_INNER_TEXT && ('innerText' in node)) {
    textContent = goog.string.canonicalizeNewlines(node.innerText);
    // Unfortunately .innerText() returns text with &shy; symbols
    // We need to filter it out and then remove duplicate whitespaces
  } else {
    var buf = [];
    goog.dom.getTextContent_(node, buf, _TRUE);
    textContent = buf.join('');
  }

  // Strip &shy; entities. goog.format.insertWordBreaks inserts them in Opera.
  textContent = textContent.replace(/ \xAD /g, ' ').replace(/\xAD/g, '');
  // Strip &#8203; entities. goog.format.insertWordBreaks inserts them in IE8.
  textContent = textContent.replace(/\u200B/g, '');

  // Skip this replacement on IE, which automatically turns &nbsp; into ' '
  // and / +/ into ' ' when reading innerText.
  if (!goog.userAgent.IE) {
    textContent = textContent.replace(/ +/g, ' ');
  }
  if (textContent != ' ') {
    textContent = textContent.replace(/^\s*/, '');
  }

  return textContent;
};


/**
 * Returns the text content of the current node, without markup.
 *
 * Unlike {@code getTextContent} this method does not collapse whitespaces
 * or normalize lines breaks.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The raw text content.
 */
goog.dom.getRawTextContent = function(node) {
  var buf = [];
  goog.dom.getTextContent_(node, buf, _FALSE);

  return buf.join('');
};


/**
 * Recursive support function for text content retrieval.
 *
 * @param {Node} node The node from which we are getting content.
 * @param {Array} buf string buffer.
 * @param {boolean} normalizeWhitespace Whether to normalize whitespace.
 * @private
 */
goog.dom.getTextContent_ = function(node, buf, normalizeWhitespace) {
  if (node.nodeName in goog.dom.TAGS_TO_IGNORE_) {
    // ignore certain tags
  } else if (node.nodeType == goog.dom.NodeType.TEXT) {
    if (normalizeWhitespace) {
      buf.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
    } else {
      buf.push(node.nodeValue);
    }
  } else if (node.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {
    buf.push(goog.dom.PREDEFINED_TAG_VALUES_[node.nodeName]);
  } else {
    var child = node.firstChild;
    while (child) {
      goog.dom.getTextContent_(child, buf, normalizeWhitespace);
      child = child.nextSibling;
    }
  }
};


/**
 * Returns true if the object is a {@code NodeList}.  To qualify as a NodeList,
 * the object must have a numeric length property and an item function (which
 * has type 'string' on IE for some reason).
 * @param {Object} val Object to test.
 * @return {boolean} Whether the object is a NodeList.
 */
goog.dom.isNodeList = function(val) {
  // TODO(user): Now the isNodeList is part of goog.dom we can use
  // goog.userAgent to make this simpler.
  // A NodeList must have a length property of type 'number' on all platforms.
  if (val && typeof val.length == 'number') {
    // A NodeList is an object everywhere except Safari, where it's a function.
    if (goog.isObject(val)) {
      // A NodeList must have an item function (on non-IE platforms) or an item
      // property of type 'string' (on IE).
      return typeof val.item == 'function' || typeof val.item == 'string';
    } else if (goog.isFunction(val)) {
      // On Safari, a NodeList is a function with an item property that is also
      // a function.
      return typeof val.item == 'function';
    }
  }

  // Not a NodeList.
  return _FALSE;
};



/**
 * Create an instance of a DOM helper with a new document object.
 * @param {Document=} opt_document Document object to associate with this
 *     DOM helper.
 * @constructor
 */
goog.dom.DomHelper = function(opt_document) {
  /**
   * Reference to the document object to use
   * @type {!Document}
   * @private
   */
  this.document_ = opt_document || goog.global.document || document;
};


/**
 * Gets the dom helper object for the document where the element resides.
 * @param {Node=} opt_node If present, gets the DomHelper for this node.
 * @return {!goog.dom.DomHelper} The DomHelper.
 */
goog.dom.DomHelper.prototype.getDomHelper = goog.dom.getDomHelper;


/**
 * Sets the document object.
 * @param {!Document} document Document object.
 */
goog.dom.DomHelper.prototype.setDocument = function(document) {
  this.document_ = document;
};


/**
 * Gets the document object being used by the dom library.
 * @return {!Document} Document object.
 */
goog.dom.DomHelper.prototype.getDocument = function() {
  return this.document_;
};


/**
 * Alias for {@code getElementById}. If a DOM node is passed in then we just
 * return that.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 */
goog.dom.DomHelper.prototype.getElement = function(element) {
  if (goog.isString(element)) {
    return this.document_.getElementById(element);
  } else {
    return element;
  }
};


/**
 * Alias for {@code getElement}.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 * @deprecated Use {@link goog.dom.DomHelper.prototype.getElement} instead.
 */
goog.dom.DomHelper.prototype.$ = goog.dom.DomHelper.prototype.getElement;


/**
 * Looks up elements by both tag and class name, using browser native functions
 * ({@code querySelectorAll}, {@code getElementsByTagName} or
 * {@code getElementsByClassName}) where possible. The returned array is a live
 * NodeList or a static list depending on the code path taken.
 *
 * @see goog.dom.query
 *
 * @param {?string=} opt_tag Element tag name or * for all tags.
 * @param {?string=} opt_class Optional class name.
 * @param {Document|Element=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 */
goog.dom.DomHelper.prototype.getElementsByTagNameAndClass = function(opt_tag,
                                                                     opt_class,
                                                                     opt_el) {
  return goog.dom.getElementsByTagNameAndClass_(this.document_, opt_tag,
                                                opt_class, opt_el);
};


/**
 * Returns an array of all the elements with the provided className.
 * @see {goog.dom.query}
 * @param {!string} className the name of the class to look for.
 * @param {Element|Document=} opt_el Optional element to look in.
 * @return { {length: number} } The items found with the class name provided.
 */
goog.dom.DomHelper.prototype.getElementsByClass = function(className, opt_el) {
  var doc = opt_el || this.document_;
  return goog.dom.getElementsByClass(className, doc);
};


/**
 * Returns the first element we find matching the provided class name.
 * @see {goog.dom.query}
 * @param {!string} className the name of the class to look for.
 * @param {Element|Document=} opt_el Optional element to look in.
 * @return {Element} The first item found with the class name provided.
 */
goog.dom.DomHelper.prototype.getElementByClass = function(className, opt_el) {
  var doc = opt_el || this.document_;
  return goog.dom.getElementByClass(className, doc);
};


/**
 * Alias for {@code getElementsByTagNameAndClass}.
 * @deprecated Use DomHelper getElementsByTagNameAndClass.
 * @see goog.dom.query
 *
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {Element=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 */
goog.dom.DomHelper.prototype.$$ =
    goog.dom.DomHelper.prototype.getElementsByTagNameAndClass;


/**
 * Sets a number of properties on a node.
 * @param {Element} element DOM node to set properties on.
 * @param {Object} properties Hash of property:value pairs.
 */
goog.dom.DomHelper.prototype.setProperties = goog.dom.setProperties;


/**
 * Gets the dimensions of the viewport.
 * @param {Window=} opt_window Optional window element to test. Defaults to
 *     the window of the Dom Helper.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 */
goog.dom.DomHelper.prototype.getViewportSize = function(opt_window) {
  // TODO(user): This should not take an argument. That breaks the rule of a
  // a DomHelper representing a single frame/window/document.
  return goog.dom.getViewportSize(opt_window || this.getWindow());
};


/**
 * Typedef for use with goog.dom.createDom and goog.dom.append.
 * @typedef {Object|string|Array|NodeList}
 */
goog.dom.Appendable;


/**
 * Returns a dom node with a set of attributes.  This function accepts varargs
 * for subsequent nodes to be added.  Subsequent nodes will be added to the
 * first node as childNodes.
 *
 * So:
 * <code>createDom('div', null, createDom('p'), createDom('p'));</code>
 * would return a div with two child paragraphs
 *
 * An easy way to move all child nodes of an existing element to a new parent
 * element is:
 * <code>createDom('div', null, oldElement.childNodes);</code>
 * which will remove all child nodes from the old element and add them as
 * child nodes of the new DIV.
 *
 * @param {string} tagName Tag to create.
 * @param {Object|string=} opt_attributes If object, then a map of name-value
 *     pairs for attributes. If a string, then this is the className of the new
 *     element.
 * @param {...goog.dom.Appendable} var_args Further DOM nodes or
 *     strings for text nodes. If one of the var_args is an array or
 *     NodeList, its elements will be added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 */
goog.dom.DomHelper.prototype.createDom = function(tagName,
                                                  opt_attributes,
                                                  var_args) {
  return goog.dom.createDom_(this.document_, arguments);
};


/**
 * Alias for {@code createDom}.
 * @param {string} tagName Tag to create.
 * @param {Object|string=} opt_attributes If object, then a map of name-value
 *     pairs for attributes. If a string, then this is the className of the new
 *     element.
 * @param {...goog.dom.Appendable} var_args Further DOM nodes or strings for
 *     text nodes.  If one of the var_args is an array, its children will be
 *     added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 * @deprecated Use {@link goog.dom.DomHelper.prototype.createDom} instead.
 */
goog.dom.DomHelper.prototype.$dom = goog.dom.DomHelper.prototype.createDom;


/**
 * Creates a new element.
 * @param {string} name Tag name.
 * @return {!Element} The new element.
 */
goog.dom.DomHelper.prototype.createElement = function(name) {
  return this.document_.createElement(name);
};


/**
 * Creates a new text node.
 * @param {string} content Content.
 * @return {!Text} The new text node.
 */
goog.dom.DomHelper.prototype.createTextNode = function(content) {
  return this.document_.createTextNode(content);
};


/**
 * Gets the window object associated with the document.
 * @return {!Window} The window associated with the given document.
 */
goog.dom.DomHelper.prototype.getWindow = function() {
  return goog.dom.getWindow_(this.document_);
};


/**
 * Appends a child to a node.
 * @param {Node} parent Parent.
 * @param {Node} child Child.
 */
goog.dom.DomHelper.prototype.appendChild = goog.dom.appendChild;


/**
 * Appends a node with text or other nodes.
 * @param {!Node} parent The node to append nodes to.
 * @param {...goog.dom.Appendable} var_args The things to append to the node.
 *     If this is a Node it is appended as is.
 *     If this is a string then a text node is appended.
 *     If this is an array like object then fields 0 to length - 1 are appended.
 */
goog.dom.DomHelper.prototype.append = goog.dom.append;


/**
 * Removes all the child nodes on a DOM node.
 * @param {Node} node Node to remove children from.
 */
goog.dom.DomHelper.prototype.removeChildren = goog.dom.removeChildren;


/**
 * Inserts a new node before an existing reference node (i.e., as the previous
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert before.
 */
goog.dom.DomHelper.prototype.insertSiblingBefore = goog.dom.insertSiblingBefore;


/**
 * Inserts a new node after an existing reference node (i.e., as the next
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert after.
 */
goog.dom.DomHelper.prototype.insertSiblingAfter = goog.dom.insertSiblingAfter;


/**
 * Removes a node from its parent.
 * @param {Node} node The node to remove.
 * @return {Node} The node removed if removed; else, null.
 */
goog.dom.DomHelper.prototype.removeNode = goog.dom.removeNode;


/**
 * Replaces a node in the DOM tree. Will do nothing if {@code oldNode} has no
 * parent.
 * @param {Node} newNode Node to insert.
 * @param {Node} oldNode Node to replace.
 */
goog.dom.DomHelper.prototype.replaceNode = goog.dom.replaceNode;


/**
 * Flattens an element. That is, removes it and replace it with its children.
 * @param {Element} element The element to flatten.
 * @return {Element|undefined} The original element, detached from the document
 *     tree, sans children, or undefined if the element was already not in the
 *     document.
 */
goog.dom.DomHelper.prototype.flattenElement = goog.dom.flattenElement;


/**
 * Whether the object looks like a DOM node.
 * @param {*} obj The object being tested for node likeness.
 * @return {boolean} Whether the object looks like a DOM node.
 */
goog.dom.DomHelper.prototype.isNodeLike = goog.dom.isNodeLike;


/**
 * Whether a node contains another node.
 * @param {Node} parent The node that should contain the other node.
 * @param {Node} descendant The node to test presence of.
 * @return {boolean} Whether the parent node contains the descendent node.
 */
goog.dom.DomHelper.prototype.contains = goog.dom.contains;


/**
 * Returns the owner document for a node.
 * @param {Node} node The node to get the document for.
 * @return {!Document} The document owning the node.
 */
goog.dom.DomHelper.prototype.getOwnerDocument = goog.dom.getOwnerDocument;


/**
 * Returns the text contents of the current node, without markup. New lines are
 * stripped and whitespace is collapsed, such that each character would be
 * visible.
 *
 * In browsers that support it, innerText is used.  Other browsers attempt to
 * simulate it via node traversal.  Line breaks are canonicalized in IE.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The text content.
 */
goog.dom.DomHelper.prototype.getTextContent = goog.dom.getTextContent;

// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Python style iteration utilities.
 */


goog.provide('goog.iter');
goog.provide('goog.iter.Iterator');
goog.provide('goog.iter.StopIteration');

//goog.require('goog.array');


// TODO(user): Add more functions from Python's itertools.
// http://docs.python.org/library/itertools.html


/**
 * @typedef {goog.iter.Iterator|{length:number}|{__iterator__}}
 */
goog.iter.Iterable;


// For script engines that already support iterators.
if ('StopIteration' in goog.global) {
  /**
   * Singleton Error object that is used to terminate iterations.
   * @type {Error}
   */
  goog.iter.StopIteration = goog.global['StopIteration'];
} else {
  /**
   * Singleton Error object that is used to terminate iterations.
   * @type {Error}
   * @suppress {duplicate}
   */
  goog.iter.StopIteration = Error('StopIteration');
}



/**
 * Class/interface for iterators.  An iterator needs to implement a {@code next}
 * method and it needs to throw a {@code goog.iter.StopIteration} when the
 * iteration passes beyond the end.  Iterators have no {@code hasNext} method.
 * It is recommended to always use the helper functions to iterate over the
 * iterator or in case you are only targeting JavaScript 1.7 for in loops.
 * @constructor
 */
goog.iter.Iterator = function() {};


/**
 * Returns the next value of the iteration.  This will throw the object
 * {@see goog.iter#StopIteration} when the iteration passes the end.
 * @return {*} Any object or value.
 */
goog.iter.Iterator.prototype.next = function() {
  throw goog.iter.StopIteration;
};


/**
 * Returns the {@code Iterator} object itself.  This is used to implement
 * the iterator protocol in JavaScript 1.7
 * @param {boolean=} opt_keys  Whether to return the keys or values. Default is
 *     to only return the values.  This is being used by the for-in loop (true)
 *     and the for-each-in loop (_FALSE).  Even though the param gives a hint
 *     about what the iterator will return there is no guarantee that it will
 *     return the keys when true is passed.
 * @return {!goog.iter.Iterator} The object itself.
 */
goog.iter.Iterator.prototype.__iterator__ = function(opt_keys) {
  return this;
};


/**
 * Returns an iterator that knows how to iterate over the values in the object.
 * @param {goog.iter.Iterable} iterable  If the object is an iterator it
 *     will be returned as is.  If the object has a {@code __iterator__} method
 *     that will be called to get the value iterator.  If the object is an
 *     array-like object we create an iterator for that.
 * @return {!goog.iter.Iterator} An iterator that knows how to iterate over the
 *     values in {@code iterable}.
 */
goog.iter.toIterator = function(iterable) {
  if (iterable instanceof goog.iter.Iterator) {
    return iterable;
  }
  if (typeof iterable.__iterator__ == 'function') {
    return iterable.__iterator__(_FALSE);
  }
  if (goog.isArrayLike(iterable)) {
    var i = 0;
    var newIter = new goog.iter.Iterator;
    newIter.next = function() {
      while (_TRUE) {
        if (i >= iterable.length) {
          throw goog.iter.StopIteration;
        }
        // Don't include deleted elements.
        if (!(i in iterable)) {
          i++;
          continue;
        }
        return iterable[i++];
      }
    };
    return newIter;
  }


  // TODO(user): Should we fall back on goog.structs.getValues()?
  throw Error('Not implemented');
};


/**
 * Calls a function for each element in the iterator with the element of the
 * iterator passed as argument.
 *
 * @param {goog.iter.Iterable} iterable  The iterator to iterate
 *     over.  If the iterable is an object {@code toIterator} will be called on
 *     it.
 * @param {Function} f  The function to call for every element.  This function
 *     takes 3 arguments (the element, undefined, and the iterator) and the
 *     return value is irrelevant.  The reason for passing undefined as the
 *     second argument is so that the same function can be used in
 *     {@see goog.array#forEach} as well as others.
 * @param {Object=} opt_obj  The object to be used as the value of 'this' within
 *     {@code f}.
 */
goog.iter.forEach = function(iterable, f, opt_obj) {
  if (goog.isArrayLike(iterable)) {
    /** @preserveTry */
    try {
      goog.array.forEach((/** @type {goog.array.ArrayLike} */ iterable), f,
                         opt_obj);
    } catch (ex) {
      if (ex !== goog.iter.StopIteration) {
        throw ex;
      }
    }
  } else {
    iterable = goog.iter.toIterator(iterable);
    /** @preserveTry */
    try {
      while (_TRUE) {
        f.call(opt_obj, iterable.next(), _UNDEFINED, iterable);
      }
    } catch (ex) {
      if (ex !== goog.iter.StopIteration) {
        throw ex;
      }
    }
  }
};


/**
 * Calls a function for every element in the iterator, and if the function
 * returns true adds the element to a new iterator.
 *
 * @param {goog.iter.Iterable} iterable The iterator to iterate over.
 * @param {Function} f The function to call for every element.  This function
 *     takes 3 arguments (the element, undefined, and the iterator) and should
 *     return a boolean.  If the return value is true the element will be
 *     included  in the returned iteror.  If it is _FALSE the element is not
 *     included.
 * @param {Object=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {!goog.iter.Iterator} A new iterator in which only elements that
 *     passed the test are present.
 */
goog.iter.filter = function(iterable, f, opt_obj) {
  iterable = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    while (_TRUE) {
      var val = iterable.next();
      if (f.call(opt_obj, val, _UNDEFINED, iterable)) {
        return val;
      }
    }
  };
  return newIter;
};


/**
 * Joins the values in a iterator with a delimiter.
 * @param {goog.iter.Iterable} iterable  The iterator to get the values from.
 * @param {string} deliminator  The text to put between the values.
 * @return {string} The joined value string.
 */
goog.iter.join = function(iterable, deliminator) {
  return goog.iter.toArray(iterable).join(deliminator);
};


/**
 * For every element in the iterator call a function and return a new iterator
 * with that value.
 *
 * @param {goog.iter.Iterable} iterable The iterator to iterate over.
 * @param {Function} f The function to call for every element.  This function
 *     takes 3 arguments (the element, undefined, and the iterator) and should
 *     return a new value.
 * @param {Object=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {!goog.iter.Iterator} A new iterator that returns the results of
 *     applying the function to each element in the original iterator.
 */
goog.iter.map = function(iterable, f, opt_obj) {
  iterable = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    while (_TRUE) {
      var val = iterable.next();
      return f.call(opt_obj, val, _UNDEFINED, iterable);
    }
  };
  return newIter;
};


/**
 * Goes through the values in the iterator. Calls f for each these and if any of
 * them returns true, this returns true (without checking the rest). If all
 * return _FALSE this will return _FALSE.
 *
 * @param {goog.iter.Iterable} iterable  The iterator object.
 * @param {Function} f  The function to call for every value. This function
 *     takes 3 arguments (the value, undefined, and the iterator) and should
 *     return a boolean.
 * @param {Object=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {boolean} true if any value passes the test.
 */
goog.iter.some = function(iterable, f, opt_obj) {
  iterable = goog.iter.toIterator(iterable);
  /** @preserveTry */
  try {
    while (_TRUE) {
      if (f.call(opt_obj, iterable.next(), _UNDEFINED, iterable)) {
        return _TRUE;
      }
    }
  } catch (ex) {
    if (ex !== goog.iter.StopIteration) {
      throw ex;
    }
  }
  return _FALSE;
};


/**
 * Goes through the values in the iterator. Calls f for each these and if any of
 * them returns _FALSE this returns _FALSE (without checking the rest). If all
 * return true this will return true.
 *
 * @param {goog.iter.Iterable} iterable  The iterator object.
 * @param {Function} f  The function to call for every value. This function
 *     takes 3 arguments (the value, undefined, and the iterator) and should
 *     return a boolean.
 * @param {Object=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {boolean} true if every value passes the test.
 */
goog.iter.every = function(iterable, f, opt_obj) {
  iterable = goog.iter.toIterator(iterable);
  /** @preserveTry */
  try {
    while (_TRUE) {
      if (!f.call(opt_obj, iterable.next(), _UNDEFINED, iterable)) {
        return _FALSE;
      }
    }
  } catch (ex) {
    if (ex !== goog.iter.StopIteration) {
      throw ex;
    }
  }
  return _TRUE;
};


/**
 * Converts the iterator to an array
 * @param {goog.iter.Iterable} iterable  The iterator to convert to an array.
 * @return {!Array} An array of the elements the iterator iterates over.
 */
goog.iter.toArray = function(iterable) {
  // Fast path for array-like.
  if (goog.isArrayLike(iterable)) {
    return goog.array.toArray((/** @type {!goog.array.ArrayLike} */ iterable));
  }
  iterable = goog.iter.toIterator(iterable);
  var array = [];
  goog.iter.forEach(iterable, function(val) {
    array.push(val);
  });
  return array;
};


/**
 * Iterates over 2 iterators and returns true if they contain the same sequence
 * of elements and have the same length.
 * @param {goog.iter.Iterable} iterable1  The first iterable object.
 * @param {goog.iter.Iterable} iterable2  The second iterable object.
 * @return {boolean} true if the iterators contain the same sequence of
 *     elements and have the same length.
 */
goog.iter.equals = function(iterable1, iterable2) {
  iterable1 = goog.iter.toIterator(iterable1);
  iterable2 = goog.iter.toIterator(iterable2);
  var b1, b2;
  /** @preserveTry */
  try {
    while (_TRUE) {
      b1 = b2 = _FALSE;
      var val1 = iterable1.next();
      b1 = _TRUE;
      var val2 = iterable2.next();
      b2 = _TRUE;
      if (val1 != val2) {
        return _FALSE;
      }
    }
  } catch (ex) {
    if (ex !== goog.iter.StopIteration) {
      throw ex;
    } else {
      if (b1 && !b2) {
        // iterable1 done but iterable2 is not done.
        return _FALSE;
      }
      if (!b2) {
        /** @preserveTry */
        try {
          // iterable2 not done?
          val2 = iterable2.next();
          // iterable2 not done but iterable1 is done
          return _FALSE;
        } catch (ex1) {
          if (ex1 !== goog.iter.StopIteration) {
            throw ex1;
          }
          // iterable2 done as well... They are equal
          return _TRUE;
        }
      }
    }
  }
  return _FALSE;
};
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Iterator subclass for DOM tree traversal.
 *
 * @author robbyw@google.com (Robby Walker)
 */

goog.provide('goog.dom.TagIterator');
goog.provide('goog.dom.TagWalkType');

//goog.require('goog.dom.NodeType');
//goog.require('goog.iter.Iterator');
//goog.require('goog.iter.StopIteration');


/**
 * There are three types of token:
 *  <ol>
 *    <li>{@code START_TAG} - The beginning of a tag.
 *    <li>{@code OTHER} - Any non-element node position.
 *    <li>{@code END_TAG} - The end of a tag.
 *  </ol>
 * Users of this enumeration can rely on {@code START_TAG + END_TAG = 0} and
 * that {@code OTHER = 0}.
 *
 * @enum {number}
 */
goog.dom.TagWalkType = {
  START_TAG: 1,
  OTHER: 0,
  END_TAG: -1
};



/**
 * A DOM tree traversal iterator.
 *
 * Starting with the given node, the iterator walks the DOM in order, reporting
 * events for the start and end of Elements, and the presence of text nodes. For
 * example:
 *
 * <pre>
 * &lt;div&gt;1&lt;span&gt;2&lt;/span&gt;3&lt;/div&gt;
 * </pre>
 *
 * Will return the following nodes:
 *
 * <code>[div, 1, span, 2, span, 3, div]</code>
 *
 * With the following states:
 *
 * <code>[START, OTHER, START, OTHER, END, OTHER, END]</code>
 *
 * And the following depths
 *
 * <code>[1, 1, 2, 2, 1, 1, 0]</code>
 *
 * Imagining <code>|</code> represents iterator position, the traversal stops at
 * each of the following locations:
 *
 * <pre>
 * &lt;div&gt;|1|&lt;span&gt;|2|&lt;/span&gt;|3|&lt;/div&gt;|
 * </pre>
 *
 * The iterator can also be used in reverse mode, which will return the nodes
 * and states in the opposite order.  The depths will be slightly different
 * since, like in normal mode, the depth is computed *after* the given node.
 *
 * Lastly, it is possible to create an iterator that is unconstrained, meaning
 * that it will continue iterating until the end of the document instead of
 * until exiting the start node.
 *
 * @param {Node=} opt_node The start node.  If unspecified or null, defaults to
 *     an empty iterator.
 * @param {boolean=} opt_reversed Whether to traverse the tree in reverse.
 * @param {boolean=} opt_unconstrained Whether the iterator is not constrained
 *     to the starting node and its children.
 * @param {goog.dom.TagWalkType?=} opt_tagType The type of the position.
 *     Defaults to the start of the given node for forward iterators, and
 *     the end of the node for reverse iterators.
 * @param {number=} opt_depth The starting tree depth.
 * @constructor
 * @extends {goog.iter.Iterator}
 */
goog.dom.TagIterator = function(opt_node, opt_reversed,
    opt_unconstrained, opt_tagType, opt_depth) {
  this.reversed = !!opt_reversed;
  if (opt_node) {
    this.setPosition(opt_node, opt_tagType);
  }
  this.depth = opt_depth != _UNDEFINED ? opt_depth : this.tagType || 0;
  if (this.reversed) {
    this.depth *= -1;
  }
  this.constrained = !opt_unconstrained;
};
goog.inherits(goog.dom.TagIterator, goog.iter.Iterator);


/**
 * The node this position is located on.
 * @type {Node}
 */
goog.dom.TagIterator.prototype.node = _NULL;


/**
 * The type of this position.
 * @type {goog.dom.TagWalkType}
 */
goog.dom.TagIterator.prototype.tagType = goog.dom.TagWalkType.OTHER;


/**
 * The tree depth of this position relative to where the iterator started.  The
 * depth is considered to be the tree depth just past the current node, so if an
 * iterator is at position <pre>
 *     <div>|</div>
 * </pre>
 * (i.e. the node is the div and the type is START_TAG) its depth will be 1.
 * @type {number}
 */
goog.dom.TagIterator.prototype.depth;


/**
 * Whether the node iterator is moving in reverse.
 * @type {boolean}
 */
goog.dom.TagIterator.prototype.reversed;


/**
 * Whether the iterator is constrained to the starting node and its children.
 * @type {boolean}
 */
goog.dom.TagIterator.prototype.constrained;


/**
 * Whether iteration has started.
 * @type {boolean}
 * @private
 */
goog.dom.TagIterator.prototype.started_ = _FALSE;


/**
 * Set the position of the iterator.  Overwrite the tree node and the position
 * type which can be one of the {@link goog.dom.TagWalkType} token types.
 * Only overwrites the tree depth when the parameter is specified.
 * @param {Node} node The node to set the position to.
 * @param {goog.dom.TagWalkType?=} opt_tagType The type of the position
 *     Defaults to the start of the given node.
 * @param {number=} opt_depth The tree depth.
 */
goog.dom.TagIterator.prototype.setPosition = function(node,
    opt_tagType, opt_depth) {
  this.node = node;

  if (node) {
    if (goog.isNumber(opt_tagType)) {
      this.tagType = opt_tagType;
    } else {
      // Auto-determine the proper type
      this.tagType = this.node.nodeType != goog.dom.NodeType.ELEMENT ?
          goog.dom.TagWalkType.OTHER :
          this.reversed ? goog.dom.TagWalkType.END_TAG :
          goog.dom.TagWalkType.START_TAG;
    }
  }

  if (goog.isNumber(opt_depth)) {
    this.depth = opt_depth;
  }
};


/**
 * Replace this iterator's values with values from another.
 * @param {goog.dom.TagIterator} other The iterator to copy.
 * @protected
 */
goog.dom.TagIterator.prototype.copyFrom = function(other) {
  this.node = other.node;
  this.tagType = other.tagType;
  this.depth = other.depth;
  this.reversed = other.reversed;
  this.constrained = other.constrained;
};


/**
 * @return {goog.dom.TagIterator} A copy of this iterator.
 */
goog.dom.TagIterator.prototype.clone = function() {
  return new goog.dom.TagIterator(this.node, this.reversed,
      !this.constrained, this.tagType, this.depth);
};


/**
 * Skip the current tag.
 */
goog.dom.TagIterator.prototype.skipTag = function() {
  var check = this.reversed ? goog.dom.TagWalkType.END_TAG :
              goog.dom.TagWalkType.START_TAG;
  if (this.tagType == check) {
    this.tagType = /** @type {goog.dom.TagWalkType} */ (check * -1);
    this.depth += this.tagType * (this.reversed ? -1 : 1);
  }
};


/**
 * Restart the current tag.
 */
goog.dom.TagIterator.prototype.restartTag = function() {
  var check = this.reversed ? goog.dom.TagWalkType.START_TAG :
              goog.dom.TagWalkType.END_TAG;
  if (this.tagType == check) {
    this.tagType = /** @type {goog.dom.TagWalkType} */ (check * -1);
    this.depth += this.tagType * (this.reversed ? -1 : 1);
  }
};


/**
 * Move to the next position in the DOM tree.
 * @return {Node} Returns the next node, or throws a goog.iter.StopIteration
 *     exception if the end of the iterator's range has been reached.
 */
goog.dom.TagIterator.prototype.next = function() {
  var node;

  if (this.started_) {
    if (!this.node || this.constrained && this.depth == 0) {
      throw goog.iter.StopIteration;
    }
    node = this.node;

    var startType = this.reversed ? goog.dom.TagWalkType.END_TAG :
        goog.dom.TagWalkType.START_TAG;

    if (this.tagType == startType) {
      // If we have entered the tag, test if there are any children to move to.
      var child = this.reversed ? node.lastChild : node.firstChild;
      if (child) {
        this.setPosition(child);
      } else {
        // If not, move on to exiting this tag.
        this.setPosition(node,
            /** @type {goog.dom.TagWalkType} */ (startType * -1));
      }
    } else {
      var sibling = this.reversed ? node.previousSibling : node.nextSibling;
      // by simonz
      // <span><div></span><strong></strong></div> \uc778 \uacbd\uc6b0\uc5d0 IE\uc5d0\uc11c \ubb34\ud55c loop\uac00 \ubc1c\uc0dd\ud55c\ub2e4.
      // strong\uc744 iteration\ud558\uc9c0 \uc54a\uace0 \ube60\uc838\ub098\uac00\ub3c4\ub85d \uc218\uc815\uc744 \ud588\ub2e4.
      if (sibling && node.parentNode == sibling.parentNode) {
//      if (sibling) {
        // Try to move to the next node.
        this.setPosition(sibling);
      } else {
        // If no such node exists, exit our parent.
        this.setPosition(node.parentNode,
            /** @type {goog.dom.TagWalkType} */ (startType * -1));
      }
    }

    this.depth += this.tagType * (this.reversed ? -1 : 1);
  } else {
    this.started_ = _TRUE;
  }

  // Check the new position for being last, and return it if it's not.
  node = this.node;
  if (!this.node) {
    throw goog.iter.StopIteration;
  }
  return node;
};


/**
 * @return {boolean} Whether next has ever been called on this iterator.
 * @protected
 */
goog.dom.TagIterator.prototype.isStarted = function() {
  return this.started_;
};


/**
 * @return {boolean} Whether this iterator's position is a start tag position.
 */
goog.dom.TagIterator.prototype.isStartTag = function() {
  return this.tagType == goog.dom.TagWalkType.START_TAG;
};


/**
 * @return {boolean} Whether this iterator's position is an end tag position.
 */
goog.dom.TagIterator.prototype.isEndTag = function() {
  return this.tagType == goog.dom.TagWalkType.END_TAG;
};


/**
 * Test if two iterators are at the same position - i.e. if the node and tagType
 * is the same.  This will still return true if the two iterators are moving in
 * opposite directions or have different constraints.
 * @param {goog.dom.TagIterator} other The iterator to compare to.
 * @return {boolean} Whether the two iterators are at the same position.
 */
goog.dom.TagIterator.prototype.equals = function(other) {
  // Nodes must be equal, and we must either have reached the end of our tree
  // or be at the same position.
  return other.node == this.node && (!this.node ||
      other.tagType == this.tagType);
};


/**
 * Replace the current node with the list of nodes. Reset the iterator so that
 * it visits the first of the nodes next.
 * @param {...Object} var_args A list of nodes to replace the current node with.
 *     If the first argument is array-like, it will be used, otherwise all the
 *     arguments are assumed to be nodes.
 */
goog.dom.TagIterator.prototype.splice = function(var_args) {
  // Reset the iterator so that it iterates over the first replacement node in
  // the arguments on the next iteration.
  var node = this.node;
  this.restartTag();
  this.reversed = !this.reversed;
  goog.dom.TagIterator.prototype.next.call(this);
  this.reversed = !this.reversed;

  // Replace the node with the arguments.
  var arr = goog.isArrayLike(arguments[0]) ? arguments[0] : arguments;
  for (var i = arr.length - 1; i >= 0; i--) {
    goog.dom.insertSiblingAfter(arr[i], node);
  }
  goog.dom.removeNode(node);
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Generics method for collection-like classes and objects.
 *
 *
 * This file contains functions to work with collections. It supports using
 * Map, Set, Array and Object and other classes that implement collection-like
 * methods.
 */


goog.provide('goog.structs');

//goog.require('goog.array');
//goog.require('goog.object');


// We treat an object as a dictionary if it has getKeys or it is an object that
// isn't arrayLike.


/**
 * Returns the number of values in the collection-like object.
 * @param {Object} col The collection-like object.
 * @return {number} The number of values in the collection-like object.
 */
goog.structs.getCount = function(col) {
  if (typeof col.getCount == 'function') {
    return col.getCount();
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return col.length;
  }
  return goog.object.getCount(col);
};


/**
 * Returns the values of the collection-like object.
 * @param {Object} col The collection-like object.
 * @return {!Array} The values in the collection-like object.
 */
goog.structs.getValues = function(col) {
  if (typeof col.getValues == 'function') {
    return col.getValues();
  }
  if (goog.isString(col)) {
    return col.split('');
  }
  if (goog.isArrayLike(col)) {
    var rv = [];
    var l = col.length;
    for (var i = 0; i < l; i++) {
      rv.push(col[i]);
    }
    return rv;
  }
  return goog.object.getValues(col);
};


/**
 * Returns the keys of the collection. Some collections have no notion of
 * keys/indexes and this function will return undefined in those cases.
 * @param {Object} col The collection-like object.
 * @return {!Array|undefined} The keys in the collection.
 */
goog.structs.getKeys = function(col) {
  if (typeof col.getKeys == 'function') {
    return col.getKeys();
  }
  // if we have getValues but no getKeys we know this is a key-less collection
  if (typeof col.getValues == 'function') {
    return _UNDEFINED;
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    var rv = [];
    var l = col.length;
    for (var i = 0; i < l; i++) {
      rv.push(i);
    }
    return rv;
  }

  return goog.object.getKeys(col);
};


/**
 * Whether the collection contains the given value. This is O(n) and uses
 * equals (==) to test the existence.
 * @param {Object} col The collection-like object.
 * @param {*} val The value to check for.
 * @return {boolean} True if the map contains the value.
 */
goog.structs.contains = function(col, val) {
  if (typeof col.contains == 'function') {
    return col.contains(val);
  }
  if (typeof col.containsValue == 'function') {
    return col.containsValue(val);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.contains(/** @type {Array} */ (col), val);
  }
  return goog.object.containsValue(col, val);
};


/**
 * Whether the collection is empty.
 * @param {Object} col The collection-like object.
 * @return {boolean} True if empty.
 */
goog.structs.isEmpty = function(col) {
  if (typeof col.isEmpty == 'function') {
    return col.isEmpty();
  }

  // We do not use goog.string.isEmpty because here we treat the string as
  // collection and as such even whitespace matters

  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.isEmpty(/** @type {Array} */ (col));
  }
  return goog.object.isEmpty(col);
};


/**
 * Removes all the elements from the collection.
 * @param {Object} col The collection-like object.
 */
goog.structs.clear = function(col) {
  // NOTE(user): This should not contain strings because strings are immutable
  if (typeof col.clear == 'function') {
    col.clear();
  } else if (goog.isArrayLike(col)) {
    goog.array.clear((/** @type {goog.array.ArrayLike} */ col));
  } else {
    goog.object.clear(col);
  }
};


/**
 * Calls a function for each value in a collection. The function takes
 * three arguments; the value, the key and the collection.
 *
 * @param {Object} col The collection-like object.
 * @param {Function} f The function to call for every value. This function takes
 *     3 arguments (the value, the key or undefined if the collection has no
 *     notion of keys, and the collection) and the return value is irrelevant.
 * @param {Object=} opt_obj The object to be used as the value of 'this'
 *     within {@code f}.
 */
goog.structs.forEach = function(col, f, opt_obj) {
  if (typeof col.forEach == 'function') {
    col.forEach(f, opt_obj);
  } else if (goog.isArrayLike(col) || goog.isString(col)) {
    goog.array.forEach(/** @type {Array} */ (col), f, opt_obj);
  } else {
    var keys = goog.structs.getKeys(col);
    var values = goog.structs.getValues(col);
    var l = values.length;
    for (var i = 0; i < l; i++) {
      f.call(opt_obj, values[i], keys && keys[i], col);
    }
  }
};


/**
 * Calls a function for every value in the collection. When a call returns true,
 * adds the value to a new collection (Array is returned by default).
 *
 * @param {Object} col The collection-like object.
 * @param {Function} f The function to call for every value. This function takes
 *     3 arguments (the value, the key or undefined if the collection has no
 *     notion of keys, and the collection) and should return a Boolean. If the
 *     return value is true the value is added to the result collection. If it
 *     is _FALSE the value is not included.
 * @param {Object=} opt_obj The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {!Object|!Array} A new collection where the passed values are
 *     present. If col is a key-less collection an array is returned.  If col
 *     has keys and values a plain old JS object is returned.
 */
goog.structs.filter = function(col, f, opt_obj) {
  if (typeof col.filter == 'function') {
    return col.filter(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.filter(/** @type {!Array} */ (col), f, opt_obj);
  }

  var rv;
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  if (keys) {
    rv = {};
    for (var i = 0; i < l; i++) {
      if (f.call(opt_obj, values[i], keys[i], col)) {
        rv[keys[i]] = values[i];
      }
    }
  } else {
    // We should not use goog.array.filter here since we want to make sure that
    // the index is undefined as well as make sure that col is passed to the
    // function.
    rv = [];
    for (var i = 0; i < l; i++) {
      if (f.call(opt_obj, values[i], _UNDEFINED, col)) {
        rv.push(values[i]);
      }
    }
  }
  return rv;
};


/**
 * Calls a function for every value in the collection and adds the result into a
 * new collection (defaults to creating a new Array).
 *
 * @param {Object} col The collection-like object.
 * @param {Function} f The function to call for every value. This function
 *     takes 3 arguments (the value, the key or undefined if the collection has
 *     no notion of keys, and the collection) and should return something. The
 *     result will be used as the value in the new collection.
 * @param {Object=} opt_obj  The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {!Object|!Array} A new collection with the new values.  If col is a
 *     key-less collection an array is returned.  If col has keys and values a
 *     plain old JS object is returned.
 */
goog.structs.map = function(col, f, opt_obj) {
  if (typeof col.map == 'function') {
    return col.map(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.map(/** @type {!Array} */ (col), f, opt_obj);
  }

  var rv;
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  if (keys) {
    rv = {};
    for (var i = 0; i < l; i++) {
      rv[keys[i]] = f.call(opt_obj, values[i], keys[i], col);
    }
  } else {
    // We should not use goog.array.map here since we want to make sure that
    // the index is undefined as well as make sure that col is passed to the
    // function.
    rv = [];
    for (var i = 0; i < l; i++) {
      rv[i] = f.call(opt_obj, values[i], _UNDEFINED, col);
    }
  }
  return rv;
};


/**
 * Calls f for each value in a collection. If any call returns true this returns
 * true (without checking the rest). If all returns _FALSE this returns _FALSE.
 *
 * @param {Object|Array|string} col The collection-like object.
 * @param {Function} f The function to call for every value. This function takes
 *     3 arguments (the value, the key or undefined if the collection has no
 *     notion of keys, and the collection) and should return a Boolean.
 * @param {Object=} opt_obj  The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {boolean} True if any value passes the test.
 */
goog.structs.some = function(col, f, opt_obj) {
  if (typeof col.some == 'function') {
    return col.some(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.some(/** @type {!Array} */ (col), f, opt_obj);
  }
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    if (f.call(opt_obj, values[i], keys && keys[i], col)) {
      return _TRUE;
    }
  }
  return _FALSE;
};


/**
 * Calls f for each value in a collection. If all calls return true this return
 * true this returns true. If any returns _FALSE this returns _FALSE at this point
 *  and does not continue to check the remaining values.
 *
 * @param {Object} col The collection-like object.
 * @param {Function} f The function to call for every value. This function takes
 *     3 arguments (the value, the key or undefined if the collection has no
 *     notion of keys, and the collection) and should return a Boolean.
 * @param {Object=} opt_obj  The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {boolean} True if all key-value pairs pass the test.
 */
goog.structs.every = function(col, f, opt_obj) {
  if (typeof col.every == 'function') {
    return col.every(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.every(/** @type {!Array} */ (col), f, opt_obj);
  }
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    if (!f.call(opt_obj, values[i], keys && keys[i], col)) {
      return _FALSE;
    }
  }
  return _TRUE;
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Datastructure: Hash Map.
 *
 *
 * This file contains an implementation of a Map structure. It implements a lot
 * of the methods used in goog.structs so those functions work on hashes.  For
 * convenience with common usage the methods accept any type for the key, though
 * internally they will be cast to strings.
 */


goog.provide('goog.structs.Map');

//goog.require('goog.iter.Iterator');
//goog.require('goog.iter.StopIteration');
//goog.require('goog.object');
//goog.require('goog.structs');



/**
 * Class for Hash Map datastructure.
 * @param {*=} opt_map Map or Object to initialize the map with.
 * @param {...*} var_args If 2 or more arguments are present then they
 *     will be used as key-value pairs.
 * @constructor
 */
goog.structs.Map = function(opt_map, var_args) {

  /**
   * Underlying JS object used to implement the map.
   * @type {!Object}
   * @private
   */
  this.map_ = {};

  /**
   * An array of keys. This is necessary for two reasons:
   *   1. Iterating the keys using for (var key in this.map_) allocates an
   *      object for every key in IE which is really bad for IE6 GC perf.
   *   2. Without a side data structure, we would need to escape all the keys
   *      as that would be the only way we could tell during iteration if the
   *      key was an internal key or a property of the object.
   *
   * This array can contain deleted keys so it's necessary to check the map
   * as well to see if the key is still in the map (this doesn't require a
   * memory allocation in IE).
   * @type {!Array.<string>}
   * @private
   */
  this.keys_ = [];

  var argLength = arguments.length;

  if (argLength > 1) {
    if (argLength % 2) {
      throw Error('Uneven number of arguments');
    }
    for (var i = 0; i < argLength; i += 2) {
      this.set(arguments[i], arguments[i + 1]);
    }
  } else if (opt_map) {
    this.addAll(/** @type {Object} */ (opt_map));
  }
};


/**
 * The number of key value pairs in the map.
 * @private
 * @type {number}
 */
goog.structs.Map.prototype.count_ = 0;


/**
 * Version used to detect changes while iterating.
 * @private
 * @type {number}
 */
goog.structs.Map.prototype.version_ = 0;


/**
 * @return {number} The number of key-value pairs in the map.
 */
goog.structs.Map.prototype.getCount = function() {
  return this.count_;
};


/**
 * Returns the values of the map.
 * @return {!Array} The values in the map.
 */
goog.structs.Map.prototype.getValues = function() {
  this.cleanupKeysArray_();

  var rv = [];
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    rv.push(this.map_[key]);
  }
  return rv;
};


/**
 * Returns the keys of the map.
 * @return {!Array.<string>} Array of string values.
 */
goog.structs.Map.prototype.getKeys = function() {
  this.cleanupKeysArray_();
  return /** @type {!Array.<string>} */ (this.keys_.concat());
};


/**
 * Whether the map contains the given key.
 * @param {*} key The key to check for.
 * @return {boolean} Whether the map contains the key.
 */
goog.structs.Map.prototype.containsKey = function(key) {
  return goog.structs.Map.hasKey_(this.map_, key);
};


/**
 * Whether the map contains the given value. This is O(n).
 * @param {*} val The value to check for.
 * @return {boolean} Whether the map contains the value.
 */
goog.structs.Map.prototype.containsValue = function(val) {
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    if (goog.structs.Map.hasKey_(this.map_, key) && this.map_[key] == val) {
      return _TRUE;
    }
  }
  return _FALSE;
};


/**
 * Whether this map is equal to the argument map.
 * @param {goog.structs.Map} otherMap The map against which to test equality.
 * @param {function(*, *) : boolean=} opt_equalityFn Optional equality function
 *     to test equality of values. If not specified, this will test whether
 *     the values contained in each map are identical objects.
 * @return {boolean} Whether the maps are equal.
 */
goog.structs.Map.prototype.equals = function(otherMap, opt_equalityFn) {
  if (this === otherMap) {
    return _TRUE;
  }

  if (this.count_ != otherMap.getCount()) {
    return _FALSE;
  }

  var equalityFn = opt_equalityFn || goog.structs.Map.defaultEquals;

  this.cleanupKeysArray_();
  for (var key, i = 0; key = this.keys_[i]; i++) {
    if (!equalityFn(this.get(key), otherMap.get(key))) {
      return _FALSE;
    }
  }

  return _TRUE;
};


/**
 * Default equality test for values.
 * @param {*} a The first value.
 * @param {*} b The second value.
 * @return {boolean} Whether a and b reference the same object.
 */
goog.structs.Map.defaultEquals = function(a, b) {
  return a === b;
};


/**
 * @return {boolean} Whether the map is empty.
 */
goog.structs.Map.prototype.isEmpty = function() {
  return this.count_ == 0;
};


/**
 * Removes all key-value pairs from the map.
 */
goog.structs.Map.prototype.clear = function() {
  this.map_ = {};
  this.keys_.length = 0;
  this.count_ = 0;
  this.version_ = 0;
};


/**
 * Removes a key-value pair based on the key. This is O(logN) amortized due to
 * updating the keys array whenever the count becomes half the size of the keys
 * in the keys array.
 * @param {*} key  The key to remove.
 * @return {boolean} Whether object was removed.
 */
goog.structs.Map.prototype.remove = function(key) {
  if (goog.structs.Map.hasKey_(this.map_, key)) {
    delete this.map_[key];
    this.count_--;
    this.version_++;

    // clean up the keys array if the threshhold is hit
    if (this.keys_.length > 2 * this.count_) {
      this.cleanupKeysArray_();
    }

    return _TRUE;
  }
  return _FALSE;
};


/**
 * Cleans up the temp keys array by removing entries that are no longer in the
 * map.
 * @private
 */
goog.structs.Map.prototype.cleanupKeysArray_ = function() {
  if (this.count_ != this.keys_.length) {
    // First remove keys that are no longer in the map.
    var srcIndex = 0;
    var destIndex = 0;
    while (srcIndex < this.keys_.length) {
      var key = this.keys_[srcIndex];
      if (goog.structs.Map.hasKey_(this.map_, key)) {
        this.keys_[destIndex++] = key;
      }
      srcIndex++;
    }
    this.keys_.length = destIndex;
  }

  if (this.count_ != this.keys_.length) {
    // If the count still isn't correct, that means we have duplicates. This can
    // happen when the same key is added and removed multiple times. Now we have
    // to allocate one extra Object to remove the duplicates. This could have
    // been done in the first pass, but in the common case, we can avoid
    // allocating an extra object by only doing this when necessary.
    var seen = {};
    var srcIndex = 0;
    var destIndex = 0;
    while (srcIndex < this.keys_.length) {
      var key = this.keys_[srcIndex];
      if (!(goog.structs.Map.hasKey_(seen, key))) {
        this.keys_[destIndex++] = key;
        seen[key] = 1;
      }
      srcIndex++;
    }
    this.keys_.length = destIndex;
  }
};


/**
 * Returns the value for the given key.  If the key is not found and the default
 * value is not given this will return {@code undefined}.
 * @param {*} key The key to get the value for.
 * @param {*=} opt_val The value to return if no item is found for the given
 *     key, defaults to undefined.
 * @return {*} The value for the given key.
 */
goog.structs.Map.prototype.get = function(key, opt_val) {
  if (goog.structs.Map.hasKey_(this.map_, key)) {
    return this.map_[key];
  }
  return opt_val;
};


/**
 * Adds a key-value pair to the map.
 * @param {*} key The key.
 * @param {*} value The value to add.
 */
goog.structs.Map.prototype.set = function(key, value) {
  if (!(goog.structs.Map.hasKey_(this.map_, key))) {
    this.count_++;
    this.keys_.push(key);
    // Only change the version if we add a new key.
    this.version_++;
  }
  this.map_[key] = value;
};


/**
 * Adds multiple key-value pairs from another goog.structs.Map or Object.
 * @param {Object} map  Object containing the data to add.
 */
goog.structs.Map.prototype.addAll = function(map) {
  var keys, values;
  if (map instanceof goog.structs.Map) {
    keys = map.getKeys();
    values = map.getValues();
  } else {
    keys = goog.object.getKeys(map);
    values = goog.object.getValues(map);
  }
  // we could use goog.array.forEach here but I don't want to introduce that
  // dependency just for this.
  for (var i = 0; i < keys.length; i++) {
    this.set(keys[i], values[i]);
  }
};


/**
 * Clones a map and returns a new map.
 * @return {!goog.structs.Map} A new map with the same key-value pairs.
 */
goog.structs.Map.prototype.clone = function() {
  return new goog.structs.Map(this);
};


/**
 * @return {!Object} Object representation of the map.
 */
goog.structs.Map.prototype.toObject = function() {
  this.cleanupKeysArray_();
  var obj = {};
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    obj[key] = this.map_[key];
  }
  return obj;
};


/**
 * Returns an iterator that iterates over the values or the keys in the map.
 * This throws an exception if the map was mutated since the iterator was
 * created.
 * @param {boolean=} opt_keys True to iterate over the keys. _FALSE to iterate
 *     over the values.  The default value is _FALSE.
 * @return {!goog.iter.Iterator} An iterator over the values or keys in the map.
 */
goog.structs.Map.prototype.__iterator__ = function(opt_keys) {
  // Clean up keys to minimize the risk of iterating over dead keys.
  this.cleanupKeysArray_();

  var i = 0;
  var keys = this.keys_;
  var map = this.map_;
  var version = this.version_;
  var selfObj = this;

  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    while (_TRUE) {
      if (version != selfObj.version_) {
        throw Error('The map has changed since the iterator was created');
      }
      if (i >= keys.length) {
        throw goog.iter.StopIteration;
      }
      var key = keys[i++];
      return opt_keys ? key : map[key];
    }
  };
  return newIter;
};


/**
 * Safe way to test for hasOwnProperty.  It even allows testing for
 * 'hasOwnProperty'.
 * @param {Object} obj The object to test for presence of the given key.
 * @param {*} key The key to check for.
 * @return {boolean} Whether the object has the key.
 * @private
 */
goog.structs.Map.hasKey_ = function(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Datastructure: Set.
 *
 *
 * This class implements a set data structure. Adding and removing is O(1). It
 * supports both object and primitive values. Be careful because you can add
 * both 1 and new Number(1), because these are not the same. You can even add
 * multiple new Number(1) because these are not equal.
 */


goog.provide('goog.structs.Set');

//goog.require('goog.structs');
//goog.require('goog.structs.Map');



/**
 * A set that can contain both primitives and objects.  Adding and removing
 * elements is O(1).  Primitives are treated as identical if they have the same
 * type and convert to the same string.  Objects are treated as identical only
 * if they are references to the same object.  WARNING: A goog.structs.Set can
 * contain both 1 and (new Number(1)), because they are not the same.  WARNING:
 * Adding (new Number(1)) twice will yield two distinct elements, because they
 * are two different objects.  WARNING: Any object that is added to a
 * goog.structs.Set will be modified!  Because goog.getUid() is used to
 * identify objects, every object in the set will be mutated.
 * @param {Array|Object=} opt_values Initial values to start with.
 * @constructor
 */
goog.structs.Set = function(opt_values) {
  this.map_ = new goog.structs.Map;
  if (opt_values) {
    this.addAll(opt_values);
  }
};


/**
 * Obtains a unique key for an element of the set.  Primitives will yield the
 * same key if they have the same type and convert to the same string.  Object
 * references will yield the same key only if they refer to the same object.
 * @param {*} val Object or primitive value to get a key for.
 * @return {string} A unique key for this value/object.
 * @private
 */
goog.structs.Set.getKey_ = function(val) {
  var type = typeof val;
  if (type == 'object' && val || type == 'function') {
    return 'o' + goog.getUid(/** @type {Object} */ (val));
  } else {
    return type.substr(0, 1) + val;
  }
};


/**
 * @return {number} The number of elements in the set.
 */
goog.structs.Set.prototype.getCount = function() {
  return this.map_.getCount();
};


/**
 * Add a primitive or an object to the set.
 * @param {*} element The primitive or object to add.
 */
goog.structs.Set.prototype.add = function(element) {
  this.map_.set(goog.structs.Set.getKey_(element), element);
};


/**
 * Adds all the values in the given collection to this set.
 * @param {Array|Object} col A collection containing the elements to add.
 */
goog.structs.Set.prototype.addAll = function(col) {
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    this.add(values[i]);
  }
};


/**
 * Removes the given element from this set.
 * @param {*} element The primitive or object to remove.
 * @return {boolean} Whether the element was found and removed.
 */
goog.structs.Set.prototype.remove = function(element) {
  return this.map_.remove(goog.structs.Set.getKey_(element));
};


/**
 * Removes all elements from this set.
 */
goog.structs.Set.prototype.clear = function() {
  this.map_.clear();
};


/**
 * Tests whether this set is empty.
 * @return {boolean} True if there are no elements in this set.
 */
goog.structs.Set.prototype.isEmpty = function() {
  return this.map_.isEmpty();
};


/**
 * Tests whether this set contains the given element.
 * @param {*} element The primitive or object to test for.
 * @return {boolean} True if this set contains the given element.
 */
goog.structs.Set.prototype.contains = function(element) {
  return this.map_.containsKey(goog.structs.Set.getKey_(element));
};


/**
 * Tests whether this set contains all the values in a given collection.
 * Repeated elements in the collection are ignored, e.g.  (new
 * goog.structs.Set([1, 2])).containsAll([1, 1]) is True.
 * @param {Object} col A collection-like object.
 * @return {boolean} True if the set contains all elements.
 */
goog.structs.Set.prototype.containsAll = function(col) {
  return goog.structs.every(col, this.contains, this);
};


/**
 * Returns an array containing all the elements in this set.
 * @return {Array} An array containing all the elements in this set.
 */
goog.structs.Set.prototype.getValues = function() {
  return this.map_.getValues();
};


/**
 * Creates a shallow clone of this set.
 * @return {goog.structs.Set} A new set containing all the same elements as
 *     this set.
 */
goog.structs.Set.prototype.clone = function() {
  return new goog.structs.Set(this);
};


/**
 * Tests whether the given collection consists of the same elements as this set,
 * regardless of order, without repetition.  Primitives are treated as equal if
 * they have the same type and convert to the same string; objects are treated
 * as equal if they are references to the same object.  This operation is O(n).
 * @param {Object} col A collection.
 * @return {boolean} True if the given collection consists of the same elements
 *     as this set, regardless of order, without repetition.
 */
goog.structs.Set.prototype.equals = function(col) {
  return this.getCount() == goog.structs.getCount(col) && this.isSubsetOf(col);
};


/**
 * Tests whether the given collection contains all the elements in this set.
 * Primitives are treated as equal if they have the same type and convert to the
 * same string; objects are treated as equal if they are references to the same
 * object.  This operation is O(n).
 * @param {Object} col A collection.
 * @return {boolean} True if this set is a subset of the given collection.
 */
goog.structs.Set.prototype.isSubsetOf = function(col) {
  var colCount = goog.structs.getCount(col);
  if (this.getCount() > colCount) {
    return _FALSE;
  }
  // TODO(user) Find the minimal collection size where the conversion makes
  // the contains() method faster.
  if (!(col instanceof goog.structs.Set) && colCount > 5) {
    // Convert to a goog.structs.Set so that goog.structs.contains runs in
    // O(1) time instead of O(n) time.
    col = new goog.structs.Set(col);
  }
  return goog.structs.every(this, function(value) {
    return goog.structs.contains(col, value);
  });
};


/**
 * Returns an iterator that iterates over the elements in this set.
 * @param {boolean=} opt_keys This argument is ignored.
 * @return {goog.iter.Iterator} An iterator over the elements in this set.
 */
goog.structs.Set.prototype.__iterator__ = function(opt_keys) {
  return this.map_.__iterator__(_FALSE);
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//goog.require('goog.array');
//goog.require('goog.string');
//goog.require('goog.structs.Set');



// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the disposable interface.  A disposable object
 * has a dispose method to to clean up references and resources.
 */


goog.provide('goog.disposable.IDisposable');



/**
 * Interface for a disposable object.  If a instance requires cleanup
 * (references COM objects, DOM notes, or other disposable objects), it should
 * implement this interface (it may subclass goog.Disposable).
 * @interface
 */
goog.disposable.IDisposable = function() {};


/**
 * Disposes of the object and its resources.
 * @return {void} Nothing.
 */
goog.disposable.IDisposable.prototype.dispose;


/**
 * @return {boolean} Whether the object has been disposed of.
 */
goog.disposable.IDisposable.prototype.isDisposed;
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Implements the disposable interface. The dispose method is used
 * to clean up references and resources.
 */


goog.provide('goog.Disposable');
goog.provide('goog.dispose');

//goog.require('goog.disposable.IDisposable');



/**
 * Class that provides the basic implementation for disposable objects. If your
 * class holds one or more references to COM objects, DOM nodes, or other
 * disposable objects, it should extend this class or implement the disposable
 * interface (defined in goog.disposable.IDisposable).
 * @constructor
 * @implements {goog.disposable.IDisposable}
 */
goog.Disposable = function() {
  if (goog.Disposable.ENABLE_MONITORING) {
    goog.Disposable.instances_[goog.getUid(this)] = this;
  }
};


/**
 * @define {boolean} Whether to enable the monitoring of the goog.Disposable
 *     instances. Switching on the monitoring is only recommended for debugging
 *     because it has a significant impact on performance and memory usage.
 *     If switched off, the monitoring code compiles down to 0 bytes.
 *     The monitoring expects that all disposable objects call the
 *     {@code goog.Disposable} base constructor.
 */
goog.Disposable.ENABLE_MONITORING = _FALSE;


/**
 * Maps the unique ID of every undisposed {@code goog.Disposable} object to
 * the object itself.
 * @type {!Object.<number, !goog.Disposable>}
 * @private
 */
goog.Disposable.instances_ = {};


/**
 * Whether the object has been disposed of.
 * @type {boolean}
 * @private
 */
goog.Disposable.prototype.disposed_ = _FALSE;


/**
 * @return {boolean} Whether the object has been disposed of.
 */
goog.Disposable.prototype.isDisposed = function() {
  return this.disposed_;
};


/**
 * @return {boolean} Whether the object has been disposed of.
 * @deprecated Use {@link #isDisposed} instead.
 */
goog.Disposable.prototype.getDisposed = goog.Disposable.prototype.isDisposed;


/**
 * Disposes of the object. If the object hasn't already been disposed of, calls
 * {@link #disposeInternal}. Classes that extend {@code goog.Disposable} should
 * override {@link #disposeInternal} in order to delete references to COM
 * objects, DOM nodes, and other disposable objects.
 *
 * @return {void} Nothing.
 */
goog.Disposable.prototype.dispose = function() {
  if (!this.disposed_) {
    // Set disposed_ to true first, in case during the chain of disposal this
    // gets disposed recursively.
    this.disposed_ = _TRUE;
    this.disposeInternal();
    if (goog.Disposable.ENABLE_MONITORING) {
      var uid = goog.getUid(this);
      if (!goog.Disposable.instances_.hasOwnProperty(uid)) {
        throw Error(this + ' did not call the goog.Disposable base ' +
            'constructor or was disposed of after a clearUndisposedObjects ' +
            'call');
      }
      delete goog.Disposable.instances_[uid];
    }
  }
};


/**
 * Deletes or nulls out any references to COM objects, DOM nodes, or other
 * disposable objects. Classes that extend {@code goog.Disposable} should
 * override this method.  For example:
 * <pre>
 *   mypackage.MyClass = function() {
 *     goog.Disposable.call(this);
 *     // Constructor logic specific to MyClass.
 *     ...
 *   };
 *   goog.inherits(mypackage.MyClass, goog.Disposable);
 *
 *   mypackage.MyClass.prototype.disposeInternal = function() {
 *     mypackage.MyClass.superClass_.disposeInternal.call(this);
 *     // Dispose logic specific to MyClass.
 *     ...
 *   };
 * </pre>
 * @protected
 */
goog.Disposable.prototype.disposeInternal = function() {
  // No-op in the base class.
};


/**
 * Calls {@code dispose} on the argument if it supports it. If obj is not an
 *     object with a dispose() method, this is a no-op.
 * @param {*} obj The object to dispose of.
 */
goog.dispose = function(obj) {
  if (obj && typeof obj.dispose == 'function') {
    obj.dispose();
  }
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A generic interface for saving and restoring ranges.
 *
 * @author robbyw@google.com (Robby Walker)
 */


goog.provide('goog.dom.SavedRange');

//goog.require('goog.Disposable');



/**
 * Abstract interface for a saved range.
 * @constructor
 * @extends {goog.Disposable}
 */
goog.dom.SavedRange = function() {
  goog.Disposable.call(this);
};
goog.inherits(goog.dom.SavedRange, goog.Disposable);


/**
 * Restores the range and by default disposes of the saved copy.  Take note:
 * this means the by default SavedRange objects are single use objects.
 * @param {boolean=} opt_stayAlive Whether this SavedRange should stay alive
 *     (not be disposed) after restoring the range. Defaults to _FALSE (dispose).
 * @return {goog.dom.AbstractRange} The restored range.
 */
goog.dom.SavedRange.prototype.restore = function(opt_stayAlive) {
  var range = this.restoreInternal();
  if (!opt_stayAlive) {
    this.dispose();
  }
  return range;
};


/**
 * Internal method to restore the saved range.
 * @return {goog.dom.AbstractRange} The restored range.
 */
goog.dom.SavedRange.prototype.restoreInternal = goog.abstractMethod;
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview An API for saving and restoring ranges as HTML carets.
 *
 * @author nicksantos@google.com (Nick Santos)
 */


goog.provide('goog.dom.SavedCaretRange');

//goog.require('goog.array');
//goog.require('goog.dom');
//goog.require('goog.dom.SavedRange');
//goog.require('goog.dom.TagName');
//goog.require('goog.string');



/**
 * A struct for holding context about saved selections.
 * This can be used to preserve the selection and restore while the DOM is
 * manipulated, or through an asynchronous call. Use goog.dom.Range factory
 * methods to obtain an {@see goog.dom.AbstractRange} instance, and use
 * {@see goog.dom.AbstractRange#saveUsingCarets} to obtain a SavedCaretRange.
 * For editor ranges under content-editable elements or design-mode iframes,
 * prefer using {@see goog.editor.range.saveUsingNormalizedCarets}.
 * @param {goog.dom.AbstractRange} range The range being saved.
 * @constructor
 * @extends {goog.dom.SavedRange}
 */
goog.dom.SavedCaretRange = function(range) {
  goog.dom.SavedRange.call(this);

  /**
   * The DOM id of the caret at the start of the range.
   * @type {string}
   * @private
   */
  this.startCaretId_ = goog.string.createUniqueString();

  /**
   * The DOM id of the caret at the end of the range.
   * @type {string}
   * @private
   */
  this.endCaretId_ = goog.string.createUniqueString();

  /**
   * A DOM helper for storing the current document context.
   * @type {goog.dom.DomHelper}
   * @private
   */
  this.dom_ = goog.dom.getDomHelper(range.getDocument());

  range.surroundWithNodes(this.createCaret_(_TRUE), this.createCaret_(_FALSE));
  this.removeIncidentalTextNode_();
};
goog.inherits(goog.dom.SavedCaretRange, goog.dom.SavedRange);


/**
 * Gets carets.
 * @param {boolean} start If true, returns the start caret. Otherwise, get the
 *     end caret.
 * @return {Element} The start or end caret in the given document.
 */
goog.dom.SavedCaretRange.prototype.getCaret = function(start) {
  return this.dom_.getElement(start ? this.startCaretId_ : this.endCaretId_);
};

goog.dom.SavedCaretRange.prototype.removeIncidentalTextNode_ = function() {
    var startCaret = this.getCaret(_TRUE);
    this.removeIfEmptyText_(startCaret.previousSibling);
    this.removeIfEmptyText_(startCaret.nextSibling);

    var endCaret = this.getCaret(_FALSE);
    this.removeIfEmptyText_(endCaret.previousSibling);
    this.removeIfEmptyText_(endCaret.nextSibling);
};

goog.dom.SavedCaretRange.prototype.removeIfEmptyText_ = function(node) {
	if (node && node.nodeType === goog.dom.NodeType.TEXT && !node.nodeValue) {
		goog.dom.removeNode(node);
	}
}

/**
 * Removes the carets from the current restoration document.
 * @param {goog.dom.AbstractRange=} opt_range A range whose offsets have already
 *     been adjusted for caret removal; it will be adjusted if it is also
 *     affected by post-removal operations, such as text node normalization.
 * @return {goog.dom.AbstractRange|undefined} The adjusted range, if opt_range
 *     was provided.
 */
goog.dom.SavedCaretRange.prototype.removeCarets = function(opt_range) {
  goog.dom.removeNode(this.getCaret(_TRUE));
  goog.dom.removeNode(this.getCaret(_FALSE));
  return opt_range;
};


/**
 * Reconstruct the selection from the given saved range. Removes carets after
 * restoring the selection. If restore does not dispose this saved range, it may
 * only be restored a second time if innerHTML or some other mechanism is used
 * to restore the carets to the dom.
 * @return {goog.dom.AbstractRange?} Restored selection.
 * @override
 * @protected
 */
goog.dom.SavedCaretRange.prototype.restoreInternal = function() {
  var range = _NULL;
  var startCaret = this.getCaret(_TRUE);
  var endCaret = this.getCaret(_FALSE);
  if (startCaret && endCaret) {
    var startNode = startCaret.parentNode;
    var startOffset = goog.array.indexOf(startNode.childNodes, startCaret);
    var endNode = endCaret.parentNode;
    var endOffset = goog.array.indexOf(endNode.childNodes, endCaret);
    range = goog.dom.Range.createFromNodes(startNode, startOffset + 1,
                                           endNode, endOffset);
    range.select();
  }
  return range;
};
//goog.dom.SavedCaretRange.prototype.restoreInternal = function() {
//  var range = null;
//  var startCaret = this.getCaret(true);
//  var endCaret = this.getCaret(false);
//  if (startCaret && endCaret) {
//    var startNode = startCaret.parentNode;
//    var startOffset = goog.array.indexOf(startNode.childNodes, startCaret);
//    var endNode = endCaret.parentNode;
//    var endOffset = goog.array.indexOf(endNode.childNodes, endCaret);
//    if (endNode == startNode) {
//      // Compensate for the start caret being removed.
//      endOffset -= 1;
//    }
//    range = goog.dom.Range.createFromNodes(startNode, startOffset,
//                                           endNode, endOffset);
//    range = this.removeCarets(range);
////    range.select();
//  } else {
//    // If only one caret was found, remove it.
//    this.removeCarets();
//  }
//  return range;
//};

/**
 * Dispose the saved range and remove the carets from the DOM.
 * @override
 * @protected
 */
goog.dom.SavedCaretRange.prototype.disposeInternal = function() {
  this.removeCarets();
  this.dom_ = _NULL;
};


/**
 * Creates a caret element.
 * @param {boolean} start If true, creates the start caret. Otherwise,
 *     creates the end caret.
 * @return {Element} The new caret element.
 * @private
 */
goog.dom.SavedCaretRange.prototype.createCaret_ = function(start) {
  return this.dom_.createDom(goog.dom.TagName.SPAN,
      {'id': start ? this.startCaretId_ : this.endCaretId_});
};


/**
 * A regex that will match all saved range carets in a string.
 * @type {RegExp}
 */
goog.dom.SavedCaretRange.CARET_REGEX = /<span\s+id="?goog_\d+"?><\/span>/ig;


// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Interface definitions for working with ranges
 * in HTML documents.
 *
 * @author robbyw@google.com (Robby Walker)
 */


goog.provide('goog.dom.AbstractRange');
goog.provide('goog.dom.RangeIterator');
goog.provide('goog.dom.RangeType');

//goog.require('goog.dom');
//goog.require('goog.dom.NodeType');
//goog.require('goog.dom.SavedCaretRange');
//goog.require('goog.dom.TagIterator');
//goog.require('goog.userAgent');


/**
 * Types of ranges.
 * @enum {string}
 */
goog.dom.RangeType = {
  TEXT: 'text',
  CONTROL: 'control',
  MULTI: 'mutli'
};



/**
 * Creates a new selection with no properties.  Do not use this constructor -
 * use one of the goog.dom.Range.from* methods instead.
 * @constructor
 */
goog.dom.AbstractRange = function() {
};


/**
 * Gets the browser native selection object from the given window.
 * @param {Window} win The window to get the selection object from.
 * @return {Object} The browser native selection object, or null if it could
 *     not be retrieved.
 */
goog.dom.AbstractRange.getBrowserSelectionForWindow = function(win) {
  if (win.getSelection) {
    // W3C
    return win.getSelection();
  } else {
    // IE
    var doc = win.document;
    var sel = doc.selection;
    if (sel) {
      // IE has a bug where it sometimes returns a selection from the wrong
      // document. Catching these cases now helps us avoid problems later.
      try {
        var range = sel.createRange();
        // Only TextRanges have a parentElement method.
        if (range.parentElement) {
          if (range.parentElement().document != doc) {
            return _NULL;
          }
        } else if (!range.length || range.item(0).document != doc) {
          // For ControlRanges, check that the range has items, and that
          // the first item in the range is in the correct document.
          return _NULL;
        }
      } catch (e) {
        // If the selection is in the wrong document, and the wrong document is
        // in a different domain, IE will throw an exception.
        return _NULL;
      }
      // TODO(user|robbyw) Sometimes IE 6 returns a selection instance
      // when there is no selection.  This object has a 'type' property equals
      // to 'None' and a typeDetail property bound to undefined. Ideally this
      // function should not return this instance.
      return sel;
    }
    return _NULL;
  }
};


/**
 * Tests if the given Object is a controlRange.
 * @param {Object} range The range object to test.
 * @return {boolean} Whether the given Object is a controlRange.
 */
goog.dom.AbstractRange.isNativeControlRange = function(range) {
  // For now, tests for presence of a control range function.
  return !!range && !!range.addElement;
};


/**
 * @return {goog.dom.AbstractRange} A clone of this range.
 */
goog.dom.AbstractRange.prototype.clone = goog.abstractMethod;


/**
 * @return {goog.dom.RangeType} The type of range represented by this object.
 */
goog.dom.AbstractRange.prototype.getType = goog.abstractMethod;


/**
 * @return {Range|TextRange} The native browser range object.
 */
goog.dom.AbstractRange.prototype.getBrowserRangeObject = goog.abstractMethod;


/**
 * Sets the native browser range object, overwriting any state this range was
 * storing.
 * @param {Range|TextRange} nativeRange The native browser range object.
 * @return {boolean} Whether the given range was accepted.  If not, the caller
 *     will need to call goog.dom.Range.createFromBrowserRange to create a new
 *     range object.
 */
goog.dom.AbstractRange.prototype.setBrowserRangeObject = function(nativeRange) {
  return _FALSE;
};


/**
 * @return {number} The number of text ranges in this range.
 */
goog.dom.AbstractRange.prototype.getTextRangeCount = goog.abstractMethod;


/**
 * Get the i-th text range in this range.  The behavior is undefined if
 * i >= getTextRangeCount or i < 0.
 * @param {number} i The range number to retrieve.
 * @return {goog.dom.TextRange} The i-th text range.
 */
goog.dom.AbstractRange.prototype.getTextRange = goog.abstractMethod;


/**
 * Gets an array of all text ranges this range is comprised of.  For non-multi
 * ranges, returns a single element array containing this.
 * @return {Array.<goog.dom.TextRange>} Array of text ranges.
 */
goog.dom.AbstractRange.prototype.getTextRanges = function() {
  var output = [];
  for (var i = 0, len = this.getTextRangeCount(); i < len; i++) {
    output.push(this.getTextRange(i));
  }
  return output;
};


/**
 * @return {Node} The deepest node that contains the entire range.
 */
goog.dom.AbstractRange.prototype.getContainer = goog.abstractMethod;



/**
 * @return {Node} The element or text node the range starts in.  For text
 *     ranges, the range comprises all text between the start and end position.
 *     For other types of range, start and end give bounds of the range but
 *     do not imply all nodes in those bounds are selected.
 */
goog.dom.AbstractRange.prototype.getStartNode = goog.abstractMethod;


/**
 * @return {number} The offset into the node the range starts in.  For text
 *     nodes, this is an offset into the node value.  For elements, this is
 *     an offset into the childNodes array.
 */
goog.dom.AbstractRange.prototype.getStartOffset = goog.abstractMethod;


/**
 * @return {Node} The element or text node the range ends in.
 */
goog.dom.AbstractRange.prototype.getEndNode = goog.abstractMethod;


/**
 * @return {number} The offset into the node the range ends in.  For text
 *     nodes, this is an offset into the node value.  For elements, this is
 *     an offset into the childNodes array.
 */
goog.dom.AbstractRange.prototype.getEndOffset = goog.abstractMethod;


/**
 * @return {Node} The element or text node the range is anchored at.
 */
goog.dom.AbstractRange.prototype.getAnchorNode = function() {
  return this.isReversed() ? this.getEndNode() : this.getStartNode();
};


/**
 * @return {number} The offset into the node the range is anchored at.  For
 *     text nodes, this is an offset into the node value.  For elements, this
 *     is an offset into the childNodes array.
 */
goog.dom.AbstractRange.prototype.getAnchorOffset = function() {
  return this.isReversed() ? this.getEndOffset() : this.getStartOffset();
};


/**
 * @return {Node} The element or text node the range is focused at - i.e. where
 *     the cursor is.
 */
goog.dom.AbstractRange.prototype.getFocusNode = function() {
  return this.isReversed() ? this.getStartNode() : this.getEndNode();
};


/**
 * @return {number} The offset into the node the range is focused at - i.e.
 *     where the cursor is.  For text nodes, this is an offset into the node
 *     value.  For elements, this is an offset into the childNodes array.
 */
goog.dom.AbstractRange.prototype.getFocusOffset = function() {
  return this.isReversed() ? this.getStartOffset() : this.getEndOffset();
};


/**
 * @return {boolean} Whether the selection is reversed.
 */
goog.dom.AbstractRange.prototype.isReversed = function() {
  return _FALSE;
};


/**
 * @return {Document} The document this selection is a part of.
 */
goog.dom.AbstractRange.prototype.getDocument = function() {
  // Using start node in IE was crashing the browser in some cases so use
  // getContainer for that browser. It's also faster for IE, but still slower
  // than start node for other browsers so we continue to use getStartNode when
  // it is not problematic. See bug 1687309.
  return goog.dom.getOwnerDocument(goog.userAgent.IE ?
      this.getContainer() : this.getStartNode());
};


/**
 * @return {Window} The window this selection is a part of.
 */
goog.dom.AbstractRange.prototype.getWindow = function() {
  return goog.dom.getWindow(this.getDocument());
};


/**
 * Tests if this range contains the given range.
 * @param {goog.dom.AbstractRange} range The range to test.
 * @param {boolean=} opt_allowPartial If true, the range can be partially
 *     contained in the selection, otherwise the range must be entirely
 *     contained.
 * @return {boolean} Whether this range contains the given range.
 */
goog.dom.AbstractRange.prototype.containsRange = goog.abstractMethod;


/**
 * Tests if this range contains the given node.
 * @param {Node} node The node to test for.
 * @param {boolean=} opt_allowPartial If not set or _FALSE, the node must be
 *     entirely contained in the selection for this function to return true.
 * @return {boolean} Whether this range contains the given node.
 */
goog.dom.AbstractRange.prototype.containsNode = function(node,
    opt_allowPartial) {
  return this.containsRange(goog.dom.Range.createFromNodeContents(node),
      opt_allowPartial);
};


/**
 * Tests whether this range is valid (i.e. whether its endpoints are still in
 * the document).  A range becomes invalid when, after this object was created,
 * either one or both of its endpoints are removed from the document.  Use of
 * an invalid range can lead to runtime errors, particularly in IE.
 * @return {boolean} Whether the range is valid.
 */
goog.dom.AbstractRange.prototype.isRangeInDocument = goog.abstractMethod;


/**
 * @return {boolean} Whether the range is collapsed.
 */
goog.dom.AbstractRange.prototype.isCollapsed = goog.abstractMethod;


/**
 * @return {string} The text content of the range.
 */
goog.dom.AbstractRange.prototype.getText = goog.abstractMethod;


/**
 * Returns the HTML fragment this range selects.  This is slow on all browsers.
 * The HTML fragment may not be valid HTML, for instance if the user selects
 * from a to b inclusively in the following html:
 *
 * &gt;div&lt;a&gt;/div&lt;b
 *
 * This method will return
 *
 * a&lt;/div&gt;b
 *
 * If you need valid HTML, use {@link #getValidHtml} instead.
 *
 * @return {string} HTML fragment of the range, does not include context
 *     containing elements.
 */
goog.dom.AbstractRange.prototype.getHtmlFragment = goog.abstractMethod;


/**
 * Returns valid HTML for this range.  This is fast on IE, and semi-fast on
 * other browsers.
 * @return {string} Valid HTML of the range, including context containing
 *     elements.
 */
goog.dom.AbstractRange.prototype.getValidHtml = goog.abstractMethod;


/**
 * Returns pastable HTML for this range.  This guarantees that any child items
 * that must have specific ancestors will have them, for instance all TDs will
 * be contained in a TR in a TBODY in a TABLE and all LIs will be contained in
 * a UL or OL as appropriate.  This is semi-fast on all browsers.
 * @return {string} Pastable HTML of the range, including context containing
 *     elements.
 */
goog.dom.AbstractRange.prototype.getPastableHtml = goog.abstractMethod;


/**
 * Returns a RangeIterator over the contents of the range.  Regardless of the
 * direction of the range, the iterator will move in document order.
 * @param {boolean=} opt_keys Unused for this iterator.
 * @return {goog.dom.RangeIterator} An iterator over tags in the range.
 */
goog.dom.AbstractRange.prototype.__iterator__ = goog.abstractMethod;


// RANGE ACTIONS


/**
 * Sets this range as the selection in its window.
 */
goog.dom.AbstractRange.prototype.select = goog.abstractMethod;


/**
 * Removes the contents of the range from the document.
 */
goog.dom.AbstractRange.prototype.removeContents = goog.abstractMethod;


/**
 * Inserts a node before (or after) the range.  The range may be disrupted
 * beyond recovery because of the way this splits nodes.
 * @param {Node} node The node to insert.
 * @param {boolean} before True to insert before, _FALSE to insert after.
 * @return {Node} The node added to the document.  This may be different
 *     than the node parameter because on IE we have to clone it.
 */
goog.dom.AbstractRange.prototype.insertNode = goog.abstractMethod;


/**
 * Surrounds this range with the two given nodes.  The range may be disrupted
 * beyond recovery because of the way this splits nodes.
 * @param {Element} startNode The node to insert at the start.
 * @param {Element} endNode The node to insert at the end.
 */
goog.dom.AbstractRange.prototype.surroundWithNodes = goog.abstractMethod;


// SAVE/RESTORE


/**
 * Saves the range so that if the start and end nodes are left alone, it can
 * be restored.
 * @return {goog.dom.SavedRange} A range representation that can be restored
 *     as long as the endpoint nodes of the selection are not modified.
 */
goog.dom.AbstractRange.prototype.saveUsingDom = goog.abstractMethod;


/**
 * Saves the range using HTML carets. As long as the carets remained in the
 * HTML, the range can be restored...even when the HTML is copied across
 * documents.
 * @return {goog.dom.SavedCaretRange?} A range representation that can be
 *     restored as long as carets are not removed. Returns null if carets
 *     could not be created.
 */
goog.dom.AbstractRange.prototype.saveUsingCarets = function() {
  return (this.getStartNode() && this.getEndNode()) ?
      new goog.dom.SavedCaretRange(this) : _NULL;
};


// RANGE MODIFICATION


/**
 * Collapses the range to one of its boundary points.
 * @param {boolean} toAnchor Whether to collapse to the anchor of the range.
 */
goog.dom.AbstractRange.prototype.collapse = goog.abstractMethod;

// RANGE ITERATION



/**
 * Subclass of goog.dom.TagIterator that iterates over a DOM range.  It
 * adds functions to determine the portion of each text node that is selected.
 * @param {Node} node The node to start traversal at.  When null, creates an
 *     empty iterator.
 * @param {boolean=} opt_reverse Whether to traverse nodes in reverse.
 * @constructor
 * @extends {goog.dom.TagIterator}
 */
goog.dom.RangeIterator = function(node, opt_reverse) {
  goog.dom.TagIterator.call(this, node, opt_reverse, _TRUE);
};
goog.inherits(goog.dom.RangeIterator, goog.dom.TagIterator);


/**
 * @return {number} The offset into the current node, or -1 if the current node
 *     is not a text node.
 */
goog.dom.RangeIterator.prototype.getStartTextOffset = goog.abstractMethod;


/**
 * @return {number} The end offset into the current node, or -1 if the current
 *     node is not a text node.
 */
goog.dom.RangeIterator.prototype.getEndTextOffset = goog.abstractMethod;


/**
 * @return {Node} node The iterator's start node.
 */
goog.dom.RangeIterator.prototype.getStartNode = goog.abstractMethod;


/**
 * @return {Node} The iterator's end node.
 */
goog.dom.RangeIterator.prototype.getEndNode = goog.abstractMethod;


/**
 * @return {boolean} Whether a call to next will fail.
 */
goog.dom.RangeIterator.prototype.isLast = goog.abstractMethod;
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for working with ranges comprised of multiple
 * sub-ranges.
 *
 * @author robbyw@google.com (Robby Walker)
 * @author jparent@google.com (Julie Parent)
 */


goog.provide('goog.dom.AbstractMultiRange');

//goog.require('goog.array');
//goog.require('goog.dom');
//goog.require('goog.dom.AbstractRange');



/**
 * Creates a new multi range with no properties.  Do not use this
 * constructor: use one of the goog.dom.Range.createFrom* methods instead.
 * @constructor
 * @extends {goog.dom.AbstractRange}
 */
goog.dom.AbstractMultiRange = function() {
};
goog.inherits(goog.dom.AbstractMultiRange, goog.dom.AbstractRange);


/** @inheritDoc */
goog.dom.AbstractMultiRange.prototype.containsRange = function(
    otherRange, opt_allowPartial) {
  // TODO(user): This will incorrectly return _FALSE if two (or more) adjacent
  // elements are both in the control range, and are also in the text range
  // being compared to.
  var ranges = this.getTextRanges();
  var otherRanges = otherRange.getTextRanges();

  var fn = opt_allowPartial ? goog.array.some : goog.array.every;
  return fn(otherRanges, function(otherRange) {
    return goog.array.some(ranges, function(range) {
      return range.containsRange(otherRange, opt_allowPartial);
    });
  });
};


/** @inheritDoc */
goog.dom.AbstractMultiRange.prototype.insertNode = function(node, before) {
  if (before) {
    goog.dom.insertSiblingBefore(node, this.getStartNode());
  } else {
    goog.dom.insertSiblingAfter(node, this.getEndNode());
  }
  return node;
};


/** @inheritDoc */
goog.dom.AbstractMultiRange.prototype.surroundWithNodes = function(startNode,
    endNode) {
  this.insertNode(startNode, _TRUE);
  this.insertNode(endNode, _FALSE);
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Iterator between two DOM text range positions.
 *
 * @author robbyw@google.com (Robby Walker)
 */

goog.provide('goog.dom.TextRangeIterator');

//goog.require('goog.array');
//goog.require('goog.dom.NodeType');
//goog.require('goog.dom.RangeIterator');
//goog.require('goog.dom.TagName');
//goog.require('goog.iter.StopIteration');



/**
 * Subclass of goog.dom.TagIterator that iterates over a DOM range.  It
 * adds functions to determine the portion of each text node that is selected.
 *
 * @param {Node} startNode The starting node position.
 * @param {number} startOffset The offset in to startNode.  If startNode is
 *     an element, indicates an offset in to childNodes.  If startNode is a
 *     text node, indicates an offset in to nodeValue.
 * @param {Node} endNode The ending node position.
 * @param {number} endOffset The offset in to endNode.  If endNode is
 *     an element, indicates an offset in to childNodes.  If endNode is a
 *     text node, indicates an offset in to nodeValue.
 * @param {boolean=} opt_reverse Whether to traverse nodes in reverse.
 * @constructor
 * @extends {goog.dom.RangeIterator}
 */
goog.dom.TextRangeIterator = function(startNode, startOffset, endNode,
    endOffset, opt_reverse) {
  var goNext;

  if (startNode) {
    this.startNode_ = startNode;
    this.startOffset_ = startOffset;
    this.endNode_ = endNode;
    this.endOffset_ = endOffset;

    // Skip to the offset nodes - being careful to special case BRs since these
    // have no children but still can appear as the startContainer of a range.
    if (startNode.nodeType == goog.dom.NodeType.ELEMENT &&
        startNode.tagName != goog.dom.TagName.BR) {
      var startChildren = startNode.childNodes;
      var candidate = startChildren[startOffset];
      if (candidate) {
        this.startNode_ = candidate;
        this.startOffset_ = 0;
      } else {
        if (startChildren.length) {
          this.startNode_ =
              /** @type {Node} */ (goog.array.peek(startChildren));
        }
        goNext = _TRUE;
      }
    }

    if (endNode.nodeType == goog.dom.NodeType.ELEMENT) {
      this.endNode_ = endNode.childNodes[endOffset];
      if (this.endNode_) {
        this.endOffset_ = 0;
      } else {
        // The offset was past the last element.
        this.endNode_ = endNode;
      }
    }
  }

  goog.dom.RangeIterator.call(this, opt_reverse ? this.endNode_ :
      this.startNode_, opt_reverse);

  if (goNext) {
    try {
      this.next();
    } catch (e) {
      if (e != goog.iter.StopIteration) {
        throw e;
      }
    }
  }
};
goog.inherits(goog.dom.TextRangeIterator, goog.dom.RangeIterator);


/**
 * The first node in the selection.
 * @type {Node}
 * @private
 */
goog.dom.TextRangeIterator.prototype.startNode_ = _NULL;


/**
 * The last node in the selection.
 * @type {Node}
 * @private
 */
goog.dom.TextRangeIterator.prototype.endNode_ = _NULL;


/**
 * The offset within the first node in the selection.
 * @type {number}
 * @private
 */
goog.dom.TextRangeIterator.prototype.startOffset_ = 0;


/**
 * The offset within the last node in the selection.
 * @type {number}
 * @private
 */
goog.dom.TextRangeIterator.prototype.endOffset_ = 0;


/** @inheritDoc */
goog.dom.TextRangeIterator.prototype.getStartTextOffset = function() {
  // Offsets only apply to text nodes.  If our current node is the start node,
  // return the saved offset.  Otherwise, return 0.
  return this.node.nodeType != goog.dom.NodeType.TEXT ? -1 :
         this.node == this.startNode_ ? this.startOffset_ : 0;
};


/** @inheritDoc */
goog.dom.TextRangeIterator.prototype.getEndTextOffset = function() {
  // Offsets only apply to text nodes.  If our current node is the end node,
  // return the saved offset.  Otherwise, return the length of the node.
  return this.node.nodeType != goog.dom.NodeType.TEXT ? -1 :
      this.node == this.endNode_ ? this.endOffset_ : this.node.nodeValue.length;
};


/** @inheritDoc */
goog.dom.TextRangeIterator.prototype.getStartNode = function() {
  return this.startNode_;
};


/**
 * Change the start node of the iterator.
 * @param {Node} node The new start node.
 */
goog.dom.TextRangeIterator.prototype.setStartNode = function(node) {
  if (!this.isStarted()) {
    this.setPosition(node);
  }

  this.startNode_ = node;
  this.startOffset_ = 0;
};


/** @inheritDoc */
goog.dom.TextRangeIterator.prototype.getEndNode = function() {
  return this.endNode_;
};


/**
 * Change the end node of the iterator.
 * @param {Node} node The new end node.
 */
goog.dom.TextRangeIterator.prototype.setEndNode = function(node) {
  this.endNode_ = node;
  this.endOffset_ = 0;
};


/** @inheritDoc */
goog.dom.TextRangeIterator.prototype.isLast = function() {
  return this.isStarted() && this.node == this.endNode_ &&
      (!this.endOffset_ || !this.isStartTag());
};


/**
 * Move to the next position in the selection.
 * Throws {@code goog.iter.StopIteration} when it passes the end of the range.
 * @return {Node} The node at the next position.
 */
goog.dom.TextRangeIterator.prototype.next = function() {
  if (this.isLast()) {
    throw goog.iter.StopIteration;
  }

  // Call the super function.
  return goog.dom.TextRangeIterator.superClass_.next.call(this);
};


/** @inheritDoc */
goog.dom.TextRangeIterator.prototype.skipTag = function() {
  goog.dom.TextRangeIterator.superClass_.skipTag.apply(this);

  // If the node we are skipping contains the end node, we just skipped past
  // the end, so we stop the iteration.
  if (goog.dom.contains(this.node, this.endNode_)) {
    throw goog.iter.StopIteration;
  }
};


/**
 * Replace this iterator's values with values from another.
 * @param {goog.dom.TextRangeIterator} other The iterator to copy.
 * @protected
 */
goog.dom.TextRangeIterator.prototype.copyFrom = function(other) {
  this.startNode_ = other.startNode_;
  this.endNode_ = other.endNode_;
  this.startOffset_ = other.startOffset_;
  this.endOffset_ = other.endOffset_;
  this.isReversed_ = other.isReversed_;

  goog.dom.TextRangeIterator.superClass_.copyFrom.call(this, other);
};


/**
 * @return {goog.dom.TextRangeIterator} An identical iterator.
 */
goog.dom.TextRangeIterator.prototype.clone = function() {
  var copy = new goog.dom.TextRangeIterator(this.startNode_,
      this.startOffset_, this.endNode_, this.endOffset_, this.isReversed_);
  copy.copyFrom(this);
  return copy;
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Detection of JScript version.
 *
 */


goog.provide('goog.userAgent.jscript');

//goog.require('goog.string');


/**
 * @define {boolean} True if it is known at compile time that the runtime
 *     environment will not be using JScript.
 */
goog.userAgent.jscript.ASSUME_NO_JSCRIPT = _FALSE;


/**
 * Initializer for goog.userAgent.jscript.  Detects if the user agent is using
 * Microsoft JScript and which version of it.
 *
 * This is a named function so that it can be stripped via the jscompiler
 * option for stripping types.
 * @private
 */
goog.userAgent.jscript.init_ = function() {
  var hasScriptEngine = 'ScriptEngine' in goog.global;

  /**
   * @type {boolean}
   * @private
   */
  goog.userAgent.jscript.DETECTED_HAS_JSCRIPT_ =
      hasScriptEngine && goog.global['ScriptEngine']() == 'JScript';

  /**
   * @type {string}
   * @private
   */
  goog.userAgent.jscript.DETECTED_VERSION_ =
      goog.userAgent.jscript.DETECTED_HAS_JSCRIPT_ ?
      (goog.global['ScriptEngineMajorVersion']() + '.' +
       goog.global['ScriptEngineMinorVersion']() + '.' +
       goog.global['ScriptEngineBuildVersion']()) :
      '0';
};

if (!goog.userAgent.jscript.ASSUME_NO_JSCRIPT) {
  goog.userAgent.jscript.init_();
}


/**
 * Whether we detect that the user agent is using Microsoft JScript.
 * @type {boolean}
 */
goog.userAgent.jscript.HAS_JSCRIPT = goog.userAgent.jscript.ASSUME_NO_JSCRIPT ?
    _FALSE : goog.userAgent.jscript.DETECTED_HAS_JSCRIPT_;


/**
 * The installed version of JScript.
 * @type {string}
 */
goog.userAgent.jscript.VERSION = goog.userAgent.jscript.ASSUME_NO_JSCRIPT ?
    '0' : goog.userAgent.jscript.DETECTED_VERSION_;


/**
 * Whether the installed version of JScript is as new or newer than a given
 * version.
 * @param {string} version The version to check.
 * @return {boolean} Whether the installed version of JScript is as new or
 *     newer than the given version.
 */
goog.userAgent.jscript.isVersion = function(version) {
  return goog.string.compareVersions(goog.userAgent.jscript.VERSION,
                                     version) >= 0;
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utility for fast string concatenation.
 */

goog.provide('goog.string.StringBuffer');

//goog.require('goog.userAgent.jscript');



/**
 * Utility class to facilitate much faster string concatenation in IE,
 * using Array.join() rather than the '+' operator.  For other browsers
 * we simply use the '+' operator.
 *
 * @param {Object|number|string|boolean=} opt_a1 Optional first initial item
 *     to append.
 * @param {...Object|number|string|boolean} var_args Other initial items to
 *     append, e.g., new goog.string.StringBuffer('foo', 'bar').
 * @constructor
 */
goog.string.StringBuffer = function(opt_a1, var_args) {
  /**
   * Internal buffer for the string to be concatenated.
   * @type {string|Array}
   * @private
   */
  this.buffer_ = goog.userAgent.jscript.HAS_JSCRIPT ? [] : '';

  if (opt_a1 != _NULL) {
    this.append.apply(this, arguments);
  }
};


/**
 * Sets the contents of the string buffer object, replacing what's currently
 * there.
 *
 * @param {string} s String to set.
 */
goog.string.StringBuffer.prototype.set = function(s) {
  this.clear();
  this.append(s);
};


if (goog.userAgent.jscript.HAS_JSCRIPT) {
  /**
   * Length of internal buffer (faster than calling buffer_.length).
   * Only used if buffer_ is an array.
   * @type {number}
   * @private
   */
  goog.string.StringBuffer.prototype.bufferLength_ = 0;

  /**
   * Appends one or more items to the buffer.
   *
   * Calling this with null, undefined, or empty arguments is an error.
   *
   * @param {Object|number|string|boolean} a1 Required first string.
   * @param {Object|number|string|boolean=} opt_a2 Optional second string.
   * @param {...Object|number|string|boolean} var_args Other items to append,
   *     e.g., sb.append('foo', 'bar', 'baz').
   * @return {goog.string.StringBuffer} This same StringBuffer object.
   */
  goog.string.StringBuffer.prototype.append = function(a1, opt_a2, var_args) {
    // IE version.

    if (opt_a2 == _NULL) { // second argument is undefined (null == undefined)
      // Array assignment is 2x faster than Array push.  Also, use a1
      // directly to avoid arguments instantiation, another 2x improvement.
      this.buffer_[this.bufferLength_++] = a1;
    } else {
      this.buffer_.push.apply(/** @type {Array} */ (this.buffer_), arguments);
      this.bufferLength_ = this.buffer_.length;
    }
    return this;
  };
} else {

  /**
   * Appends one or more items to the buffer.
   *
   * Calling this with null, undefined, or empty arguments is an error.
   *
   * @param {Object|number|string|boolean} a1 Required first string.
   * @param {Object|number|string|boolean=} opt_a2 Optional second string.
   * @param {...Object|number|string|boolean} var_args Other items to append,
   *     e.g., sb.append('foo', 'bar', 'baz').
   * @return {goog.string.StringBuffer} This same StringBuffer object.
   * @suppress {duplicate}
   */
  goog.string.StringBuffer.prototype.append = function(a1, opt_a2, var_args) {
    // W3 version.

    // Use a1 directly to avoid arguments instantiation for single-arg case.
    this.buffer_ += a1;
    if (opt_a2 != _NULL) { // second argument is undefined (null == undefined)
      for (var i = 1; i < arguments.length; i++) {
        this.buffer_ += arguments[i];
      }
    }
    return this;
  };
}


/**
 * Clears the internal buffer.
 */
goog.string.StringBuffer.prototype.clear = function() {
  if (goog.userAgent.jscript.HAS_JSCRIPT) {
     this.buffer_.length = 0;  // Reuse the array to avoid creating new object.
     this.bufferLength_ = 0;
   } else {
     this.buffer_ = '';
   }
};


/**
 * Returns the length of the current contents of the buffer.  In IE, this is
 * O(n) where n = number of appends, so to avoid quadratic behavior, do not call
 * this after every append.
 *
 * @return {number} the length of the current contents of the buffer.
 */
goog.string.StringBuffer.prototype.getLength = function() {
   return this.toString().length;
};


/**
 * Returns the concatenated string.
 *
 * @return {string} The concatenated string.
 */
goog.string.StringBuffer.prototype.toString = function() {
  if (goog.userAgent.jscript.HAS_JSCRIPT) {
    var str = this.buffer_.join('');
    // Given a string with the entire contents, simplify the StringBuffer by
    // setting its contents to only be this string, rather than many fragments.
    this.clear();
    if (str) {
      this.append(str);
    }
    return str;
  } else {
    return /** @type {string} */ (this.buffer_);
  }
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Simple struct for endpoints of a range.
 *
 * @author robbyw@google.com (Robby Walker)
 */


goog.provide('goog.dom.RangeEndpoint');


/**
 * Constants for selection endpoints.
 * @enum {number}
 */
goog.dom.RangeEndpoint = {
  START: 1,
  END: 0
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the browser range interface.
 *
 * DO NOT USE THIS FILE DIRECTLY.  Use goog.dom.Range instead.
 *
 * @author robbyw@google.com (Robby Walker)
 * @author ojan@google.com (Ojan Vafai)
 * @author jparent@google.com (Julie Parent)
 */


goog.provide('goog.dom.browserrange.AbstractRange');

//goog.require('goog.dom');
//goog.require('goog.dom.NodeType');
//goog.require('goog.dom.RangeEndpoint');
//goog.require('goog.dom.TagName');
//goog.require('goog.dom.TextRangeIterator');
//goog.require('goog.iter');
//goog.require('goog.string');
//goog.require('goog.string.StringBuffer');
//goog.require('goog.userAgent');



/**
 * The constructor for abstract ranges.  Don't call this from subclasses.
 * @constructor
 */
goog.dom.browserrange.AbstractRange = function() {
};


/**
 * @return {goog.dom.browserrange.AbstractRange} A clone of this range.
 */
goog.dom.browserrange.AbstractRange.prototype.clone = goog.abstractMethod;


/**
 * Returns the browser native implementation of the range.  Please refrain from
 * using this function - if you find you need the range please add wrappers for
 * the functionality you need rather than just using the native range.
 * @return {Range|TextRange} The browser native range object.
 */
goog.dom.browserrange.AbstractRange.prototype.getBrowserRange =
    goog.abstractMethod;


/**
 * Returns the deepest node in the tree that contains the entire range.
 * @return {Node} The deepest node that contains the entire range.
 */
goog.dom.browserrange.AbstractRange.prototype.getContainer =
    goog.abstractMethod;


/**
 * Returns the node the range starts in.
 * @return {Node} The element or text node the range starts in.
 */
goog.dom.browserrange.AbstractRange.prototype.getStartNode =
    goog.abstractMethod;


/**
 * Returns the offset into the node the range starts in.
 * @return {number} The offset into the node the range starts in.  For text
 *     nodes, this is an offset into the node value.  For elements, this is
 *     an offset into the childNodes array.
 */
goog.dom.browserrange.AbstractRange.prototype.getStartOffset =
    goog.abstractMethod;


/**
 * Returns the node the range ends in.
 * @return {Node} The element or text node the range ends in.
 */
goog.dom.browserrange.AbstractRange.prototype.getEndNode =
    goog.abstractMethod;


/**
 * Returns the offset into the node the range ends in.
 * @return {number} The offset into the node the range ends in.  For text
 *     nodes, this is an offset into the node value.  For elements, this is
 *     an offset into the childNodes array.
 */
goog.dom.browserrange.AbstractRange.prototype.getEndOffset =
    goog.abstractMethod;


/**
 * Compares one endpoint of this range with the endpoint of another browser
 * native range object.
 * @param {Range|TextRange} range The browser native range to compare against.
 * @param {goog.dom.RangeEndpoint} thisEndpoint The endpoint of this range
 *     to compare with.
 * @param {goog.dom.RangeEndpoint} otherEndpoint The endpoint of the other
 *     range to compare with.
 * @return {number} 0 if the endpoints are equal, negative if this range
 *     endpoint comes before the other range endpoint, and positive otherwise.
 */
goog.dom.browserrange.AbstractRange.prototype.compareBrowserRangeEndpoints =
    goog.abstractMethod;


/**
 * Tests if this range contains the given range.
 * @param {goog.dom.browserrange.AbstractRange} abstractRange The range to test.
 * @param {boolean=} opt_allowPartial If not set or _FALSE, the range must be
 *     entirely contained in the selection for this function to return true.
 * @return {boolean} Whether this range contains the given range.
 */
goog.dom.browserrange.AbstractRange.prototype.containsRange =
    function(abstractRange, opt_allowPartial) {
  // IE sometimes misreports the boundaries for collapsed ranges. So if the
  // other range is collapsed, make sure the whole range is contained. This is
  // logically equivalent, and works around IE's bug.
  var checkPartial = opt_allowPartial && !abstractRange.isCollapsed();

  var range = abstractRange.getBrowserRange();
  var start = goog.dom.RangeEndpoint.START, end = goog.dom.RangeEndpoint.END;
  /** {@preserveTry} */
  try {
    if (checkPartial) {
      // There are two ways to not overlap.  Being before, and being after.
      // Before is represented by this.end before range.start: comparison < 0.
      // After is represented by this.start after range.end: comparison > 0.
      // The below is the negation of not overlapping.
      return this.compareBrowserRangeEndpoints(range, end, start) >= 0 &&
             this.compareBrowserRangeEndpoints(range, start, end) <= 0;

    } else {
      // Return true if this range bounds the parameter range from both sides.
      return this.compareBrowserRangeEndpoints(range, end, end) >= 0 &&
          this.compareBrowserRangeEndpoints(range, start, start) <= 0;
    }
  } catch (e) {
    if (!goog.userAgent.IE) {
      throw e;
    }
    // IE sometimes throws exceptions when one range is invalid, i.e. points
    // to a node that has been removed from the document.  Return _FALSE in this
    // case.
    return _FALSE;
  }
};


/**
 * Tests if this range contains the given node.
 * @param {Node} node The node to test.
 * @param {boolean=} opt_allowPartial If not set or _FALSE, the node must be
 *     entirely contained in the selection for this function to return true.
 * @return {boolean} Whether this range contains the given node.
 */
goog.dom.browserrange.AbstractRange.prototype.containsNode = function(node,
    opt_allowPartial) {
  return this.containsRange(
      goog.dom.browserrange.createRangeFromNodeContents(node),
      opt_allowPartial);
};


/**
 * Tests if the selection is collapsed - i.e. is just a caret.
 * @return {boolean} Whether the range is collapsed.
 */
goog.dom.browserrange.AbstractRange.prototype.isCollapsed =
    goog.abstractMethod;


/**
 * @return {string} The text content of the range.
 */
goog.dom.browserrange.AbstractRange.prototype.getText =
    goog.abstractMethod;


/**
 * Returns the HTML fragment this range selects.  This is slow on all browsers.
 * @return {string} HTML fragment of the range, does not include context
 *     containing elements.
 */
goog.dom.browserrange.AbstractRange.prototype.getHtmlFragment = function() {
  var output = new goog.string.StringBuffer();
  goog.iter.forEach(this, function(node, ignore, it) {
    if (node.nodeType == goog.dom.NodeType.TEXT) {
      output.append(goog.string.htmlEscape(node.nodeValue.substring(
          it.getStartTextOffset(), it.getEndTextOffset())));
    } else if (node.nodeType == goog.dom.NodeType.ELEMENT) {
      if (it.isEndTag()) {
        if (goog.dom.canHaveChildren(node)) {
          output.append('</' + node.tagName + '>');
        }
      } else {
        var shallow = node.cloneNode(_FALSE);
        var html = goog.dom.getOuterHtml(shallow);
        if (goog.userAgent.IE && node.tagName == goog.dom.TagName.LI) {
          // For an LI, IE just returns "<li>" with no closing tag
          output.append(html);
        } else {
          var index = html.lastIndexOf('<');
          output.append(index ? html.substr(0, index) : html);
        }
      }
    }
  }, this);

  return output.toString();
};


/**
 * Returns valid HTML for this range.  This is fast on IE, and semi-fast on
 * other browsers.
 * @return {string} Valid HTML of the range, including context containing
 *     elements.
 */
goog.dom.browserrange.AbstractRange.prototype.getValidHtml =
    goog.abstractMethod;


/**
 * Returns a RangeIterator over the contents of the range.  Regardless of the
 * direction of the range, the iterator will move in document order.
 * @param {boolean=} opt_keys Unused for this iterator.
 * @return {goog.dom.RangeIterator} An iterator over tags in the range.
 */
goog.dom.browserrange.AbstractRange.prototype.__iterator__ = function(
    opt_keys) {
  return new goog.dom.TextRangeIterator(this.getStartNode(),
      this.getStartOffset(), this.getEndNode(), this.getEndOffset());
};


// SELECTION MODIFICATION


/**
 * Set this range as the selection in its window.
 * @param {boolean=} opt_reverse Whether to select the range in reverse,
 *     if possible.
 */
goog.dom.browserrange.AbstractRange.prototype.select =
    goog.abstractMethod;


/**
 * Removes the contents of the range from the document.  As a side effect, the
 * selection will be collapsed.  The behavior of content removal is normalized
 * across browsers.  For instance, IE sometimes creates extra text nodes that
 * a W3C browser does not.  That behavior is corrected for.
 */
goog.dom.browserrange.AbstractRange.prototype.removeContents =
    goog.abstractMethod;


/**
 * Surrounds the text range with the specified element (on Mozilla) or with a
 * clone of the specified element (on IE).  Returns a reference to the
 * surrounding element if the operation was successful; returns null if the
 * operation failed.
 * @param {Element} element The element with which the selection is to be
 *    surrounded.
 * @return {Element} The surrounding element (same as the argument on Mozilla,
 *    but not on IE), or null if unsuccessful.
 */
goog.dom.browserrange.AbstractRange.prototype.surroundContents =
    goog.abstractMethod;


/**
 * Inserts a node before (or after) the range.  The range may be disrupted
 * beyond recovery because of the way this splits nodes.
 * @param {Node} node The node to insert.
 * @param {boolean} before True to insert before, _FALSE to insert after.
 * @return {Node} The node added to the document.  This may be different
 *     than the node parameter because on IE we have to clone it.
 */
goog.dom.browserrange.AbstractRange.prototype.insertNode =
    goog.abstractMethod;


/**
 * Surrounds this range with the two given nodes.  The range may be disrupted
 * beyond recovery because of the way this splits nodes.
 * @param {Element} startNode The node to insert at the start.
 * @param {Element} endNode The node to insert at the end.
 */
goog.dom.browserrange.AbstractRange.prototype.surroundWithNodes =
    goog.abstractMethod;


/**
 * Collapses the range to one of its boundary points.
 * @param {boolean} toStart Whether to collapse to the start of the range.
 */
goog.dom.browserrange.AbstractRange.prototype.collapse =
    goog.abstractMethod;
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the W3C spec following range wrapper.
 *
 * DO NOT USE THIS FILE DIRECTLY.  Use goog.dom.Range instead.
 *
 * @author robbyw@google.com (Robby Walker)
 * @author ojan@google.com (Ojan Vafai)
 * @author jparent@google.com (Julie Parent)
 */


goog.provide('goog.dom.browserrange.W3cRange');

//goog.require('goog.dom');
//goog.require('goog.dom.NodeType');
//goog.require('goog.dom.RangeEndpoint');
//goog.require('goog.dom.browserrange.AbstractRange');
//goog.require('goog.string');



/**
 * The constructor for W3C specific browser ranges.
 * @param {Range} range The range object.
 * @constructor
 * @extends {goog.dom.browserrange.AbstractRange}
 */
goog.dom.browserrange.W3cRange = function(range) {
  this.range_ = range;
};
goog.inherits(goog.dom.browserrange.W3cRange,
              goog.dom.browserrange.AbstractRange);


/**
 * Returns a browser range spanning the given node's contents.
 * @param {Node} node The node to select.
 * @return {Range} A browser range spanning the node's contents.
 * @protected
 */
goog.dom.browserrange.W3cRange.getBrowserRangeForNode = function(node) {
  var nodeRange = goog.dom.getOwnerDocument(node).createRange();

  if (node.nodeType == goog.dom.NodeType.TEXT) {
    nodeRange.setStart(node, 0);
    nodeRange.setEnd(node, node.length);
  } else {
    if (!goog.dom.browserrange.canContainRangeEndpoint(node)) {
      var rangeParent = node.parentNode;
      var rangeStartOffset = goog.array.indexOf(rangeParent.childNodes, node);
      nodeRange.setStart(rangeParent, rangeStartOffset);
      nodeRange.setEnd(rangeParent, rangeStartOffset + 1);
    } else {
      var tempNode, leaf = node;
      while ((tempNode = leaf.firstChild) &&
          goog.dom.browserrange.canContainRangeEndpoint(tempNode)) {
        leaf = tempNode;
      }
      nodeRange.setStart(leaf, 0);

      leaf = node;
      while ((tempNode = leaf.lastChild) &&
          goog.dom.browserrange.canContainRangeEndpoint(tempNode)) {
        leaf = tempNode;
      }
      nodeRange.setEnd(leaf, leaf.nodeType == goog.dom.NodeType.ELEMENT ?
          leaf.childNodes.length : leaf.length);
    }
  }

  return nodeRange;
};


/**
 * Returns a browser range spanning the given nodes.
 * @param {Node} startNode The node to start with - should not be a BR.
 * @param {number} startOffset The offset within the start node.
 * @param {Node} endNode The node to end with - should not be a BR.
 * @param {number} endOffset The offset within the end node.
 * @return {Range} A browser range spanning the node's contents.
 * @protected
 */
goog.dom.browserrange.W3cRange.getBrowserRangeForNodes = function(startNode,
    startOffset, endNode, endOffset) {
  // Create and return the range.
  var nodeRange = goog.dom.getOwnerDocument(startNode).createRange();
  nodeRange.setStart(startNode, startOffset);
  nodeRange.setEnd(endNode, endOffset);
  return nodeRange;
};


/**
 * Creates a range object that selects the given node's text.
 * @param {Node} node The node to select.
 * @return {goog.dom.browserrange.W3cRange} A Gecko range wrapper object.
 */
goog.dom.browserrange.W3cRange.createFromNodeContents = function(node) {
  return new goog.dom.browserrange.W3cRange(
      goog.dom.browserrange.W3cRange.getBrowserRangeForNode(node));
};


/**
 * Creates a range object that selects between the given nodes.
 * @param {Node} startNode The node to start with.
 * @param {number} startOffset The offset within the start node.
 * @param {Node} endNode The node to end with.
 * @param {number} endOffset The offset within the end node.
 * @return {goog.dom.browserrange.W3cRange} A wrapper object.
 */
goog.dom.browserrange.W3cRange.createFromNodes = function(startNode,
    startOffset, endNode, endOffset) {
  return new goog.dom.browserrange.W3cRange(
      goog.dom.browserrange.W3cRange.getBrowserRangeForNodes(startNode,
          startOffset, endNode, endOffset));
};


/**
 * @return {goog.dom.browserrange.W3cRange} A clone of this range.
 */
goog.dom.browserrange.W3cRange.prototype.clone = function() {
  return new this.constructor(this.range_.cloneRange());
};


/** @inheritDoc */
goog.dom.browserrange.W3cRange.prototype.getBrowserRange = function() {
  return this.range_;
};


/** @inheritDoc */
goog.dom.browserrange.W3cRange.prototype.getContainer = function() {
  return this.range_.commonAncestorContainer;
};


/** @inheritDoc */
goog.dom.browserrange.W3cRange.prototype.getStartNode = function() {
  return this.range_.startContainer;
};


/** @inheritDoc */
goog.dom.browserrange.W3cRange.prototype.getStartOffset = function() {
  return this.range_.startOffset;
};


/** @inheritDoc */
goog.dom.browserrange.W3cRange.prototype.getEndNode = function() {
  return this.range_.endContainer;
};


/** @inheritDoc */
goog.dom.browserrange.W3cRange.prototype.getEndOffset = function() {
  return this.range_.endOffset;
};


/** @inheritDoc */
goog.dom.browserrange.W3cRange.prototype.compareBrowserRangeEndpoints =
    function(range, thisEndpoint, otherEndpoint) {
  return this.range_.compareBoundaryPoints(
      otherEndpoint == goog.dom.RangeEndpoint.START ?
          (thisEndpoint == goog.dom.RangeEndpoint.START ?
              goog.global['Range'].START_TO_START :
              goog.global['Range'].START_TO_END) :
          (thisEndpoint == goog.dom.RangeEndpoint.START ?
              goog.global['Range'].END_TO_START :
              goog.global['Range'].END_TO_END),
      /** @type {Range} */ (range));
};


/** @inheritDoc */
goog.dom.browserrange.W3cRange.prototype.isCollapsed = function() {
  return this.range_.collapsed;
};


/** @inheritDoc */
goog.dom.browserrange.W3cRange.prototype.getText = function() {
  return this.range_.toString();
};


/** @inheritDoc */
goog.dom.browserrange.W3cRange.prototype.getValidHtml = function() {
  var div = goog.dom.getDomHelper(this.range_.startContainer).createDom('div');
  div.appendChild(this.range_.cloneContents());
  var result = div.innerHTML;

  if (goog.string.startsWith(result, '<') ||
      !this.isCollapsed() && !goog.string.contains(result, '<')) {
    // We attempt to mimic IE, which returns no containing element when a
    // only text nodes are selected, does return the containing element when
    // the selection is empty, and does return the element when multiple nodes
    // are selected.
    return result;
  }

  var container = this.getContainer();
  container = container.nodeType == goog.dom.NodeType.ELEMENT ? container :
      container.parentNode;

  var html = goog.dom.getOuterHtml(
      /** @type {Element} */ (container.cloneNode(_FALSE)));
  return html.replace('>', '>' + result);
};


// SELECTION MODIFICATION


/** @inheritDoc */
goog.dom.browserrange.W3cRange.prototype.select = function(reverse) {
  var win = goog.dom.getWindow(goog.dom.getOwnerDocument(this.getStartNode()));
  this.selectInternal(win.getSelection(), reverse);
};


/**
 * Select this range.
 * @param {Selection} selection Browser selection object.
 * @param {*} reverse Whether to select this range in reverse.
 * @protected
 */
goog.dom.browserrange.W3cRange.prototype.selectInternal = function(selection,
                                                                   reverse) {
  // Browser-specific tricks are needed to create reversed selections
  // programatically. For this generic W3C codepath, ignore the reverse
  // parameter.
  selection.removeAllRanges();
  selection.addRange(this.range_);
};


/** @inheritDoc */
goog.dom.browserrange.W3cRange.prototype.removeContents = function() {
  var range = this.range_;
  range.extractContents();

  if (range.startContainer.hasChildNodes()) {
    // Remove any now empty nodes surrounding the extracted contents.
    var rangeStartContainer =
        range.startContainer.childNodes[range.startOffset];
    if (rangeStartContainer) {
      var rangePrevious = rangeStartContainer.previousSibling;

      if (goog.dom.getRawTextContent(rangeStartContainer) == '') {
        goog.dom.removeNode(rangeStartContainer);
      }

      if (rangePrevious && goog.dom.getRawTextContent(rangePrevious) == '') {
        goog.dom.removeNode(rangePrevious);
      }
    }
  }
};


/** @inheritDoc */
goog.dom.browserrange.W3cRange.prototype.surroundContents = function(element) {
  this.range_.surroundContents(element);
  return element;
};


/** @inheritDoc */
goog.dom.browserrange.W3cRange.prototype.insertNode = function(node, before) {
  var range = this.range_.cloneRange();
  range.collapse(before);
  range.insertNode(node);
  range.detach();

  return node;
};


/** @inheritDoc */
goog.dom.browserrange.W3cRange.prototype.surroundWithNodes = function(
    startNode, endNode) {
  var win = goog.dom.getWindow(
      goog.dom.getOwnerDocument(this.getStartNode()));
  var selectionRange = goog.dom.Range.createFromWindow(win);
  if (selectionRange) {
    var sNode = selectionRange.getStartNode();
    var eNode = selectionRange.getEndNode();
    var sOffset = selectionRange.getStartOffset();
    var eOffset = selectionRange.getEndOffset();
  }

  var clone1 = this.range_.cloneRange();
  var clone2 = this.range_.cloneRange();

  clone1.collapse(_FALSE);
  clone2.collapse(_TRUE);

  clone1.insertNode(endNode);
  clone2.insertNode(startNode);

  clone1.detach();
  clone2.detach();

  if (selectionRange) {
    // There are 4 ways that surroundWithNodes can wreck the saved
    // selection object. All of them happen when an inserted node splits
    // a text node, and one of the end points of the selection was in the
    // latter half of that text node.
    //
    // Clients of this library should use saveUsingCarets to avoid this
    // problem. Unfortunately, saveUsingCarets uses this method, so that's
    // not really an option for us. :( We just recompute the offsets.
    var isInsertedNode = function(n) {
      return n == startNode || n == endNode;
    };
    if (sNode.nodeType == goog.dom.NodeType.TEXT) {
      while (sOffset > sNode.length) {
        sOffset -= sNode.length;
        do {
          sNode = sNode.nextSibling;
        } while (isInsertedNode(sNode));
      }
    }

    if (eNode.nodeType == goog.dom.NodeType.TEXT) {
      while (eOffset > eNode.length) {
        eOffset -= eNode.length;
        do {
          eNode = eNode.nextSibling;
        } while (isInsertedNode(eNode));
      }
    }

    goog.dom.Range.createFromNodes(
        sNode, /** @type {number} */ (sOffset),
        eNode, /** @type {number} */ (eOffset)).select();
  }
};


/** @inheritDoc */
goog.dom.browserrange.W3cRange.prototype.collapse = function(toStart) {
  this.range_.collapse(toStart);
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the WebKit specific range wrapper.  Inherits most
 * functionality from W3CRange, but adds exceptions as necessary.
 *
 * DO NOT USE THIS FILE DIRECTLY.  Use goog.dom.Range instead.
 *
 * @author robbyw@google.com (Robby Walker)
 */


goog.provide('goog.dom.browserrange.WebKitRange');

//goog.require('goog.dom.RangeEndpoint');
//goog.require('goog.dom.browserrange.W3cRange');
//goog.require('goog.userAgent');



/**
 * The constructor for WebKit specific browser ranges.
 * @param {Range} range The range object.
 * @constructor
 * @extends {goog.dom.browserrange.W3cRange}
 */
goog.dom.browserrange.WebKitRange = function(range) {
  goog.dom.browserrange.W3cRange.call(this, range);
};
goog.inherits(goog.dom.browserrange.WebKitRange,
              goog.dom.browserrange.W3cRange);


/**
 * Creates a range object that selects the given node's text.
 * @param {Node} node The node to select.
 * @return {goog.dom.browserrange.WebKitRange} A WebKit range wrapper object.
 */
goog.dom.browserrange.WebKitRange.createFromNodeContents = function(node) {
  return new goog.dom.browserrange.WebKitRange(
      goog.dom.browserrange.W3cRange.getBrowserRangeForNode(node));
};


/**
 * Creates a range object that selects between the given nodes.
 * @param {Node} startNode The node to start with.
 * @param {number} startOffset The offset within the start node.
 * @param {Node} endNode The node to end with.
 * @param {number} endOffset The offset within the end node.
 * @return {goog.dom.browserrange.WebKitRange} A wrapper object.
 */
goog.dom.browserrange.WebKitRange.createFromNodes = function(startNode,
    startOffset, endNode, endOffset) {
  return new goog.dom.browserrange.WebKitRange(
      goog.dom.browserrange.W3cRange.getBrowserRangeForNodes(startNode,
          startOffset, endNode, endOffset));
};


/** @inheritDoc */
goog.dom.browserrange.WebKitRange.prototype.compareBrowserRangeEndpoints =
    function(range, thisEndpoint, otherEndpoint) {
  // Webkit pre-528 has some bugs where compareBoundaryPoints() doesn't work the
  // way it is supposed to, but if we reverse the sense of two comparisons,
  // it works fine.
  // https://bugs.webkit.org/show_bug.cgi?id=20738
  if (goog.userAgent.isVersion('528')) {
    return (goog.dom.browserrange.WebKitRange.superClass_.
                compareBrowserRangeEndpoints.call(
                    this, range, thisEndpoint, otherEndpoint));
  }
  return this.range_.compareBoundaryPoints(
      otherEndpoint == goog.dom.RangeEndpoint.START ?
          (thisEndpoint == goog.dom.RangeEndpoint.START ?
              goog.global['Range'].START_TO_START :
              goog.global['Range'].END_TO_START) : // Sense reversed
          (thisEndpoint == goog.dom.RangeEndpoint.START ?
              goog.global['Range'].START_TO_END : // Sense reversed
              goog.global['Range'].END_TO_END),
      /** @type {Range} */ (range));
};


/** @inheritDoc */
goog.dom.browserrange.WebKitRange.prototype.selectInternal = function(
    selection, reversed) {
  // Unselect everything. This addresses a bug in Webkit where it sometimes
  // caches the old selection.
  // https://bugs.webkit.org/show_bug.cgi?id=20117
  selection.removeAllRanges();

  if (reversed) {
    selection.setBaseAndExtent(this.getEndNode(), this.getEndOffset(),
        this.getStartNode(), this.getStartOffset());
  } else {
    selection.setBaseAndExtent(this.getStartNode(), this.getStartOffset(),
        this.getEndNode(), this.getEndOffset());
  }
};
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Iterator subclass for DOM tree traversal.
 *
 * @author robbyw@google.com (Robby Walker)
 */

goog.provide('goog.dom.NodeIterator');

//goog.require('goog.dom.TagIterator');



/**
 * A DOM tree traversal iterator.
 *
 * Starting with the given node, the iterator walks the DOM in order, reporting
 * events for each node.  The iterator acts as a prefix iterator:
 *
 * <pre>
 * &lt;div&gt;1&lt;span&gt;2&lt;/span&gt;3&lt;/div&gt;
 * </pre>
 *
 * Will return the following nodes:
 *
 * <code>[div, 1, span, 2, 3]</code>
 *
 * With the following depths
 *
 * <code>[1, 1, 2, 2, 1]</code>
 *
 * Imagining <code>|</code> represents iterator position, the traversal stops at
 * each of the following locations:
 *
 * <pre>&lt;div&gt;|1|&lt;span&gt;|2|&lt;/span&gt;3|&lt;/div&gt;</pre>
 *
 * The iterator can also be used in reverse mode, which will return the nodes
 * and states in the opposite order.  The depths will be slightly different
 * since, like in normal mode, the depth is computed *after* the last move.
 *
 * Lastly, it is possible to create an iterator that is unconstrained, meaning
 * that it will continue iterating until the end of the document instead of
 * until exiting the start node.
 *
 * @param {Node=} opt_node The start node.  Defaults to an empty iterator.
 * @param {boolean=} opt_reversed Whether to traverse the tree in reverse.
 * @param {boolean=} opt_unconstrained Whether the iterator is not constrained
 *     to the starting node and its children.
 * @param {number=} opt_depth The starting tree depth.
 * @constructor
 * @extends {goog.dom.TagIterator}
 */
goog.dom.NodeIterator = function(opt_node, opt_reversed,
    opt_unconstrained, opt_depth) {
  goog.dom.TagIterator.call(this, opt_node, opt_reversed, opt_unconstrained,
      _NULL, opt_depth);
};
goog.inherits(goog.dom.NodeIterator, goog.dom.TagIterator);


/**
 * Moves to the next position in the DOM tree.
 * @return {Node} Returns the next node, or throws a goog.iter.StopIteration
 *     exception if the end of the iterator's range has been reached.
 */
goog.dom.NodeIterator.prototype.next = function() {
  do {
    goog.dom.NodeIterator.superClass_.next.call(this);
  } while (this.isEndTag());

  return this.node;
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the IE browser specific range wrapper.
 *
 * DO NOT USE THIS FILE DIRECTLY.  Use goog.dom.Range instead.
 *
 * @author robbyw@google.com (Robby Walker)
 * @author ojan@google.com (Ojan Vafai)
 * @author jparent@google.com (Julie Parent)
 */


goog.provide('goog.dom.browserrange.IeRange');

//goog.require('goog.array');
//goog.require('goog.dom');
//goog.require('goog.dom.NodeIterator');
//goog.require('goog.dom.NodeType');
//goog.require('goog.dom.RangeEndpoint');
//goog.require('goog.dom.TagName');
//goog.require('goog.dom.browserrange.AbstractRange');
//goog.require('goog.iter');
//goog.require('goog.iter.StopIteration');
//goog.require('goog.string');



/**
 * The constructor for IE specific browser ranges.
 * @param {TextRange} range The range object.
 * @param {Document} doc The document the range exists in.
 * @constructor
 * @extends {goog.dom.browserrange.AbstractRange}
 */
goog.dom.browserrange.IeRange = function(range, doc) {
  /**
   * The browser range object this class wraps.
   * @type {TextRange}
   * @private
   */
  this.range_ = range;

  /**
   * The document the range exists in.
   * @type {Document}
   * @private
   */
  this.doc_ = doc;
};
goog.inherits(goog.dom.browserrange.IeRange,
    goog.dom.browserrange.AbstractRange);


/**
 * Returns a browser range spanning the given node's contents.
 * @param {Node} node The node to select.
 * @return {TextRange} A browser range spanning the node's contents.
 * @private
 */
goog.dom.browserrange.IeRange.getBrowserRangeForNode_ = function(node) {
  var nodeRange = goog.dom.getOwnerDocument(node).body.createTextRange();
  if (node.nodeType == goog.dom.NodeType.ELEMENT) {
    // Elements are easy.
    nodeRange.moveToElementText(node);
    // Note(user) : If there are no child nodes of the element, the
    // range.htmlText includes the element's outerHTML. The range created above
    // is not collapsed, and should be collapsed explicitly.
    // Example : node = <div></div>
    // But if the node is sth like <br>, it shouldnt be collapsed.
    if (goog.dom.browserrange.canContainRangeEndpoint(node) &&
        !node.childNodes.length) {
      nodeRange.collapse(_FALSE);
    }
  } else {
    // Text nodes are hard.
    // Compute the offset from the nearest element related position.
    var offset = 0;
    var sibling = node;
    while (sibling = sibling.previousSibling) {
      var nodeType = sibling.nodeType;
      if (nodeType == goog.dom.NodeType.TEXT) {
        offset += sibling.length;
      } else if (nodeType == goog.dom.NodeType.ELEMENT) {
        // Move to the space after this element.
        nodeRange.moveToElementText(sibling);
        break;
      }
    }

    if (!sibling) {
      nodeRange.moveToElementText(node.parentNode);
    }

    nodeRange.collapse(!sibling);

    if (offset) {
      nodeRange.move('character', offset);
    }

    nodeRange.moveEnd('character', node.length);
  }

  return nodeRange;
};


/**
 * Returns a browser range spanning the given nodes.
 * @param {Node} startNode The node to start with.
 * @param {number} startOffset The offset within the start node.
 * @param {Node} endNode The node to end with.
 * @param {number} endOffset The offset within the end node.
 * @return {TextRange} A browser range spanning the node's contents.
 * @private
 */
goog.dom.browserrange.IeRange.getBrowserRangeForNodes_ = function(startNode,
    startOffset, endNode, endOffset) {
  // Create a range starting at the correct start position.
  var child, collapse = _FALSE;
  if (startNode.nodeType == goog.dom.NodeType.ELEMENT) {
    child = startNode.childNodes[startOffset];
    collapse = !child;
    startNode = child || startNode.lastChild || startNode;
    startOffset = 0;
  }
  var leftRange = goog.dom.browserrange.IeRange.
      getBrowserRangeForNode_(startNode);

  // This happens only when startNode is a text node.
  if (startOffset) {
    leftRange.move('character', startOffset);
  }


  // The range movements in IE are still an approximation to the standard W3C
  // behavior, and IE has its trickery when it comes to htmlText and text
  // properties of the range. So we short-circuit computation whenever we can.
  if (startNode == endNode && startOffset == endOffset) {
    leftRange.collapse(_TRUE);
    return leftRange;
  }

  // This can happen only when the startNode is an element, and there is no node
  // at the given offset. We start at the last point inside the startNode in
  // that case.
  if (collapse) {
    leftRange.collapse(_FALSE);
  }

  // Create a range that ends at the right position.
  collapse = _FALSE;
  if (endNode.nodeType == goog.dom.NodeType.ELEMENT) {
    child = endNode.childNodes[endOffset];
    endNode = child || endNode.lastChild || endNode;
    endOffset = 0;
    collapse = !child;
  }
  var rightRange = goog.dom.browserrange.IeRange.
      getBrowserRangeForNode_(endNode);
  rightRange.collapse(!collapse);
  if (endOffset) {
    rightRange.moveEnd('character', endOffset);
  }

  // Merge and return.
  leftRange.setEndPoint('EndToEnd', rightRange);
  return leftRange;
};


/**
 * Create a range object that selects the given node's text.
 * @param {Node} node The node to select.
 * @return {goog.dom.browserrange.IeRange} An IE range wrapper object.
 */
goog.dom.browserrange.IeRange.createFromNodeContents = function(node) {
  var range = new goog.dom.browserrange.IeRange(
      goog.dom.browserrange.IeRange.getBrowserRangeForNode_(node),
      goog.dom.getOwnerDocument(node));

  if (!goog.dom.browserrange.canContainRangeEndpoint(node)) {
    range.startNode_ = range.endNode_ = range.parentNode_ = node.parentNode;
    range.startOffset_ = goog.array.indexOf(range.parentNode_.childNodes, node);
    range.endOffset_ = range.startOffset_ + 1;
  } else {
    // Note(user) : Emulate the behavior of W3CRange - Go to deepest possible
    // range containers on both edges. It seems W3CRange did this to match the
    // IE behavior, and now it is a circle. Changing W3CRange may break clients
    // in all sorts of ways.
    var tempNode, leaf = node;
    while ((tempNode = leaf.firstChild) &&
           goog.dom.browserrange.canContainRangeEndpoint(tempNode)) {
      leaf = tempNode;
    }
    range.startNode_ = leaf;
    range.startOffset_ = 0;

    leaf = node;
    while ((tempNode = leaf.lastChild) &&
           goog.dom.browserrange.canContainRangeEndpoint(tempNode)) {
      leaf = tempNode;
    }
    range.endNode_ = leaf;
    range.endOffset_ = leaf.nodeType == goog.dom.NodeType.ELEMENT ?
                       leaf.childNodes.length : leaf.length;
    range.parentNode_ = node;
  }
  return range;
};


/**
 * Static method that returns the proper type of browser range.
 * @param {Node} startNode The node to start with.
 * @param {number} startOffset The offset within the start node.
 * @param {Node} endNode The node to end with.
 * @param {number} endOffset The offset within the end node.
 * @return {goog.dom.browserrange.AbstractRange} A wrapper object.
 */
goog.dom.browserrange.IeRange.createFromNodes = function(startNode,
    startOffset, endNode, endOffset) {
  var range = new goog.dom.browserrange.IeRange(
      goog.dom.browserrange.IeRange.getBrowserRangeForNodes_(startNode,
          startOffset, endNode, endOffset),
      goog.dom.getOwnerDocument(startNode));
  range.startNode_ = startNode;
  range.startOffset_ = startOffset;
  range.endNode_ = endNode;
  range.endOffset_ = endOffset;
  return range;
};


// Even though goog.dom.TextRange does similar caching to below, keeping these
// caches allows for better performance in the get*Offset methods.


/**
 * Lazy cache of the node containing the entire selection.
 * @type {Node}
 * @private
 */
goog.dom.browserrange.IeRange.prototype.parentNode_ = _NULL;


/**
 * Lazy cache of the node containing the start of the selection.
 * @type {Node}
 * @private
 */
goog.dom.browserrange.IeRange.prototype.startNode_ = _NULL;


/**
 * Lazy cache of the node containing the end of the selection.
 * @type {Node}
 * @private
 */
goog.dom.browserrange.IeRange.prototype.endNode_ = _NULL;


/**
 * Lazy cache of the offset in startNode_ where this range starts.
 * @type {number}
 * @private
 */
goog.dom.browserrange.IeRange.prototype.startOffset_ = -1;


/**
 * Lazy cache of the offset in endNode_ where this range ends.
 * @type {number}
 * @private
 */
goog.dom.browserrange.IeRange.prototype.endOffset_ = -1;


/**
 * @return {goog.dom.browserrange.IeRange} A clone of this range.
 */
goog.dom.browserrange.IeRange.prototype.clone = function() {
  var range = new goog.dom.browserrange.IeRange(
      this.range_.duplicate(), this.doc_);
  range.parentNode_ = this.parentNode_;
  range.startNode_ = this.startNode_;
  range.endNode_ = this.endNode_;
  return range;
};


/** @inheritDoc */
goog.dom.browserrange.IeRange.prototype.getBrowserRange = function() {
  return this.range_;
};


/**
 * Clears the cached values for containers.
 * @private
 */
goog.dom.browserrange.IeRange.prototype.clearCachedValues_ = function() {
  this.parentNode_ = this.startNode_ = this.endNode_ = _NULL;
  this.startOffset_ = this.endOffset_ = -1;
};


/** @inheritDoc */
goog.dom.browserrange.IeRange.prototype.getContainer = function() {
  if (!this.parentNode_) {
    var selectText = this.range_.text;

    // If the selection ends with spaces, we need to remove these to get the
    // parent container of only the real contents.  This is to get around IE's
    // inconsistency where it selects the spaces after a word when you double
    // click, but leaves out the spaces during execCommands.
    var range = this.range_.duplicate();
    // We can't use goog.string.trimRight, as that will remove other whitespace
    // too.
    var rightTrimmedSelectText = selectText.replace(/ +$/, '');
    var numSpacesAtEnd = selectText.length - rightTrimmedSelectText.length;
    if (numSpacesAtEnd) {
      range.moveEnd('character', -numSpacesAtEnd);
    }

    // Get the parent node.  This should be the end, but alas, it is not.
    var parent = range.parentElement();

    var htmlText = range.htmlText;
    var htmlTextLen = goog.string.stripNewlines(htmlText).length;
    if (this.isCollapsed() && htmlTextLen > 0) {
      return (this.parentNode_ = parent);
    }

    // Deal with selection bug where IE thinks one of the selection's children
    // is actually the selection's parent. Relies on the assumption that the
    // HTML text of the parent container is longer than the length of the
    // selection's HTML text.

    // Also note IE will sometimes insert \r and \n whitespace, which should be
    // disregarded. Otherwise the loop may run too long and return wrong parent
    while (htmlTextLen > goog.string.stripNewlines(parent.outerHTML).length) {
      parent = parent.parentNode;
    }

    // Deal with IE's selecting the outer tags when you double click
    // If the innerText is the same, then we just want the inner node
    while (parent.childNodes.length == 1 &&
           parent.firstChild &&     // FTDUEDTR-1212
           parent.innerText == goog.dom.browserrange.IeRange.getNodeText_(
               parent.firstChild)) {
      // A container should be an element which can have children or a text
      // node. Elements like IMG, BR, etc. can not be containers.
      if (!goog.dom.browserrange.canContainRangeEndpoint(parent.firstChild)) {
        break;
      }
      parent = parent.firstChild;
    }

    // If the selection is empty, we may need to do extra work to position it
    // properly.
    if (selectText.length == 0) {
      parent = this.findDeepestContainer_(parent);
    }

    this.parentNode_ = parent;
  }

  return this.parentNode_;
};


/**
 * Helper method to find the deepest parent for this range, starting
 * the search from {@code node}, which must contain the range.
 * @param {Node} node The node to start the search from.
 * @return {Node} The deepest parent for this range.
 * @private
 */
goog.dom.browserrange.IeRange.prototype.findDeepestContainer_ = function(node) {
  var childNodes = node.childNodes;
  for (var i = 0, len = childNodes.length; i < len; i++) {
    var child = childNodes[i];

    if (goog.dom.browserrange.canContainRangeEndpoint(child)) {
      var childRange =
          goog.dom.browserrange.IeRange.getBrowserRangeForNode_(child);
      var start = goog.dom.RangeEndpoint.START;
      var end = goog.dom.RangeEndpoint.END;

      // There are two types of erratic nodes where the range over node has
      // different htmlText than the node's outerHTML.
      // Case 1 - A node with magic &nbsp; child. In this case :
      //    nodeRange.htmlText shows &nbsp; ('<p>&nbsp;</p>), while
      //    node.outerHTML doesn't show the magic node (<p></p>).
      // Case 2 - Empty span. In this case :
      //    node.outerHTML shows '<span></span>'
      //    node.htmlText is just empty string ''.
      var isChildRangeErratic = (childRange.htmlText != child.outerHTML);

      // Moreover the inRange comparison fails only when the
      var isNativeInRangeErratic = this.isCollapsed() && isChildRangeErratic;

      // In case 2 mentioned above, childRange is also collapsed. So we need to
      // compare start of this range with both start and end of child range.
      var inChildRange = isNativeInRangeErratic ?
          (this.compareBrowserRangeEndpoints(childRange, start, start) >= 0 &&
              this.compareBrowserRangeEndpoints(childRange, start, end) <= 0) :
           this.range_.inRange(childRange);
      if (inChildRange) {
        return this.findDeepestContainer_(child);
      }
    }
  }

  return node;
};


/** @inheritDoc */
goog.dom.browserrange.IeRange.prototype.getStartNode = function() {
  if (!this.startNode_) {
    this.startNode_ = this.getEndpointNode_(goog.dom.RangeEndpoint.START);
    if (this.isCollapsed()) {
      this.endNode_ = this.startNode_;
    }
  }
  return this.startNode_;
};


/** @inheritDoc */
goog.dom.browserrange.IeRange.prototype.getStartOffset = function() {
  if (this.startOffset_ < 0) {
    this.startOffset_ = this.getOffset_(goog.dom.RangeEndpoint.START);
    if (this.isCollapsed()) {
      this.endOffset_ = this.startOffset_;
    }
  }
  return this.startOffset_;
};


/** @inheritDoc */
goog.dom.browserrange.IeRange.prototype.getEndNode = function() {
  if (this.isCollapsed()) {
    return this.getStartNode();
  }
  if (!this.endNode_) {
    this.endNode_ = this.getEndpointNode_(goog.dom.RangeEndpoint.END);
  }
  return this.endNode_;
};


/** @inheritDoc */
goog.dom.browserrange.IeRange.prototype.getEndOffset = function() {
  if (this.isCollapsed()) {
    return this.getStartOffset();
  }
  if (this.endOffset_ < 0) {
    this.endOffset_ = this.getOffset_(goog.dom.RangeEndpoint.END);
    if (this.isCollapsed()) {
      this.startOffset_ = this.endOffset_;
    }
  }
  return this.endOffset_;
};


/** @inheritDoc */
goog.dom.browserrange.IeRange.prototype.compareBrowserRangeEndpoints = function(
    range, thisEndpoint, otherEndpoint) {
  return this.range_.compareEndPoints(
      (thisEndpoint == goog.dom.RangeEndpoint.START ? 'Start' : 'End') +
      'To' +
      (otherEndpoint == goog.dom.RangeEndpoint.START ? 'Start' : 'End'),
      range);
};


/**
 * Recurses to find the correct node for the given endpoint.
 * @param {goog.dom.RangeEndpoint} endpoint The endpoint to get the node for.
 * @param {Node=} opt_node Optional node to start the search from.
 * @return {Node} The deepest node containing the endpoint.
 * @private
 */
goog.dom.browserrange.IeRange.prototype.getEndpointNode_ = function(endpoint,
    opt_node) {

  /** @type {Node} */
  var node = opt_node || this.getContainer();

  // If we're at a leaf in the DOM, we're done.
  if (!node || !node.firstChild) {
    return node;
  }

  var start = goog.dom.RangeEndpoint.START, end = goog.dom.RangeEndpoint.END;
  var isStartEndpoint = endpoint == start;

  // Find the first/last child that overlaps the selection.
  // NOTE(user) : One of the children can be the magic &nbsp; node. This
  // node will have only nodeType property as valid and accessible. All other
  // dom related properties like ownerDocument, parentNode, nextSibling etc
  // cause error when accessed. Therefore use the for-loop on childNodes to
  // iterate.
  for (var j = 0, length = node.childNodes.length; j < length; j++) {
    var i = isStartEndpoint ? j : length - j - 1;
    var child = node.childNodes[i];
    var childRange;
    try {
      childRange = goog.dom.browserrange.createRangeFromNodeContents(child);
    } catch (e) {
      // If the child is the magic &nbsp; node, then the above will throw
      // error. The magic node exists only when editing using keyboard, so can
      // not add any unit test.
      continue;
    }
    var ieRange = childRange.getBrowserRange();

    // Case 1 : Finding end points when this range is collapsed.
    // Note that in case of collapsed range, getEnd{Node,Offset} call
    // getStart{Node,Offset}.
    if (this.isCollapsed()) {
      // Handle situations where caret is not in a text node. In such cases,
      // the adjacent child won't be a valid range endpoint container.
      if (!goog.dom.browserrange.canContainRangeEndpoint(child)) {
        // The following handles a scenario like <div><BR>[caret]<BR></div>,
        // where point should be (div, 1).
        if (this.compareBrowserRangeEndpoints(ieRange, start, start) == 0) {
          this.startOffset_ = this.endOffset_ = i;
          return node;
        }
      } else if (childRange.containsRange(this)) {
        // For collapsed range, we should invert the containsRange check with
        // childRange.
        return this.getEndpointNode_(endpoint, child);
      }

    // Case 2 - The first child encountered to have overlap this range is
    // contained entirely in this range.
    } else if (this.containsRange(childRange)) {
      // If it is an element which can not be a range endpoint container, the
      // current child offset can be used to deduce the endpoint offset.
      if (!goog.dom.browserrange.canContainRangeEndpoint(child)) {

        // Container can't be any deeper, so current node is the container.
        if (isStartEndpoint) {
          this.startOffset_ = i;
        } else {
          this.endOffset_ = i + 1;
        }
        return node;
      }

      // If child can contain range endpoints, recurse inside this child.
      while(child.childNodes.length == 1) {
        child = child.firstChild;
      }
      return this.getEndpointNode_(endpoint, child);

    // Case 3 - Partial non-adjacency overlap.
    } else if (this.compareBrowserRangeEndpoints(ieRange, start, end) < 0 &&
               this.compareBrowserRangeEndpoints(ieRange, end, start) > 0) {
      // If this child overlaps the selection partially, recurse down to find
      // the first/last child the next level down that overlaps the selection
      // completely. We do not consider edge-adjacency (== 0) as overlap.
    	
      while(child.childNodes.length == 1 && child.firstChild) {
        child = child.firstChild;
      }
      return this.getEndpointNode_(endpoint, child);
    }

  }

  // None of the children of this node overlapped the selection, that means
  // the selection starts/ends in this node directly.
  return node;
};


/**
 * Compares one endpoint of this range with the endpoint of a node.
 * For internal methods, we should prefer this method to containsNode.
 * containsNode has a lot of _FALSE negatives when we're dealing with
 * {@code <br>} tags.
 *
 * @param {Node} node The node to compare against.
 * @param {goog.dom.RangeEndpoint} thisEndpoint The endpoint of this range
 *     to compare with.
 * @param {goog.dom.RangeEndpoint} otherEndpoint The endpoint of the node
 *     to compare with.
 * @return {number} 0 if the endpoints are equal, negative if this range
 *     endpoint comes before the other node endpoint, and positive otherwise.
 * @private
 */
goog.dom.browserrange.IeRange.prototype.compareNodeEndpoints_ =
    function(node, thisEndpoint, otherEndpoint) {
  return this.range_.compareEndPoints(
      (thisEndpoint == goog.dom.RangeEndpoint.START ? 'Start' : 'End') +
      'To' +
      (otherEndpoint == goog.dom.RangeEndpoint.START ? 'Start' : 'End'),
      goog.dom.browserrange.createRangeFromNodeContents(node).
          getBrowserRange());
};


/**
 * Returns the offset into the start/end container.
 * @param {goog.dom.RangeEndpoint} endpoint The endpoint to get the offset for.
 * @param {Node=} opt_container The container to get the offset relative to.
 *     Defaults to the value returned by getStartNode/getEndNode.
 * @return {number} The offset.
 * @private
 */
goog.dom.browserrange.IeRange.prototype.getOffset_ = function(endpoint,
    opt_container) {
  var isStartEndpoint = endpoint == goog.dom.RangeEndpoint.START;
  var container = opt_container ||
      (isStartEndpoint ? this.getStartNode() : this.getEndNode());

  if (container.nodeType == goog.dom.NodeType.ELEMENT) {
    // Find the first/last child that overlaps the selection
    var children = container.childNodes;
    var len = children.length;
    var edge = isStartEndpoint ? 0 : len - 1;
    var sign = isStartEndpoint ? 1 : - 1;

    // We find the index in the child array of the endpoint of the selection.
    for (var i = edge; i >= 0 && i < len; i += sign) {
      var child = children[i];
      // Ignore the child nodes, which could be end point containers.
      if (goog.dom.browserrange.canContainRangeEndpoint(child)) {
        continue;
      }
      // Stop looping when we reach the edge of the selection.
      var endPointCompare =
          this.compareNodeEndpoints_(child, endpoint, endpoint);
      if (endPointCompare == 0) {
        return isStartEndpoint ? i : i + 1;
      }
    }

    // When starting from the end in an empty container, we erroneously return
    // -1: fix this to return 0.
    return i == -1 ? 0 : i;
  } else {
    // Get a temporary range object.
    var range = this.range_.duplicate();

    // Create a range that selects the entire container.
    var nodeRange = goog.dom.browserrange.IeRange.getBrowserRangeForNode_(
        container);

    // Now, intersect our range with the container range - this should give us
    // the part of our selection that is in the container.
    range.setEndPoint(isStartEndpoint ? 'EndToEnd' : 'StartToStart', nodeRange);

    var rangeLength = range.text.length;
    return isStartEndpoint ? container.length - rangeLength : rangeLength;
  }
};


/**
 * Returns the text of the given node.  Uses IE specific properties.
 * @param {Node} node The node to retrieve the text of.
 * @return {string} The node's text.
 * @private
 */
goog.dom.browserrange.IeRange.getNodeText_ = function(node) {
  return node.nodeType == goog.dom.NodeType.TEXT ?
         node.nodeValue : node.innerText;
};


/**
 * Tests whether this range is valid (i.e. whether its endpoints are still in
 * the document).  A range becomes invalid when, after this object was created,
 * either one or both of its endpoints are removed from the document.  Use of
 * an invalid range can lead to runtime errors, particularly in IE.
 * @return {boolean} Whether the range is valid.
 */
goog.dom.browserrange.IeRange.prototype.isRangeInDocument = function() {
  var range = this.doc_.body.createTextRange();
  range.moveToElementText(this.doc_.body);

  return this.containsRange(
      new goog.dom.browserrange.IeRange(range, this.doc_), _TRUE);
};


/** @inheritDoc */
goog.dom.browserrange.IeRange.prototype.isCollapsed = function() {
  // Note(user) : The earlier implementation used (range.text == ''), but this
  // fails when (range.htmlText == '<br>')
  // Alternative: this.range_.htmlText == '';
  return this.range_.compareEndPoints('StartToEnd', this.range_) == 0;
};


/** @inheritDoc */
goog.dom.browserrange.IeRange.prototype.getText = function() {
  return this.range_.text;
};


/** @inheritDoc */
goog.dom.browserrange.IeRange.prototype.getValidHtml = function() {
  return this.range_.htmlText;
};


// SELECTION MODIFICATION


/** @inheritDoc */
goog.dom.browserrange.IeRange.prototype.select = function(opt_reverse) {
  // IE doesn't support programmatic reversed selections.
  this.range_.select();
};


/** @inheritDoc */
goog.dom.browserrange.IeRange.prototype.removeContents = function() {
  if (this.range_.htmlText) {
    // Store some before-removal state.
    var startNode = this.getStartNode();
    var endNode = this.getEndNode();
    var oldText = this.range_.text;

    // IE sometimes deletes nodes unrelated to the selection.  This trick fixes
    // that problem most of the time.  Even though it looks like a no-op, it is
    // somehow changing IE's internal state such that empty unrelated nodes are
    // no longer deleted.
    var clone = this.range_.duplicate();
    clone.moveStart('character', 1);
    clone.moveStart('character', -1);

    // However, sometimes when the range is empty, moving the start back and
    // forth ends up changing the range.  This indicates a case we need to
    // handle manually.
    if (clone.text != oldText) {
      // Delete all nodes entirely contained in the range.
      var iter = new goog.dom.NodeIterator(startNode, _FALSE, _TRUE);
      var toDelete = [];
      goog.iter.forEach(iter, function(node) {
        // Any text node we encounter here is by definition contained entirely
        // in the range.
        if (node.nodeType != goog.dom.NodeType.TEXT &&
            this.containsNode(node)) {
          toDelete.push(node);
          iter.skipTag();
        }
        if (node == endNode) {
          throw goog.iter.StopIteration;
        }
      });
      this.collapse(_TRUE);
      goog.array.forEach(toDelete, goog.dom.removeNode);

      this.clearCachedValues_();
      return;
    }

    // Outside of the unfortunate cases where we have to handle deletion
    // manually, we can use the browser's native deletion code.
    this.range_ = clone;
    this.range_.text = '';
    this.clearCachedValues_();

    // Unfortunately, when deleting a portion of a single text node, IE creates
    // an extra text node unlike other browsers which just change the text in
    // the node.  We normalize for that behavior here, making IE behave like all
    // the other browsers.
    var newStartNode = this.getStartNode();
    var newStartOffset = this.getStartOffset();
    /** @preserveTry */
    try {
      var sibling = startNode.nextSibling;
      if (startNode == endNode && startNode.parentNode &&
          startNode.nodeType == goog.dom.NodeType.TEXT &&
          sibling && sibling.nodeType == goog.dom.NodeType.TEXT) {
        startNode.nodeValue += sibling.nodeValue;
        goog.dom.removeNode(sibling);

        // Make sure to reselect the appropriate position.
        this.range_ = goog.dom.browserrange.IeRange.getBrowserRangeForNode_(
            newStartNode);
        this.range_.move('character', newStartOffset);
        this.clearCachedValues_();
      }
    } catch (e) {
      // IE throws errors on orphaned nodes.
    }
  }
};


/**
 * @param {TextRange} range The range to get a dom helper for.
 * @return {goog.dom.DomHelper} A dom helper for the document the range
 *     resides in.
 * @private
 */
goog.dom.browserrange.IeRange.getDomHelper_ = function(range) {
  return goog.dom.getDomHelper(range.parentElement());
};


/**
 * Pastes the given element into the given range, returning the resulting
 * element.
 * @param {TextRange} range The range to paste into.
 * @param {Element} element The node to insert a copy of.
 * @param {goog.dom.DomHelper=} opt_domHelper DOM helper object for the document
 *     the range resides in.
 * @return {Element} The resulting copy of element.
 * @private
 */
goog.dom.browserrange.IeRange.pasteElement_ = function(range, element,
    opt_domHelper) {
  opt_domHelper = opt_domHelper || goog.dom.browserrange.IeRange.getDomHelper_(
      range);

  // Make sure the node has a unique id.
  var id;
  var originalId = id = element.id;
  if (!id) {
    id = element.id = goog.string.createUniqueString();
  }

  // Insert (a clone of) the node.
  range.pasteHTML(element.outerHTML);

  // Pasting the outerHTML of the modified element into the document creates
  // a clone of the element argument.  We want to return a reference to the
  // clone, not the original.  However we need to remove the temporary ID
  // first.
  element = opt_domHelper.getElement(id);

  // If element is null here, we failed.
  if (element) {
    if (!originalId) {
      element.removeAttribute('id');
    }
  }

  return element;
};


/** @inheritDoc */
goog.dom.browserrange.IeRange.prototype.surroundContents = function(element) {
  // Make sure the element is detached from the document.
  goog.dom.removeNode(element);

  // IE more or less guarantees that range.htmlText is well-formed & valid.
  element.innerHTML = this.range_.htmlText;
  element = goog.dom.browserrange.IeRange.pasteElement_(this.range_, element);

  // If element is null here, we failed.
  if (element) {
    this.range_.moveToElementText(element);
  }

  this.clearCachedValues_();

  return element;
};


/**
 * Internal handler for inserting a node.
 * @param {TextRange} clone A clone of this range's browser range object.
 * @param {Node} node The node to insert.
 * @param {boolean} before Whether to insert the node before or after the range.
 * @param {goog.dom.DomHelper=} opt_domHelper The dom helper to use.
 * @return {Node} The resulting copy of node.
 * @private
 */
goog.dom.browserrange.IeRange.insertNode_ = function(clone, node,
    before, opt_domHelper) {
  // Get a DOM helper.
  opt_domHelper = opt_domHelper || goog.dom.browserrange.IeRange.getDomHelper_(
      clone);

  // If it's not an element, wrap it in one.
  var isNonElement;
  if (node.nodeType != goog.dom.NodeType.ELEMENT) {
    isNonElement = _TRUE;
    node = opt_domHelper.createDom(goog.dom.TagName.DIV, _NULL, node);
  }

  clone.collapse(before);
  node = goog.dom.browserrange.IeRange.pasteElement_(clone,
      /** @type {Element} */ (node), opt_domHelper);

  // If we didn't want an element, unwrap the element and return the node.
  if (isNonElement) {
    // pasteElement_() may have returned a copy of the wrapper div, and the
    // node it wraps could also be a new copy. So we must extract that new
    // node from the new wrapper.
    var newNonElement = node.firstChild;
    opt_domHelper.flattenElement(node);
    node = newNonElement;
  }

  return node;
};


/** @inheritDoc */
goog.dom.browserrange.IeRange.prototype.insertNode = function(node, before) {
  var output = goog.dom.browserrange.IeRange.insertNode_(
      this.range_.duplicate(), node, before);
  this.clearCachedValues_();
  return output;
};


/** @inheritDoc */
goog.dom.browserrange.IeRange.prototype.surroundWithNodes = function(
    startNode, endNode) {
  var clone1 = this.range_.duplicate();
  var clone2 = this.range_.duplicate();
  goog.dom.browserrange.IeRange.insertNode_(clone1, startNode, _TRUE);
  goog.dom.browserrange.IeRange.insertNode_(clone2, endNode, _FALSE);

  this.clearCachedValues_();
};


/** @inheritDoc */
goog.dom.browserrange.IeRange.prototype.collapse = function(toStart) {
  this.range_.collapse(toStart);

  if (toStart) {
    this.endNode_ = this.startNode_;
    this.endOffset_ = this.startOffset_;
  } else {
    this.startNode_ = this.endNode_;
    this.startOffset_ = this.endOffset_;
  }
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the Gecko specific range wrapper.  Inherits most
 * functionality from W3CRange, but adds exceptions as necessary.
 *
 * DO NOT USE THIS FILE DIRECTLY.  Use goog.dom.Range instead.
 *
 * @author robbyw@google.com (Robby Walker)
 */


goog.provide('goog.dom.browserrange.GeckoRange');

//goog.require('goog.dom.browserrange.W3cRange');



/**
 * The constructor for Gecko specific browser ranges.
 * @param {Range} range The range object.
 * @constructor
 * @extends {goog.dom.browserrange.W3cRange}
 */
goog.dom.browserrange.GeckoRange = function(range) {
  goog.dom.browserrange.W3cRange.call(this, range);
};
goog.inherits(goog.dom.browserrange.GeckoRange, goog.dom.browserrange.W3cRange);


/**
 * Creates a range object that selects the given node's text.
 * @param {Node} node The node to select.
 * @return {goog.dom.browserrange.GeckoRange} A Gecko range wrapper object.
 */
goog.dom.browserrange.GeckoRange.createFromNodeContents = function(node) {
  return new goog.dom.browserrange.GeckoRange(
      goog.dom.browserrange.W3cRange.getBrowserRangeForNode(node));
};


/**
 * Creates a range object that selects between the given nodes.
 * @param {Node} startNode The node to start with.
 * @param {number} startOffset The offset within the node to start.
 * @param {Node} endNode The node to end with.
 * @param {number} endOffset The offset within the node to end.
 * @return {goog.dom.browserrange.GeckoRange} A wrapper object.
 */
goog.dom.browserrange.GeckoRange.createFromNodes = function(startNode,
    startOffset, endNode, endOffset) {
  return new goog.dom.browserrange.GeckoRange(
      goog.dom.browserrange.W3cRange.getBrowserRangeForNodes(startNode,
          startOffset, endNode, endOffset));
};


/** @inheritDoc */
goog.dom.browserrange.GeckoRange.prototype.selectInternal = function(
    selection, reversed) {
  var anchorNode = reversed ? this.getEndNode() : this.getStartNode();
  var anchorOffset = reversed ? this.getEndOffset() : this.getStartOffset();
  var focusNode = reversed ? this.getStartNode() : this.getEndNode();
  var focusOffset = reversed ? this.getStartOffset() : this.getEndOffset();

  selection.collapse(anchorNode, anchorOffset);
  if (anchorNode != focusNode || anchorOffset != focusOffset) {
    selection.extend(focusNode, focusOffset);
  }
};
// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the Opera specific range wrapper.  Inherits most
 * functionality from W3CRange, but adds exceptions as necessary.
 *
 * DO NOT USE THIS FILE DIRECTLY.  Use goog.dom.Range instead.
 *
 */


goog.provide('goog.dom.browserrange.OperaRange');

//goog.require('goog.dom.browserrange.W3cRange');



/**
 * The constructor for Opera specific browser ranges.
 * @param {Range} range The range object.
 * @constructor
 * @extends {goog.dom.browserrange.W3cRange}
 */
goog.dom.browserrange.OperaRange = function(range) {
  goog.dom.browserrange.W3cRange.call(this, range);
};
goog.inherits(goog.dom.browserrange.OperaRange, goog.dom.browserrange.W3cRange);


/**
 * Creates a range object that selects the given node's text.
 * @param {Node} node The node to select.
 * @return {goog.dom.browserrange.OperaRange} A Opera range wrapper object.
 */
goog.dom.browserrange.OperaRange.createFromNodeContents = function(node) {
  return new goog.dom.browserrange.OperaRange(
      goog.dom.browserrange.W3cRange.getBrowserRangeForNode(node));
};


/**
 * Creates a range object that selects between the given nodes.
 * @param {Node} startNode The node to start with.
 * @param {number} startOffset The offset within the node to start.
 * @param {Node} endNode The node to end with.
 * @param {number} endOffset The offset within the node to end.
 * @return {goog.dom.browserrange.OperaRange} A wrapper object.
 */
goog.dom.browserrange.OperaRange.createFromNodes = function(startNode,
    startOffset, endNode, endOffset) {
  return new goog.dom.browserrange.OperaRange(
      goog.dom.browserrange.W3cRange.getBrowserRangeForNodes(startNode,
          startOffset, endNode, endOffset));
};


/** @inheritDoc */
goog.dom.browserrange.OperaRange.prototype.selectInternal = function(
    selection, reversed) {
  // Avoid using addRange as we have to removeAllRanges first, which
  // blurs editable fields in Opera.
  selection.collapse(this.getStartNode(), this.getStartOffset());
  if (this.getEndNode() != this.getStartNode() ||
      this.getEndOffset() != this.getStartOffset()) {
    selection.extend(this.getEndNode(), this.getEndOffset());
  }
  // This can happen if the range isn't in an editable field.
  if (selection.rangeCount == 0) {
    selection.addRange(this.range_);
  }
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the browser range namespace and interface, as
 * well as several useful utility functions.
 *
 * DO NOT USE THIS FILE DIRECTLY.  Use goog.dom.Range instead.
 *
 * @author robbyw@google.com (Robby Walker)
 * @author ojan@google.com (Ojan Vafai)
 * @author jparent@google.com (Julie Parent)
 *
 * @supported IE6, IE7, FF1.5+, Safari.
 */


goog.provide('goog.dom.browserrange');
goog.provide('goog.dom.browserrange.Error');

//goog.require('goog.dom');
//goog.require('goog.dom.browserrange.GeckoRange');
//goog.require('goog.dom.browserrange.IeRange');
//goog.require('goog.dom.browserrange.OperaRange');
//goog.require('goog.dom.browserrange.W3cRange');
//goog.require('goog.dom.browserrange.WebKitRange');
//goog.require('goog.userAgent');


/**
 * Common error constants.
 * @enum {string}
 */
goog.dom.browserrange.Error = {
  NOT_IMPLEMENTED: 'Not Implemented'
};


// NOTE(robbyw): While it would be nice to eliminate the duplicate switches
//               below, doing so uncovers bugs in the JsCompiler in which
//               necessary code is stripped out.


/**
 * Static method that returns the proper type of browser range.
 * @param {Range|TextRange} range A browser range object.
 * @return {goog.dom.browserrange.AbstractRange} A wrapper object.
 */
goog.dom.browserrange.createRange = function(range) {
  if (goog.userAgent.IE && !goog.userAgent.isDocumentMode(9)) {
    return new goog.dom.browserrange.IeRange(
        /** @type {TextRange} */ (range),
        goog.dom.getOwnerDocument(range.parentElement()));
  } else if (goog.userAgent.WEBKIT) {
    return new goog.dom.browserrange.WebKitRange(
        /** @type {Range} */ (range));
  } else if (goog.userAgent.GECKO) {
    return new goog.dom.browserrange.GeckoRange(
        /** @type {Range} */ (range));
  } else if (goog.userAgent.OPERA) {
    return new goog.dom.browserrange.OperaRange(
        /** @type {Range} */ (range));
  } else {
    // Default other browsers, including Opera, to W3c ranges.
    return new goog.dom.browserrange.W3cRange(
        /** @type {Range} */ (range));
  }
};


/**
 * Static method that returns the proper type of browser range.
 * @param {Node} node The node to select.
 * @return {goog.dom.browserrange.AbstractRange} A wrapper object.
 */
goog.dom.browserrange.createRangeFromNodeContents = function(node) {
  if (goog.userAgent.IE && !goog.userAgent.isDocumentMode(9)) {
    return goog.dom.browserrange.IeRange.createFromNodeContents(node);
  } else if (goog.userAgent.WEBKIT) {
    return goog.dom.browserrange.WebKitRange.createFromNodeContents(node);
  } else if (goog.userAgent.GECKO) {
    return goog.dom.browserrange.GeckoRange.createFromNodeContents(node);
  } else if (goog.userAgent.OPERA) {
    return goog.dom.browserrange.OperaRange.createFromNodeContents(node);
  } else {
    // Default other browsers to W3c ranges.
    return goog.dom.browserrange.W3cRange.createFromNodeContents(node);
  }
};


/**
 * Static method that returns the proper type of browser range.
 * @param {Node} startNode The node to start with.
 * @param {number} startOffset The offset within the node to start.  This is
 *     either the index into the childNodes array for element startNodes or
 *     the index into the character array for text startNodes.
 * @param {Node} endNode The node to end with.
 * @param {number} endOffset The offset within the node to end.  This is
 *     either the index into the childNodes array for element endNodes or
 *     the index into the character array for text endNodes.
 * @return {goog.dom.browserrange.AbstractRange} A wrapper object.
 */
goog.dom.browserrange.createRangeFromNodes = function(startNode, startOffset,
    endNode, endOffset) {
  if (goog.userAgent.IE && !goog.userAgent.isDocumentMode(9)) {
    return goog.dom.browserrange.IeRange.createFromNodes(startNode, startOffset,
        endNode, endOffset);
  } else if (goog.userAgent.WEBKIT) {
    return goog.dom.browserrange.WebKitRange.createFromNodes(startNode,
        startOffset, endNode, endOffset);
  } else if (goog.userAgent.GECKO) {
    return goog.dom.browserrange.GeckoRange.createFromNodes(startNode,
        startOffset, endNode, endOffset);
  } else if (goog.userAgent.OPERA) {
    return goog.dom.browserrange.OperaRange.createFromNodes(startNode,
        startOffset, endNode, endOffset);
  } else {
    // Default other browsers to W3c ranges.
    return goog.dom.browserrange.W3cRange.createFromNodes(startNode,
        startOffset, endNode, endOffset);
  }
};


/**
 * Tests whether the given node can contain a range end point.
 * @param {Node} node The node to check.
 * @return {boolean} Whether the given node can contain a range end point.
 */
goog.dom.browserrange.canContainRangeEndpoint = function(node) {
  // NOTE(user, bloom): This is not complete, as divs with style -
  // 'display:inline-block' or 'position:absolute' can also not contain range
  // endpoints. A more complete check is to see if that element can be partially
  // selected (can be container) or not.
  return goog.dom.canHaveChildren(node) ||
      node.nodeType == goog.dom.NodeType.TEXT;
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for working with text ranges in HTML documents.
 *
 * @author robbyw@google.com (Robby Walker)
 * @author ojan@google.com (Ojan Vafai)
 * @author jparent@google.com (Julie Parent)
 */


goog.provide('goog.dom.TextRange');

//goog.require('goog.array');
//goog.require('goog.dom');
//goog.require('goog.dom.AbstractRange');
//goog.require('goog.dom.RangeType');
//goog.require('goog.dom.SavedRange');
//goog.require('goog.dom.TagName');
//goog.require('goog.dom.TextRangeIterator');
//goog.require('goog.dom.browserrange');
//goog.require('goog.string');
//goog.require('goog.userAgent');



/**
 * Create a new text selection with no properties.  Do not use this constructor:
 * use one of the goog.dom.Range.createFrom* methods instead.
 * @constructor
 * @extends {goog.dom.AbstractRange}
 */
goog.dom.TextRange = function() {
};
goog.inherits(goog.dom.TextRange, goog.dom.AbstractRange);


/**
 * Create a new range wrapper from the given browser range object.  Do not use
 * this method directly - please use goog.dom.Range.createFrom* instead.
 * @param {Range|TextRange} range The browser range object.
 * @param {boolean=} opt_isReversed Whether the focus node is before the anchor
 *     node.
 * @return {goog.dom.TextRange} A range wrapper object.
 */
goog.dom.TextRange.createFromBrowserRange = function(range, opt_isReversed) {
  return goog.dom.TextRange.createFromBrowserRangeWrapper_(
      goog.dom.browserrange.createRange(range), opt_isReversed);
};


/**
 * Create a new range wrapper from the given browser range wrapper.
 * @param {goog.dom.browserrange.AbstractRange} browserRange The browser range
 *     wrapper.
 * @param {boolean=} opt_isReversed Whether the focus node is before the anchor
 *     node.
 * @return {goog.dom.TextRange} A range wrapper object.
 * @private
 */
goog.dom.TextRange.createFromBrowserRangeWrapper_ = function(browserRange,
    opt_isReversed) {
  var range = new goog.dom.TextRange();

  // Initialize the range as a browser range wrapper type range.
  range.browserRangeWrapper_ = browserRange;
  range.isReversed_ = !!opt_isReversed;

  return range;
};


/**
 * Create a new range wrapper that selects the given node's text.  Do not use
 * this method directly - please use goog.dom.Range.createFrom* instead.
 * @param {Node} node The node to select.
 * @param {boolean=} opt_isReversed Whether the focus node is before the anchor
 *     node.
 * @return {goog.dom.TextRange} A range wrapper object.
 */
goog.dom.TextRange.createFromNodeContents = function(node, opt_isReversed) {
  return goog.dom.TextRange.createFromBrowserRangeWrapper_(
      goog.dom.browserrange.createRangeFromNodeContents(node),
      opt_isReversed);
};


/**
 * Create a new range wrapper that selects the area between the given nodes,
 * accounting for the given offsets.  Do not use this method directly - please
 * use goog.dom.Range.createFrom* instead.
 * @param {Node} anchorNode The node to start with.
 * @param {number} anchorOffset The offset within the node to start.
 * @param {Node} focusNode The node to end with.
 * @param {number} focusOffset The offset within the node to end.
 * @return {goog.dom.TextRange} A range wrapper object.
 */
goog.dom.TextRange.createFromNodes = function(anchorNode, anchorOffset,
    focusNode, focusOffset) {
  var range = new goog.dom.TextRange();
  range.isReversed_ = goog.dom.Range.isReversed(anchorNode, anchorOffset,
      focusNode, focusOffset);

  // Avoid selecting BRs directly
  if (anchorNode.tagName == 'BR') {
    var parent = anchorNode.parentNode;
    anchorOffset = goog.array.indexOf(parent.childNodes, anchorNode);
    anchorNode = parent;
  }

  if (focusNode.tagName == 'BR') {
    var parent = focusNode.parentNode;
    focusOffset = goog.array.indexOf(parent.childNodes, focusNode);
    focusNode = parent;
  }

  // Initialize the range as a W3C style range.
  if (range.isReversed_) {
    range.startNode_ = focusNode;
    range.startOffset_ = focusOffset;
    range.endNode_ = anchorNode;
    range.endOffset_ = anchorOffset;
  } else {
    range.startNode_ = anchorNode;
    range.startOffset_ = anchorOffset;
    range.endNode_ = focusNode;
    range.endOffset_ = focusOffset;
  }

  return range;
};


// Representation 1: a browser range wrapper.


/**
 * The browser specific range wrapper.  This can be null if one of the other
 * representations of the range is specified.
 * @type {goog.dom.browserrange.AbstractRange?}
 * @private
 */
goog.dom.TextRange.prototype.browserRangeWrapper_ = _NULL;


// Representation 2: two endpoints specified as nodes + offsets


/**
 * The start node of the range.  This can be null if one of the other
 * representations of the range is specified.
 * @type {Node}
 * @private
 */
goog.dom.TextRange.prototype.startNode_ = _NULL;


/**
 * The start offset of the range.  This can be null if one of the other
 * representations of the range is specified.
 * @type {?number}
 * @private
 */
goog.dom.TextRange.prototype.startOffset_ = _NULL;


/**
 * The end node of the range.  This can be null if one of the other
 * representations of the range is specified.
 * @type {Node}
 * @private
 */
goog.dom.TextRange.prototype.endNode_ = _NULL;


/**
 * The end offset of the range.  This can be null if one of the other
 * representations of the range is specified.
 * @type {?number}
 * @private
 */
goog.dom.TextRange.prototype.endOffset_ = _NULL;


/**
 * Whether the focus node is before the anchor node.
 * @type {boolean}
 * @private
 */
goog.dom.TextRange.prototype.isReversed_ = _FALSE;


// Method implementations


/**
 * @return {goog.dom.TextRange} A clone of this range.
 */
goog.dom.TextRange.prototype.clone = function() {
  var range = new goog.dom.TextRange();
  range.browserRangeWrapper_ = this.browserRangeWrapper_;
  range.startNode_ = this.startNode_;
  range.startOffset_ = this.startOffset_;
  range.endNode_ = this.endNode_;
  range.endOffset_ = this.endOffset_;
  range.isReversed_ = this.isReversed_;

  return range;
};


/** @inheritDoc */
goog.dom.TextRange.prototype.getType = function() {
  return goog.dom.RangeType.TEXT;
};


/** @inheritDoc */
goog.dom.TextRange.prototype.getBrowserRangeObject = function() {
  return this.getBrowserRangeWrapper_().getBrowserRange();
};


/** @inheritDoc */
goog.dom.TextRange.prototype.setBrowserRangeObject = function(nativeRange) {
  // Test if it's a control range by seeing if a control range only method
  // exists.
  if (goog.dom.AbstractRange.isNativeControlRange(nativeRange)) {
    return _FALSE;
  }
  this.browserRangeWrapper_ = goog.dom.browserrange.createRange(
      nativeRange);
  this.clearCachedValues_();
  return _TRUE;
};


/**
 * Clear all cached values.
 * @private
 */
goog.dom.TextRange.prototype.clearCachedValues_ = function() {
  this.startNode_ = this.startOffset_ = this.endNode_ = this.endOffset_ = _NULL;
};


/** @inheritDoc */
goog.dom.TextRange.prototype.getTextRangeCount = function() {
  return 1;
};


/** @inheritDoc */
goog.dom.TextRange.prototype.getTextRange = function(i) {
  return this;
};


/**
 * @return {goog.dom.browserrange.AbstractRange} The range wrapper object.
 * @private
 */
goog.dom.TextRange.prototype.getBrowserRangeWrapper_ = function() {
  return this.browserRangeWrapper_ ||
      (this.browserRangeWrapper_ = goog.dom.browserrange.createRangeFromNodes(
          this.getStartNode(), this.getStartOffset(),
          this.getEndNode(), this.getEndOffset()));
};


/** @inheritDoc */
goog.dom.TextRange.prototype.getContainer = function() {
  return this.getBrowserRangeWrapper_().getContainer();
};


/** @inheritDoc */
goog.dom.TextRange.prototype.getStartNode = function() {
  return this.startNode_ ||
      (this.startNode_ = this.getBrowserRangeWrapper_().getStartNode());
};


/** @inheritDoc */
goog.dom.TextRange.prototype.getStartOffset = function() {
  return this.startOffset_ != _NULL ? this.startOffset_ :
      (this.startOffset_ = this.getBrowserRangeWrapper_().getStartOffset());
};


/** @inheritDoc */
goog.dom.TextRange.prototype.getEndNode = function() {
  return this.endNode_ ||
      (this.endNode_ = this.getBrowserRangeWrapper_().getEndNode());
};


/** @inheritDoc */
goog.dom.TextRange.prototype.getEndOffset = function() {
  return this.endOffset_ != _NULL ? this.endOffset_ :
      (this.endOffset_ = this.getBrowserRangeWrapper_().getEndOffset());
};


/**
 * Moves a TextRange to the provided nodes and offsets.
 * @param {Node} startNode The node to start with.
 * @param {number} startOffset The offset within the node to start.
 * @param {Node} endNode The node to end with.
 * @param {number} endOffset The offset within the node to end.
 * @param {boolean} isReversed Whether the range is reversed.
 */
goog.dom.TextRange.prototype.moveToNodes = function(startNode, startOffset,
                                                    endNode, endOffset,
                                                    isReversed) {
  this.startNode_ = startNode;
  this.startOffset_ = startOffset;
  this.endNode_ = endNode;
  this.endOffset_ = endOffset;
  this.isReversed_ = isReversed;
  this.browserRangeWrapper_ = _NULL;
};


/** @inheritDoc */
goog.dom.TextRange.prototype.isReversed = function() {
  return this.isReversed_;
};


/** @inheritDoc */
goog.dom.TextRange.prototype.containsRange = function(otherRange,
                                                      opt_allowPartial) {
  var otherRangeType = otherRange.getType();
  if (otherRangeType == goog.dom.RangeType.TEXT) {
    return this.getBrowserRangeWrapper_().containsRange(
        otherRange.getBrowserRangeWrapper_(), opt_allowPartial);
  } else if (otherRangeType == goog.dom.RangeType.CONTROL) {
    var elements = otherRange.getElements();
    var fn = opt_allowPartial ? goog.array.some : goog.array.every;
    return fn(elements, function(el) {
      return this.containsNode(el, opt_allowPartial);
    }, this);
  }
  return _FALSE;
};


/**
 * Tests if the given node is in a document.
 * @param {Node} node The node to check.
 * @return {boolean} Whether the given node is in the given document.
 */
goog.dom.TextRange.isAttachedNode = function(node) {
  if (goog.userAgent.IE && !goog.userAgent.isDocumentMode(9)) {
    var returnValue = _FALSE;
    /** @preserveTry */
    try {
      returnValue = node.parentNode;
    } catch (e) {
      // IE sometimes throws Invalid Argument errors when a node is detached.
      // Note: trying to return a value from the above try block can cause IE
      // to crash.  It is necessary to use the local returnValue
    }
    return !!returnValue;
  } else {
    return goog.dom.contains(node.ownerDocument.body, node);
  }
};


/** @inheritDoc */
goog.dom.TextRange.prototype.isRangeInDocument = function() {
  // Ensure any cached nodes are in the document.  IE also allows ranges to
  // become detached, so we check if the range is still in the document as
  // well for IE.
  return (!this.startNode_ ||
          goog.dom.TextRange.isAttachedNode(this.startNode_)) &&
         (!this.endNode_ ||
          goog.dom.TextRange.isAttachedNode(this.endNode_)) &&
         (!(goog.userAgent.IE && !goog.userAgent.isDocumentMode(9)) ||
          this.getBrowserRangeWrapper_().isRangeInDocument());
};


/** @inheritDoc */
goog.dom.TextRange.prototype.isCollapsed = function() {
  return this.getBrowserRangeWrapper_().isCollapsed();
};


/** @inheritDoc */
goog.dom.TextRange.prototype.getText = function() {
  return this.getBrowserRangeWrapper_().getText();
};


/** @inheritDoc */
goog.dom.TextRange.prototype.getHtmlFragment = function() {
  // TODO(robbyw): Generalize the code in browserrange so it is static and
  // just takes an iterator.  This would mean we don't always have to create a
  // browser range.
  return this.getBrowserRangeWrapper_().getHtmlFragment();
};


/** @inheritDoc */
goog.dom.TextRange.prototype.getValidHtml = function() {
  return this.getBrowserRangeWrapper_().getValidHtml();
};


/** @inheritDoc */
goog.dom.TextRange.prototype.getPastableHtml = function() {
  // TODO(robbyw): Get any attributes the table or tr has.

  var html = this.getValidHtml();

  if (html.match(/^\s*<td\b/i)) {
    // Match html starting with a TD.
    html = '<table><tbody><tr>' + html + '</tr></tbody></table>';
  } else if (html.match(/^\s*<tr\b/i)) {
    // Match html starting with a TR.
    html = '<table><tbody>' + html + '</tbody></table>';
  } else if (html.match(/^\s*<tbody\b/i)) {
    // Match html starting with a TBODY.
    html = '<table>' + html + '</table>';
  } else if (html.match(/^\s*<li\b/i)) {
    // Match html starting with an LI.
    var container = this.getContainer();
    var tagType = goog.dom.TagName.UL;
    while (container) {
      if (container.tagName == goog.dom.TagName.OL) {
        tagType = goog.dom.TagName.OL;
        break;
      } else if (container.tagName == goog.dom.TagName.UL) {
        break;
      }
      container = container.parentNode;
    }
    html = goog.string.buildString('<', tagType, '>', html, '</', tagType, '>');
  }

  return html;
};


/**
 * Returns a TextRangeIterator over the contents of the range.  Regardless of
 * the direction of the range, the iterator will move in document order.
 * @param {boolean=} opt_keys Unused for this iterator.
 * @return {goog.dom.TextRangeIterator} An iterator over tags in the range.
 */
goog.dom.TextRange.prototype.__iterator__ = function(opt_keys) {
  return new goog.dom.TextRangeIterator(this.getStartNode(),
      this.getStartOffset(), this.getEndNode(), this.getEndOffset());
};


// RANGE ACTIONS


/** @inheritDoc */
goog.dom.TextRange.prototype.select = function() {
  this.getBrowserRangeWrapper_().select(this.isReversed_);
};


/** @inheritDoc */
goog.dom.TextRange.prototype.removeContents = function() {
  this.getBrowserRangeWrapper_().removeContents();
  this.clearCachedValues_();
};


/**
 * Surrounds the text range with the specified element (on Mozilla) or with a
 * clone of the specified element (on IE).  Returns a reference to the
 * surrounding element if the operation was successful; returns null if the
 * operation failed.
 * @param {Element} element The element with which the selection is to be
 *    surrounded.
 * @return {Element} The surrounding element (same as the argument on Mozilla,
 *    but not on IE), or null if unsuccessful.
 */
goog.dom.TextRange.prototype.surroundContents = function(element) {
  var output = this.getBrowserRangeWrapper_().surroundContents(element);
  this.clearCachedValues_();
  return output;
};


/** @inheritDoc */
goog.dom.TextRange.prototype.insertNode = function(node, before) {
  var output = this.getBrowserRangeWrapper_().insertNode(node, before);
  this.clearCachedValues_();
  return output;
};


/** @inheritDoc */
goog.dom.TextRange.prototype.surroundWithNodes = function(startNode, endNode) {
  this.getBrowserRangeWrapper_().surroundWithNodes(startNode, endNode);
  this.clearCachedValues_();
};


// SAVE/RESTORE


/** @inheritDoc */
goog.dom.TextRange.prototype.saveUsingDom = function() {
  return new goog.dom.DomSavedTextRange_(this);
};


// RANGE MODIFICATION


/** @inheritDoc */
goog.dom.TextRange.prototype.collapse = function(toAnchor) {
  var toStart = this.isReversed() ? !toAnchor : toAnchor;

  if (this.browserRangeWrapper_) {
    this.browserRangeWrapper_.collapse(toStart);
  }

  if (toStart) {
    this.endNode_ = this.startNode_;
    this.endOffset_ = this.startOffset_;
  } else {
    this.startNode_ = this.endNode_;
    this.startOffset_ = this.endOffset_;
  }

  // Collapsed ranges can't be reversed
  this.isReversed_ = _FALSE;
};


// SAVED RANGE OBJECTS



/**
 * A SavedRange implementation using DOM endpoints.
 * @param {goog.dom.AbstractRange} range The range to save.
 * @constructor
 * @extends {goog.dom.SavedRange}
 * @private
 */
goog.dom.DomSavedTextRange_ = function(range) {
  /**
   * The anchor node.
   * @type {Node}
   * @private
   */
  this.anchorNode_ = range.getAnchorNode();

  /**
   * The anchor node offset.
   * @type {number}
   * @private
   */
  this.anchorOffset_ = range.getAnchorOffset();

  /**
   * The focus node.
   * @type {Node}
   * @private
   */
  this.focusNode_ = range.getFocusNode();

  /**
   * The focus node offset.
   * @type {number}
   * @private
   */
  this.focusOffset_ = range.getFocusOffset();
};
goog.inherits(goog.dom.DomSavedTextRange_, goog.dom.SavedRange);


/**
 * @return {goog.dom.AbstractRange} The restored range.
 */
goog.dom.DomSavedTextRange_.prototype.restoreInternal = function() {
  return goog.dom.Range.createFromNodes(this.anchorNode_, this.anchorOffset_,
      this.focusNode_, this.focusOffset_);
};


/** @inheritDoc */
goog.dom.DomSavedTextRange_.prototype.disposeInternal = function() {
  goog.dom.DomSavedTextRange_.superClass_.disposeInternal.call(this);

  this.anchorNode_ = _NULL;
  this.focusNode_ = _NULL;
};
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for working with W3C multi-part ranges.
 *
 * @author robbyw@google.com (Robby Walker)
 */


goog.provide('goog.dom.MultiRange');
goog.provide('goog.dom.MultiRangeIterator');

////goog.require('goog.array');
//goog.require('goog.dom.AbstractMultiRange');
//goog.require('goog.dom.AbstractRange');
//goog.require('goog.dom.RangeIterator');
//goog.require('goog.dom.RangeType');
//goog.require('goog.dom.SavedRange');
//goog.require('goog.dom.TextRange');
//goog.require('goog.iter.StopIteration');



/**
 * Creates a new multi part range with no properties.  Do not use this
 * constructor: use one of the goog.dom.Range.createFrom* methods instead.
 * @constructor
 * @extends {goog.dom.AbstractMultiRange}
 */
goog.dom.MultiRange = function() {
  /**
   * Array of browser sub-ranges comprising this multi-range.
   * @type {Array.<Range>}
   * @private
   */
  this.browserRanges_ = [];

  /**
   * Lazily initialized array of range objects comprising this multi-range.
   * @type {Array.<goog.dom.TextRange>}
   * @private
   */
  this.ranges_ = [];

  /**
   * Lazily computed sorted version of ranges_, sorted by start point.
   * @type {Array.<goog.dom.TextRange>?}
   * @private
   */
  this.sortedRanges_ = _NULL;

  /**
   * Lazily computed container node.
   * @type {Node}
   * @private
   */
  this.container_ = _NULL;
};
goog.inherits(goog.dom.MultiRange, goog.dom.AbstractMultiRange);


/**
 * Creates a new range wrapper from the given browser selection object.  Do not
 * use this method directly - please use goog.dom.Range.createFrom* instead.
 * @param {Selection} selection The browser selection object.
 * @return {goog.dom.MultiRange} A range wrapper object.
 */
goog.dom.MultiRange.createFromBrowserSelection = function(selection) {
  var range = new goog.dom.MultiRange();
  for (var i = 0, len = selection.rangeCount; i < len; i++) {
    range.browserRanges_.push(selection.getRangeAt(i));
  }
  return range;
};


/**
 * Creates a new range wrapper from the given browser ranges.  Do not
 * use this method directly - please use goog.dom.Range.createFrom* instead.
 * @param {Array.<Range>} browserRanges The browser ranges.
 * @return {goog.dom.MultiRange} A range wrapper object.
 */
goog.dom.MultiRange.createFromBrowserRanges = function(browserRanges) {
  var range = new goog.dom.MultiRange();
  range.browserRanges_ = goog.array.clone(browserRanges);
  return range;
};


/**
 * Creates a new range wrapper from the given goog.dom.TextRange objects.  Do
 * not use this method directly - please use goog.dom.Range.createFrom* instead.
 * @param {Array.<goog.dom.TextRange>} textRanges The text range objects.
 * @return {goog.dom.MultiRange} A range wrapper object.
 */
goog.dom.MultiRange.createFromTextRanges = function(textRanges) {
  var range = new goog.dom.MultiRange();
  range.ranges_ = textRanges;
  range.browserRanges_ = textRanges.map(function(range) {	// modified
    return range.getBrowserRangeObject();
  });
  return range;
};

// Method implementations


/**
 * Clears cached values.  Should be called whenever this.browserRanges_ is
 * modified.
 * @private
 */
goog.dom.MultiRange.prototype.clearCachedValues_ = function() {
  this.ranges_ = [];
  this.sortedRanges_ = _NULL;
  this.container_ = _NULL;
};


/**
 * @return {goog.dom.MultiRange} A clone of this range.
 */
goog.dom.MultiRange.prototype.clone = function() {
  return goog.dom.MultiRange.createFromBrowserRanges(this.browserRanges_);
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.getType = function() {
  return goog.dom.RangeType.MULTI;
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.getBrowserRangeObject = function() {
  // NOTE(robbyw): This method does not make sense for multi-ranges.
  return this.browserRanges_[0];
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.setBrowserRangeObject = function(nativeRange) {
  // TODO(robbyw): Look in to adding setBrowserSelectionObject.
  return _FALSE;
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.getTextRangeCount = function() {
  return this.browserRanges_.length;
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.getTextRange = function(i) {
  if (!this.ranges_[i]) {
    this.ranges_[i] = goog.dom.TextRange.createFromBrowserRange(
        this.browserRanges_[i]);
  }
  return this.ranges_[i];
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.getContainer = function() {
  if (!this.container_) {
    var nodes = [];
    for (var i = 0, len = this.getTextRangeCount(); i < len; i++) {
      nodes.push(this.getTextRange(i).getContainer());
    }
    this.container_ = goog.dom.findCommonAncestor.apply(_NULL, nodes);
  }
  return this.container_;
};


/**
 * @return {Array.<goog.dom.TextRange>} An array of sub-ranges, sorted by start
 *     point.
 */
goog.dom.MultiRange.prototype.getSortedRanges = function() {
  if (!this.sortedRanges_) {
    this.sortedRanges_ = this.getTextRanges();
    this.sortedRanges_.sort(function(a, b) {
      var aStartNode = a.getStartNode();
      var aStartOffset = a.getStartOffset();
      var bStartNode = b.getStartNode();
      var bStartOffset = b.getStartOffset();

      if (aStartNode == bStartNode && aStartOffset == bStartOffset) {
        return 0;
      }

      return goog.dom.Range.isReversed(aStartNode, aStartOffset, bStartNode,
          bStartOffset) ? 1 : -1;
    });
  }
  return this.sortedRanges_;
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.getStartNode = function() {
  return this.getSortedRanges()[0].getStartNode();
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.getStartOffset = function() {
  return this.getSortedRanges()[0].getStartOffset();
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.getEndNode = function() {
  // NOTE(robbyw): This may return the wrong node if any subranges overlap.
  return this.getSortedRanges().last().getEndNode();	// modified
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.getEndOffset = function() {
  // NOTE(robbyw): This may return the wrong value if any subranges overlap.
  return this.getSortedRanges().last().getEndOffset();	// modified
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.isRangeInDocument = function() {
  return this.getTextRanges().every(function(range) {	// modified
    return range.isRangeInDocument();
  });
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.isCollapsed = function() {
  return this.browserRanges_.length == 0 ||
      this.browserRanges_.length == 1 && this.getTextRange(0).isCollapsed();
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.getText = function() {
  return this.getTextRanges().map(function(range) {	// modified
    return range.getText();
  }).join('');
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.getHtmlFragment = function() {
  return this.getValidHtml();
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.getValidHtml = function() {
  // NOTE(robbyw): This does not behave well if the sub-ranges overlap.
  return this.getTextRanges().map(function(range) {	// modified
    return range.getValidHtml();
  }).join('');
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.getPastableHtml = function() {
  // TODO(robbyw): This should probably do something smart like group TR and TD
  // selections in to the same table.
  return this.getValidHtml();
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.__iterator__ = function(opt_keys) {
  return new goog.dom.MultiRangeIterator(this);
};


// RANGE ACTIONS


/** @inheritDoc */
goog.dom.MultiRange.prototype.select = function() {
  var selection = goog.dom.AbstractRange.getBrowserSelectionForWindow(
      this.getWindow());
  selection.removeAllRanges();
  for (var i = 0, len = this.getTextRangeCount(); i < len; i++) {
    selection.addRange(this.getTextRange(i).getBrowserRangeObject());
  }
};


/** @inheritDoc */
goog.dom.MultiRange.prototype.removeContents = function() {
  this.getTextRanges().each(function(range) {	// modified
    range.removeContents();
  });
};


// SAVE/RESTORE


/** @inheritDoc */
goog.dom.MultiRange.prototype.saveUsingDom = function() {
  return new goog.dom.DomSavedMultiRange_(this);
};


// RANGE MODIFICATION


/**
 * Collapses this range to a single point, either the first or last point
 * depending on the parameter.  This will result in the number of ranges in this
 * multi range becoming 1.
 * @param {boolean} toAnchor Whether to collapse to the anchor.
 */
goog.dom.MultiRange.prototype.collapse = function(toAnchor) {
  if (!this.isCollapsed()) {
    var range = toAnchor ? this.getTextRange(0) : this.getTextRange(
        this.getTextRangeCount() - 1);

    this.clearCachedValues_();
    range.collapse(toAnchor);
    this.ranges_ = [range];
    this.sortedRanges_ = [range];
    this.browserRanges_ = [range.getBrowserRangeObject()];
  }
};


// SAVED RANGE OBJECTS



/**
 * A SavedRange implementation using DOM endpoints.
 * @param {goog.dom.MultiRange} range The range to save.
 * @constructor
 * @extends {goog.dom.SavedRange}
 * @private
 */
goog.dom.DomSavedMultiRange_ = function(range) {
  /**
   * Array of saved ranges.
   * @type {Array.<goog.dom.SavedRange>}
   * @private
   */
  this.savedRanges_ = range.getTextRanges().map(function(range) {	// modified
    return range.saveUsingDom();
  });
};
goog.inherits(goog.dom.DomSavedMultiRange_, goog.dom.SavedRange);


/**
 * @return {goog.dom.MultiRange} The restored range.
 */
goog.dom.DomSavedMultiRange_.prototype.restoreInternal = function() {
  var ranges = this.savedRanges_.map(function(savedRange) {	// modified
    return savedRange.restore();
  });
  return goog.dom.MultiRange.createFromTextRanges(ranges);
};


/** @inheritDoc */
goog.dom.DomSavedMultiRange_.prototype.disposeInternal = function() {
  goog.dom.DomSavedMultiRange_.superClass_.disposeInternal.call(this);

  this.savedRanges_.map(function(savedRange) {	// modified
    savedRange.dispose();
  });
  delete this.savedRanges_;
};


// RANGE ITERATION



/**
 * Subclass of goog.dom.TagIterator that iterates over a DOM range.  It
 * adds functions to determine the portion of each text node that is selected.
 *
 * @param {goog.dom.MultiRange} range The range to traverse.
 * @constructor
 * @extends {goog.dom.RangeIterator}
 */
goog.dom.MultiRangeIterator = function(range) {
  if (range) {
    this.iterators_ = range.getSortedRanges().map(
        function(r) {
          return goog.iter.toIterator(r);
        });
  }

  goog.dom.RangeIterator.call(
      this, range ? this.getStartNode() : _NULL, _FALSE);
};
goog.inherits(goog.dom.MultiRangeIterator, goog.dom.RangeIterator);


/**
 * The list of range iterators left to traverse.
 * @type {Array.<goog.dom.RangeIterator>?}
 * @private
 */
goog.dom.MultiRangeIterator.prototype.iterators_ = _NULL;


/**
 * The index of the current sub-iterator being traversed.
 * @type {number}
 * @private
 */
goog.dom.MultiRangeIterator.prototype.currentIdx_ = 0;


/** @inheritDoc */
goog.dom.MultiRangeIterator.prototype.getStartTextOffset = function() {
  return this.iterators_[this.currentIdx_].getStartTextOffset();
};


/** @inheritDoc */
goog.dom.MultiRangeIterator.prototype.getEndTextOffset = function() {
  return this.iterators_[this.currentIdx_].getEndTextOffset();
};


/** @inheritDoc */
goog.dom.MultiRangeIterator.prototype.getStartNode = function() {
  return this.iterators_[0].getStartNode();
};


/** @inheritDoc */
goog.dom.MultiRangeIterator.prototype.getEndNode = function() {
  return this.iterators_.last().getEndNode();
};


/** @inheritDoc */
goog.dom.MultiRangeIterator.prototype.isLast = function() {
  return this.iterators_[this.currentIdx_].isLast();
};


/** @inheritDoc */
goog.dom.MultiRangeIterator.prototype.next = function() {
  /** @preserveTry */
  try {
    var it = this.iterators_[this.currentIdx_];
    var next = it.next();
    this.setPosition(it.node, it.tagType, it.depth);
    return next;
  } catch (ex) {
    if (ex !== goog.iter.StopIteration ||
        this.iterators_.length - 1 == this.currentIdx_) {
      throw ex;
    } else {
      // In case we got a StopIteration, increment counter and try again.
      this.currentIdx_++;
      return this.next();
    }
  }
};


/**
 * Replaces this iterator's values with values from another.
 * @param {goog.dom.MultiRangeIterator} other The iterator to copy.
 * @protected
 */
goog.dom.MultiRangeIterator.prototype.copyFrom = function(other) {
  this.iterators_ = goog.array.clone(other.iterators_);
  goog.dom.MultiRangeIterator.superClass_.copyFrom.call(this, other);
};


/**
 * @return {goog.dom.MultiRangeIterator} An identical iterator.
 */
goog.dom.MultiRangeIterator.prototype.clone = function() {
  var copy = new goog.dom.MultiRangeIterator(_NULL);
  copy.copyFrom(this);
  return copy;
};
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for working with IE control ranges.
 *
 * @author robbyw@google.com (Robby Walker)
 * @author jparent@google.com (Julie Parent)
 */


goog.provide('goog.dom.ControlRange');
goog.provide('goog.dom.ControlRangeIterator');

//goog.require('goog.dom');
//goog.require('goog.dom.AbstractMultiRange');
//goog.require('goog.dom.AbstractRange');
//goog.require('goog.dom.RangeIterator');
//goog.require('goog.dom.RangeType');
//goog.require('goog.dom.SavedRange');
//goog.require('goog.dom.TagWalkType');
//goog.require('goog.dom.TextRange');
//goog.require('goog.iter.StopIteration');
//goog.require('goog.userAgent');



/**
 * Create a new control selection with no properties.  Do not use this
 * constructor: use one of the goog.dom.Range.createFrom* methods instead.
 * @constructor
 * @extends {goog.dom.AbstractMultiRange}
 */
goog.dom.ControlRange = function() {
};
goog.inherits(goog.dom.ControlRange, goog.dom.AbstractMultiRange);


/**
 * Create a new range wrapper from the given browser range object.  Do not use
 * this method directly - please use goog.dom.Range.createFrom* instead.
 * @param {Object} controlRange The browser range object.
 * @return {goog.dom.ControlRange} A range wrapper object.
 */
goog.dom.ControlRange.createFromBrowserRange = function(controlRange) {
  var range = new goog.dom.ControlRange();
  range.range_ = controlRange;
  return range;
};


/**
 * Create a new range wrapper that selects the given element.  Do not use
 * this method directly - please use goog.dom.Range.createFrom* instead.
 * @param {...Element} var_args The element(s) to select.
 * @return {goog.dom.ControlRange} A range wrapper object.
 */
goog.dom.ControlRange.createFromElements = function(var_args) {
  var range = goog.dom.getOwnerDocument(arguments[0]).body.createControlRange();
  for (var i = 0, len = arguments.length; i < len; i++) {
    range.addElement(arguments[i]);
  }
  return goog.dom.ControlRange.createFromBrowserRange(range);
};


/**
 * The IE control range obejct.
 * @type {Object}
 * @private
 */
goog.dom.ControlRange.prototype.range_ = _NULL;


/**
 * Cached list of elements.
 * @type {Array.<Element>?}
 * @private
 */
goog.dom.ControlRange.prototype.elements_ = _NULL;


/**
 * Cached sorted list of elements.
 * @type {Array.<Element>?}
 * @private
 */
goog.dom.ControlRange.prototype.sortedElements_ = _NULL;


// Method implementations


/**
 * Clear cached values.
 * @private
 */
goog.dom.ControlRange.prototype.clearCachedValues_ = function() {
  this.elements_ = _NULL;
  this.sortedElements_ = _NULL;
};


/**
 * @return {goog.dom.ControlRange} A clone of this range.
 */
goog.dom.ControlRange.prototype.clone = function() {
  return goog.dom.ControlRange.createFromElements.apply(this,
                                                        this.getElements());
};


/** @inheritDoc */
goog.dom.ControlRange.prototype.getType = function() {
  return goog.dom.RangeType.CONTROL;
};


/** @inheritDoc */
goog.dom.ControlRange.prototype.getBrowserRangeObject = function() {
  return this.range_ || _DOC.body.createControlRange();
};


/** @inheritDoc */
goog.dom.ControlRange.prototype.setBrowserRangeObject = function(nativeRange) {
  if (!goog.dom.AbstractRange.isNativeControlRange(nativeRange)) {
    return _FALSE;
  }
  this.range_ = nativeRange;
  return _TRUE;
};


/** @inheritDoc */
goog.dom.ControlRange.prototype.getTextRangeCount = function() {
  return this.range_ ? this.range_.length : 0;
};


/** @inheritDoc */
goog.dom.ControlRange.prototype.getTextRange = function(i) {
  return goog.dom.TextRange.createFromNodeContents(this.range_.item(i));
};


/** @inheritDoc */
goog.dom.ControlRange.prototype.getContainer = function() {
  return goog.dom.findCommonAncestor.apply(_NULL, this.getElements());
};


/** @inheritDoc */
goog.dom.ControlRange.prototype.getStartNode = function() {
  return this.getSortedElements()[0];
};


/** @inheritDoc */
goog.dom.ControlRange.prototype.getStartOffset = function() {
  return 0;
};


/** @inheritDoc */
goog.dom.ControlRange.prototype.getEndNode = function() {
  var sorted = this.getSortedElements();
  var startsLast = /** @type {Node} */ (sorted.last());	// modified
  return /** @type {Node} */ (sorted.find(function(el) {
    return goog.dom.contains(el, startsLast);
  }));
};


/** @inheritDoc */
goog.dom.ControlRange.prototype.getEndOffset = function() {
  return this.getEndNode().childNodes.length;
};


// TODO(robbyw): Figure out how to unify getElements with TextRange API.
/**
 * @return {Array.<Element>} Array of elements in the control range.
 */
goog.dom.ControlRange.prototype.getElements = function() {
  if (!this.elements_) {
    this.elements_ = [];
    if (this.range_) {
      for (var i = 0; i < this.range_.length; i++) {
        this.elements_.push(this.range_.item(i));
      }
    }
  }

  return this.elements_;
};


/**
 * @return {Array.<Element>} Array of elements comprising the control range,
 *     sorted by document order.
 */
goog.dom.ControlRange.prototype.getSortedElements = function() {
  if (!this.sortedElements_) {
    this.sortedElements_ = this.getElements().concat();
    this.sortedElements_.sort(function(a, b) {
      return a.sourceIndex - b.sourceIndex;
    });
  }

  return this.sortedElements_;
};


/** @inheritDoc */
goog.dom.ControlRange.prototype.isRangeInDocument = function() {
  var returnValue = _FALSE;

  try {
    returnValue = this.getElements().every(function(element) {	// modified
      // On IE, this throws an exception when the range is detached.
      return goog.userAgent.IE ?
          element.parentNode :
          goog.dom.contains(element.ownerDocument.body, element);
    });
  } catch (e) {
    // IE sometimes throws Invalid Argument errors for detached elements.
    // Note: trying to return a value from the above try block can cause IE
    // to crash.  It is necessary to use the local returnValue.
  }

  return returnValue;
};


/** @inheritDoc */
goog.dom.ControlRange.prototype.isCollapsed = function() {
  return !this.range_ || !this.range_.length;
};


/** @inheritDoc */
goog.dom.ControlRange.prototype.getText = function() {
  // TODO(robbyw): What about for table selections?  Should those have text?
  return '';
};


/** @inheritDoc */
goog.dom.ControlRange.prototype.getHtmlFragment = function() {
  return this.getSortedElements().map(goog.dom.getOuterHtml).	// modified
      join('');
};


/** @inheritDoc */
goog.dom.ControlRange.prototype.getValidHtml = function() {
  return this.getHtmlFragment();
};


/** @inheritDoc */
goog.dom.ControlRange.prototype.getPastableHtml =
    goog.dom.ControlRange.prototype.getValidHtml;


/** @inheritDoc */
goog.dom.ControlRange.prototype.__iterator__ = function(opt_keys) {
  return new goog.dom.ControlRangeIterator(this);
};


// RANGE ACTIONS


/** @inheritDoc */
goog.dom.ControlRange.prototype.select = function() {
  if (this.range_) {
    this.range_.select();
  }
};


/** @inheritDoc */
goog.dom.ControlRange.prototype.removeContents = function() {
  // TODO(robbyw): Test implementing with execCommand('Delete')
  if (this.range_) {
    var nodes = [];
    for (var i = 0, len = this.range_.length; i < len; i++) {
      nodes.push(this.range_.item(i));
    }
    nodes.each(goog.dom.removeNode);	// modified

    this.collapse(_FALSE);
  }
};


// SAVE/RESTORE


/** @inheritDoc */
goog.dom.ControlRange.prototype.saveUsingDom = function() {
  return new goog.dom.DomSavedControlRange_(this);
};


// RANGE MODIFICATION


/** @inheritDoc */
goog.dom.ControlRange.prototype.collapse = function(toAnchor) {
  // TODO(robbyw): Should this return a text range?  If so, API needs to change.
  this.range_ = _NULL;
  this.clearCachedValues_();
};


// SAVED RANGE OBJECTS



/**
 * A SavedRange implementation using DOM endpoints.
 * @param {goog.dom.ControlRange} range The range to save.
 * @constructor
 * @extends {goog.dom.SavedRange}
 * @private
 */
goog.dom.DomSavedControlRange_ = function(range) {
  /**
   * The element list.
   * @type {Array.<Element>}
   * @private
   */
  this.elements_ = range.getElements();
};
goog.inherits(goog.dom.DomSavedControlRange_, goog.dom.SavedRange);


/**
 * @return {goog.dom.ControlRange} The restored range.
 */
goog.dom.DomSavedControlRange_.prototype.restoreInternal = function() {
  var doc = this.elements_.length ?
      goog.dom.getOwnerDocument(this.elements_[0]) : document;
  var controlRange = doc.body.createControlRange();
  for (var i = 0, len = this.elements_.length; i < len; i++) {
    controlRange.addElement(this.elements_[i]);
  }
  return goog.dom.ControlRange.createFromBrowserRange(controlRange);
};


/** @inheritDoc */
goog.dom.DomSavedControlRange_.prototype.disposeInternal = function() {
  goog.dom.DomSavedControlRange_.superClass_.disposeInternal.call(this);
  delete this.elements_;
};


// RANGE ITERATION



/**
 * Subclass of goog.dom.TagIterator that iterates over a DOM range.  It
 * adds functions to determine the portion of each text node that is selected.
 *
 * @param {goog.dom.ControlRange?} range The range to traverse.
 * @constructor
 * @extends {goog.dom.RangeIterator}
 */
goog.dom.ControlRangeIterator = function(range) {
  if (range) {
    this.elements_ = range.getSortedElements();
    this.startNode_ = this.elements_.shift();
    this.endNode_ = /** @type {Node} */ (this.elements_.last()) ||	// modified
        this.startNode_;
  }

  goog.dom.RangeIterator.call(this, this.startNode_, _FALSE);
};
goog.inherits(goog.dom.ControlRangeIterator, goog.dom.RangeIterator);


/**
 * The first node in the selection.
 * @type {Node}
 * @private
 */
goog.dom.ControlRangeIterator.prototype.startNode_ = _NULL;


/**
 * The last node in the selection.
 * @type {Node}
 * @private
 */
goog.dom.ControlRangeIterator.prototype.endNode_ = _NULL;


/**
 * The list of elements left to traverse.
 * @type {Array.<Element>?}
 * @private
 */
goog.dom.ControlRangeIterator.prototype.elements_ = _NULL;


/** @inheritDoc */
goog.dom.ControlRangeIterator.prototype.getStartTextOffset = function() {
  return 0;
};


/** @inheritDoc */
goog.dom.ControlRangeIterator.prototype.getEndTextOffset = function() {
  return 0;
};


/** @inheritDoc */
goog.dom.ControlRangeIterator.prototype.getStartNode = function() {
  return this.startNode_;
};


/** @inheritDoc */
goog.dom.ControlRangeIterator.prototype.getEndNode = function() {
  return this.endNode_;
};


/** @inheritDoc */
goog.dom.ControlRangeIterator.prototype.isLast = function() {
  return !this.depth && !this.elements_.length;
};


/**
 * Move to the next position in the selection.
 * Throws {@code goog.iter.StopIteration} when it passes the end of the range.
 * @return {Node} The node at the next position.
 */
goog.dom.ControlRangeIterator.prototype.next = function() {
  // Iterate over each element in the range, and all of its children.
  if (this.isLast()) {
    throw goog.iter.StopIteration;
  } else if (!this.depth) {
    var el = this.elements_.shift();
    this.setPosition(el,
                     goog.dom.TagWalkType.START_TAG,
                     goog.dom.TagWalkType.START_TAG);
    return el;
  }

  // Call the super function.
  return goog.dom.ControlRangeIterator.superClass_.next.call(this);
};


/**
 * Replace this iterator's values with values from another.
 * @param {goog.dom.ControlRangeIterator} other The iterator to copy.
 * @protected
 */
goog.dom.ControlRangeIterator.prototype.copyFrom = function(other) {
  this.elements_ = other.elements_;
  this.startNode_ = other.startNode_;
  this.endNode_ = other.endNode_;

  goog.dom.ControlRangeIterator.superClass_.copyFrom.call(this, other);
};


/**
 * @return {goog.dom.ControlRangeIterator} An identical iterator.
 */
goog.dom.ControlRangeIterator.prototype.clone = function() {
  var copy = new goog.dom.ControlRangeIterator(_NULL);
  copy.copyFrom(this);
  return copy;
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for working with ranges in HTML documents.
 *
 * @author robbyw@google.com (Robby Walker)
 * @author ojan@google.com (Ojan Vafai)
 * @author jparent@google.com (Julie Parent)
 */

goog.provide('goog.dom.Range');

//goog.require('goog.dom');
//goog.require('goog.dom.AbstractRange');
//goog.require('goog.dom.ControlRange');
//goog.require('goog.dom.MultiRange');
//goog.require('goog.dom.NodeType');
//goog.require('goog.dom.TextRange');
//goog.require('goog.userAgent');


/**
 * Create a new selection from the given browser window's current selection.
 * Note that this object does not auto-update if the user changes their
 * selection and should be used as a snapshot.
 * @param {Window=} opt_win The window to get the selection of.  Defaults to the
 *     window this class was defined in.
 * @return {goog.dom.AbstractRange?} A range wrapper object, or null if there
 *     was an error.
 */
goog.dom.Range.createFromWindow = function(opt_win) {
  var sel = goog.dom.AbstractRange.getBrowserSelectionForWindow(
      opt_win || window);
  return sel && goog.dom.Range.createFromBrowserSelection(sel);
};


/**
 * Create a new range wrapper from the given browser selection object.  Note
 * that this object does not auto-update if the user changes their selection and
 * should be used as a snapshot.
 * @param {!Object} selection The browser selection object.
 * @return {goog.dom.AbstractRange?} A range wrapper object or null if there
 *    was an error.
 */
goog.dom.Range.createFromBrowserSelection = function(selection) {
  var range;
  var isReversed = _FALSE;
  if (selection.createRange) {
    /** @preserveTry */
    try {
      range = selection.createRange();
    } catch (e) {
      // Access denied errors can be thrown here in IE if the selection was
      // a flash obj or if there are cross domain issues
      return _NULL;
    }
  } else if (selection.rangeCount) {
    if (selection.rangeCount > 1) {
      return goog.dom.MultiRange.createFromBrowserSelection(
          /** @type {Selection} */ (selection));
    } else {
      range = selection.getRangeAt(0);
      isReversed = goog.dom.Range.isReversed(selection.anchorNode,
          selection.anchorOffset, selection.focusNode, selection.focusOffset);
    }
  } else {
    return _NULL;
  }

  return goog.dom.Range.createFromBrowserRange(range, isReversed);
};


/**
 * Create a new range wrapper from the given browser range object.
 * @param {Range|TextRange} range The browser range object.
 * @param {boolean=} opt_isReversed Whether the focus node is before the anchor
 *     node.
 * @return {goog.dom.AbstractRange} A range wrapper object.
 */
goog.dom.Range.createFromBrowserRange = function(range, opt_isReversed) {
  // Create an IE control range when appropriate.
  return goog.dom.AbstractRange.isNativeControlRange(range) ?
      goog.dom.ControlRange.createFromBrowserRange(range) :
      goog.dom.TextRange.createFromBrowserRange(range, opt_isReversed);
};


/**
 * Create a new range wrapper that selects the given node's text.
 * @param {Node} node The node to select.
 * @param {boolean=} opt_isReversed Whether the focus node is before the anchor
 *     node.
 * @return {goog.dom.AbstractRange} A range wrapper object.
 */
goog.dom.Range.createFromNodeContents = function(node, opt_isReversed) {
  return goog.dom.TextRange.createFromNodeContents(node, opt_isReversed);
};


/**
 * Create a new range wrapper that represents a caret at the given node,
 * accounting for the given offset.  This always creates a TextRange, regardless
 * of whether node is an image node or other control range type node.
 * @param {Node} node The node to place a caret at.
 * @param {number} offset The offset within the node to place the caret at.
 * @return {goog.dom.AbstractRange} A range wrapper object.
 */
goog.dom.Range.createCaret = function(node, offset) {
  return goog.dom.TextRange.createFromNodes(node, offset, node, offset);
};


/**
 * Create a new range wrapper that selects the area between the given nodes,
 * accounting for the given offsets.
 * @param {Node} startNode The node to start with.
 * @param {number} startOffset The offset within the node to start.
 * @param {Node} endNode The node to end with.
 * @param {number} endOffset The offset within the node to end.
 * @return {goog.dom.AbstractRange} A range wrapper object.
 */
goog.dom.Range.createFromNodes = function(startNode, startOffset, endNode,
    endOffset) {
  return goog.dom.TextRange.createFromNodes(startNode, startOffset, endNode,
      endOffset);
};


/**
 * Clears the window's selection.
 * @param {Window=} opt_win The window to get the selection of.  Defaults to the
 *     window this class was defined in.
 */
goog.dom.Range.clearSelection = function(opt_win) {
  var sel = goog.dom.AbstractRange.getBrowserSelectionForWindow(
      opt_win || window);
  if (!sel) {
    return;
  }
  if (sel.empty) {
    // We can't just check that the selection is empty, becuase IE
    // sometimes gets confused.
    try {
      sel.empty();
    } catch (e) {
      // Emptying an already empty selection throws an exception in IE
    }
  } else {
    sel.removeAllRanges();
  }
};


/**
 * Returns whether the focus position occurs before the anchor position.
 * @param {Node} anchorNode The node to start with.
 * @param {number} anchorOffset The offset within the node to start.
 * @param {Node} focusNode The node to end with.
 * @param {number} focusOffset The offset within the node to end.
 * @return {boolean} Whether the focus position occurs before the anchor
 *     position.
 */
goog.dom.Range.isReversed = function(anchorNode, anchorOffset, focusNode,
    focusOffset) {
  if (anchorNode == focusNode) {
    return focusOffset < anchorOffset;
  }
  var child;
  if (anchorNode.nodeType == goog.dom.NodeType.ELEMENT && anchorOffset) {
    child = anchorNode.childNodes[anchorOffset];
    if (child) {
      anchorNode = child;
      anchorOffset = 0;
    } else if (goog.dom.contains(anchorNode, focusNode)) {
      // If focus node is contained in anchorNode, it must be before the
      // end of the node.  Hence we are reversed.
      return _TRUE;
    }
  }
  if (focusNode.nodeType == goog.dom.NodeType.ELEMENT && focusOffset) {
    child = focusNode.childNodes[focusOffset];
    if (child) {
      focusNode = child;
      focusOffset = 0;
    } else if (goog.dom.contains(focusNode, anchorNode)) {
      // If anchor node is contained in focusNode, it must be before the
      // end of the node.  Hence we are not reversed.
      return _FALSE;
    }
  }
  return (goog.dom.compareNodeOrder(anchorNode, focusNode) ||
      anchorOffset - focusOffset) > 0;
};
goog.provide("export_dep");

//goog.require('goog.dom.ControlRange');
//goog.require('goog.dom.MultiRange');
//goog.require('goog.dom.Range');
/* megascript */
_WIN.tx = {};

function each(a, f) {
    for (var i = 0, l = a.length; i < l; i++) f(a[i]);
}
_WIN.installHyperscript = function(namespace, oDocument) {
	each('a big blockquote br b center code dd dl dt div em font form h1 h2 h3 h4 h5 h6 hr img iframe input i li ol option pre p script select small span strike strong style sub sup table tbody td textarea tr ul u'.split(' '),
	    function(label) {
	        namespace[label]=function(){
	            var tag=oDocument.createElement(label);
	            each(arguments, function(arg){ 
	                if(arg.nodeType) {
						tag.appendChild(arg);
					} else if(typeof arg=='string' || typeof arg=='number') {
						if(label == "textarea") {
							if($tx.msie) {
								tag.value+=arg;	
							} else {
								tag.text+=arg;	
							}
						} else {
							tag.innerHTML+=arg;	
						}
					} else if(typeof arg=='array') {
						for(var i=0; i<arg.length; i++) {
							tag.appendChild(arg[i]);
						}
	                } else {
						for(var attr in arg) {
	                        if(attr=='style') {
								for(var sty in arg[attr]) {
									if((sty == 'float' || sty == 'cssFloat')) {
										tag[attr][tag[attr].styleFloat === _UNDEFINED ? 'cssFloat' : 'styleFloat'] = arg[attr][sty];
									} else {
										tag[attr][sty]=arg[attr][sty];
									}
								}
							} else if(["more", "less", "longDesc"].contains(attr)) {	 	// custom attributes
								if (tag.setAttribute) {
									tag.setAttribute(attr, arg[attr]);					
								}
							} else if (["colSpan", "rowSpan", "cellPadding", "cellSpacing"].contains(attr)) { // nonstandard attributes
								if (tag.setAttribute) {
									tag.setAttribute(attr, arg[attr]);
								}
							} else {
								if (arg[attr]) {
									tag[attr] = arg[attr];
								}
							}
						}
	                }
	            });
	            return tag;
	        };
	    });	
};
installHyperscript(_WIN.tx, _DOC);

/**
 * Template - Very Very Simple Template Engine
 *  similar prototype.js template engine
 *  add syntax > #{for:name:maxCount:cutCount} template #{/for:name}
 *  add syntax > #{if:name sign value} template #{/if:name}
 */
(function(){
	
	function evaluate(data, tpl) {
		if (!data) {
			return '';
		}
		if (tpl.indexOf("\{if:") > -1) {
			tpl = tpl.replace(/#\{if:([_\w]+)([=><!]+)([_'"\-\w]+)\}([\s\S]*?)#\{\/if:\1\}/gm, function(full, start, sign, value, condtpl){
				if (data[start] == _NULL) {
					return full;
				}
				var _condition = _FALSE;
				try {
					sign = ((sign=="=")? "==": sign);
					var _left = "\"" + (data[start] + "").replace(/['"]/g, "") + "\"";
					var _right = "\"" + value.replace(/['"]/g, "") + "\"";
					_condition = txEval("(" + _left + sign + _right + ")");
				}catch(e) { _condition = _FALSE; }
				if(_condition) {
					return evaluate(data, condtpl);
				} else {
					return "";
				}
			});
		}
		if (tpl.indexOf("\{for:") > -1) {
			tpl = tpl.replace(/#\{for:([_\w]+):?(\d*):?(\d*)\}([\s\S]*?)#\{\/for:\1\}/gm, function(full, start, maxCnt, cutCnt, looptpl) {
				if (!data[start] || !data[start].length) {
					return full;
				}
				var _list = data[start];
				var _listTpl = [];
				maxCnt = !!maxCnt? (isNaN(maxCnt)? _list.length: parseInt(maxCnt)): _list.length;
				cutCnt = !!cutCnt? (isNaN(cutCnt)? 0: parseInt(cutCnt)): 0;
				for (var i = 0, len = Math.min(_list.length, maxCnt); i < len; i++) {
					_listTpl.push(evaluate(_list[i], looptpl));
				}
				return _listTpl.join("").substring(cutCnt);
			});
		}
		return tpl.replace(/#\{([_\w]+)\}/g, function(full, name) {
			if(data[name] != _NULL) {
				return data[name];
			} else {
				return full;
			}
		});
	}
	
	var tmp = _WIN.Template = function(template) {
		this.template = template;
	};
	
	tmp.prototype = {
		evaluate : function(data) {
			return evaluate(data, this.template);
		},
		evaluateToDom : function(data, element) {
			if(typeof(element) === 'string') {
				element = _DOC.getElementById(element);
			}
			element.innerHTML = evaluate(data, this.template);
		},
		evaluateAsDom : function(data, context) {
			var _tmpNode = (context || document).createElement('div');
			_tmpNode.innerHTML = evaluate(data, this.template);
			return _tmpNode.firstChild;
		}
	};
	/*
	Template.prototype.evaluate = function(data) {
		return evaluate(data, this.template);
	};
	
	Template.prototype.evaluateToDom = function(data, element) {
		if(typeof(element) === 'string') {
			element = _DOC.getElementById(element);
		}
		element.innerHTML = evaluate(data, this.template);
	};
	
	Template.prototype.evaluateAsDom = function(data, context) {
		var _tmpNode = (context || document).createElement('div');
		_tmpNode.innerHTML = evaluate(data, this.template);
		return _tmpNode.firstChild;
	};
	*/

})();

/**
 * DomGetty - Very Very Simple Dom Selector Engine
 * - id : #
 * - class : .
 * - tag : tagname
 */
(function(){
	var m, el, els;
	var filters = {
		'#': function(cnxt, expr){
			if ((m = /(\S*)#(\S+)/.exec(expr)) !== _NULL) {
				var tag = m[1];
				var id = m[2];
				if(!cnxt.getElementById) { //ie
					cnxt = cnxt.ownerDocument;
				}
				if (el = cnxt.getElementById(id)) {
					if (tag.length < 1 || el.nodeName.toLowerCase() == tag) {
						return [el];
					}
				}
			}
			return [];
		},
		'.': function(cnxt, expr){
			if ((m = /(\S*)\.(\S+)/.exec(expr)) !== _NULL) {
				var tag = ((m[1] === "") ? "*" : m[1]);
				var klass = m[2];
				if ((els = cnxt.getElementsByTagName(tag)).length > 0) {
					var results = [];
					for (var i=0; i<els.length; i++) {
						var el = els[i];
						if ( (new RegExp("(^| )" + klass + "($| )")).test(el.className)) {
							results.push(el);
						}
					}
					return results;
				}
			}
			return [];
		},
		'*': function(cnxt, expr){
			if ((els = cnxt.getElementsByTagName(expr)).length > 0) {
				var results = [];
				for (var i=0; i<els.length; i++) {
					results.push(els[i]);
				}
				return results;
			}
			return [];
		}
	};
	
	var match = function(cnxt, expr) {
        if (cnxt.length < 1) {
            return [];
        }
        var fltr;
        if ((f = /(\.|#)/.exec(expr)) !== _NULL) {
            if (filters[f[1]]) {
                fltr = f[1];
            }
        }
        fltr = fltr || "*";
        var results = [];
        for (var i = 0; i < cnxt.length; i++) {
            results = results.concat(filters[fltr](cnxt[i], expr));
        }
        return results;
    };
	
	var collect = function(cnxt, expr) {
        var els = [cnxt];
        var exprs = expr.split(" ");
        for (var j = 0; j < exprs.length; j++) {
            els = match(els, exprs[j]);
        }
        return els;
    };
	
	var DomGetty = function(context, selector, all) {
		all = !!all;
		if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
			return (all? []: _NULL);
		}
		if ( !selector || typeof selector !== "string" ) {
			return (all? []: _NULL);
		}

		var els;
		var mathes = [];
		var exprs = selector.split(",");
		for (var i = 0; i < exprs.length; i++) {
			els = collect(context, exprs[i]);
			if(els && els.length > 0) {
				mathes = mathes.concat(els);
				if(!all) {
					break;
				}
			}
		}
		if(all) {
			return mathes;
		} else {
			return mathes[0];
		} 
	};
 
	/**
	 * Get Element By Css Selector
	 * 
	 * dGetty(element, selector) or dGetty(selector)
	 * ex)
	 *  dGetty(document, "#wrapper div.article")
	 *  dGetty($tx("#wrapper"), "div.article")
	 *  dGetty("#wrapper div.article") -> default document
	 */
	_WIN.dGetty = function() {
		var args = arguments;
		if(args.length == 1) {
			if(typeof (args[0]) === "string") {
				return DomGetty(_DOC, args[0]);
			}
		} else if(args.length == 2) {
			if(args[0].nodeType && typeof (args[1]) === "string") {
				return DomGetty(args[0], args[1]);
			}
		}
		return _NULL;
	};
	
	/**
	 * Get Element List By Css Selector
	 * 
	 * dGetties(element, selector) or dGetties(selector)
	 * ex)
	 *  dGetties(document, "#wrapper div.article")
	 *  dGetties($tx("#wrapper"), "div.article")
	 *  dGetties("#wrapper div.article") -> default document
	 */
	_WIN.dGetties = function() {
		var args = arguments;
		if(args.length == 1) {
			if(typeof (args[0]) === "string") {
				return DomGetty(_DOC, args[0], _TRUE);
			}
		} else if(args.length == 2) {
			if(args[0].nodeType && typeof (args[1]) === "string") {
				return DomGetty(args[0], args[1], _TRUE);
			}
		}
		return [];
	};
	
})();	

/**
 * DomChecky - Very Very Simple Dom Check Engine By Selector
 * - id : #
 * - class : .
 * - tag : tagname
 */
(function(){
	var m, el, els;
	var filters = {
		'#': function(cnxt, expr){
			if ((m = /(\S*)#(\S+)/.exec(expr)) !== _NULL) {
				var tag = m[1];
				var id = m[2];
				if (tag.length < 1 || cnxt.nodeName.toLowerCase() == tag) {
					if (cnxt.id == id) {
						return _TRUE;
					}
				}
			}
			return _FALSE;
		},
		'.': function(cnxt, expr){
			if ((m = /(\S*)\.(\S+)/.exec(expr)) !== _NULL) {
				var tag = m[1];
				var klass = m[2];
				if (tag.length < 1 || cnxt.nodeName.toLowerCase() == tag) {
					if (cnxt.className.indexOf(klass) > -1) {
						return _TRUE;
					}
				}
			}
			return _FALSE;
		},
		'*': function(cnxt, expr){
			var tag = expr;
			if (cnxt.nodeName.toLowerCase() == tag) {
				return _TRUE;
			}
			return _FALSE;
		}
	};
	
	var check = function(cnxt, expr) {
        var fltr;
        if ((f = /(\.|#)/.exec(expr)) !== _NULL) {
            if (filters[f[1]]) {
                fltr = f[1];
            }
        }
        fltr = fltr || "*";
        return filters[fltr](cnxt, expr);
    };
	
	var DomChecky = function(context, selector) {
		if ( context.nodeType !== 1) {
			return _FALSE;
		}

		var found = _FALSE;
		var exprs = selector.split(",");
		for (var i = 0; i < exprs.length; i++) {
			found = check(context, exprs[i]);
			if(found) {
				break;
			}
		}
		return found;
	};
	
	/**
	 * Check Element By Css Selector
	 * @returns boolean
	 * 
	 * dChecky(element, selector)
	 * ex)
	 *  dChecky(document, "#wrapper")
	 */
	_WIN.dChecky = function() {
		var args = arguments;
		if(args.length == 2) {
			if(args[0].nodeType && typeof (args[1]) === "string") {
				return DomChecky(args[0], args[1]);
			}
		}
		return _FALSE;
	};

})();

/**
 * DomFindy - Very Very Simple Dom Selector Engine, But find ancestor
 * - id : #
 * - class : .
 * - tag : tagname
 */
(function(){
	var m, el, els;
	var filters = {
		'#': function(cnxt, expr){
			if ((m = /(\S*)#(\S+)/.exec(expr)) !== _NULL) {
				var tag = ((m[1] === "") ? "*" : m[1]);
				var id = m[2];
				var _node = cnxt;
				while(_node) {
					if(_node.nodeName.toLowerCase() == "body") {
						break;
					}
					if (tag == "*" || _node.nodeName.toLowerCase() == tag) {
						if (_node.id == id) {
							return _node;
						}
					}
					_node = _node.parentNode;
				}
			}
			return _NULL;
		},
		'.': function(cnxt, expr){
			if ((m = /(\S*)\.(\S+)/.exec(expr)) !== _NULL) {
				var tag = ((m[1] === "") ? "*" : m[1]);
				var klass = m[2];
				var _node = cnxt;
				while(_node) {
					if(_node.nodeName.toLowerCase() == "body"||_node.nodeType === 9) {
						break;
					}
					if (tag == "*" || _node.nodeName.toLowerCase() == tag) {
						if (_node.className.indexOf(klass) > -1) {
							return _node;
						}
					}
					_node = _node.parentNode;
				}
			}
			return _NULL;
		},
		'*': function(cnxt, expr){
			var _node = cnxt;
			var map = {};
			var exprs = expr.split(",");
			for (var i=0,len=exprs.length; i<len; i++) {
				map[exprs[i]] = _TRUE;
			}
			while(_node) {
				if(_node.nodeName.toLowerCase() == "body") {
					break;
				}
				if (map[_node.nodeName.toLowerCase()]) {
					return _node;
				}
				_node = _node.parentNode;
			}
			return _NULL;
		}
	};
	
	var find = function(cnxt, expr) {
        var fltr;
        if ((f = /(\.|#|:\w+)/.exec(expr)) !== _NULL) {
            if (filters[f[1]]) {
                fltr = f[1];
            }
        }
        fltr = fltr || "*";
        var result = _NULL;
        if ((result = filters[fltr](cnxt, expr)) != _NULL) {
            return result;
        }
        return _NULL;
    };
	
	var DomFindy = function(context, selector) {
		if ( !selector || typeof selector !== "string" ) {
			return _NULL;
		}
		
		var els = context;
		var exprs = selector.split(" ");
		for(var i=0,len=exprs.length; i<len; i++) {
			if((els = find(els, exprs[i])) == _NULL) {
				return _NULL;
			}
		} 
		return els;
		/*
		if (els.length < 1) {
			return _NULL;
		} else if (els.length < 2) {
			return els[0];
		} else {
			return els;
		}*/
	};
 
	/**
	 * Find Ancestor Element By Css Selector
	 * 
	 * dFindy(element, selector) or dFindy(selector)
	 * ex)
	 *  dFindy($tx("#wrapper"), "div.article")
	 *  dFindy("#wrapper div.article") -> default document
	 */
	_WIN.dFindy = function() {
		var args = arguments;
		if(args.length == 1) {
			throw new Error("need more arguments");
		} else if(args.length == 2) {
			if(args[0].nodeType && typeof (args[1]) === "string") {
				return DomFindy(args[0], args[1]);
			}
		}
		return _NULL;
	};
})();

/**
 * XMLGetty - Very Very Simple XML Dom Selector Engine By XPath
 * - xpath
 */
(function(){
	
	var XMLGetty = function(node){
		this.selectSingleNode = function(path) {
			if(!node) {
				return _NULL;
			}
			return node.selectSingleNode(path);
		};
		this.selectNodes = function(path) {
			if(!node) {
				return [];
			}
			return node.selectNodes(path);
		};
		this.getAttributeNode = function(name) {
			if(!node) {
				return _NULL;
			}
			return node.getAttributeNode(name);
		};
		this.hasChildNodes = function() {
			if(!node) {
				return _FALSE;
			}
			return node.hasChildNodes();
		};
		this.text = node? (node.textContent || node.text) : _NULL;
		this.type = node? node.nodeType : 0;
		this.name = (node && node.nodeType == 1)? (node.nodeName || "") : "";
		return this;
	};
	
	XMLGetty.prototype = {
		'getValueOrDefault': function(val, defval) {
			if (val === "") {
				return defval;
			} else {
				if (typeof(defval) === 'number') {
					return (isNaN(val) ? 0 : parseInt(val));
				} else if (typeof(defval) === 'boolean') {
					return !!val;
				} else {
					return val;
				}
			}
		},
			
		'xText': function(defval){
			defval = defval || "";
			var val = this.text;
			val = (val || "").trim();
			
			return this.getValueOrDefault(val, defval);
		},
		'xAttr': function(name, defval){
			defval = defval || "";
			var attr = this.getAttributeNode(name);
			var val = (!attr) ? "" : attr.nodeValue.trim();

			return this.getValueOrDefault(val, defval);
		},
		'xGet': function(path){
			return xGetty(this, path);
		},
		'xGets': function(path){
			return xGetties(this, path);
		}
	};
	
	var ieXmlParsers = [
		"MSXML2.DOMDocument.6.0",
		"MSXML2.DOMDocument.5.0",
		"MSXML2.DOMDocument.4.0",
		"MSXML4.DOMDocument",
		"MSXML3.DOMDocument",
		"MSXML2.DOMDocument",
		"MSXML.DOMDocument",
		"Microsoft.XmlDom"
	];
	/**
	 * xCreate : Get XML DOM From XML Text
	 * @example
	 * var _xmlDoc = xCreate("<data><name>hopeserver</name></data>");
	 * 
	 * @param {string} text - responseText
	 * @return node 
	 * 			extend function as xText, xAttr, xGet, xGets
	 */
	_WIN.xCreate = function(text) {
		if($tx.msie) {
			var xObj = (function() {
				var _xObj = _NULL;
				for(var i=0; i<ieXmlParsers.length; i++) {
					try {
						_xObj = new ActiveXObject(ieXmlParsers[i]);
					} catch (e) {}
					if(_xObj !== _NULL) {
						return _xObj;
					}
				}
				return _NULL;
			})();
			if(xObj === _NULL){
				return _NULL;
			}
			xObj.async = _FALSE;
			xObj.loadXML(text);
			if (xObj.parseError.errorCode !== 0) {
				return _NULL;
			}
			return new XMLGetty(xObj);
		} else {
			var oParser = new DOMParser();
			var xObj = oParser.parseFromString(new String(text), "text/xml");
			return new XMLGetty(xObj);
		}
	};

	/**
	 * xGetty : Get Node By Xpath
	 * @example
	 * var _node = xGetty(node, "/rss/items/title")
	 * 
	 * @param {element} node - node
	 * @param {string} path - xpath expression
	 * 
	 * @return node 
	 * 			node extends function as xText, xAttr, xGet, xGets
	 */
	_WIN.xGetty = function(node, path) {
		if(node === _NULL) {
			return _NULL;
		}
		return new XMLGetty(node.selectSingleNode(path));
	};
	
	/**
	 * xGetties : Get Node List By Xpath
	 * @example
	 * var _nodelist = xGetties(node, "/rss/items/title")
	 * 
	 * @param {element} node - node
	 * @param {string} path - xpath expression
	 * 
	 * @return node array
	 * 			each node extends function as xText, xAttr, xGet, xGets
	 */
	_WIN.xGetties = function(node, path) {
		if(node === _NULL) {
			return [];
		}
		var list = [];
		var nodes = node.selectNodes(path);
		for(var i=0, len=nodes.length; i<len; i++) {
			list.push(new XMLGetty(nodes[i]));
		}
		return list;
	};

})();
function extend(dest, org) {
    for (var key in org) {
        dest[key] = org[key];
    }
    return dest;
}
var FontCssProperty = function() {
    this.empty = true;
    this.shorthand = false;
    this.properties = {};
};

FontCssProperty.TAGS_FOR_PRESENTATION = {
    U: { textDecoration: "underline" },
    B: { fontWeight: "bold" },
    STRONG: { fontWeight: "bold" },
    I: { fontStyle: "italic" },
    EM: { fontStyle: "italic" },
//    SUB: { fontSize: "smaller", verticalAlign: "sub"},
//    SUP: { fontSize: "smaller", verticalAlign: "super"},
//    BIG: { fontSize: "larger" },
//    SMALL: { fontSize: "smaller" },
    S: { textDecoration: "line-through" },
    STRIKE: { textDecoration: "line-through" },
    INS: { textDecoration: "underline" },
    DEL: { textDecoration: "line-through" },
    FONT: function(attributes) {
        var result = {};
        if (attributes.face) {
            result.fontFamily = attributes.face;
        }
        if (attributes.color) {
            result.color = attributes.color;
        }

        var fontSizeMap = ["", "x-small", "small", "medium", "large", "x-large", "xx-large"];
        if (attributes.size) {
            var fontSize = attributes.size;
            result.fontSize = isNaN(fontSize) ?
                fontSize : fontSizeMap[Math.min(Math.max(1, fontSize), 6)];
        }
        return result;
    }
};

FontCssProperty.FONT_RELATED_CSS_PROPERTIES = {
    "font": "font",
    "font-style": "fontStyle",
    "font-weight": "fontWeight",
    "font-size": "fontSize",
    "font-family": "fontFamily",
    "text-decoration": "textDecoration",
    "color": "color",
    "background-color": "backgroundColor"
};

FontCssProperty.create = function(nodeName, attributes) {
    var fontCssProperty = new FontCssProperty();
    var elemStyle = FontCssProperty.TAGS_FOR_PRESENTATION[nodeName];
    if (elemStyle) {
        var fontTagStyle = (typeof elemStyle == "function") ? elemStyle(attributes) : elemStyle;
        for (var name in fontTagStyle) {
            fontCssProperty.setProperty(name, fontTagStyle[name]);
        }
    }
    var cssText = attributes.style;
    if (cssText) {
        cssText = cssText.replace(/[\w-]+:\s?;/g, "");
        var properties = cssText.split(/; ?|: ?/);
        for (var i = 0; i < properties.length - 1; i += 2) {
            var styleName = FontCssProperty.FONT_RELATED_CSS_PROPERTIES[properties[i].toLowerCase()];
            if (styleName) {
                // block\uc5d0 \uc9c0\uc815\ub41c backgroundColor style\uc740 \uac00\uc838\uc624\uc9c0 \uc54a\ub294\ub2e4.
                // TODO font related tags
                if (styleName != "backgroundColor" || (FontCssProperty.TAGS_FOR_PRESENTATION[nodeName] || nodeName == "SPAN")) {
                    fontCssProperty.setProperty(styleName, properties[i + 1]);
                }
            }
        }
    }
    return fontCssProperty.getComputedStyles();
};

FontCssProperty.FONT_CSS_REGEXP = /(.*?)(\w+)(\/\w+)?\s+(['"]?[\w\uac00-\ud7a3]+['"]?)$/;
FontCssProperty.NORMAL_VALUE = "normal";

FontCssProperty.prototype.isEmpty = function() {
    return this.empty;
};

FontCssProperty.prototype.setProperty = function(name, value) {
    if (/^font$/i.test(name)) {
        // because of opera
        var parsedProperties = this.fromShorthand(value);
        if (parsedProperties) {
            this.shorthand = true;
            extend(this.properties, this.fromShorthand(value));
        }
    } else {
        this.properties[name] = value;
    }
    this.empty = false;
};

FontCssProperty.prototype.getComputedStyles = function() {
    if (this.shorthand) {
        return this.toShorthand();
    } else {
        return extend({}, this.properties);
    }
};

FontCssProperty.prototype.fromShorthand = function(fontCssText) {
    // parse extra font-families
    var indexOfComma = fontCssText.indexOf(","), extraFontFamilies = "";
    if (indexOfComma > 0) {
        extraFontFamilies = fontCssText.substring(indexOfComma);
        fontCssText = fontCssText.substring(0, indexOfComma);
    }
    var splittedProperties = fontCssText.match(FontCssProperty.FONT_CSS_REGEXP);
    if (splittedProperties === _NULL) {  // invalid font css property value
        return _NULL;
    }
    var NORMAL = FontCssProperty.NORMAL_VALUE;
    // parse main properties
    var properties = {
        fontSize: splittedProperties[2],
        lineHeight: (splittedProperties[3] || NORMAL).replace("/", ""),
        fontFamily: splittedProperties[4] + extraFontFamilies,
        fontWeight: NORMAL,
        fontStyle: NORMAL,
        fontVariant: NORMAL
    };
    // parse optional properties
    var optionalProperties = splittedProperties[1];
    if (/bold|700/i.test(optionalProperties)) {
        properties.fontWeight = "bold";
    }
    if (/italic/i.test(optionalProperties)) {
        properties.fontStyle = "italic";
    }
    if (/small-caps/i.test(optionalProperties)) {
        properties.fontVarient = "small-caps";
    }
    return properties;
};

FontCssProperty.prototype.toShorthand = function() {
    var propertiesClone = extend({}, this.properties);
    var NORMAL = FontCssProperty.NORMAL_VALUE;
    var validFontProperties = [];
    ["fontWeight", "fontStyle", "fontVarient"].each(function(name) {
        if (propertiesClone[name] != NORMAL) {
            validFontProperties.push(propertiesClone[name]);
        }
    });
    if (propertiesClone.lineHeight != NORMAL) {
        validFontProperties.push(propertiesClone.fontSize + "/" + propertiesClone.lineHeight);
    } else {
        validFontProperties.push(propertiesClone.fontSize);
    }
    validFontProperties.push(propertiesClone.fontFamily);
    ["fontWeight", "fontStyle", "fontVarient", "fontSize", "lineHeight", "fontFamily"].each(function(name) {
        delete propertiesClone[name];
    });
    var result = { font: validFontProperties.join(" ") };
    result = extend(result, propertiesClone);
    return result;
};
/**
 * @fileoverview  
 * Trex \uc815\uc758
 */

/** @namespace */
var Trex = {
	__WORD_JOINER: "\ufeff",
	__WORD_JOINER_REGEXP: /\ufeff/g,
    __WAITING_IMG_SRC: 'data:image/gif;base64,R0lGODlhEAAQAOUdAOvr69HR0cHBwby8vOzs7PHx8ff397W1tbOzs+Xl5ebm5vDw8PPz88PDw7e3t+3t7dvb2+7u7vX19eTk5OPj4+rq6tbW1unp6bu7u+fn5+jo6N/f3+/v7/7+/ra2ttXV1f39/fz8/Li4uMXFxfb29vLy8vr6+sLCwtPT0/j4+PT09MDAwL+/v7m5ubS0tM7OzsrKytra2tTU1MfHx+Li4tDQ0M/Pz9nZ2b6+vgAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFMAA5ACwAAAAAEAAQAAAGg8CcMAcICAY5QsEwHBYPCMQhl6guGM5GNOqgVhMPbA6y5Xq/kZwkN3Fsu98EJcdYKCo5i7kKwCorVRd4GAg5GVgAfBpxaRtsZwkaiwpfD0NxkYl8QngARF8AdhmeDwl4pngUCQsVHDl2m2iveDkXcZ6YTgS3kAS0RKWxVQ+/TqydrE1BACH5BAkwADkALAAAAAAQABAAAAZ+wJwwJ1kQIgNBgDMcdh6KRILgQSAOn46TIJVSrdZGSMjpeqtgREAoYWi6BFF6xCAJS6ZyYhEIUwxNQgYkFxwBByh2gU0kKRVHi4sgOQuRTRJtJgwSBJElihwMQioqGmw5gEMLKk2AEkSBq4ElQmNNoYG2OVpDuE6Lrzmfp0NBACH5BAUwADkALAAAAAAQABAAAAaFwJwwJ1kQCDlCwTAcMh6KhDQnVSwYTkJ1un1gc5wtdxsh5iqaLbVKyVEWigq4ugZgTyiA9CK/JHIZWCsICCxpVWV/EzkHhAgth1UPQ4OOLXpScmebFA6ELHAZclBycXIULi8VZXCZawplFG05flWlakIVWravCgSaZ1CuksBDFQsAcsfFQQAh+QQJMAA5ACwAAAAAEAAQAAAGQcCccEgsGo/IpHLJzDGaOcKCCUgkAEuFNaFRbq1dJCxX2WKRCFdMmJiiEQjRp1BJwu8y5R3RWNsRBx9+SSsxgzlBACH5BAkwADkALAAAAAAQABAAAAaJwJwwJ1kQCDlCwTAcMh6KhDQnVSwYTkJ1un1gc5wtdxsh5iqaLbVKyTEWigq4ugZglRXpRX5J5DJYAFIAaVVlfhNrURqFVQ9DYhqCgzkzCGdnVQBwGRU0LQiXCRUAORQJCwAcOTChoYplBXIKLq6vUXRCCQ22olUEcroJB66KD8FNCjUrlxWpTUEAIfkEBTAAOQAsAAAAABAAEAAABobAnDAnWRAIOULBMBwyHoqENCdVLBhOQnW6fWBznC13G8nZchXNllql5Bg2xA1cZQOwShwCMdDkLgk5GVgAUgAie3syVDkTbFIaiIkIJ0NiGnp7HiNonRVVAHEuFjlQFVQVAI0JCzYjrKCPZQWnf1unYkMVWrFbBLVoUIaPD8C6CwCnAMhNQQA7',
	__KEY: {
		ENTER: '13',
		DELETE: '46',
		SPACE: '32',
		BACKSPACE: '8',
		TAB: '9',
		PASTE: '86', //+ ctrl
		CUT: '88' //+ ctrl
	},
	__EXCLUDE_IMG : [
		"txc-2image-c", "txc-3image-c", "txc-footnote", "txc-jukebox", "txc-movie", "txc-gallery", "txc-imazing", "txc-map",
		"txc-file",'txc-emo',"tx-entry-embed", "txc-bgm", "txc-pie"
	],
	I: {},
	X: {},
	define: function(destination, properties) {
		return Object.extend(destination, properties);
	},
	available: function(config, name) {
		if(!$tx("tx_" + name)){
			//
			return _FALSE;
		}
		if(!config){
			//
			return _FALSE;
		}
		if(config.use == _FALSE) {
			//
			return _FALSE;
		}
		return _TRUE;
	}
};

//oop
(function(Trex){

	function $$reference($instance) {
		var _$ref = $instance;
		while(_$ref.$reference) {
			_$ref = _$ref.$reference;
		}
		return _$ref;
	}
	
	function $$super($instance) {
		var _$superclass = $instance.constructor.superclass;
		if(_$superclass) {
			var _$initbak = _$superclass.prototype.initialize;
			_$superclass.prototype.initialize = function() {
				this.$reference = $instance;
			}; //fake initialize
			var _$superobj = new _$superclass();
			_$superclass.prototype.initialize = _$initbak;
			
			var _wrapFunc = function(name) {
				if(!_$superobj[name]) return _NULL;
				return function() {
					var _arguments = arguments;
					var _$reference = $$reference($instance);
					var _$superbak = _$reference.$super;
					_$reference.$super = _$superobj.$super;
					var _returns = _$superobj[name].apply(_$reference, _arguments);
					_$reference.$super = _$superbak;
					return _returns;
				};
			};
			
			var _$wrapobj = {};
			for(var _name in _$superobj) {
				if(_name.charAt(0) != '$') {
					if (typeof(_$superobj[_name]) == 'function') {
						_$wrapobj[_name] = _wrapFunc(_name);
					}
				}
			}
			$instance.$super = _$wrapobj;
		}
	}
	
	/**
	 * @namespace
	 * @name Trex.Class
	 */
	Trex.Class = /** @lends Trex.Class */ {
        single: function(properties){
            var _class = function() {
                if(this.constructor._single)
                    return this.constructor._single;
                var _proto = this.constructor.prototype; //NOTE: Cuz properties must not share
                for(var _name in _proto) {
                    if(_proto[_name] && typeof(_proto[_name]) === 'object') {
                        if(_proto[_name].constructor == Array) { //Array
                            this[_name] = [].concat(_proto[_name]);
                        } else {
                            this[_name] = Object.extend({}, _proto[_name]);
                        }
                    }
                }
                $$super(this);
                var _arguments = arguments;
                this.initialize.apply(this, _arguments);
                this.constructor._single = this;
            };
            return Trex.Class.draft(properties, _class);
        },
		/**
		 * creates class 
		 * @param {Object} properties
		 */
		create: function(properties) {
			var _class = function() {
				var _proto = this.constructor.prototype; //NOTE: Cuz properties must not share
				for(var _name in _proto) {
					if(_proto[_name] && typeof(_proto[_name]) === 'object') {
						if(_proto[_name].constructor == Array) { //Array
							this[_name] = [].concat(_proto[_name]);
						} else {
							this[_name] = Object.extend({}, _proto[_name]);
						}
					}
				}
				$$super(this);
				var _arguments = arguments;
				this.initialize.apply(this, _arguments);
			};
			return Trex.Class.draft(properties, _class);
		},
		draft: function(properties, aClass) {
			var _class = aClass ? 
				aClass : 
				function() {
					$$super(this);
				}; 
			
			if(properties.$const) {
				Object.extend(_class, properties.$const);
			}
			
			if(properties.$extend) {
				Object.extend(_class.prototype, properties.$extend.prototype);
				_class.superclass = properties.$extend;
			}
			
			if(properties.$mixins) {
				var sources = $A(properties.$mixins);
				sources.each(function(source) {
					Object.extend(_class.prototype, source);
				});
			}
			for(var _name in properties) {
				if(_name.charAt(0) != '$') {
					_class.prototype[_name] = properties[_name];
				}
			}
			return _class;
		},
		overwrite: function(source, properties) {
            if(source.prototype) {
				Object.extend(source.prototype, properties);
			}
			return source;
		}
	};
	
	/**
	 * @namespace
	 * @name Trex.Faculty, Trex.Mixin
	 */
	Trex.Mixin = Trex.Faculty = /** @lends Trex.Mixin */ {
		/**
		 * Creates  
		 * @param {Object} properties
		 */
		create: function(properties) {
			var _class = {};
			for(var _name in properties) {
				if(properties[_name] && typeof(properties[_name]) === 'object') {
					if(properties[_name].constructor == Array) { //Array
						_class[_name] = [].concat(properties[_name]);
					} else {
						_class[_name] = Object.extend({}, properties[_name]);
					}
				} else {
					_class[_name] = properties[_name];
				}
			}
			return _class;
		},
		toClass: function(properties, initializeFunc) {
			return Trex.Class.create(
				Object.extend({
					initialize: initializeFunc? initializeFunc: function() {}
				}, properties)
			);
		}
	};
})(Trex);

//module
(function(Trex){
	Object.extend(Trex, /** @lends Trex */ {
		installs: [],
		registers: [],
		modules: [],
		modulesX: [],
		/**
		 * Installs component
		 * @param {Object} description
		 * @param {Object} fn
		 */
		install: function(description, fn){
			fn.desc = '[install] ' + description;
			Trex.installs.push(fn);	
		},
		register: function(description, fn){
			fn.desc = '[register] ' + description;
			Trex.registers.push(fn);	
		},
		module: function(description, fn){
			//
			fn.desc = '[module] ' + description;
			Trex.modules.push(fn);
		},
		moduleX: function(description, fn){
			fn.desc = '[moduleX] ' + description;
			Trex.modulesX.push(fn);
		},
		invoke: function(fns, editor, toolbar, sidebar, canvas, config){
			for(var i=0,len=fns.length; i<len; i++){
				var fn = fns[i];
				fn(editor, toolbar, sidebar, canvas, config);
			}
		},
		invokeInstallation: function(editor, toolbar, sidebar, canvas, config){
			Trex.invoke(Trex.installs, editor, toolbar, sidebar, canvas, config);
		},
		invokeRegisters: function(editor, toolbar, sidebar, canvas, config){
			Trex.invoke(Trex.registers, editor, toolbar, sidebar, canvas, config);
		},
		invokeModules: function(editor, toolbar, sidebar, canvas, config){
			Trex.invoke(Trex.modules, editor, toolbar, sidebar, canvas, config);
		},
		group: function(){},
		groupEnd: function(){}
	});
})(Trex);

_WIN.Trex = Trex;
/**
 * @fileoverview  
 * \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8\ub97c \ubbf8\ub9ac \uc815\uc758
 */

(function(Trex) {
	/**
	 *  @namespace 
	 *  @name Trex.Ev
	 */
	Trex.Ev = /** @lends Trex.Ev */ {
		/** wysiwyg mode */
		__EDITOR_PANEL_MOUSEDOWN: 'editor.panel.mousedown',
        /**
         * Editor\uc5d0 \ub370\uc774\ud130\uc758 \uc14b\ud305\uc774 \uc2dc\uc791\ub418\uba74 \ubc1c\uc0dd\ud558\ub294 \uc774\ubca4\ud2b8
         * @example
         * 	editor.observeJob(Trex.Ev.__EDITOR_LOAD_DATA_BEGIN, function(ev) {
		 *	});
         */
        __EDITOR_LOAD_DATA_BEGIN: 'editor.load.data.begin',
        /**
         * Editor\uc5d0 \ub370\uc774\ud130\uc758 \uc14b\ud305\uc774 \uc644\ub8cc\ub418\uba74 \ubc1c\uc0dd\ud558\ub294 \uc774\ubca4\ud2b8
         * @example
         * 	editor.observeJob(Trex.Ev.__EDITOR_LOAD_DATA_END, function(ev) {
		 *	});
         */
        __EDITOR_LOAD_DATA_END: 'editor.load.data.end',
		/**
		 * wysiwyg \uc601\uc5ed\uc5d0 \ubc1c\uc0dd\ud558\ub294 keydown \uc774\ubca4\ud2b8
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_KEYDOWN, function(ev) {
		 *	});
		 */
		__CANVAS_PANEL_KEYDOWN: 'canvas.panel.keydown',
		/** 
		 * wysiwyg \uc601\uc5ed\uc5d0 \ubc1c\uc0dd\ud558\ub294 keyup \uc774\ubca4\ud2b8
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_KEYUP, function(ev) {
		 *	});
		 */
		__CANVAS_PANEL_KEYUP: 'canvas.panel.keyup',
		/** 
		 * wysiwyg \uc601\uc5ed\uc5d0 \ubc1c\uc0dd\ud558\ub294 mousedown \uc774\ubca4\ud2b8<br/>
		 * Element Observer \ubcf4\ub2e4 \ub2a6\uac8c \uc2e4\ud589\ub418\uba70, mouseclick \ubcf4\ub2e4 \uc55e\uc11c \uc2e4\ud589\ub41c\ub2e4.
		 * \uacbd\uc6b0\uc5d0 \ub530\ub77c \uc0c1\uc704 \uc5d8\ub9ac\uba3c\ud2b8\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uc5ec \uc2e4\ud589\ud558\ub294 Element Observer\ub97c \uc0ac\uc6a9\ud55c\ub2e4.
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEDOWN, function(ev) {
		 *		//execute function
		 *	});
		 *  canvas.observeElement({ tag: "img", klass: "txc-image" }, function(element) {
		 *		//execute function with element
		 *	});
		 */
		__CANVAS_PANEL_MOUSEDOWN: 'canvas.panel.mousedown',
		/** 
		 * wysiwyg \uc601\uc5ed\uc5d0 \ubc1c\uc0dd\ud558\ub294 mouseup \uc774\ubca4\ud2b8
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEUP, function(ev) {
		 *	});
		 */
		__CANVAS_PANEL_MOUSEUP: 'canvas.panel.mouseup',
		/** 
		 * wysiwyg \uc601\uc5ed\uc5d0 \ubc1c\uc0dd\ud558\ub294 mouseover \uc774\ubca4\ud2b8<br/>
		 * wysiwyg \uc601\uc5ed\uc5d0\uc11c \ub9c8\uc6b0\uc2a4\ub97c \uc6c0\uc9c1\uc77c \ub54c\ub9c8\ub2e4 \ubc1c\uc0dd\ud558\ubbc0\ub85c \uacfc\ud558\uac8c \uc0ac\uc6a9\ud558\uc9c0 \uc54a\ub3c4\ub85d \ud55c\ub2e4.
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEOVER, function(ev) {
		 *	});
		 */
		__CANVAS_PANEL_MOUSEOVER: 'canvas.panel.mouseover',
		/** 
		 * wysiwyg \uc601\uc5ed\uc5d0 \ubc1c\uc0dd\ud558\ub294 mouseout \uc774\ubca4\ud2b8<br/>
		 * wysiwyg \uc601\uc5ed\uc5d0\uc11c \ub9c8\uc6b0\uc2a4\ub97c \uc6c0\uc9c1\uc77c \ub54c\ub9c8\ub2e4 \ubc1c\uc0dd\ud558\ubbc0\ub85c \uacfc\ud558\uac8c \uc0ac\uc6a9\ud558\uc9c0 \uc54a\ub3c4\ub85d \ud55c\ub2e4.
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEOUT, function(ev) {
		 *	});
		 */
		__CANVAS_PANEL_MOUSEOUT: 'canvas.panel.mouseout',
        /**
         * wysiwyg \uc601\uc5ed\uc5d0 \ubc1c\uc0dd\ud558\ub294 movemove \uc774\ubca4\ud2b8<br/>
         * wysiwyg \uc601\uc5ed\uc5d0\uc11c \ub9c8\uc6b0\uc2a4\ub97c \uc6c0\uc9c1\uc77c \ub54c\ub9c8\ub2e4 \ubc1c\uc0dd\ud558\ubbc0\ub85c \uacfc\ud558\uac8c \uc0ac\uc6a9\ud558\uc9c0 \uc54a\ub3c4\ub85d \ud55c\ub2e4.
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEMOVE, function(ev) {
		 *	});
         */
        __CANVAS_PANEL_MOUSEMOVE: 'canvas.panel.mousemove',
		/** 
		 * wysiwyg \uc601\uc5ed\uc5d0 \ubc1c\uc0dd\ud558\ub294 click \uc774\ubca4\ud2b8
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_CLICK, function(ev) {
		 *	});
		 */
		__CANVAS_PANEL_CLICK: 'canvas.panel.click',
		/** 
		 * wysiwyg \uc601\uc5ed\uc5d0\uc11c \ubc1c\uc0dd\ud558\ub294 \ub354\ube14\ud074\ub9ad \uc774\ubca4\ud2b8<br/>
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_DBLCLICK, function(ev) {
		 *	});
         */
        __CANVAS_PANEL_DBLCLICK: 'canvas.panel.dbclick',
        /**
         * wysiwyg \uc601\uc5ed\uc5d0\uc11c \ubc1c\uc0dd\ud558\ub294 dragover \uc774\ubca4\ud2b8<br/>
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_DBLCLICK, function(ev) {
		 *	});
         */
        __CANVAS_PANEL_DRAGOVER: 'canvas.panel.dragover',
        /**
         * wysiwyg \uc601\uc5ed\uc5d0\uc11c \ubc1c\uc0dd\ud558\ub294 dragenter \uc774\ubca4\ud2b8<br/>
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_DRAGENTER, function(ev) {
		 *	});
         */
        __CANVAS_PANEL_DRAGENTER: 'canvas.panel.dragenter',
        /**
         * wysiwyg \uc601\uc5ed\uc5d0\uc11c \ubc1c\uc0dd\ud558\ub294 dragleave \uc774\ubca4\ud2b8<br/>
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_DRAGLEAVE, function(ev) {
		 *	});
         */
        __CANVAS_PANEL_DRAGLEAVE: 'canvas.panel.dragleave',
        /**
         * wysiwyg \uc601\uc5ed\uc5d0\uc11c \ubc1c\uc0dd\ud558\ub294 \ub4dc\ub86d \uc774\ubca4\ud2b8<br/>
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_DROP, function(ev) {
		 *	});
         */
        __CANVAS_PANEL_DROP: 'canvas.panel.drop',
		/** 
		 * wysiwyg \uc601\uc5ed\uc5d0\uc11c \ubc1c\uc0dd\ud558\ub294 \ubd99\uc5ec\ub123\uae30 \uc774\ubca4\ud2b8<br/>
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_PASTE, function() {
		 *	});
		 */
		__CANVAS_PANEL_PASTE: 'canvas.panel.paste',
		/** 
		 * wysiwyg \uc601\uc5ed\uc5d0\uc11c \ubc1c\uc0dd\ud558\ub294 \uc2a4\ud06c\ub864 \ubcc0\uacbd \uc774\ubca4\ud2b8<br/>
		 * \uc774 \uc774\ubca4\ud2b8\ub294 wysiwyg \uc601\uc5ed\uc758 \uc2a4\ud06c\ub864 \ub192\uc774\uac00 \ubcc0\uacbd\ub418\uac70\ub098 \uc704\uce58\uac00 \ubcc0\uacbd\ub420 \uacbd\uc6b0 \ubc1c\uc0dd\ud55c\ub2e4.
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_SCROLLING, function(ev) {
		 *	});
		 */
		__CANVAS_PANEL_SCROLLING: 'canvas.panel.scrolling',
		/** 
		 * wysiwyg \uc601\uc5ed\uc774 \ub85c\ub4dc\ub418\uc5c8\uc744 \uacbd\uc6b0 \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function(ev) {
		 *	});
		 */
		__IFRAME_LOAD_COMPLETE: 'iframe.load.complete',
        /**
         * wysiwyg \uc601\uc5ed\uc774 loading \ub418\uae30\uae4c\uc9c0 \uac78\ub9b0\uc2dc\uac04\uc744 \uc54c\ub9ac\ub294 \uc774\ubca4\ud2b8
         */
        __IFRAME_LOADING_TIME: 'iframe.loading.time',
		/** 
		 * HTML\ubaa8\ub4dc(\uc18c\uc2a4\ubaa8\ub4dc) \uc601\uc5ed\uc5d0\uc11c \ubc1c\uc0dd\ud558\ub294 click \uc774\ubca4\ud2b8
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_SOURCE_PANEL_CLICK, function(ev) {
		 *	});
		 */
		__CANVAS_SOURCE_PANEL_CLICK: 'canvas.source.panel.click',
		/** 
		 * HTML\ubaa8\ub4dc(\uc18c\uc2a4\ubaa8\ub4dc) \uc601\uc5ed\uc5d0\uc11c \ubc1c\uc0dd\ud558\ub294 keydown \uc774\ubca4\ud2b8
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_SOURCE_PANEL_KEYDOWN, function(ev) {
		 *	});
		 */
		__CANVAS_SOURCE_PANEL_KEYDOWN: 'canvas.source.panel.mousedown',
		/** 
		 * HTML\ubaa8\ub4dc(\uc18c\uc2a4\ubaa8\ub4dc) \uc601\uc5ed\uc5d0\uc11c \ubc1c\uc0dd\ud558\ub294 mousedown \uc774\ubca4\ud2b8
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_SOURCE_PANEL_MOUSEDOWN, function(ev) {
		 *	});
		 */
		__CANVAS_SOURCE_PANEL_MOUSEDOWN: 'canvas.source.panel.mousedown',
		/** 
		 * \ud14d\uc2a4\ud2b8\ubaa8\ub4dc \uc601\uc5ed\uc5d0\uc11c \ubc1c\uc0dd\ud558\ub294 click \uc774\ubca4\ud2b8
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_TEXT_PANEL_CLICK, function(ev) {
		 *	});
		 */
		__CANVAS_TEXT_PANEL_CLICK: 'canvas.text.panel.click',
		/** 
		 * \ubaa8\ub4dc\uac00 \ubcc0\uacbd\ub420 \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_MODE_CHANGE, function(from, to) {
		 *		//from - \ubcc0\uacbd\ub418\uae30 \uc804 \ubaa8\ub4dc
		 *		//to - \ubcc0\uacbd\ub418\uace0\ub09c \ud6c4 \ubaa8\ub4dc
		 *	});
		 */
		__CANVAS_MODE_CHANGE: 'canvas.mode.change',
        /**
         * \uc804\uccb4\ud654\uba74\uc6a9 canvas\ub85c \ubcc0\uacbd \uc2dc \ubc1c\uc0dd
         */
        __CANVAS_FULL_SCREEN_CHANGE: 'canvas.fullscreen.change',
        /**
         * \uc77c\ubc18\ud654\uba74\uc6a9 canvas\ub85c \ubcc0\uacbd \uc2dc \ubc1c\uc0dd
         */
        __CANVAS_NORMAL_SCREEN_CHANGE: 'canvas.normalscreen.change',
		/**
		 * \ud234\ubc14\uc758 \ubc84\ud2bc\uc774 \ub20c\ub838\uc744 \uacbd\uc6b0 \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__TOOL_CLICK, function(identity) {
		 *		//identity - tool\uc758 Identity(bold, aligncenter...)
		 *	});
		 */
		__TOOL_CLICK: 'toolbar.button.click',
        /**
         * \ud234\uc774 \ub2e8\ucd95\ud0a4\uc5d0 \uc758\ud574 \uc2e4\ud589 \ub418\uc5c8\uc744 \uacbd\uc6b0 \ubc1c\uc0dd
         */
        __TOOL_SHORTCUT_KEY: 'toolbar.shortcut',
		/** 
		 * Editor.save()\uac00 \ud638\ucd9c\ub418\uc5c8\uc744 \uacbd\uc6b0 \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8<br/>
		 * \uc2e4\uc81c form\uc774 submit\uc774 \ub418\uae30 \uc804\uc5d0 \ubc1c\uc0dd\ud55c\ub2e4.
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__ON_SUBMIT, function(editor) {
		 *		//editor - editor \uac1d\uccb4
		 *	});
		 */
		__ON_SUBMIT: "editor.submit",
		/** 
		 * \uc5d0\ub514\ud130 \ub798\ud37c\uc758 \ub108\ube44\uac00 \ubcc0\uacbd\ub41c \ud6c4 \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_WRAP_WIDTH_CHANGE, function() {
		 *	});
		 */
		__CANVAS_WRAP_WIDTH_CHANGE: 'canvas.wrap.width.change',
		/** 
		 * \uc5d0\ub514\ud130\uc758 \ub192\uc774\uac00 \ubcc0\uacbd\ub41c \ud6c4 \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_HEIGHT_CHANGE, function(height) {
		 *		//height - \ubcc0\uacbd\ub41c \ub192\uc774
		 *	});
		 */
		__CANVAS_HEIGHT_CHANGE: 'canvas.height.change',
		/** 
		 * wysiwyg \uc601\uc5ed\uc5d0\uc11c \ud0a4\uc774\ubca4\ud2b8\ub098 \ub9c8\uc6b0\uc2a4\uc774\ubca4\ud2b8\uac00 \ubc1c\uc0dd\ud560 \uacbd\uc6b0 \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8<br/>
		 * \uc8fc\ub85c \ud234\ubc14 \ubc84\ud2bc\uc758 \uc0c1\ud0dc\ub97c \ud45c\uc2dc\ud560 \ub54c\uc5d0 \uc0ac\uc6a9\ud55c\ub2e4.
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, function() {
		 *	});
		 */
		__CANVAS_PANEL_QUERY_STATUS: 'canvas.panel.style.change',
		/** 
		 * wysiwyg \uc601\uc5ed\uc5d0\uc11c delete \ud0a4\uac00 \ub20c\ub838\uc744 \uacbd\uc6b0 \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8<br/>
		 * \uc8fc\ub85c \ucee8\ud150\uce20\uc640 \ub3d9\uae30\ud654\ub97c \ub9de\ucd94\uae30 \uc704\ud574 \uc0ac\uc6a9\ud55c\ub2e4.
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_DELETE_SOMETHING, function() {
		 *	});
		 */
		__CANVAS_PANEL_DELETE_SOMETHING: 'canvas.panel.delkey.press',
		/** 
		 * Entry Box\uc5d0 Entry\uac00 \ucd94\uac00\ub418\uc5c8\uc744 \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @example
		 * 	attachbox.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_ADDED, function(entry) {
		 *		//\uc0dd\uc131\ub41c entry \uac1d\uccb4\ub97c \uc778\uc790\ub85c \ubc1b\ub294\ub2e4.
		 *	});
		 */
		__ENTRYBOX_ENTRY_ADDED: 'entrybox.entryadded',
        /**
         * wysiwyg \uc601\uc5ed\uc5d0\uc11c backspace \ud0a4\uac00 \ub20c\ub838\uc744 \uacbd\uc6b0 \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8<br/>
         * \ud14c\uc774\ube14 \uc0ad\uc81c\ub97c \uc704\ud574 \uc0ac\uc6a9\ud55c\ub2e4.
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_PANEL_BACKSPACE_TABLE, function() {
		 *	});
         */
        __CANVAS_PANEL_BACKSPACE_TABLE: 'canvas.panel.backspace.table',
		/** 
		 * Entry Box\uc758 Entry\uac00 \uc218\uc815\ub418\uc5c8\uc744 \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @example
		 * 	attachbox.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_MODIFIED, function(entry) {
		 *		//\uc218\uc815\ub41c entry \uac1d\uccb4\ub97c \uc778\uc790\ub85c \ubc1b\ub294\ub2e4.
		 *	});
		 */
		__ENTRYBOX_ENTRY_MODIFIED: 'entrybox.entrymodified',
		/** 
		 * Entry Box\uc5d0\uc11c Entry\uac00 \uc81c\uac70\ub418\uc5c8\uc744 \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @example
		 * 	attachbox.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_REMOVED, function(entry) {
		 *		//\uc0ad\uc81c\ub420 entry \uac1d\uccb4\ub97c \uc778\uc790\ub85c \ubc1b\ub294\ub2e4.
		 *	});
		 */
		__ENTRYBOX_ENTRY_REMOVED: 'entrybox.entryremoved',
		/** 
		 * Entry Box\uc5d0\uc11c \ubaa8\ub4e0 Entry\uac00 \uc81c\uac70\ub418\uc5c8\uc744 \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @example
		 * 	attachbox.observeJob(Trex.Ev.__ENTRYBOX_ALL_ENTRY_REMOVED, function() {
		 *	});
		 */
		__ENTRYBOX_ALL_ENTRY_REMOVED: 'entrybox.removed.all.perfectly',
        /**
		 * Entry Box\uc5d0\uc11c Entry\uc758 \ucd94\uac00/\uc218\uc815/\uc0ad\uc81c\ub85c capacity\uac00 \ubcc0\uacbd \ub420 \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @example
		 * 	attachbox.observeJob(Trex.Ev.__ENTRYBOX_CAPACITY_UPDATE, function(capacity) {
		 *	});
		 */
		__ENTRYBOX_CAPACITY_UPDATE: 'entrybox.capacity.update',
		/** 
		 * Attach Box\uac00 \ubcf4\uc5ec\uc9c8 \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @example
		 * 	attachbox.observeJob(Trex.Ev.__ATTACHBOX_SHOW, function() {
		 *	});
		 */
		__ATTACHBOX_SHOW: 'attachbox.show',
		/** 
		 * Attach Box\uac00 \uac10\ucdb0\uc9c8 \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @example
		 * 	attachbox.observeJob(Trex.Ev.__ATTACHBOX_HIDE, function() {
		 *	});
		 */
		__ATTACHBOX_HIDE: 'attachbox.hide',
        /**
         * fullscreen \uc0c1\ud0dc\uc5d0\uc11c Attach Box\uac00 \ubcf4\uc5ec\uc9c8 \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
         * @example
         * 	attachbox.observeJob(Trex.Ev.__ATTACHBOX_FULLSCREEN_SHOW, function() {
		 *	});
         */
        __ATTACHBOX_FULLSCREEN_SHOW: 'attachbox.fullscreen.show',
        /**
         * fullscreen \uc0c1\ud0dc\uc5d0\uc11c Attach Box\uac00 \uac10\ucdb0\uc9c8 \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
         * @example
         * 	attachbox.observeJob(Trex.Ev.__ATTACHBOX_FULLSCREEN_HIDE, function() {
		 *	});
         */
        __ATTACHBOX_FULLSCREEN_HIDE: 'attachbox.fullscreen.hide',
		/** 
		 * \uc5d0\ub514\ud130 \ud398\uc774\uc9c0\ub97c \ubc97\uc5b4\ub098\uae30 \uc804\uc5d0 \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @example
		 * 	canvas.observeJob(Trex.Ev.__CANVAS_BEFORE_UNLOAD, function() {
		 *	});
		 */
		__CANVAS_BEFORE_UNLOAD: 'canvas.unload',
		/** 
		 * \uac01 \ucca8\ubd80\uac00 \ucd94\uac00\ub420 \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8<br/>
		 * entry\uac00 \uc0dd\uc131\ub418\uace0 \ubcf8\ubb38\uc5d0 \uc0bd\uc785\uc774 \uc644\ub8cc\ub418\uace0 \ud638\ucd9c\ub41c\ub2e4.
		 * \uc2e4\uc81c\ub85c\ub294 entry \ubd80\ubd84\uc774 \ucca8\ubd80\uc758 Identity(image, movie, media...)\ub85c \ub300\uccb4\ub41c\ub2e4.
		 * @abstract
		 * @example
		 * 	canvas.observeJob('canvas.movie.added', function(entry) {
		 *		//\uc0dd\uc131\ub41c entry \uac1d\uccb4\ub97c \uc778\uc790\ub85c \ubc1b\ub294\ub2e4.
		 *	});
		 */
		__CANVAS_ENTRY_ADDED: 'canvas.entry.added',
		/** 
		 * \ud234\uc744 \uc774\uc6a9\ud574 wysiwyg\uc5d0 \uc694\uc18c\uac00 \uc0bd\uc785\uc774 \ub420 \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @abstract
		 * @example
		 * 	toolbar.observeJob('cmd.textbox.added', function(node) {
		 *		//\ud544\uc694\uc5d0 \ub530\ub77c \ub9cc\ub4e4\uc5b4\uc9c4 \uc694\uc18c \uc5d8\ub9ac\uba3c\ud2b8
		 *	});
		 */
		__COMMAND_NODE_ADDED: 'cmd.entry.added',
		/** 
		 * \uc67c\ucabd \uc815\ub82c\uc744 \uc2e4\ud589\ud558\uace0\uc11c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @private
		 */
		__CMD_ALIGN_LEFT: 'align.left',
		/** 
		 * \uac00\uc6b4\ub370 \uc815\ub82c\uc744 \uc2e4\ud589\ud558\uace0\uc11c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @private
		 */
		__CMD_ALIGN_CENTER: 'align.center',
		/** 
		 * \uc624\ub978\ucabd \uc815\ub82c\uc744 \uc2e4\ud589\ud558\uace0\uc11c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @private
		 */
		__CMD_ALIGN_RIGHT: 'align.right',
		/** 
		 * \uc591\ucabd \uc815\ub82c\uc744 \uc2e4\ud589\ud558\uace0\uc11c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @private
		 */
		__CMD_ALIGN_FULL: 'align.full',
		/** 
		 * \uc774\ubbf8\uc9c0 \uc67c\ucabd \uc815\ub82c\uc744 \uc2e4\ud589\ud558\uace0\uc11c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @private
		 */
		__CMD_ALIGN_IMG_LEFT: 'align.img.left',
		/** 
		 * \uc774\ubbf8\uc9c0 \uac00\uc6b4\ub370 \uc815\ub82c\uc744 \uc2e4\ud589\ud558\uace0\uc11c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @private
		 */
		__CMD_ALIGN_IMG_CENTER: 'align.img.center',
		/** 
		 * \uc774\ubbf8\uc9c0 \uc67c\ucabd\ud750\ub984 \uc815\ub82c\uc744 \uc2e4\ud589\ud558\uace0\uc11c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @private
		 */
		__CMD_ALIGN_IMG_FLOAT_LEFT: 'align.img.floatleft',
		/** 
		 * \uc774\ubbf8\uc9c0 \uc624\ub978\ucabd\ud750\ub984 \uc815\ub82c\uc744 \uc2e4\ud589\ud558\uace0\uc11c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @private
		 */
		__CMD_ALIGN_IMG_FLOAT_RIGHT: 'align.img.floatright',
        /**
         * table \uac00\uc6b4\ub370 \uc815\ub82c\uc744 \uc2e4\ud589\ud558\uace0\uc11c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
         * @private
         */
        __CMD_ALIGN_TABLE_CENTER: 'align.table.center',
        /**
         * table \uc624\ub978\ucabd\ud750\ub984 \uc815\ub82c\uc744 \uc2e4\ud589\ud558\uace0\uc11c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
         * @private
         */
        __CMD_ALIGN_TABLE_FLOAT_RIGHT: 'align.table.right',
        /**
         * table \uc67c\ucabd\ud750\ub984 \uc815\ub82c\uc744 \uc2e4\ud589\ud558\uace0\uc11c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
         * @private
         */
        __CMD_ALIGN_TABLE_FLOAT_LEFT: 'align.table.left',
        /**
         * \ud14c\uc774\ube14 \uc67c\ucabd \uc815\ub82c\uc744 \uc2e4\ud589\ud558\uace0\uc11c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
         * @private
         */
        __CMD_ALIGN_TABLE_LEFT: 'align.table.none',
        /**
         * \ud234\ubc14\uc758 \ucd95\uc18c\ub97c\uc744 \uc2e4\ud589\ud558\uace0 \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
         */
        __CMD_ADVANCED_FOLD: 'toolbar.advanced.fold',
        /**
         * \ud234\ubc14\uc758 \ud655\uc7a5\uc744 \uc2e4\ud589\ud558\uace0 \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
         */
        __CMD_ADVANCED_SPREAD: 'toolbar.advanced.spread',
		/**
		 * table \uc758 border \ub97c \uc870\uc815\ud558\ub294 \uc138\uac00\uc9c0 \uc18d\uc131\uc911\uc5d0 \ud55c\uac00\uc9c0\uac00 \ubcc0\uacbd\ub420 \ub54c \ubc1c\uc0dd\ud568.
		 * border \uc758 \uc138\uac00\uc9c0 \uc18d\uc131: cellslinecolor, cellslineheight, cellslinestyle.
		 * @private
		 */
		__TOOL_CELL_LINE_CHANGE: 'tool.cell.line.change',
		/** 
		 * \uc5d0\ub514\ud130 \ub85c\ub529\ud560 \ub54c \ud604\uc7ac \ubaa8\ub4dc\uc640 config\uc758 \ubaa8\ub4dc\uac00 \ub2e4\ub97c \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @private
		 */
		__CANVAS_MODE_INITIALIZE: 'canvas.mode.initialize',
		/** 
		 * \uc5d0\ub514\ud130 \ub85c\ub529\ud560 \ub54c \ucee8\ud150\uce20\ub97c \ucd08\uae30\ud654\ud55c \ud6c4 \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @private
		 */
		__CANVAS_DATA_INITIALIZE: 'canvas.load.data',
		/** 
		 * Attach Box\uc758 ENTRY\uc758 \uc0c1\ud0dc\uac00 \ubcc0\uacbd\ub420 \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @private
		 */
		__ENTRYBOX_ENTRY_REFRESH: 'entrybox.entryrefresh',
		/** 
		 * \uc815\ubcf4\ucca8\ubd80\uac00 \uc0bd\uc785\ub420 \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @private
		 */
		__PASTE_SEARCHRESULT: 'trex.paste.info',
		/** 
		 * \uc5d0\ub514\ud130\uc5d0\uc11c \ub7f0\ud0c0\uc784\uc5d0\ub7ec\uac00 \ub0ac\uc744 \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
		 * @private
		 */
		__RUNTIME_EXCEPTION: "editor.runtime.exception",
		/** 
		 * \uc5d0\ub514\ud130 \uc7a5\uc560 \ub85c\uadf8\ub97c \ub0a8\uae38 \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8<br/>
		 * \ub85c\uadf8\ub97c \uc804\uc1a1\ud55c \ud6c4 \uc2e4\ud589 \ub41c\ub2e4.
		 * @private
		 */
        __REPORT_TO_MAGPIE: "editor.report.magpie",
        /**
         * \uc790\ub3d9\uc800\uc7a5 \ub9ac\uc2a4\ud2b8\ub97c \uc5f4 \ub54c \ubc1c\uc0dd\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \uc774\ubca4\ud2b8
         * @private
         */
        __SHOULD_CLOSE_MENUS: "editor.shouldclosemenus",
        /**
         * wysiwyg \uc601\uc5ed\uc5d0\uc11c \ubc1c\uc0dd\ud558\ub294 \uc774\ubbf8\uc9c0\uc758 \ub354\ube14\ud074\ub9ad \uc774\ubca4\ud2b8<br/>
         * @example
         * 	canvas.observeJob(Trex.Ev.__CANVAS_IMAGE_PLACEHOLDER_DBLCLICK, function(ev) {
		 *	});
         */
        __CANVAS_IMAGE_PLACEHOLDER_DBLCLICK: 'canvas.image.placeholder.dbclick',
        /**
         * \ud234\ubc14\uc758 \ub808\uc774\uc5b4\ud615 \uba54\ub274\uac00 \ud654\uba74\uc5d0 \ud45c\uc2dc\ub418\uba74 \ud638\ucd9c.
         */
        __MENU_LAYER_SHOW: 'menu.layer.show',
        /**
         * \ud234\ubc14\uc758 \ub808\uc774\uc5b4\ud615 \uba54\ub274\uac00 \ud654\uba74\uc5d0 \uc0ac\ub77c\uc9c0\uba74 \ud638\ucd9c.
         */
        __MENU_LAYER_HIDE: 'menu.layer.hide',
        /**
         * \ud234\ubc14\uc758 \ub808\uc774\uc5b4\ud615 \uba54\ub274\uc758 \ud06c\uae30\uac00 \ubcc0\uacbd\ub418\uba74 \ud638\ucd9c.
         */
        __MENU_LAYER_CHANGE_SIZE: 'menu.layer.change.size',

        /**
         * table, img\uac00 \uc120\ud0dd \ub41c \uacbd\uc6b0 \ud638\ucd9c
         */
        __CANVAS_SELECT_ITEM: 'canvas.select.item',
        __CANVAS_UNSELECT_ITEM: 'canvas.unselect.item'

	};
})(Trex);

/** @namespace */
var TrexEvent = {
	/**
	 * fires observer for target element 
	 * @param {Object} el
	 * @param {Object} handles
	 */
	fire: function(el, handles){
		if (el && el.tagName) {
			var fn = handles[el.tagName.toLowerCase()];
			if (fn) {
				fn(el, handles);
			}else {
				TrexEvent.propagateToParent(el, handles);
			}
		}else {
			
		}
	},
	propagateToParent : function(element, handles){
		var _el = element.parentNode;
		if(_el && _el.tagName && _el.tagName.toLowerCase ){
			var fn = handles[_el.tagName.toLowerCase()];
			if(fn){
				fn(_el, handles);
			}else{
				TrexEvent.propagateToParent(_el, handles);
			}
		}
	},
	stopPropagation : function(){ }
};


var textboxOption = function( data, padding, bgcolor, border ){
	return { 
		data: data, 
		style: { 
			padding:padding, backgroundColor:bgcolor, border:border 
		} 
	};
};
Trex.__CONFIG_COMMON = {
	thumbs: {
		options:[
			{color:"#FF0000"}, {color:"#FF5E00"}, {color:"#FFBB00"}, {color:"#FFE400"}, {color:"#ABF200"}, {color:"#1FDA11"}, {color:"#00D8FF"}, {color:"#0055FF"}, {color:"#0900FF"}, {color:"#6600FF"}, {color:"#FF00DD"}, {color:"#FF007F"}, {color:"#000000"}, {color:"#FFFFFF"},
			{color:"#FFD8D8"}, {color:"#FAE0D4"}, {color:"#FAECC5"}, {color:"#FAF4C0"}, {color:"#E4F7BA"}, {color:"#CEFBC9"}, {color:"#D4F4FA"}, {color:"#D9E5FF"}, {color:"#DAD9FF"}, {color:"#E8D9FF"}, {color:"#FFD9FA"}, {color:"#FFD9EC"}, {color:"#F6F6F6"}, {color:"#EAEAEA"},
			{color:"#FFA7A7"}, {color:"#FFC19E"}, {color:"#FFE08C"}, {color:"#FAED7D"}, {color:"#CEF279"}, {color:"#B7F0B1"}, {color:"#B2EBF4"}, {color:"#B2CCFF"}, {color:"#B5B2FF"}, {color:"#D1B2FF"}, {color:"#FFB2F5"}, {color:"#FFB2D9"}, {color:"#D5D5D5"}, {color:"#BDBDBD"},
			{color:"#F15F5F"}, {color:"#F29661"}, {color:"#F2CB61"}, {color:"#E5D85C"}, {color:"#BCE55C"}, {color:"#86E57F"}, {color:"#5CD1E5"}, {color:"#6699FF"}, {color:"#6B66FF"}, {color:"#A366FF"}, {color:"#F261DF"}, {color:"#F261AA"}, {color:"#A6A6A6"}, {color:"#8C8C8C"},
			{color:"#CC3D3D"}, {color:"#CC723D"}, {color:"#CCA63D"}, {color:"#C4B73B"}, {color:"#9FC93C"}, {color:"#47C83E"}, {color:"#3DB7CC"}, {color:"#4174D9"}, {color:"#4641D9"}, {color:"#7E41D9"}, {color:"#D941C5"}, {color:"#D9418D"}, {color:"#747474"}, {color:"#5D5D5D"},
			{color:"#980000"}, {color:"#993800"}, {color:"#997000"}, {color:"#998A00"}, {color:"#6B9900"}, {color:"#2F9D27"}, {color:"#008299"}, {color:"#003399"}, {color:"#050099"}, {color:"#3D0099"}, {color:"#990085"}, {color:"#99004C"}, {color:"#4C4C4C"}, {color:"#353535"},
			{color:"#670000"}, {color:"#662500"}, {color:"#664B00"}, {color:"#665C00"}, {color:"#476600"}, {color:"#22741C"}, {color:"#005766"}, {color:"#002266"}, {color:"#030066"}, {color:"#290066"}, {color:"#660058"}, {color:"#660033"}, {color:"#212121"}, {color:"#000000"}
		],
		transparent: { 
			color: "transparent", 
			border: "#999999", 
			image: "#iconpath/ic_transparent4.gif",
			thumb: "#iconpath/txt_transparent.gif",
			thumbImage:"#iconpath/color_transparent_prev.gif"
		}
	},
	textbox: {
		 options: [
			textboxOption('txc-textbox1', '10px', '#ffffff', '1px solid #f7f7f7'),
			textboxOption('txc-textbox2', '10px', '#eeeeee', '1px solid #eeeeee'),
			textboxOption('txc-textbox3', '10px', '#fefeb8', '1px solid #fefeb8'),
			textboxOption('txc-textbox4', '10px', '#fedec7', '1px solid #fedec7'),
			textboxOption('txc-textbox5', '10px', '#e7fdb5', '1px solid #e7fdb5'),
			textboxOption('txc-textbox6', '10px', '#dbe8fb', '1px solid #dbe8fb'),
			
			textboxOption('txc-textbox7', '10px', '#ffffff', '1px dashed #cbcbcb'),
			textboxOption('txc-textbox8', '10px', '#eeeeee', '1px dashed #c1c1c1'),
			textboxOption('txc-textbox9', '10px', '#fefeb8', '1px dashed #f3c534'),
			textboxOption('txc-textbox10', '10px', '#fedec7', '1px dashed #fe8943'),
			textboxOption('txc-textbox11', '10px', '#e7fdb5', '1px dashed #9fd331'),
			textboxOption('txc-textbox12', '10px', '#dbe8fb', '1px dashed #79a5e4'),
			
			textboxOption('txc-textbox13', '10px', '#ffffff', '1px solid #cbcbcb'),
			textboxOption('txc-textbox14', '10px', '#eeeeee', '1px solid #c1c1c1'),
			textboxOption('txc-textbox15', '10px', '#fefeb8', '1px solid #f3c534'),
			textboxOption('txc-textbox16', '10px', '#fedec7', '1px solid #fe8943'),
			textboxOption('txc-textbox17', '10px', '#e7fdb5', '1px solid #9fd331'),
			textboxOption('txc-textbox18', '10px', '#dbe8fb', '1px solid #79a5e4'),
			
			textboxOption('txc-textbox19', '10px', '#ffffff', '3px double #cbcbcb'),
			textboxOption('txc-textbox20', '10px', '#eeeeee', '3px double #c1c1c1'),
			textboxOption('txc-textbox21', '10px', '#fefeb8', '3px double #f3c534'),
			textboxOption('txc-textbox22', '10px', '#fedec7', '3px double #fe8943'),
			textboxOption('txc-textbox23', '10px', '#e7fdb5', '3px double #9fd331'),
			textboxOption('txc-textbox24', '10px', '#dbe8fb', '3px double #79a5e4')
		]
	}
};

/**
 * \uc5d0\ub514\ud130 \uc804\ubc18\uc801\uc778 \uc124\uc815\uc744 \uad00\ub9ac\ud558\ub294 \ud074\ub798\uc2a4\ub85c \uac01 \ud568\uc218\ub97c static \ud558\uac8c \uc811\uadfc\ud560 \uc218 \uc788\ub2e4.
 *
 * @class
 */
var TrexConfig = function() {
	//preset < daumx < project < page
	var __IS_SETUP = _FALSE;
	var __POST_PROCESSOR = [];
	var __TREX_PARAM = {};
	var __TREX_CONFIGURE = {
		txHost: '',
		txPath: '/modules/editor/',
		cdnHost: '',
		cmnHost: '',
		wrapper: 'tx_trex_container',
		form: 'tx_editor_form',
		txSkin: 'default',
		txIconPath: '',
		txDecoPath: '',
		initializedId: '',
		params: [],
		events: {
			preventUnload: _TRUE,
			useHotKey: _TRUE
		},
		save: { },	
		adaptor: { },
		toolbar: { },
		sidebar: {
			attachbox: { },
			embeder: { },
			attacher: { },
			searcher: { }
		},
		plugin: { }
	};
	
    var _createAnchors = function() {
        return {
            "Tool": __TREX_CONFIGURE.toolbar,
            "Sidebar": __TREX_CONFIGURE.sidebar,
            "Plugin": __TREX_CONFIGURE.plugin,
            "Adaptor": __TREX_CONFIGURE.adaptor,
            "Save": __TREX_CONFIGURE.save,
            "Attacher": __TREX_CONFIGURE.sidebar.attacher,
            "Embeder": __TREX_CONFIGURE.sidebar.embeder,
            "Searcher": __TREX_CONFIGURE.sidebar.searcher
        };
    };

	var _addParameter = function(tname, pname) {
		if (__IS_SETUP) {
			throw new Error("configure is already setup (addParameter)")
		}
		__TREX_PARAM[tname] = pname;
	};
	
	var _trexConfig = /** @lends TrexConfig */{
		/**
		 * url\uc744 \uc5d0\ub514\ud130 \uc124\uc815\uac12\uacfc \uc8fc\uc5b4\uc9c4 \ud30c\ub77c\ubbf8\ud130 \uac12\uc73c\ub85c \ubcc0\ud658\ud558\uc5ec \ub118\uaca8\uc900\ub2e4.
		 * @function
		 * @param {String} url - url 
		 * @param {Object} params - \ud0a4,\uac12 \uc30d\uc73c\ub85c \uc774\ub8e8\uc5b4\uc9c4 \ub370\uc774\ud130 
		 * @returns {String} \ubcc0\ud658\ub41c url
		 * @example 
		 * 		TrexConfig.getUrl("#host#path/pages/trex/image.html?username=#username", {
		 * 			'username': 'daumeditor'
		 * 		});
		 */
		getUrl: function(url, params) {
			if(typeof url !== 'string') { return url; };
			var loader = _WIN['EditorJSLoader'] || opener && opener['EditorJSLoader'] || (PopupUtil && PopupUtil.getOpener()['EditorJSLoader']);
			url = url.replace(/#host#path\/pages\//g, loader.getPageBasePath());
			url = url.replace(/#host/g, __TREX_CONFIGURE["txHost"]);
			url = url.replace(/#path\/?/g, __TREX_CONFIGURE["txPath"]);
			url = url.replace(/#Upload\/?/g, __TREX_CONFIGURE["txUpload"]);
			url = url.replace(/#cdnhost/g, __TREX_CONFIGURE["cdnHost"]);
			url = url.replace(/#cmnhost/g, __TREX_CONFIGURE["cmnHost"]);

			for(var _name in __TREX_PARAM) {
				url = url.replace(new RegExp("#".concat(_name), "g"), __TREX_CONFIGURE[__TREX_PARAM[_name]]);
			}

			if(params) {
				for(var name in params) {
					url = url.replace(new RegExp("#".concat(name), "g"), params[name]);
				}
			}
			
			return url;
		},
		/**
		 * \ud31d\uc5c5\ucc3d\uc744 \ub744\uc6b8\ub54c \uc635\uc158\uc744 \ubb38\uc790\uc5f4\ub85c \ub9cc\ub4e4\uc5b4 \ub118\uaca8\uc900\ub2e4.
		 * @function
		 * @param {Object} features - \ud0a4,\uac12 \uc30d\uc73c\ub85c \uc774\ub8e8\uc5b4\uc9c4 \ub370\uc774\ud130 
		 * @returns {String} \uc635\uc158 \ubb38\uc790\uc5f4
		 * @example 
		 * 		TrexConfig.getPopFeatures({ left:250, top:65, width:797, height:644 });
		 */
		getPopFeatures: function(features) {
			if(features == _NULL) return _NULL;
			if(typeof(features) === "string") { //redefine
				return features;
			}
			var popFeatures = [];
			["toolbar", "location", "directories", "menubar"].each(function(name) {
				popFeatures.push(name + "=" + (features[name] || "no"));	
			});
			["scrollbars", "resizable", "status"].each(function(name) {
				popFeatures.push(name + "=" + (features[name] || "no"));
			});
			["width", "height"].each(function(name) {
				popFeatures.push(name + "=" + (features[name] || "500"));	
			});
			["left", "top"].each(function(name) {
				popFeatures.push(name + "=" + (features[name] || "100"));	
			});
			return popFeatures.join(",");
		},
		/**
		 * \ucee8\ud150\uce20 \uc0bd\uc785\uc6a9 \uc774\ubbf8\uc9c0\uc758 \uc0c1\uc704 url\uc744 \ub118\uaca8\uc900\ub2e4. <br/>
		 * txDecoPath \uac12\uc774 \uc14b\ud305\ub41c \uacbd\uc6b0\ub294 \ud574\ub2f9 url\uc744 \ub118\uaca8\uc900\ub2e4.
		 * @function
		 * @param {String} url - url 
		 * @param {String} subpath - \ud558\uc704 \ub514\ub809\ud130\ub9ac (optional)
		 * @returns {String} \ubcc0\ud658\ub41c \ucee8\ud150\uce20 \uc0bd\uc785\uc6a9 \uc774\ubbf8\uc9c0url
		 */
		getDecoPath: function(url) {
			return __TREX_CONFIGURE["txDecoPath"]
				? url.replace(/#decopath\/?/, this.getUrl(__TREX_CONFIGURE["txDecoPath"]))
				: url.replace(/#decopath\/?/, this.getUrl(__TREX_CONFIGURE["txHost"]+__TREX_CONFIGURE["txPath"]+"theme/"+__TREX_CONFIGURE["txSkin"]+"/images/deco/contents/"));
		},
		/**
		 * \uc5d0\ub514\ud130\uc5d0\uc11c \uc0ac\uc6a9\ub418\ub294 \uc774\ubbf8\uc9c0\uc758 \uc0c1\uc704 url\uc744 \ub118\uaca8\uc900\ub2e4. <br/>
		 * txIconPath \uac12\uc774 \uc14b\ud305\ub41c \uacbd\uc6b0\ub294 \ud574\ub2f9 url\uc744 \ub118\uaca8\uc900\ub2e4.
		 * @function
		 * @param {String} url - url 
		 * @param {String} subpath - \ud558\uc704 \ub514\ub809\ud130\ub9ac (optional)
		 * @returns {String} \uc5d0\ub514\ud130\uc5d0\uc11c \uc0ac\uc6a9\ub418\ub294 \uc774\ubbf8\uc9c0url
		 */
		getIconPath: function(url) {
			return __TREX_CONFIGURE["txIconPath"]
				? url.replace(/#iconpath\/?/, this.getUrl(__TREX_CONFIGURE["txIconPath"]))
				: url.replace(/#iconpath\/?/, this.getUrl(__TREX_CONFIGURE["txHost"]+__TREX_CONFIGURE["txPath"]+"theme/"+__TREX_CONFIGURE["txSkin"]+"/images/icon/editor/"));
		},
		/**
		 * \uc5d0\ub514\ud130 \ub85c\ub529\uc774 \uc644\ub8cc\ub418\uba74 \uc124\uc815\uac12\uc744 \uc14b\uc5c5\uc2dc\ud0a4\ub294 \ud568\uc218\ub85c
		 * postprocessing\ub85c \ub4f1\ub85d\ub41c \ud568\uc218\ub4e4\uc744 \uc2e4\ud589\ud558\uba70
		 * \uc774\ud6c4\uc5d0\ub294 \uc124\uc815\uac12\uc744 \ucd94\uac00\ud560 \uc218 \uc5c6\ub2e4.
		 * @private
		 * @function
		 * @param {Object} config - new Editor() \ud560 \ub54c \uc785\ub825\ud55c \uc124\uc815\uac12
		 * @returns {Object} \uc14b\uc5c5\ub41c \uc124\uc815\uac12
		 */
		setup: function(config) { 
			$tx.deepcopy(__TREX_CONFIGURE, config);
			
			__TREX_CONFIGURE.params.each(function(name) {
				_addParameter(name, name);
			});
			__POST_PROCESSOR.each(function(fn) {
				fn(__TREX_CONFIGURE);
			});
	
			__IS_SETUP = _TRUE;
			
			this.setupVersion();
			return __TREX_CONFIGURE;
		},
		setupVersion: function() {
			// \ub2e4\ub978 \uacf3\uc5d0\uc11c txVersion \uc744 \uc0ac\uc6a9\ud560 \uc218\ub3c4 \uc788\uae30\uc5d0 \ud638\ud658\uc744 \uc704\ud574 txVersion \ucd94\uac00
			__TREX_CONFIGURE.txVersion = Editor.version;
		},
		/**
		 * \ud30c\ub77c\ubbf8\ud130\ub97c \ucd94\uac00\ud55c\ub2e4.<br/> 
		 * \ud30c\ub77c\ubbf8\ud130\ub780 getUrl \ud560 \ub54c \uae30\ubcf8\uc73c\ub85c \ubcc0\ud658\ud560 \ud0a4,\uac12\ub4e4\uc744 \uc815\uc758\ud574\ub193\uc740 \ub370\uc774\ud130
		 * @function
		 * @param {String} tname - url\uc5d0 \ud3ec\ud568\ub420 id 
		 * @param {String} pname - \uc124\uc815\uac12\uc5d0 \uc874\uc7ac\ud558\ub294 id
		 * @example
		 * 		TrexConfig.addParameter('host', 'txHost');
		 */
		addParameter: function(tname, pname) {
			_addParameter(tname, pname);
		},
		/**
		 * \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12\uc744 deep copy\ub85c \ubcf5\uc0ac\ud55c\ub2e4.
		 * @function
		 * @param {Object} config - \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12
		 */
		clone: function(config) {
			return $tx.deepcopy({}, config);
		},
		/**
		 * \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12\uc5d0 \uc0c8\ub85c\uc6b4 \uc124\uc815\uac12\ub4e4\uc744 deep copy\ub85c \ubcf5\uc0ac\ud55c\ub2e4. 
		 * @function
		 * @param {Object} config - \uccab\ubc88\uc9f8 \uc778\uc790\ub294 \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12, \uadf8 \uc774\ud6c4\ub294 \uc0c8\ub85c\uc6b4 \uc124\uc815\uac12\ub4e4
		 * @example 
		 * 		TrexConfig.merge(config, { 'id': 'tx_happy' }, { 'options': [1,2,3] });
		 */
		merge: function() {
			var _config = {};
			$A(arguments).each(function(source) {
				$tx.deepcopy(_config, source);
			});
			return _config;
		}
	};
	
	/**
	 * \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12\uc744 root \uc124\uc815\uac12\uc5d0 \ucd94\uac00\ud55c\ub2e4.
	 * @name add
	 * @memberOf TrexConfig
	 * @function
	 * @param {Object} config - \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12
	 * @param {Function} postprocessing - \uc5d0\ub514\ud130\uac00 \ub85c\ub529\ub41c \ud6c4 \ucc98\ub9ac\ud560 \ud568\uc218 (optional)
	 */
	_trexConfig["add"] = function(config, postprocessing) {
		if (__IS_SETUP) {
			throw new Error("configure is already setup (mergeConfig)")
		}
		$tx.deepcopy(__TREX_CONFIGURE, config);
		if(postprocessing) {
			__POST_PROCESSOR.push(postprocessing);
		}
	};
	/**
	 * \uc8fc\uc5b4\uc9c4 \ud0a4\ub85c \uc124\uc815\uac12\uc744 \ub9ac\ud134\ud55c\ub2e4.
	 * @name get
	 * @memberOf TrexConfig
	 * @function
	 * @param {String} key - \uc8fc\uc5b4\uc9c4 \ud0a4
	 */
	_trexConfig["get"] = function(key) {
		return __TREX_CONFIGURE[key];
	};
	
	/**
	 * \uc8fc\uc5b4\uc9c4 \ud0a4\ub85c \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12\uc744 root/toolbar \uc544\ub798\uc5d0 \ucd94\uac00\ud55c\ub2e4.
	 * @name addTool
	 * @memberOf TrexConfig
	 * @function
	 * @param {String} key - \uc8fc\uc5b4\uc9c4 \ud0a4\uac12 
	 * @param {Object} config - \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12
	 * @param {Function} postprocessing - \uc5d0\ub514\ud130\uac00 \ub85c\ub529\ub41c \ud6c4 \ucc98\ub9ac\ud560 \ud568\uc218 (optional)
	 */
	/**
	 * \uc8fc\uc5b4\uc9c4 \ud0a4\ub85c \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12\uc744 root/sidebar \uc544\ub798\uc5d0 \ucd94\uac00\ud55c\ub2e4.
	 * @name addSidebar
	 * @memberOf TrexConfig
	 * @function
	 * @param {String} key - \uc8fc\uc5b4\uc9c4 \ud0a4\uac12 
	 * @param {Object} config - \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12
	 * @param {Function} postprocessing - \uc5d0\ub514\ud130\uac00 \ub85c\ub529\ub41c \ud6c4 \ucc98\ub9ac\ud560 \ud568\uc218 (optional)
	 */
	/**
	 * \uc8fc\uc5b4\uc9c4 \ud0a4\ub85c \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12\uc744 root/plugin \uc544\ub798\uc5d0 \ucd94\uac00\ud55c\ub2e4.
	 * @name addPlugin
	 * @memberOf TrexConfig
	 * @function
	 * @param {String} key - \uc8fc\uc5b4\uc9c4 \ud0a4\uac12 
	 * @param {Object} config - \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12
	 * @param {Function} postprocessing - \uc5d0\ub514\ud130\uac00 \ub85c\ub529\ub41c \ud6c4 \ucc98\ub9ac\ud560 \ud568\uc218 (optional)
	 */
	/**
	 * \uc8fc\uc5b4\uc9c4 \ud0a4\ub85c \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12\uc744 root/adaptor \uc544\ub798\uc5d0 \ucd94\uac00\ud55c\ub2e4.
	 * @name addAdaptor
	 * @memberOf TrexConfig
	 * @function
	 * @param {String} key - \uc8fc\uc5b4\uc9c4 \ud0a4\uac12 
	 * @param {Object} config - \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12
	 * @param {Function} postprocessing - \uc5d0\ub514\ud130\uac00 \ub85c\ub529\ub41c \ud6c4 \ucc98\ub9ac\ud560 \ud568\uc218 (optional)
	 */
	/**
	 * \uc8fc\uc5b4\uc9c4 \ud0a4\ub85c \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12\uc744 root/save \uc544\ub798\uc5d0 \ucd94\uac00\ud55c\ub2e4.
	 * @name addSave
	 * @memberOf TrexConfig
	 * @function
	 * @param {String} key - \uc8fc\uc5b4\uc9c4 \ud0a4\uac12 
	 * @param {Object} config - \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12
	 * @param {Function} postprocessing - \uc5d0\ub514\ud130\uac00 \ub85c\ub529\ub41c \ud6c4 \ucc98\ub9ac\ud560 \ud568\uc218 (optional)
	 */
	/**
	 * \uc8fc\uc5b4\uc9c4 \ud0a4\ub85c \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12\uc744 root/sidebar/attacher \uc544\ub798\uc5d0 \ucd94\uac00\ud55c\ub2e4.
	 * @name addAttacher
	 * @memberOf TrexConfig
	 * @function
	 * @param {String} key - \uc8fc\uc5b4\uc9c4 \ud0a4\uac12 
	 * @param {Object} config - \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12
	 * @param {Function} postprocessing - \uc5d0\ub514\ud130\uac00 \ub85c\ub529\ub41c \ud6c4 \ucc98\ub9ac\ud560 \ud568\uc218 (optional)
	 */
	/**
	 * \uc8fc\uc5b4\uc9c4 \ud0a4\ub85c \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12\uc744 root/sidebar/embeder \uc544\ub798\uc5d0 \ucd94\uac00\ud55c\ub2e4.
	 * @name addEmbeder
	 * @memberOf TrexConfig
	 * @function
	 * @param {String} key - \uc8fc\uc5b4\uc9c4 \ud0a4\uac12 
	 * @param {Object} config - \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12
	 * @param {Function} postprocessing - \uc5d0\ub514\ud130\uac00 \ub85c\ub529\ub41c \ud6c4 \ucc98\ub9ac\ud560 \ud568\uc218 (optional)
	 */
	/**
	 * \uc8fc\uc5b4\uc9c4 \ud0a4\ub85c \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12\uc744 root/sidebar/searcher \uc544\ub798\uc5d0 \ucd94\uac00\ud55c\ub2e4.
	 * @name addSearcher
	 * @memberOf TrexConfig
	 * @function
	 * @param {String} key - \uc8fc\uc5b4\uc9c4 \ud0a4\uac12 
	 * @param {Object} config - \uc8fc\uc5b4\uc9c4 \uc124\uc815\uac12
	 * @param {Function} postprocessing - \uc5d0\ub514\ud130\uac00 \ub85c\ub529\ub41c \ud6c4 \ucc98\ub9ac\ud560 \ud568\uc218 (optional)
	 */
	var _addConfig = function(key, config, postprocessing) {
		if (__IS_SETUP) {
			throw new Error("configure is already setup (mergeConfig)")
		}
		this[key] = this[key] || {};
		$tx.deepcopy(this[key], config);
		if(postprocessing) {
			__POST_PROCESSOR.push(postprocessing);
		}
	};
	
	/**
	 * \uc8fc\uc5b4\uc9c4 \ud0a4\ub85c root/toolbar[key]\uc758 \uc124\uc815\uac12\uc744 \ub9ac\ud134\ud55c\ub2e4.
	 * @name getTool
	 * @memberOf TrexConfig
	 * @function
	 * @param {String,Object} key - \uc8fc\uc5b4\uc9c4 \ud0a4
	 */
	/**
	 * \uc8fc\uc5b4\uc9c4 \ud0a4\ub85c root/sidebar[key]\uc758 \uc124\uc815\uac12\uc744 \ub9ac\ud134\ud55c\ub2e4.
	 * @name getSidebar
	 * @memberOf TrexConfig
	 * @function
	 * @param {String,Object} key - \uc8fc\uc5b4\uc9c4 \ud0a4
	 */
	/**
	 * \uc8fc\uc5b4\uc9c4 \ud0a4\ub85c root/adaptor[key]\uc758 \uc124\uc815\uac12\uc744 \ub9ac\ud134\ud55c\ub2e4.
	 * @name getAdaptor
	 * @memberOf TrexConfig
	 * @function
	 * @param {String,Object} key - \uc8fc\uc5b4\uc9c4 \ud0a4
	 */
	/**
	 * \uc8fc\uc5b4\uc9c4 \ud0a4\ub85c root/save[key]\uc758 \uc124\uc815\uac12\uc744 \ub9ac\ud134\ud55c\ub2e4.
	 * @name getSave
	 * @memberOf TrexConfig
	 * @function
	 * @param {String,Object} key - \uc8fc\uc5b4\uc9c4 \ud0a4
	 */
	/**
	 * \uc8fc\uc5b4\uc9c4 \ud0a4\ub85c root/sidebar/attacher[key]\uc758 \uc124\uc815\uac12\uc744 \ub9ac\ud134\ud55c\ub2e4.
	 * @name getAttacher
	 * @memberOf TrexConfig
	 * @function
	 * @param {String,Object} key - \uc8fc\uc5b4\uc9c4 \ud0a4
	 */
	/**
	 * \uc8fc\uc5b4\uc9c4 \ud0a4\ub85c root/sidebar/embeder[key]\uc758 \uc124\uc815\uac12\uc744 \ub9ac\ud134\ud55c\ub2e4.
	 * @name getEmbeder
	 * @memberOf TrexConfig
	 * @function
	 * @param {String,Object} key - \uc8fc\uc5b4\uc9c4 \ud0a4
	 */
	/**
	 * \uc8fc\uc5b4\uc9c4 \ud0a4\ub85c root/sidebar/searcher[key]\uc758 \uc124\uc815\uac12\uc744 \ub9ac\ud134\ud55c\ub2e4.
	 * @name getSearcher
	 * @memberOf TrexConfig
	 * @function
	 * @param {String,Object} key - \uc8fc\uc5b4\uc9c4 \ud0a4
	 */
	var _getConfig = function(key) {
		return this[key];
	};
	
	var _anchors = _createAnchors();
	for(var _name in _anchors) {
		_trexConfig["add" + _name] = _addConfig.bind(_anchors[_name]);
		_trexConfig["get" + _name] = _getConfig.bind(_anchors[_name]);
	}
	
	return _trexConfig;
	
}();

_WIN.TrexConfig = TrexConfig;
var TrexMessage = function () {
    var __MESSAGES = {};

    function decorateIconPath(message) {
        return (message.indexOf("#iconpath") > -1) ?
            TrexConfig.getIconPath(message) : message;
    }

    function decorateDecoPath(message) {
        return (message.indexOf("#decopath") > -1) ?
            TrexConfig.getDecoPath(message) : message;
    }

    return {
        getMsg: function (msgid) {
            var message = __MESSAGES[msgid] || "";
            return decorateIconPath(decorateDecoPath(message));
        },

        addMsg: function (messages) {
            $tx.deepcopy(__MESSAGES, messages);
        },

        printAll: function () {
            for (var name in __MESSAGES) {
                if (__MESSAGES.hasOwnProperty(name)) {
                    
                }
            }
        }
    };
}();

_WIN.TXMSG = TrexMessage.getMsg;
_WIN.TrexMessage = TrexMessage;
var EditorConfigBuilder = function (defaultConfigObject /* optional */) {
	this.config = defaultConfigObject || {};
};

EditorConfigBuilder.prototype.set = function (path, value) {
	var splitedPath = path.split(".");
	var lastKey = splitedPath[splitedPath.length - 1];
	
	var curObj = this.config;
	for (var i = 0; i < splitedPath.length - 1; i++) {
		var key = splitedPath[i];
		if (!curObj[key]) {
			curObj[key] = {};	
		}
		curObj = curObj[key];
	}
	
	if ($tx.isPrimitiveType(value)) {
		curObj[lastKey] = value;
	} else {
		if (!curObj[lastKey]) {
			curObj[lastKey] = {};
		}
		$tx.deepcopy(curObj[lastKey], value);
	}
};

EditorConfigBuilder.prototype.getConfig = function () {
	return this.config;
};

_WIN.EditorConfigBuilder = EditorConfigBuilder;
Trex.MarkupTemplate = {};

(function() {
	var __TEMPLATES = {};
	Trex.define(Trex.MarkupTemplate, {
		add: function(name, template) {
			__TEMPLATES[name] = template;
		},
		get: function(name) {
			if(!__TEMPLATES[name]) {
				return {
					evaluate: function() { return ""; },
					evaluateToDom: function() { return ""; }
				};
			}
			if(typeof(__TEMPLATES[name]) == 'string') {
				var _template = __TEMPLATES[name].replace(/@[\w\.]+/g, function(full) {
					return TXMSG(full);
				});
				__TEMPLATES[name] = new Template(_template);
			}
			return __TEMPLATES[name];
		},
		splitList: function(rows, cols, items){
			var _matrix = { 'row': [] };
			var _total = items.length;
			var _matrix_row = _matrix.row; 
			for(var row=0; row<rows; row++) {
				_matrix_row.push({ 'col': [] });
				var _matrix_col = _matrix_row.last().col;
				for(var col=0; col<cols; col++) {
					var _item = {
						'image': '',
						'data': '&nbsp;',
						'klass': ''
					};
					if(row * cols + col < _total) {
						if(typeof(items[row * cols + col]) == 'string') {
							_item.data = items[row * cols + col];
						} else {
							_item = Object.extend(_item ,items[row * cols + col]);
						}
					}
					_matrix_col.push(_item);
				}
			}
			return _matrix;
		}
	});
})();

/** @namespace */
var $tom = {};

(function() {
	var __TRANSLATIONS = {
		'%body': ['body'],
		'%text': ['#text', 'br'],
		'%element': ['#element'],
		'%control': ['img','object','hr','table','button','iframe'], //['input','select','textarea','label','br'],
		'%inline': ['span','font','u','i','b','em','strong','big','small','a','sub','sup','span'],//['tt','dfn','code','samp','kbd','var','cite','abbr','acronym','img','object','br','script','map','q','bdo','input','select','textarea','label','button'],
		'%block': ['p','div','ul','ol','h1','h2','h3','h4','h5','h6','pre','dl','hr','table','button'], //['noscript','blockquote','form','fieldset','address'], !button
		'%paragraph': ['p','li','dd','dt','h1','h2','h3','h4','h5','h6','td','th','div','caption'], //!button
		'%wrapper': ['div','ul','ol','dl','pre','xmp','table','button','blockquote'],// FTDUEDTR-1412
		'%innergroup': ['li','dd','dt','td', 'th'],
		'%outergroup': ['ul','ol','dl','tr','tbody','thead','tfoot','table'],
		'%tablegroup': ['td', 'th','tr','tbody','thead','tfoot','table'],
		'%listgroup': ['li','ul','ol'],
		'%datagroup': ['dd','dt','dl'],
		'%listhead': ['ul','ol']
	};
	
	var __TRANSLATIONS_MAP = {}; //for caching
	for(var _ptrn in __TRANSLATIONS) {
		__TRANSLATIONS_MAP[_ptrn] = {};
		if (__TRANSLATIONS[_ptrn]) {
			$A(__TRANSLATIONS[_ptrn]).each(function(tag){
				__TRANSLATIONS_MAP[_ptrn][tag] = _TRUE;
			});
		}
	}
	
	function createMap(patterns) {
		var _map = {};
		var _patterns = patterns.split(",");
		_patterns.each(function(pattern) {
			if(__TRANSLATIONS_MAP[pattern]) {
				for(var _part in __TRANSLATIONS_MAP[pattern]) {
					_map[_part] = _TRUE;
				}
			} else {
				_map[pattern] = _TRUE;
			}
		});
		return _map;
	}
	
	var Translator = Trex.Class.create({
		initialize: function(patterns) {
			this.patterns = patterns;
			this.map = createMap(patterns);
		},
		hasParts: function() {
			return (this.patterns.length > 0);
		},
		include: function(partPtrn) {
			var _partMap = createMap(partPtrn);
			for(var _part in _partMap) {
				if(this.map[_part]) {
					return _TRUE;
				}
			}
			return _FALSE;
		},
		memberOf: function(wholePtrn) {
			var _wholeMap = createMap(wholePtrn);
			for(var _part in this.map) {
				if(_wholeMap[_part]) {
					return _TRUE;
				}
			}
			return _FALSE;
		},
		extract: function(wholePtrn) {
			var _wholeMap = createMap(wholePtrn);
			var _matches = [];
			for(var _part in this.map) {
				if(_wholeMap[_part]) {
					_matches.push(_part);
				}
			}
			return $tom.translate(_matches.join(","));
		},
		getExpression: function() {
			if(!this.exprs) {
				var _exprs = [];
				for(var _part in this.map) {
					_exprs.push(_part);
				}
				this.exprs = _exprs.join(",");
			}
			return this.exprs;
		}
	});
	
	var __TRANSLATOR_CACHES = {}; //for caching	
	Object.extend($tom, {
		translate: function(pattern) {
			if(!__TRANSLATOR_CACHES[pattern]) {
				__TRANSLATOR_CACHES[pattern] = new Translator(pattern);
			}
			return __TRANSLATOR_CACHES[pattern];
		}
	});
	
})();

Object.extend($tom, {
	__POSITION: {
		__START_OF_TEXT: -1,
		__MIDDLE_OF_TEXT: 0,
		__END_OF_TEXT: 1,
		__EMPTY_TEXT: -2
	}
});

Object.extend($tom, /** @lends $tom */{
	/**
	 * node\uac00 HTMLElement\uc774\uba74 true\ub97c \uc544\ub2c8\uba74 false\ub97c \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 */
	isElement: function(node) {
        return node && node.nodeType == 1;
	},
	/**
	 * node\uac00 <body> \uc694\uc18c\uc774\uba74 true\ub97c \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 */
	isBody: function(node) {
        return $tom.isElement(node) && node.tagName == "BODY";
	},
	/**
	 * node\uac00 \uc544\ub798\uc5d0 \ub098\uc5f4\ub41c block \uc694\uc18c\uc774\uba74 true \ub97c \ubc18\ud658\ud55c\ub2e4.
	 * 'p','div','ul','ol','h1','h2','h3','h4','h5','h6','pre','dl','hr','table','button'
	 * @function
	 */
	isBlock: function(node) {
		return $tom.kindOf(node, '%block');
	},
    /**
	 * node\uac00 \uc544\ub798\uc5d0 \ub098\uc5f4\ub41c \uc694\uc18c\uc774\uba74 true \ub97c \ubc18\ud658\ud55c\ub2e4.
	 * 'p','li','dd','dt','h1','h2','h3','h4','h5','h6','td','th','div','caption'
	 * @function
	 */
	isParagraph: function(node) {
        return $tom.kindOf(node, '%paragraph');
	},
	/**
	 * node\uac00 \ud14d\uc2a4\ud2b8\uc774\uac70\ub098 <br> \uc694\uc18c\uc774\uba74 true \ub97c \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 */
	isText: function(node) {
		return $tom.kindOf(node, '%text');
	},
	/**
	 * node\uac00 \uc544\ub798\uc5d0 \ub098\uc5f4\ub41c \uc694\uc18c\uc774\uba74 true\ub97c \ubc18\ud658\ud55c\ub2e4.
	 * 'img','object','hr','table','button'
	 * @function
	 */
	isControl: function(node) {
		return $tom.kindOf(node, '%control');
	},
    /**
     * element\uac00 tagName\uba74 true\ub97c \ubc18\ud658\ud55c\ub2e4.
     * @function
     */
    isTagName: function(element, tagName){
        tagName = tagName.toUpperCase();
        return element && element.tagName === tagName;

    },
    getOwnerDocument: function(node) {
        return node.ownerDocument || node.document;
    },
	/**
	 * node\uc758 \uc774\ub984\uc744 \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 */
	getName: function(node) {
		return ((node && node.nodeType == 1)? node.nodeName.toLowerCase(): "");
	},
	/**
	 * node\uc758 text content \ub97c \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 */
	getText: function(node) {
		return node.textContent || node.text || node.innerText || "";
	},
	/**
	 * \uc694\uc18c\uc758 nodeType 1\uc774\uba74 child \ub178\ub4dc\uc758 \uae38\uc774\ub97c, nodeType 3\uc774\uba74 nodeValue\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud55c\ub2e4.  
	 * @function
	 */
	getLength: function(node) {
		if(!node) {
			return 0;
		}
		if(node.nodeType == 1) {
			return node.childNodes.length;
		} else if(node.nodeType == 3) {
			return node.nodeValue.length;
		}
		return 0; 
	},
	/**
	 * node\uac00 \uac19\uc740 \ub808\ubca8\uc758 \uc694\uc18c \uc911 \uba87 \ubc88\uc9f8\uc778\uc9c0 \uc778\ub371\uc2a4\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 */
	indexOf: function(node){
		if(!node) {
			return -1;
		}
		var _pNode = node.parentNode;
        for (var i = 0, len = _pNode.childNodes.length, childNodes = _pNode.childNodes; i < len; i++) {
            if (childNodes[i] == node) {
                return i;
            }
        }
        return -1;
	},
	/**
	 * node\uac00 textNode\uc774\uba74 \uacf5\ubc31\uc744 \uc81c\uac70\ud55c nodeValue\uc758 \ub0b4\uc6a9\uc774 \uc874\uc7ac\ud558\uba74 true\ub97c \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 */
	hasContent: function(node, ignoreZWNBS) {
		if(!node || node.nodeType != 3) {
			return _TRUE;
		}

		var _text = $tom.removeMeaninglessSpace( node.nodeValue );
		if(ignoreZWNBS) {
			_text = _text.replace(Trex.__WORD_JOINER_REGEXP, "");
		}
		return (_text != "");
	},
    removeEmptyTextNode: function(textNode) {
        if (textNode && textNode.nodeType == 3 && !textNode.nodeValue) {
            $tom.remove(textNode);
        }
    },
	hasUsefulChildren: function(node, ignoreZWNBS) {
		if(!node) {
			return _FALSE;
		}
		var _inner = $tom.removeMeaninglessSpace( node.innerHTML );
		if(ignoreZWNBS) {
			_inner = _inner.replace(Trex.__WORD_JOINER_REGEXP, "");
		}
		if(!_inner) {
			return _FALSE;
		}
		if(_inner.stripTags()) {
			return _TRUE;
		}
		if(_inner.search(/<(img|br|hr)\s?[^>]*>/i) > -1) {
			return _TRUE;
		}
		if(_inner.search(/<span\sid="?tx_(start|end)_marker"?><\/span>/i) > -1) {
			return _TRUE;
		}
		return _FALSE;
	},
	/**
	 * node\uc5d0 \uc758\ubbf8\uc788\ub294 \ub370\uc774\ud130\uac00 \uc788\ub294\uc9c0 \ud655\uc778\ud55c\ub2e4.
	 * @function
	 */
	hasData: function(node, ignoreStuff) {
		if(!node) {
			return _FALSE;
		}
		
		var _inner = '';
		if(node.nodeType == 1) {
			_inner = node.innerHTML;
		} else {
			_inner = node.nodeValue;
		}
		_inner = $tom.removeMeaninglessSpace( _inner );
		if(_inner.trim() == '') {// #PCCAFEQA-11
			return _FALSE;
		}
		if(_inner.stripTags() != '') {
			return _TRUE;
		}
		if(ignoreStuff) {
			return _FALSE;
		}
		if(_inner.search(/<br\s?\/?>/i) > -1) {
			return _TRUE;
		}
		return _FALSE;
	},
	/**
	 * \uc8fc\uc5b4\uc9c4 \uc2a4\ud2b8\ub9c1\uc5d0\uc11c \uc758\ubbf8\uc5c6\ub294 \uc2a4\ud398\uc774\uc2a4\ub97c \uc81c\uac70\ud558\ub294 \ud568\uc218.
	 * @function
	 */
	removeMeaninglessSpace: function(str){
		/* /\s/ == /[\f\n\r\t\v\u2028\u2029\u00a0]/ */
		return str.replace(/(^[\f\n\r\t\v\u2028\u2029]*)|([\f\n\r\t\v\u2028\u2029]*$)/g, "");
	}
});	

Object.extend($tom, /** @lends $tom */{
	/**
	 * $tom.find, $tom.collect, $tom.collectAll \uc5d0\uc11c \uacf5\ud1b5\uc801\uc73c\ub85c \ud638\ucd9c\ub418\ub294 \ud568\uc218.
	 * @function
	 * @example
	 *   var result1 = $tom.search(["td,th"], dFindy, _NULL);
	 *   var result2 = $tom.search([context, "td,th"], dFindy, _NULL);
	 *   var results = $tom.search([context, "td,th"], dGetties, []);
	 */
	search: function(args, searchFunction, defaultValue) {
		var context = (args.length == 1) ? _DOC : args[0];
		var pattern = args[args.length - 1];
		
		var invalidArgument = (!pattern ||
								!context ||
								!context.nodeType ||
								typeof pattern != "string");
		if (invalidArgument) {
			return defaultValue;
		}
		
		var translator = $tom.translate(pattern);
		return searchFunction(context, translator.getExpression());
	},
	/**
	 * css selector \ub85c \uc694\uc18c\ub97c \ucc3e\uc544\uc11c \ubc18\ud658\ud558\ub294\ub370 \uc778\uc790 node\uc758 \uc0c1\uc704\uc5d0 \uc788\ub294 \uc694\uc18c\ub97c \ucc3e\ub294\ub2e4.
	 * @function
	 * @example
	 *  var _elNode = $tom.find(node, "table.txc-layout-wz");
	 */
	find: function() {
		return this.search(arguments, dFindy, _NULL);
	},
	/**
	 * css selector \ub85c \uc694\uc18c\ub97c \ucc3e\uc544\uc11c \ubc18\ud658\ud558\ub294\ub370 \uc778\uc790 node\uc758 \ud558\uc704\uc5d0 \uc788\ub294 \uc694\uc18c\ub97c \ucc3e\ub294\ub2e4.
	 * @function
	 * @example
	 *  var _elInput = $tom.collect(this.elMenu, 'textarea');
	 */
	collect: function() {
		return this.search(arguments, dGetty, _NULL);
	},
	/**
	 * css selector\ub85c \uc694\uc18c\ub97c \ucc3e\uc544\uc11c \ubc18\ud658\ud558\ub294\ub370 \uc778\uc790 node\uc758 \ud558\uc704\uc5d0 \uc788\ub294 \uc694\uc18c\ub97c \ucc3e\uace0 \ubaa8\ub4e0 \uc694\uc18c\ub97c \ubc30\uc5f4\uc5d0 \ub2f4\uc544\uc11c \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 * @example
	 *  var _elItemList = $tom.collectAll(this.elMenu, "li a");  
	 */
	collectAll: function() {
		return this.search(arguments, dGetties, []);
	}
});	

(function() {
	function makeFilter(pattern) {
		if(pattern) {
			if(typeof(pattern) === 'function') {
				return pattern;
			} else {
				var _translator = $tom.translate(pattern);
				return function(node) {
					if(node.nodeType == 1) {
						if (_translator.include('#element')) {
							return _TRUE;
						} else {
							return dChecky(node, _translator.getExpression());
						}
					} else {
						return _translator.include('#text');
					}
				};
			}
		} else {
			return _NULL;
		}
	}

    var nodePatternCache = {};
    function findNodePattern(pattern) {
        pattern = pattern || "#element,#text";

        if (nodePatternCache[pattern]) {
            return nodePatternCache[pattern];
        }
        var filter = new NodePattern(pattern);
        nodePatternCache[pattern] = filter;
        return filter;
    }

    var NodePattern = Trex.Class.create({
        initialize: function(pattern) {
            this.pattern = pattern;
            this.translator = $tom.translate(pattern);
            // for better performance
            this.hasClassPattern = pattern.indexOf(".") >= 0;
            this.hasIdPattern = pattern.indexOf("#") >= 0;
            this.matchesText = this.translator.include("#text");
            this.matchesElement = this.translator.include("#element");
        },
        test: function(node) {
            var nodeType = node.nodeType;
            var translatorMap = this.translator.map;
            if (nodeType == 1) {
                if (this.matchesElement) {
                    return _TRUE;
                }
                var tagName = node.tagName.toLowerCase();

                // early matching for performance
                if (translatorMap[tagName]) {
                    return _TRUE;
                }

                var checkPattern = [];
                if (this.hasClassPattern && node.className) {
                    node.className.split(/\s/).each(function(className) {
                        checkPattern.push("." + className);
                        checkPattern.push(tagName + "." + className);
                    });
                }
                if (this.hasIdPattern && node.id) {
                    var id = node.id;
                    checkPattern.push("#" + id);
                    checkPattern.push(tagName + "#" + id);
                }
                for (var i = 0; i < checkPattern.length; i++) {
                    if (translatorMap[checkPattern[i]]) {
                        return _TRUE;
                    }
                }
                return _FALSE;
            } else if (nodeType == 3) {
                return this.matchesText;
            }
        }
    });

	Object.extend($tom, /** @lends $tom */{
        tagName: function(node, tagName) {
            if (!node) {
                return _NULL;
            }
            return node.tagName;
        },
		/**
		 * node\uac00 pattern\uc5d0 \ub9de\ub294 \uc694\uc18c\uc774\uba74 true\ub97c \ubc18\ud658\ud55c\ub2e4. 
		 * @function
		 * @param node
		 * @param pattern css selector rule
		 * @example
		 *  $tom.kindOf(node, "img.txc-image") // node\uac00 txc-image\ub77c\ub294 \uc774\ub984\uc758 class\uc18d\uc131\uc744 \uac00\uc9c4 img \uc694\uc18c\uc774\uba74 true
		 */
        // \ub354 \uc774\uc0c1 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\ub294 dChecky\ub97c \uc5c6\uc560\uc790.
        kindOf: function(node, pattern) {
            if (!node || !pattern) {
                return _FALSE;
            }
            var filter = findNodePattern(pattern);
            return filter.test(node);
        },
		kindOf_old: function(node, pattern) {
			if(!node || !pattern) {
				return _FALSE;
			}
			return makeFilter(pattern)(node);
		},
		/* has filter */
		/**
		 * pattern\uc5d0 \ub9de\ub294 descendant\uc758 \uc0c1\uc704\uc694\uc18c\ub97c \ucc3e\uc544\uc11c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		ancestor: function(descendant, pattern) {
			if(!descendant || !descendant.parentNode) {
				return _NULL;
			}
            var filter = findNodePattern(pattern);
			var _node = descendant.parentNode;
			while(_node) {
				if($tom.isBody(_node)) {
					return _NULL;
				}
                if (filter.test(_node)) {
                    break;
                }
				_node = _node.parentNode;
			}
			return _node;
        },
        findAncestor: function(node, matched, mustStop) {
            while (!mustStop(node)) {
                if (matched(node)) {
                    return node;
                }
                node = node.parentNode;
            }
            return _NULL;
        },
        /**
		 * pattern\uc5d0 \ub9de\ub294 descendant\uc758 \ud558\uc704\uc694\uc18c\ub97c \ucc3e\uc544\uc11c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		descendant: function(ancestor, pattern) {
			var _nodes = $tom.descendants(ancestor, pattern, _TRUE);
			if(_nodes.length == 0) {
				return _NULL;
			}
			return _nodes[0];
		}, 
		/**
		 * pattern\uc5d0 \ub9de\ub294 descendant\uc758 \ubaa8\ub4e0 \ud558\uc704\uc694\uc18c\ub97c \ucc3e\uc544\uc11c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		descendants: function(ancestor, pattern, single) {
			single = single || _FALSE;
			if(!ancestor || !ancestor.firstChild) {
				return [];
			}
			var _found = _FALSE;
            var filter = findNodePattern(pattern);
			var _nodes = [];
			var _gets = function(parent) {
				if(single && _found) {
					return;
				}
				if(!$tom.first(parent)) {
					return;
				}
				var _chilren = $tom.children(parent);
				for(var i=0,len=_chilren.length;i<len;i++) {
					if (filter.test(_chilren[i])) {
						_nodes.push(_chilren[i]);
						_found = _TRUE;
					} else {
						_gets(_chilren[i]);
					}
				}
			};
			_gets(ancestor);
			return _nodes;
		}, 
		/**
		 * node\uc758 \uc790\uc2dd\uc694\uc18c \uc911 pattern\uc5d0 \ub9de\ub294 \ubaa8\ub4e0 \uc694\uc18c\ub97c \ucc3e\uc544\uc11c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		children: function(node, pattern) {
			var _nodes = [];
			if(!node || !node.firstChild) {
				return _nodes;
			}
            var filter = findNodePattern(pattern);
			var _node = $tom.first(node);
			while(_node) {
                if (filter.test(_node)) {
					_nodes.push(_node);
				}
				_node = _node.nextSibling;
			}
			return _nodes;
		},
		/**
		 * node\uc758 nextSibling \uc694\uc18c \uc911 pattern\uc5d0 \ub9de\ub294 \uc694\uc18c\ub97c \ucc3e\uc544\uc11c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		next: function(node, pattern) {
			if(!node || !node.nextSibling) {
				return _NULL;
			}
            var filter = findNodePattern(pattern);
			var _node = node.nextSibling;
			while(_node) {
				if($tom.hasContent(_node)) {
					if (filter.test(_node)) {
						break;
					}
				}
				_node = _node.nextSibling;
			}
			return _node;
		},
		/**
		 * node\uc758 previousSibling \uc694\uc18c \uc911 pattern\uc5d0 \ub9de\ub294 \uc694\uc18c\ub97c \ucc3e\uc544\uc11c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		previous: function(node, pattern) {
			if(!node || !node.previousSibling) {
				return _NULL;
			}
            var filter = findNodePattern(pattern);
			var _node = node.previousSibling;
			while(_node) {
				if($tom.hasContent(_node)) {
					if (filter.test(_node)) {
						break;
					}
				}
				_node = _node.previousSibling;
			}
			return _node;
		},
		/**
		 * pattern\uc5d0 \ub9de\ub294 node\uc758 \uccab\ubc88\uc9f8 \uc790\uc2dd\uc694\uc18c\ub97c \ucc3e\uc544\uc11c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		first: function(node, pattern) {
			if(!node || !node.firstChild) {
				return _NULL;
			}
            var filter = findNodePattern(pattern);
			var _node = node.firstChild;
			while(_node) {
				if($tom.hasContent(_node)) {
                    if (filter.test(_node)) {
                        break;
                    }
				}
				_node = _node.nextSibling;
			}
			return _node;
		},
		/**
		 * pattern\uc5d0 \ub9de\ub294 node\uc758 \ub9c8\uc9c0\ub9c9 \uc790\uc2dd\uc694\uc18c\ub97c \ucc3e\uc544\uc11c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		last: function(node, pattern) {
			if(!node || !node.lastChild) {
				return _NULL;
			}
            var filter = findNodePattern(pattern);
			var _node = node.lastChild;
			while(_node) {
				if($tom.hasContent(_node)) {
                    if (filter.test(_node)) {
						break;
					}
				}
				_node = _node.previousSibling;
			}
			return _node;
		},
		/**
		 * 
		 * @function
		 */
		extract: function(parent, child, pattern) {
			var _nodes = [];
			if(!parent || !child ||!pattern) {
				return _nodes;
			}
            var filter = findNodePattern(pattern);
			var _found = _FALSE;
			var _node = parent.firstChild;
			while(_node) {
				if($tom.include(_node, child)) {
					_found = _TRUE;
				}
                if (filter.test(_node)) {
					_nodes.push(_node);
				} else {
					if(_found) {
						break;
					} else {
						_nodes = [];
					}
				}
				_node = _node.nextSibling;
			}
            return _found ? _nodes : [];
//			return _nodes;
		},
		/* has no filter */
		/**
		 * node\uc758 parent node\ub97c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		parent: function(node) {
			if(!node || !node.parentNode) {
				return _NULL;
			}
			return node.parentNode;
		}, 
		/**
		 * node\ub97c \ud3ec\ud568\ud558\uace0 \uc788\ub294 body \uc694\uc18c\ub97c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		body: function(node) {
			if(!node || !node.parentNode) {
				return _NULL;
			}
			var _node = node.parentNode;
			while(_node) {
				if($tom.isBody(_node)) {
					return _node;
				}
				_node = _node.parentNode;
			}
			return _NULL;
		}, 
		/**
		 * ancestor\uc758 \ud558\uc704\uc5d0\uc11c \ucc98\uc74c \ub098\uc624\ub294 \ud14d\uc2a4\ud2b8 \ub178\ub4dc\ub97c \ucc3e\uc544\uc11c \ubc18\ud658\ud55c\ub2e4. 
		 * @function
		 */
		top: function(ancestor, all) {
			all = all || _FALSE;
			var _node = ancestor;
			
			while($tom.first(_node)) {
				_node = $tom.first(_node);
			}
			if(all) {
				return _node;
			} else {
				if ($tom.kindOf(_node, "#tx_start_marker,#tx_end_marker")) {
					_node = _node.nextSibling || _node.parentNode;
				} else if($tom.kindOf(_node, '%control')) {
					_node = _node.parentNode;
				}
				return _node;
			}
		}, 
		/**
		 * ancestor\uc758 \ud558\uc704\uc5d0\uc11c \ub9c8\uc9c0\ub9c9\uc5d0 \ub098\uc624\ub294 \ud14d\uc2a4\ud2b8 \ub178\ub4dc\ub97c \ucc3e\uc544\uc11c \ubc18\ud658\ud55c\ub2e4. 
		 * @function
		 */
		bottom: function(ancestor, all) {
			all = all || _FALSE;
			var _node = ancestor;
			while($tom.last(_node)) {
				_node = $tom.last(_node);
			}
			if (all) {
				return _node;
			} else {
				if ($tom.kindOf(_node, "#tx_start_marker,#tx_end_marker")) {
					_node = _node.previousSibling || _node.parentNode;
				} else if ($tom.kindOf(_node, '%control')) {
					_node = _node.parentNode;
				}
				return _node;
			}
		},
		/**
		 * child\uac00 parent\uc5d0 \ud3ec\ud568\ub418\uc5b4 \uc788\ub294 \uc694\uc18c\uc774\uba74 true\ub97c \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		include: function(parent, child) {
			if(!parent || !child) {
				return _FALSE;
			}
			if(parent == child) {
				return _TRUE;
			}
			var _node = child;
			while (_node) {
				if ($tom.isBody(_node)) {
					return _FALSE;
				} else if (_node == parent) {
					return _TRUE;
				}
				_node = _node.parentNode;
			}
			return _FALSE;
		},
        /**
         * node, offset \uc774\uc804 \ucee4\uc11c\uc758 \uc704\uce58\ub97c \ubc18\ud658\ud55c\ub2e4.
         * @function
         */
        prevNodeUntilTagName: function(node, offset, tagName){
            tagName = tagName.toUpperCase();
            if(offset === 0)
                node = node.previousSibling;
            else {
                node = node.childNodes[offset-1];
            }
            while(node&&node.lastChild){
                if(node.tagName === tagName)
                    break;
                node = node.lastChild;
            }
            return node;
        },
        /**
         * node \ub2e4\uc74c content\ub97c \ubc18\ud658\ud55c\ub2e4.
         * @function
         */
        nextContent : function (node, filter){
            do{
                var _node = $tom.next(node, filter);
                if(_node)
                    return _node;
                node = $tom.parent(node);
            }while(node && !$tom.isBody(node));
            return null;
        }
	});
	
})();



Object.extend($tom, /** @lends $tom */{
	/**
	 * parent\uc694\uc18c\uc758 \uccab\ubc88\uc9f8 \uc790\uc2dd\ub178\ub4dc\ub85c child\ub97c \uc0bd\uc785\ud55c\ub2e4.
	 * @function
	 */
	insertFirst: function(parent, child) {
		if(!parent || !child) {
			return;
		}
		if (parent.firstChild) {
			parent.insertBefore(child, parent.firstChild);
		} else {
			parent.appendChild(child);
		}
		return child;
	},
	/**
	 * target \uc694\uc18c \uc804 \uc704\uce58\uc5d0 source \uc694\uc18c\ub97c \uc0bd\uc785\ud55c\uace0 source \uc694\uc18c\ub97c \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 */
	insertAt: function(source, target) {
		if(!source || !target) {
			return;
		}
		target.parentNode.insertBefore(source, target);
		return source;
	},
	/**
	 * target \uc694\uc18c \ub2e4\uc74c \uc704\uce58\uc5d0 source \uc694\uc18c\ub97c \uc0bd\uc785\ud55c\uace0 source \uc694\uc18c\ub97c \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 */
	insertNext: function(source, target) {
		if(!source || !target) {
			return;
		}
        var nextSibling = target.nextSibling;
		if (nextSibling) {
			nextSibling.parentNode.insertBefore(source, nextSibling);
		} else {
			target.parentNode.appendChild(source);
		}
		return source;
	},
	/**
	 * parent \uc694\uc18c\uc5d0 child \uc694\uc18c\ub97c \ubd99\uc778 \ud6c4 child \uc694\uc18c\ub97c \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 */
	append: function(parent, child) {
		if(!parent || !child) {
			return;
		}
		parent.appendChild(child);
		return child;
	},
	/**
	 * node \ub97c \uc81c\uac70\ud55c\ub2e4.
	 * @function
	 */
	remove: function(node) {
		if(!node) {
			return;
		}
		if(node.parentNode) {
			node.parentNode.removeChild(node);
		}
		node = _NULL;
	},
	/**
	 * node\uc758 innerHTML\ub85c html\ub97c \ub123\uace0 node\ub97c \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 */
	html: function(node, html) {
		if(!node) {
			return;
		}
		node.innerHTML = html || "";
		return node;
	},
	/**
	 * node\uc758 \ub0b4\uc6a9\uc744 \uc9c0\uc6b4\ub2e4.
	 * @function
	 */
	clean: function(node) {
		return $tom.html(node);
	},
	/**
	 * node\uc548\uc5d0 \ud574\ub2f9 html\ub97c \ucc44\uc6cc\ub123\uace0 node\ub97c \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 */
	stuff: function(node, html) {
		if(!node) {
			return node;
		}
		if($tom.hasUsefulChildren(node, _TRUE)) {
			return node;
		}
		if(node.lastChild) {
			var _node = node;
			while (_node.lastChild) {
				_node = _node.lastChild;
			}
			$tom.insertNext(html, _node);
		} else {
			$tom.append(node, html);
		}
		return node;
	}
});

Object.extend($tom, /** @lends $tom */{
    /**
     * child\uac00 \uc5c6\ub294 listhead\ub77c\uba74 \uc0ad\uc81c\ud55c\ub2e4
     * @param node
     */
    removeListIfEmpty: function(node) {
        while ($tom.kindOf(node, "%listhead") && node.childNodes.length == 1 && $tom.kindOf(node.firstChild, "%listhead")) {
            node = node.firstChild;
        }

        while ($tom.kindOf(node, "%listhead") && node.childNodes.length == 0) {
            var tempNode = node.parentNode;
            $tom.remove(node);
            node = tempNode;
        }
    }
});

Object.extend($tom, /** @lends $tom */{
	/**
	 * sNode\uc758 \uc790\uc2dd\ub178\ub4dc\ub4e4\uc744 dNode\uc758 child\ub85c \uc0bd\uc785 \ud558\ub294\ub370 sInx, eInx\ub294 \uc790\uc2dd\ub178\ub4dc\uc758 \uc2dc\uc791, \ub05d \uc778\ub371\uc2a4\ubc88\ud638\ub2e4.
	 * @function
	 * @param sNode
	 * @param dNode
	 * @param sInx
	 * @param eInx
	 */
	moveChild: function(sNode, dNode, sInx, eInx) {
		if(!sNode || !dNode) {
			return;
		}
		sInx = Math.min(Math.max(sInx || 0), sNode.childNodes.length);
		eInx = Math.min(Math.max(eInx || sNode.childNodes.length), sNode.childNodes.length);
		if(sInx >= eInx) {
			return;
		}
		
		var _inx = sInx;
		while (_inx++ < eInx && sInx < sNode.childNodes.length) {
			dNode.appendChild(sNode.childNodes[sInx]);
		}
	},
	/**
	 * node\uc758 \uc790\uc2dd\ub178\ub4dc\ub97c node\uc758 \ubd80\ubaa8\ub178\ub4dc\uc5d0 \ubd99\uc778\ub2e4.
	 * @function
	 */
	moveChildToParent: function(node) {
		if(!node) {
			return;
		}
        while (node.firstChild) {
            node.parentNode.insertBefore(node.firstChild, node);
        }
	}
});

/*
 * Create, Destroy, Change
 */
Object.extend($tom, /** @lends $tom */{
	/**
	 * source\ub97c target\ub85c \uad50\uccb4\ud558\uace0 target\ub97c \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 */
    replace: function(source, target) {
        if (!source || !target) {
            return _NULL;
        }
        if ($tom.getName(source) == $tom.getName(target)) {
            $tom.remove(target);
            return source;
        } else {
            // FTDUEDTR-1248
            var children = [],
                childNodes = source.childNodes,
                len = childNodes.length;
            for (var i = 0; i < len; i++) {
                children.push(childNodes[i]);
            }
            for (i = 0; i < len; i++) {
                var child = children[i];
                if (child.lastChild === source) {
                    var cloneChild = $tom.clone(child);
                    $tom.moveChild(child, cloneChild);
                    child.innerHTML = "";
                    target.appendChild(cloneChild);
                } else {
                    target.appendChild(child);
                }
            }
            $tom.insertAt(target, source);
            $tom.remove(source);
            return target;
        }
    },
	/**
	 * node\ub97c \ubcf5\uc0ac \ud6c4 \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 */
	clone: function(node, deep) {
        var cloneNode = node.cloneNode(!!deep);
        if (node.nodeType == 1) {
            cloneNode.removeAttribute("id");
        }
        return cloneNode;
	}
});
	
/*
 * Wrap, Unwrap
 */
Object.extend($tom, /** @lends $tom */{
	/**
	 * wNode \uc544\ub798\uc5d0 pNodes\ub97c \ubd99\uc5ec\uc11c pNodes\ub97c wNode\ub85c \uac10\uc2fc\ub2e4.
	 * @function
	 * @return wNode
	 */
	wrap: function(wNode, pNodes) { //NOTE: quote, quotenodesign, textbox \ub4f1\uc5d0\uc11c \uc0ac\uc6a9\ub428, actually using 'div', 'blockquote'
		if (!wNode || !pNodes) {
			return _NULL;
		}
        if (pNodes instanceof Array == _FALSE) {
			pNodes = [].concat(pNodes);
		}

		$tom.insertAt(wNode, pNodes[0]);
		pNodes.each((function(pNode){
			$tom.append(wNode, pNode);
		}));
		return wNode;
	},
	/**
	 * node\ub97c \uc81c\uac70\ud558\uace0 node\uc758 \uc790\uc2dd\ub178\ub4dc\ub294 node\uc758 \uc0c1\uc704\uc5d0 \ubd99\uc778\ub2e4.
	 * @function
	 */
	unwrap: function(node) { 
		if (!node) {
			return _NULL;
		}
        var _nNode = $tom.first(node);
        if ($tx.msie_nonstd) {
            node.removeNode();  // IE\uc5d0\uc11c\ub294 \uc774\uac8c \ub354 \ube60\ub984
        } else {
            $tom.moveChildToParent(node);
            $tom.remove(node);
        }
        return _nNode;
	}
});

	
Object.extend($tom, /** @lends $tom */{
	/**
	 * @private
	 * @function
	 */
	divideText: function(node, offset) {
		if(!$tom.isText(node)) {
			return node;
		}
		if(offset <= 0 || offset >= node.length) { //\ub098\ub20c\ud544\uc694\uac00 \uc788\uc744\uae4c?
			return node;
		}
		var _newNode = node.cloneNode(_FALSE);
        node.deleteData(offset, node.length - offset);
		_newNode.deleteData(0, offset);
		$tom.insertNext(_newNode, node);
		return _newNode;
	},
	/**
     * node\uc758 offset\ubc88\uc9f8 child\ub97c \uae30\uc900\uc73c\ub85c \ub450 \uac1c\ub85c \ubd84\ub9ac\ud55c\ub2e4.
	 */
	divideNode: function(node, offset) {
		if(!$tom.isElement(node)) {
			return _NULL;
		}
		/*if(offset <= 0 || offset >= node.childNodes.length) { //\ub098\ub20c\ud544\uc694\uac00 \uc788\uc744\uae4c?
			return node;
		}*/
		var _lastOffset = node.childNodes.length - offset;
		var _newNode = node.cloneNode(_FALSE);
		for(var i=0;i<_lastOffset;i++) {
			$tom.insertFirst(_newNode, node.lastChild);
		}
		$tom.insertNext(_newNode, node);
		return _newNode;
	},
    /**
     * divideNode\uc640 \ube44\uc2b7\ud55c\ub370, node\ub97c clone\ud560 \ub54c\uc5d0 style, attribute\ub97c \ubaa8\ub450 \ubcf5\uc0ac\ud558\uac8c \ub41c\ub2e4.
     * divideNode \uc0ac\uc6a9\uc5d0 \ub300\ud55c legacy \ub54c\ubb38\uc5d0 \ub530\ub85c \ub9cc\ub4e4\uc5c8\uc73c\uba70, \uc0ac\uc6a9\ubc95\uc774 \ud655\uc778\ub41c \uc774\ud6c4\uc5d0\ub294 \ub450 \uac1c\uac00 \ud569\uccd0\uc9c8 \ud544\uc694\uac00 \uc788\ub2e4.
     * \uc608\ub97c \ub4e4\uc5b4 style\uc744 \ubcf5\uc0ac\ud558\ub294 \ucc45\uc784\uc744 caller\uc5d0\uac8c \ub118\uae30\ub294 \ubc29\uc2dd\uc774\ub098, \ud30c\ub77c\ubbf8\ud130\ub85c \uc120\ud0dd\ud560 \uc218 \uc788\ub3c4\ub85d \ud574\uc11c...
     */
    splitAt: function(node, index) {
        if (!$tom.isElement(node)) {
            return;
        }
        var clonedNode = $tom.clone(node);
        $tom.moveChild(node, clonedNode, index + 1, node.childNodes.length);
        $tom.insertNext(clonedNode, node);
        return clonedNode;
    },
    /**
     * stopAncestor\uc740 dividedPoint\uc758 ancestor \uc774\uc5b4\uc57c \ud568
     * stopAncestor\uc640 dividedPoint \uc0ac\uc774\uc5d0 table\uc774 \uc5c6\uc5b4\uc57c \ud568
     */
    divideTree: function(stopAncestor, dividedPoint) {
        var currentNode = dividedPoint, offset, parent;
        do {
            parent = currentNode.parentNode;
            offset = $tom.indexOf(currentNode);
            currentNode = $tom.divideNode(parent, offset);
        } while (currentNode.previousSibling != stopAncestor);
        return currentNode;
    },
	/**
	 * @private
	 * @function
	 */
	divideParagraph: function(node) {
		var _node = node;
		var _offset = $tom.indexOf(node);
		
		var _divided = _node;
		while (_node) {
			if ($tom.isBody(_node)) {
				break;
			} else if ($tom.kindOf(_node, 'td,th,%wrapper,%outergroup')) {
				break;
			} else if ($tom.kindOf(_node, "#tx_start_marker,#tx_end_marker")) {
				_offset = $tom.indexOf(_node);
			} else if($tom.isControl(_node)) {
				_offset = $tom.indexOf(_node);
			} else if ($tom.isText(_node)) { //text
				_node = $tom.divideText(_node, _offset);
				_offset = $tom.indexOf(_node);
			} else { //%inline, %paragraph
				_node = $tom.divideNode(_node, _offset);
				_offset = $tom.indexOf(_node);
				_divided = _node;
				if ($tom.kindOf(_node, 'p,li,dd,dt,h1,h2,h3,h4,h5,h6')) {
					break;
				}
			}
			_node = _node.parentNode;
		}
		return _divided;
	},
    wrapInlinesWithP: function(inline, ancestorBlock) {
        var ownerDocument = $tom.getOwnerDocument(inline);
        var inlineNodes = $tom.extract(ancestorBlock || ownerDocument.body, inline, '%text,%inline,%control');
        // caret\uc740 \uace7 \uc0ac\ub77c\uc9c0\uae30 \ub54c\ubb38\uc5d0P\ub85c \uac10\uc300 \ud544\uc694\uac00 \uc5c6\ub2e4
        if (this.hasOnlySavedCaret(inlineNodes, inline)) {
            return _NULL;
        }
        var newParagraph = ownerDocument.createElement("p");
        $tom.wrap(newParagraph, inlineNodes);
        return newParagraph;
    },
    hasOnlySavedCaret: function(inlines, inline) {
        var validInlines = inlines.findAll(function(node) {
            return node.nodeType != 3 || node.nodeValue.trim() != "";
        });
        return this.isGoogRangeCaret(inline) && validInlines.length == 1 && validInlines[0] == inline;
    },
    isGoogRangeCaret: function(node) {
        return node && /goog_[0-9]+/.test(node.id);
    }
});

Object.extend($tom, /** @lends $tom */{
	/**
	 * name\uc758 \ud558\uc704\uc694\uc18c\ub85c \ub4e4\uc5b4\uc62c \uc694\uc18c\uc774\ub984 \ubc18\ud658
	 * @function
	 * @example
	 *  $tom.paragraphOf("table") // 'td'\ub97c \ubc18\ud658\ud55c\ub2e4.
	 */
	paragraphOf: function(name) {
		if(!name) {
			return 'p';
		}
		var _translator = $tom.translate(name);
		if (_translator.memberOf('ul,ol')) {
			return 'li';
		} else if (_translator.memberOf('dl')) {
			return 'dd';
		} else if (_translator.memberOf('tr,tbody,thead,tfoot,table')) {
			return 'td';
		} else {
			return 'p';
		}
	},
	/**
	 * 'span' \uc744 \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 */
	inlineOf: function() {
		return 'span';
	},
	/**
	 * \uc694\uc18c\uc758 name\uc744 \ubc1b\uc544\uc11c \uc0c1\uc704\uc694\uc18c\uac00 \ub418\ub294 \uc694\uc18c\uc774\ub984\uc744 \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 * @example
	 *  $tom.outerOf("td") // "table"\uc744 \ubc18\ud658\ud55c\ub2e4.
	 */
	outerOf: function(name) {
		if(!name) {
			return 'span';
		}
		var _translator = $tom.translate(name);
		if (_translator.memberOf('li')) {
			return 'ol';
		} else if (_translator.memberOf('dd,dt')) {
			return 'dl';
		} else if (_translator.memberOf('td,th,tr')) {
			return 'table';
		} else {
			return 'p';
		}
	}
});
	
(function() {
	var __IGNORE_NAME_FLAG = 0;

	var UnitCalculate = Trex.Class.create({
		$const: {
			__FONT_SIZE_BASIS: 9,
			__REG_EXT_NUMBER: new RegExp("[0-9\.]+"),
			__REG_EXT_UNIT: new RegExp("px|pt|em")
		},
		initialize: function() {
			this.unitConverter = { //1em = 9pt
				"px2em": 1 / 12,
				"px2pt": 9 / 12,
				"em2px": 12, // 12 : 1
				"em2pt": 9,  // 9 : 1
				"pt2px": 12 / 9,
				"pt2em": 1 / 9
			};
		},
		calculate: function(strA, strB) {
			if (strA == _NULL || strA.length == 0) {
				strA = "0em";
			}
			if (strB == _NULL || strB.length == 0) {
				strB = "0em";
			}
	
			var _sign = this.extractSign(strB);
			
			var _unitA = this.extractUnit(strA);
			var _unitB = this.extractUnit(strB); //basis unit
			
			var _numA = this.extractNumber(strA).toNumber();
			var _numB = this.extractNumber(strB).toNumber();
			if(_unitA != _unitB) { //different unit
				if(this.unitConverter[_unitA+"2"+_unitB]) {
					_numA *= this.unitConverter[_unitA+"2"+_unitB];
				}
			}
			var _result = 0;
			if(_sign == "-") {
				_result = Math.max(_numA - _numB, 0);
			} else {
				_result = (_numA + _numB);
			} 
			_result = (Math.round(_result*10)/10);
			if (_result == 0) {
				return _NULL;
			} else {
				return _result + _unitB;
			}
		},
		needCalculation: function(str) {
			if(str == _NULL || typeof str != "string") {
				return _FALSE;
			} else {
				return (str.charAt(0) == '+' || str.charAt(0) == '-');
			}
		},
		extractSign: function(str) {
			var _sign = "+";
			if(str.charAt(0) == '+' || str.charAt(0) == '-') {
				_sign = str.charAt(0);
			}
			return _sign;
		},
		extractNumber: function(str) {
			var _num = 0;
			var _match;
			if((_match = str.match(UnitCalculate.__REG_EXT_NUMBER)) != _NULL) {
				_num = _match[0];
			}
			if(str.indexOf("%") > -1) { //%
				_num = _num / 100;
			}
			return _num;
		},
		extractUnit: function(str) {
			var _unit = "em";
			var _match;
			if((_match = str.match(UnitCalculate.__REG_EXT_UNIT)) != _NULL) {
				_unit = _match[0];
			}
			return _unit;
		}
	});
	var _unitCalculator = new UnitCalculate();
	
	var __ATTRIBUTE_TRANSLATIONS = {
	    colspan:   "colSpan",
	    rowspan:   "rowSpan",
	    valign:    "vAlign",
	    datetime:  "dateTime",
	    accesskey: "accessKey",
	    tabindex:  "tabIndex",
	    enctype:   "encType",
	    maxlength: "maxLength",
	    readonly:  "readOnly",
	    longdesc:  "longDesc",
	    cellPadding:  "cellPadding",
	    cellSpacing:  "cellSpacing",
	    more:  "more",
	    less:  "less",
        style: "style"
	};
	
	Object.extend($tom, /** @lends $tom */{ 
		/**
		 * node\uc5d0 \uc778\uc790\ub85c \ubc1b\uc740 attributes \uc18d\uc131\uc744 \uc138\ud305\ud55c\ub2e4.
		 * @function
		 * @param {Element} node
		 * @param {JSON} attributes
		 * @example
		 *  $tom.applyAttributes(inNode, {
		 *		'style': { 'fontSize': null },
		 *		'size': null
		 *	});
		 */
		applyAttributes: function(node, attributes) {
			if(!$tom.isElement(node)) {
				return;
			}
			for(var _name in attributes) {
				if(_name == "style") {
					$tom.applyStyles(node, attributes[_name]);
				} else {
					$tom.setAttribute(node, _name, attributes[_name]);
				}
			}
		},
		/**
		 * node\uc5d0 \uc778\uc790\ub85c \ubc1b\uc740 attributes \uc18d\uc131\uc744 \uc81c\uac70\ud55c\ub2e4.
		 * @function
		 */
		removeAttributes: function(node, attributes) {
			if(!$tom.isElement(node)) {
				return;
			}
			for(var _name in attributes) {
				if(_name == "style") {
					$tom.removeStyles(attributes[_name])
				} else {
					node.removeAttribute(_name, __IGNORE_NAME_FLAG);
				}
			}
		},
		/**
		 * node\uc5d0\uc11c attrName\uc744 \uc774\ub984\uc73c\ub85c \uac16\ub294 \uc18d\uc131\uc758 \uac12\uc744 \ubc18\ud658
		 * @function
		 * @example
		 *  $tx("tx_image").getAttribute("class") // class\uc18d\uc131\uc758 \uac12 \ubc18\ud658
		 */
		getAttribute: function(node, attrName) {
			if(!$tom.isElement(node)) {
				return _NULL;
			}
			if(node && node.getAttribute) {
				var val = node.getAttribute(__ATTRIBUTE_TRANSLATIONS[attrName] || attrName)
				return (val)? val:_NULL ;
			} else {
				return _NULL;
			}
		},
		/**
		 * node\uc5d0 attrName\ub97c \uc774\ub984\uc73c\ub85c, attrValue\ub97c \uac12\uc73c\ub85c \uac16\ub294 \uc18d\uc131\uc744 \uc138\ud305\ud55c\ub2e4.
		 * @function
		 */
		setAttribute: function(node, attrName, attrValue) {
			if(!$tom.isElement(node)) {
				return;
			}
			if(attrValue == _NULL || attrValue.length == 0 || attrValue == 0) {
				node.removeAttribute(attrName, __IGNORE_NAME_FLAG);
			} else {
				if(__ATTRIBUTE_TRANSLATIONS[attrName]) {
					node.setAttribute(__ATTRIBUTE_TRANSLATIONS[attrName], attrValue);
				} else {
					try {
						node[attrName] = attrValue;
					} catch(e) {
                        
						node.setAttribute(__ATTRIBUTE_TRANSLATIONS[attrName] || attrName, attrValue);
					}
				}
			}
		},
        // TODO : refactoring \ubb54\uac00 \ubcf5\uc7a1\ud558\ub2e4.
        setStyles: function(node, styles, overwrite) {
            var nodeCssText = node.style.cssText;
            var canSetStyle;
            var styleToSet = Object.extend({}, styles);
            if (styleToSet.font) {
                if (overwrite) {
                    node.style.font = styleToSet.font;  // \uc774 \ubd80\ubd84\uc5d0\uc11c chrome, opera\ub294 font\uc758 css \uc18d\uc131\uc774 \ubd84\ud574\ub41c \ud615\ud0dc\ub85c \uc801\uc6a9\ub41c\ub2e4.
                } else if (node.style.cssText.indexOf("font:") == -1) {
                    node.style.cssText = 'font: ' + styleToSet.font + '; ' + node.style.cssText;
                }
                delete styleToSet.font;
            }
            for (var styleName in styleToSet) {
                var styleValue;
                if (_unitCalculator.needCalculation(styleToSet[styleName])) {
                    styleValue = _unitCalculator.calculate(node.style[styleName], styleToSet[styleName]);
                } else {
                    styleValue = styleToSet[styleName];
                }
                if (styleValue == _NULL) {
                    styleValue = "";
                }

                if (styleName == 'float') {
                    styleName = $tx.msie ? 'styleFloat' : 'cssFloat';
                }
                canSetStyle = (!node.style[styleName] && (styleName.indexOf("font") != 0 || nodeCssText.indexOf("font:") == -1)) || overwrite;
                var newTextDecoration = (styleName == "textDecoration") && !node.style[styleName].include(styleValue);
                if (canSetStyle) {
                    node.style[styleName] = styleValue;
                } else if (newTextDecoration) {
                    node.style[styleName] += " " + styleValue;
                }
            }
            $tom._clearUselessStyle(node);
        },
		/**
		 * node\uc5d0 styles\uc5d0\uc11c \uc9c0\uc815\ud55c \uc2a4\ud0c0\uc77c\uc744 \uc801\uc6a9\ud55c\ub2e4.
		 * @function
		 * @example
		 *  $tom.applyStyles(node, {
		 * 		'width': width
		 *  });
		 */
		applyStyles: function(node, styles) {
            this.setStyles(node, styles, _TRUE);
        },
        /**
         * node\uc758 style \uc18d\uc131\uac12\uc744 \uc801\uc6a9\ud558\ub418, \uc774\ubbf8 \uc874\uc7ac\ud558\ub294 \uc18d\uc131\uc740 \uc720\uc9c0\ub41c\ub2e4.
         * @param node
         * @param styles
         */
        addStyles: function(node, styles) {
            this.setStyles(node, styles, _FALSE);
        },
		/**
		 * node\uc5d0\uc11c styles\uc778\uc790\uc5d0\uc11c \uc9c0\uc815\ud55c \uc2a4\ud0c0\uc77c \uc18d\uc131\uac12\uc744 \uc81c\uac70\ud55c\ub2e4. 
		 * @function
		 */
		removeStyles: function(node, styles) {
            // FTDUEDTR-1166
            var cssText = node.style.cssText;
            var orignalCssText = cssText;
			for(var _name in styles) {
                _name = _name.replace(/([A-Z])/g, "-$1");
                cssText = cssText.replace(new RegExp("(^| )" + _name + "\\s*:[^;]+;? ?", "ig"), "");
			}
            if (orignalCssText != cssText) {
                node.style.cssText = cssText;
                $tom._clearUselessStyle(node);
            }
		},
        _clearUselessStyle: function(node) {
            var _attrValue = $tom.getAttribute(node, "style");
            if (!_attrValue) { //remove needless style
                node.removeAttribute("style", __IGNORE_NAME_FLAG);
            }
        },
		/**
		 * node\uc5d0\uc11c style \uc18d\uc131\uac12 \ud14d\uc2a4\ud2b8\ub97c \ubaa8\ub450 \ubc18\ud658\ud55c\ub2e4.
		 * @function
		 */
		getStyleText: function(node) {
            return node.style.cssText;
		},
		/**
		 * node\uc758 style \uc18d\uc131\uac12\uc744 value\ub85c \ub123\ub294\ub2e4. \uae30\uc874\uc5d0 \uc788\ub294 \uac12\uc740 \ub36e\uc5b4\uc4f0\uc5ec\uc9c4\ub2e4.
		 * @function
		 * @param {Element} node
		 * @param {String} value style \uc18d\uc131\uc5d0 \ubc14\ub85c \uc138\ud305\ud560 \ud14d\uc2a4\ud2b8 \uac12\uc744 \ub123\uc5b4\uc57c \ud568
		 * @example
		 *  $tom.setStyleText($tx("tx_article_category"), "width:50px;height:10px")
		 */
		setStyleText: function(node, value) {
            node.style.cssText = value;
            !value && $tom._clearUselessStyle(node);
		}
	});
})();

Object.extend($tom, /** @lends $tom */{ 
	/**
	 * @private
	 * @function
	 */
	goInto: function(node, toTop) {
		if(!node || !node.scrollIntoView) {
			return;
		}
		node.scrollIntoView(toTop);
	},
	/**
	 * \uc218\uc9c1 \uc2a4\ud06c\ub864 \uc704\uce58\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 * @example
	 *  $tom.getScrollTop(document)
	 */
	getScrollTop: function(doc) {
		if(!doc) {
			return 0;
		}
		return doc.documentElement.scrollTop >= 0 ? doc.documentElement.scrollTop : doc.body.scrollTop;
	},
	/**
	 * \uc218\uc9c1 \uc2a4\ud06c\ub864 \uac12\uc744 \uc14b\ud305\ud55c\ub2e4.
	 * @function
	 * @param {Element} doc
	 * @param {Number} scrollTop \uc218\uc9c1 \uc2a4\ud06c\ub864 \uac12
	 */
	setScrollTop: function(doc, scrollTop) {
		if(!doc) {
			return;
		}
		if(doc.documentElement.scrollTop) {
			doc.documentElement.scrollTop = scrollTop;
		} else {
			doc.body.scrollTop = scrollTop;
		}
	},
	/**
	 * \uc218\ud3c9 \uc2a4\ud06c\ub864 \uc704\uce58\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 */
	getScrollLeft: function(doc) {
		if(!doc) {
			return 0;
		}
		return (doc.documentElement.scrollLeft || doc.body.scrollLeft);
	},
	/**
	 * \uc218\ud3c9 \uc2a4\ud06c\ub864 \uac12\uc744 \uc14b\ud305\ud55c\ub2e4.
	 * @function
	 * @param {Element} doc
	 * @param {Number} scrollLeft \uc218\ud3c9 \uc2a4\ud06c\ub864 \uac12
	 */
	setScrollLeft: function(doc, scrollLeft) {
		if(!doc) {
			return;
		}
		if(doc.documentElement.scrollLeft) {
			doc.documentElement.scrollLeft = scrollLeft;
		} else {
			doc.body.scrollLeft = scrollLeft;
		}
	},
	/**
	 * element\uc694\uc18c\uc758 left, top, width, height \uac12\uc744 \uacc4\uc0b0\ud558\uc5ec \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 * @return {
	 * 		x: 0,
	 * 		y: 0,
	 * 		width: 0,
	 * 		height: 0
	 * 	}
	 */
	getPosition: function(element, cumulative) {
		if(!element) {
			return {
				x: 0,
				y: 0,
				width: 0,
				height: 0
			};
		}
		cumulative = !!cumulative;
		element = $tx(element);
		var pos = (cumulative)? $tx.cumulativeOffset(element): $tx.positionedOffset(element);
		var dim;
		var display = element.style.display;
		if (display != 'none' && display != _NULL) { //Safari bug
			dim = {
				width: element.offsetWidth,
				height: element.offsetHeight
			};
		} else {
			var els = element.style;
			var originalVisibility = els.visibility;
			var originalPosition = els.position;
			var originalDisplay = els.display;
			els.visibility = 'hidden';
			els.position = 'absolute';
			els.display = 'block';
			var originalWidth = element.clientWidth;
			var originalHeight = element.clientHeight;
			els.display = originalDisplay;
			els.position = originalPosition;
			els.visibility = originalVisibility;
			dim = {
				width: originalWidth,
				height: originalHeight
			};
		}
		return {
			x: pos[0],
			y: pos[1],
			width: dim.width,
			height: dim.height
		};
	},
	/**
	 * node \uc694\uc18c\uc758 width\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.
	 * inline style\uc774 px\uac12\uc73c\ub85c \uc720\ud6a8\ud558\uc9c0 \uc54a\uc73c\uba74 offset\uc73c\ub85c \ub300\uccb4\ud55c\ub2e4.
	 * @function
	 */
	getWidth: function(node) {
		var width = node.style["width"];
		if( width.isPx() ){
			return width.parsePx();
		} 
		return node.offsetWidth;
	},
	/**
	 * node \uc694\uc18c \uc2a4\ud0c0\uc77c\uc18d\uc131\uc758 width \uac12\uc744 \uc138\ud305\ud55c\ub2e4.
	 * @function
	 */
	setWidth: function(node, width) {
		$tom.applyStyles(node, {
			'width': width
		});
	},
	/**
	 * node \uc694\uc18c\uc758 height\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.
	 * inline style\uc774 px\uac12\uc73c\ub85c \uc720\ud6a8\ud558\uc9c0 \uc54a\uc73c\uba74 offset\uc73c\ub85c \ub300\uccb4\ud55c\ub2e4.
	 * @function
	 */
	getHeight: function(node) {
		var height = node.style["height"];
		if( height.isPx() ){
			return height.parsePx();
		} 
		return node.offsetHeight;
	},
	/**
	 * node \uc694\uc18c \uc2a4\ud0c0\uc77c\uc18d\uc131\uc758 height \uac12\uc744 \uc138\ud305\ud55c\ub2e4.
	 * @function
	 */
	setHeight: function(node, height) {
		$tom.applyStyles(node, {
			'height': height
		});
	},
	/**
	 * @private
	 * @function
	 */
	replacePngPath: function(node) {
		if ($tx.msie6) {
			if(_DOC.location.href.indexOf("http://") > -1) {
				return;
			}
			try {
				var _orgFilter = $tx.getStyle(node, 'filter');
				var _orgSrc = /src='([^']+)'/.exec(_orgFilter)[1];
				if(!_orgSrc || _orgSrc == 'none') {
					return;
				} else if(_orgSrc.indexOf("http://") > -1) {
					return;
				}
				
				var _docPathSlices = _DOC.location.href.split("/");
				_docPathSlices.push("css");
				_docPathSlices.pop();
				_orgSrc = _orgSrc.replace(/\.\.\//g, function() {
					_docPathSlices.pop();
					return "";
				});
				
				var _newSrc = _docPathSlices.join("/") + "/" + _orgSrc;
				node.style.filter = _orgFilter.replace(/src='([^']+)'/, "src='" + _newSrc + "'");
			} catch(e) {alert(e)}
		}
	}
});

Object.extend($tom, /** @lends $tom */{
    /**
     * \ud3b8\uc9d1\uc601\uc5ed\uc5d0\uc11c \uae30\ubcf8 \ube48 \ubb38\ub2e8\uc5d0 \ud574\ub2f9\ud558\ub294 content
     * @constant
     */
    EMPTY_BOGUS: ($tx.msie_quirks || $tx.msie && $tx.msie_ver < 11 ? "&nbsp;" : "<br>")
});

Object.extend($tom, /** @lends $tom */{
    /**
	 * \ud3b8\uc9d1\uc601\uc5ed\uc5d0\uc11c \uae30\ubcf8 \ube48 \ubb38\ub2e8\uc5d0 \ud574\ub2f9\ud558\ub294 HTML
	 * @constant
	 */
    EMPTY_PARAGRAPH_HTML: "<p>" + $tom.EMPTY_BOGUS + "</p>"
});

_WIN.$tom = $tom;
(function(Trex) {
	/**
	 * @namespace
	 * @name Trex.Util
	 */
	Trex.Util = /** @lends Trex.Util */ {
		_dispElIds: [],
		getDispElId: function() {
			var _genId;
			do {
				_genId = "tx_entry_" + (Math.floor(Math.random() * 90000) + 10000) + "_"; //id: 10000~99999
			} while(Trex.Util._dispElIds.contains(_genId));
			Trex.Util._dispElIds.push(_genId);
			return _genId;
		},
		generateKey: function() {
			return parseInt(Math.random() * 100000000);
		},
		toStyleString: function(styles) {
			var _str = [];
			for(var _name in styles) {
				if(styles[_name]) {
					_str.push(_name.replace(/([A-Z])/g, "-$1").toLowerCase());
					_str.push(":");
					_str.push(styles[_name]);
					_str.push(";");
				}
			}
			return _str.join("");
		},
		toAttrString: function(attrs) {
			var _str = [];
			if(TrexConfig.get("imgWidth")) {
				var _imgWidth = TrexConfig.get("imgWidth");
				if (attrs['width']>_imgWidth) {
					attrs['height'] = parseInt(attrs['height']*(_imgWidth/attrs['width']));
					attrs['width'] = _imgWidth;
				}
			}
			for(var _name in attrs) {
				if(attrs[_name]) {
					_str.push(" " + _name + "=\"" + attrs[_name] + "\"");
				}
			}
			return _str.join("");
		},
		getMatchValue: function(reg, html, inx) {
			var _matchs;
			if((_matchs = reg.exec(html)) != _NULL) {
				return _matchs[inx];
			} else {
				return _NULL;
			}
		},
		getAttachmentType: function(mimeType){
			mimeType = (mimeType || "").toLowerCase();

            var imageMimeTypes = ['image/jpg', 'image/jpeg', 'image/png', 'image/tiff',
                'image/gif', 'image/bmp', 'image/x-jg', 'image/ief', 'image/pict',
                'jpg', 'bmp', 'gif', 'png'];

            if (imageMimeTypes.contains(mimeType)) {
                return 'image';
            }
            return 'file';
		},
		/**
		 * \ud655\uc7a5\uc790\uc5d0 \ub530\ub294 thumbnail \uc774\ubbf8\uc9c0 url\uc744 \uac00\uc838\uc628\ub2e4.
		 * @param {Object} ext
		 */
		thumburl: function(ext) {
			ext = (ext || "").toLowerCase();
			switch (ext) {
				case "doc":
				case "docx":
					return getIconPath("#iconpath/pn_word.gif");
				case "xls":
				case "xlsx":
					return getIconPath("#iconpath/pn_xls.gif");
				case "ppt":
				case "pptx":
					return getIconPath("#iconpath/pn_ppt.gif");
				case "pdf":
					return getIconPath("#iconpath/pn_pdf.gif");
				case "txt":
					return getIconPath("#iconpath/pn_txt.gif");
				case "hwp":
					return getIconPath("#iconpath/pn_hwp.gif");
				case "zip":
				case "rar":
				case "7z":
				case "alz":
					return getIconPath("#iconpath/pn_zip.gif");
				case "mp3":
				case "wav":
				case "ogg":
				case "wma":
				case "ape":
				case "ra":
				case "ram":
					return getIconPath("#iconpath/pn_mp3.gif");
				case "avi":
				case "mpeg":
				case "wmv":
				case "asf":
				case "mp4":
				case "mkv":             
					return getIconPath("#iconpath/pn_movie.gif");
				case "swf":
					return getIconPath("#iconpath/pn_swf.gif");
				case "htm" :
				case "html":
					return getIconPath("#iconpath/pn_html.gif");
				case "jpg":
				case "gif":
				case "png":
				case "bmp":
					return getIconPath("#iconpath/pn_etc.gif");
				default:
					return getIconPath("#iconpath/pn_etc.gif");
			}
		},
		/**
		 * \ud655\uc7a5\uc790\uc5d0 \ub530\ub294 preview \uc774\ubbf8\uc9c0 url\uc744 \uac00\uc838\uc628\ub2e4.
		 * @param {Object} ext
		 */
		prevurl: function(ext) {
			ext = (ext || "").toLowerCase();
			switch (ext) {
				case "doc":
				case "docx":
					return getIconPath("#iconpath/p_word_s.gif");
				case "xls":
				case "xlsx":
					return getIconPath("#iconpath/p_xls_s.gif");
				case "ppt":
				case "pptx":
					return getIconPath("#iconpath/p_ppt_s.gif");
				case "pdf":
					return getIconPath("#iconpath/p_pdf_s.gif");
				case "txt":
					return getIconPath("#iconpath/p_txt_s.gif");
				case "hwp":
					return getIconPath("#iconpath/p_hwp_s.gif");
				case "zip":
				case "rar":
				case "7z":             
				case "alz":
					return getIconPath("#iconpath/p_zip_s.gif");
				case "mp3":
				case "wav":
				case "ogg":
				case "wma":
				case "ape":
				case "ra":
				case "ram":
				case "m4a":
					return getIconPath("#iconpath/p_mp3_s.gif");
				case "avi":
				case "mpeg":
				case "wmv":
				case "asf":
				case "mp4":
				case "mkv":             
					return getIconPath("#iconpath/p_movie_s.gif");
				case "swf":
					return getIconPath("#iconpath/p_swf_s.gif");
				case "htm" :
				case "html":
					return getIconPath("#iconpath/p_html_s.gif");
				case "jpg":
					return getIconPath("#iconpath/p_jpg_s.gif");
				case "gif":
					return getIconPath("#iconpath/p_gif_s.gif");
				case "png":
				case "bmp":
					return getIconPath("#iconpath/p_png_s.gif");
				default:
					return getIconPath("#iconpath/p_etc_s.gif");
			}
		},
		getMatchedClassName: function(element, classes){
			var matched = _FALSE;
			var _class = "";
			for(var i = 0; i < classes.length; i++){
				_class = classes[i];
				if($tx.hasClassName(element, _class)){
					matched = _class;
					break;
				}
			}
			return matched;
		},
		getAllAttributesFromEmbed: function(embedSrc){
			var map = {};
			embedSrc = embedSrc.replace(/<embed|>/ig,"");
			try {
				var regSplit = /(\w+)=((?:\")[^\"]+(?:\"|$)|(?:')[^']+(?:'|$)|(?:[^\"'][^ \n]+($| |\n)))/ig;
                var result;
				while( (result = regSplit.exec(embedSrc)) != _NULL ){
					map[result[1].trim().toLowerCase()] = result[2].replace(/^(\"|')/i,"").replace(/(\"|')$/i,"").trim();
				}
			}catch(e){ }

			return map;
		},
		getAllAttributes: function(source){
			var _map = {};
			var _matchsAttr;

			var _reg = /style="(?:\s*|(?:[^"]*(?:;\s*)))width\s*:\s*([0-9]+)px[^"]*"/ig;
			while ((_matchsAttr = _reg.exec(source)) != _NULL) {
				_map["width"] = _matchsAttr[1];
			}
			_reg = /style="(?:\s*|(?:[^"]*(?:;\s*)))height\s*:\s*([0-9]+)px[^"]*"/ig;
			while ((_matchsAttr = _reg.exec(source)) != _NULL) {
				_map["height"] = _matchsAttr[1];
			}
			_reg = new RegExp("\\s+([a-zA-Z\-]+)=\"([^\"]*)\"", "g");
			while ((_matchsAttr = _reg.exec(source)) != _NULL) {
				if (!_map[_matchsAttr[1].toLowerCase()]) {
					_map[_matchsAttr[1].toLowerCase()] = _matchsAttr[2];
				}
			}
			_reg = new RegExp("\\s+([a-zA-Z\-]+)='([^']*)'", "g");
			while ((_matchsAttr = _reg.exec(source)) != _NULL) {
				if (!_map[_matchsAttr[1].toLowerCase()]) {
					_map[_matchsAttr[1].toLowerCase()] = _matchsAttr[2];
				}
			}
			_reg = new RegExp("\\s+([a-zA-Z\-]+)=([^\\s>]*)", "g");
			while ((_matchsAttr = _reg.exec(source)) != _NULL) {
				if (!_map[_matchsAttr[1].toLowerCase()]) {
					_map[_matchsAttr[1].toLowerCase()] = _matchsAttr[2];
				}
			}
			return _map;
		}
	};

	/**
	 * @namespace
	 * @name Trex.HtmlCreator
	 */
	Trex.HtmlCreator = {
		/**
		 * Create Table Markup String
		 *
		 *  @example
		 *  var items =[
		 *  		{
		 *  			klass: 'klassName',
		 *  			image: 'image url', // can be omitted
		 *  			data: 'data'
		 *  		}
		 *  	]
		 *
		 *	var tableMarkup = Trex.HtmlCreator.createTableMarkup(row, col, item);
		 *
		 * @param {int} rows
		 * @param {int} cols
		 * @param {Object} items
		 *
		 */
		createTableMarkup: function(rows, cols, items){
			var _html = [];
			_html.push('<table unselectable="on">');
			_html.push('<tbody>');

			var _total = items.length;
			var _item;
            for (var row = 0; row < rows; row++) {
				_html.push('<tr>');
                for (var col = 0; col < cols; col++) {
                    if (row * cols + col < _total) {
                        _item = items[row * cols + col];
                        if (_item.image) {
                            var imageUrl = TrexConfig.getIconPath(_item.image); //\uae00\uc0c1\uc790 > \uc9c1\uc811\uc120\ud0dd > \uc120\uc2a4\ud0c0\uc77c \uc774\ubbf8\uc9c0.
                            _html.push('<td class="tx-menu-list-item"><a href="javascript:;"><span class="' + (_item.klass || '') + '"><img src="' + imageUrl + '" data="' + _item.data + '"/></span></a></td>');
                        } else {
                            _html.push('<td class="tx-menu-list-item"><a href="javascript:;"><span class="' + (_item.klass || '') + '">' + _item.data + '</span></a></td>');
                        }
                    } else {
                        _html.push('<td class="tx-menu-list-item"><a href="javascript:;"><span class="">&nbsp;</span></a></td>');
                    }
                }
				_html.push('</tr>');
			}
			_html.push('</tbody>');
			_html.push('</table>');
			return _html.join("\n");
		}
	};

	Trex.String = {
		escapeQuot: function(str) {
			return str.replace(new RegExp('"', "g"), "&quot;").replace(new RegExp("'", "g"), "&#39;");
		},
		unescapeQuot: function(str) {
			return str.replace(new RegExp("&quot;", "gi"), '"').replace(new RegExp("&#39;", "g"), "'");
		},
		htmlspecialchars: function(str) {
			return Trex.String.escapeQuot(str.replace(new RegExp("&", "g"), "&amp;").replace(new RegExp("<", "g"), "&lt;").replace(new RegExp(">", "g"), "&gt;"));
		},
		unHtmlspecialchars: function(str) {
			return Trex.String.unescapeQuot(str.replace(new RegExp("&amp;", "gi"), "&").replace(new RegExp("&lt;", "gi"), "<").replace(new RegExp("&gt;", "gi"), ">"));
		},
		parseAttribute: function(elStr, attrName){
			var regAttribute1 = new RegExp("(^|\\W)" + attrName + '="([^"]*)"', "gi");
			var regAttribute2 = new RegExp("(^|\\W)" + attrName + "='([^']*)'", "gi");
			var regAttribute3 = new RegExp("(^|\\W)" + attrName + "=([^\\s>]*)", "gi");
            var result;
			if (result = regAttribute1.exec(elStr)) {
				return result[2];
			}else if (result = regAttribute2.exec(elStr)) {
				return result[2];
			}else if (result = regAttribute3.exec(elStr)) {
				return result[2];
			}else {
				return "";
			}
		},
		changeAttribute: function(elStr, attrName, currentValue, value ){
			var regAttribute1 = new RegExp("(^|\\W)(" + attrName + '=")' + currentValue + '(")', "gi");
			var regAttribute2 = new RegExp("(^|\\W)(" + attrName + "=')" + currentValue + "(')", "gi");
			var regAttribute3 = new RegExp("(^|\\W)(" + attrName + "=)"+currentValue, "gi");
			var regAttribute4 = new RegExp("<([\\w]+\\s*)", "gi");
			var _exists = _FALSE;
			if (elStr.search(regAttribute1) > -1) {
				_exists = _TRUE;
				elStr = elStr.replace(regAttribute1, "$1$2"+value+"$3");
			}
			if (elStr.search(regAttribute2) > -1) {
				_exists = _TRUE;
				elStr = elStr.replace(regAttribute2, "$1$2"+value+"$3");
			}
			if (elStr.search(regAttribute3) > -1) {
				_exists = _TRUE;
				elStr = elStr.replace(regAttribute3, "$1$2"+value);
			}
			if(!_exists) {
				elStr = elStr.replace(regAttribute4, "<$1" + attrName + '=' + value + ' ');
			}
			return elStr;
		}
	};

	/*---- Trex.Validator ------------------------------------------------------*/
	Trex.Validator = Trex.Class.create({
		initialize: function() { },
		strip: function(content) {
			return content.stripTags().replace(/&nbsp;/g, "").replace(Trex.__WORD_JOINER_REGEXP, "").trim();
		},
		exists: function(content) {
			if(!content) {
				return _FALSE;
			}
			if(this.strip(content) == "") {
				if(content.search(/<(img|iframe|object|embed|table|hr|script|TXDB)/i) < 0) {
					return _FALSE;
				}
			}
			return _TRUE;
		},
		equals: function(content, text) {
			if(!content || !text) {
				return _FALSE;
			}
			if(content.search(/<(img|iframe|object|embed|table|hr|script|TXDB)/i) < 0) {
				if(this.strip(content) == this.strip(text)) {
					return _TRUE;
				}
			}
			return _FALSE;
		}
	});

	/*---- Trex.Repeater ------------------------------------------------------*/
	Trex.Repeater = Trex.Class.create({
		initialize: function(execHandler) {
			this.execHandler = execHandler;
		},
		start: function(term) {
			if(this.tItv) {
				this.clear();
			}
			this.tItv = _WIN.setInterval(this.onTimer.bind(this), term);
		},
		clear: function() {
			_WIN.clearInterval(this.tItv);
			this.tItv = _NULL;
		},
		onTimer: function() {
			if(this.execHandler != _NULL) {
				this.execHandler();
			}
		}
	});

	/*---- Trex.Timer ------------------------------------------------------*/
	Trex.Timer = Trex.Class.create({
		initialize: function(execHandler) {
			this.execHandler = execHandler;
		},
		start: function(term) {
			_WIN.setTimeout(this.onTimer.bind(this), term);
		},
		onTimer: function() {
			if(this.execHandler != _NULL) {
				this.execHandler();
			}
		}
	});

	/**
	 * Trex.Paging Class
	 * paging\uc744 \uc704\ud55c class. Ajax\ub098 fileter \ub4f1\uc744 \ud1b5\ud55c dynamic data\ubc14\uc778\ub529\uc740 \uace0\ub824\ub418\uc9c0 \uc54a\uc74c. static array\ub85c\ub9cc \uc0ac\uc6a9\uc774 \uac00\ub2a5
	 * @class
	 * @param {Array} data
	 * @param {Object} config
	  */
	Trex.Paging = Trex.Class.create({
		$const:{
			DEFAULT_PAGE_SIZE: 5,
			DEFAULT_BLOCK_SIZE:10
		},
		initialize: function(data, config ){
			this.data = data;
			this.currentpage = config.initPage || 1;
			this.totalrow = config.totalrow || this.getTotalRow();
			this.pagesize = config.pagesize || Trex.Paging.DEFAULT_PAGE_SIZE;
			this.blocksize = config.blocksize || Trex.Paging.DEFAULT_PAGE_SIZE;
			this.totalpage = Math.ceil( this.totalrow / this.pagesize );
			this.totalblock = Math.ceil( this.totalpage / this.blocksize );
		},
		getNextPage: function(){
			return (this.currentpage < this.totalpage)?this.currentpage+1:0;
		},
		getPrevPage: function(){
			return (this.currentpage > 1)?this.currentpage-1:0;
		},
		getNextBlock: function(){
			var _currentblock = Math.ceil(this.currentpage/this.blocksize);
			return ( _currentblock < this.totalblock)?_currentblock * this.blocksize + 1:0
		},
		getPrevBlock: function(){
			var _currentblock = Math.ceil(this.currentpage/this.blocksize);
			return (_currentblock > 1)?(_currentblock-2) * this.blocksize + 1:0;
		},
		getPageList: function(){
			var pages = [];
			var _startBlock = Math.ceil( this.currentpage / this.blocksize ) - 1;
			var _startPage = ( _startBlock * this.blocksize + 1 );
			var _endPage = Math.min( this.totalpage, (_startPage + this.blocksize - 1) );
			for ( var i = _startPage; i <= _endPage; i++ ){
				pages.push(i);
			}

			return pages;
		},
		movePage: function( page ){
			this.currentpage = page || this.currentpage;
		},
		getOnePageData: function(){
			var result = [];
			var _start = (this.currentpage-1) * this.pagesize;
			var _end = Math.min( this.currentpage * this.pagesize, this.totalrow ) ;
			for( var i = _start; i < _end; i++ ){
				result.push( this.data[i] );
			}

			return result;
		},
		getTotalRow: function(){
			return this.data.length;
		}
	});

	/**
	 * Trex.Slidebar Class
	 * slidebar \uc704\uc82f. \ub9c8\ud06c\uc5c5, CSS\uc5d0 \uc758\uc874\uc131\uc774 \uc788\ub2e4.
	 * @class
	 * @param {Object} config
	  */
	Trex.Slidebar = Trex.Class.create({
		initialize: function(config){
			/* config = {
			 * 		handler: function, \uc2ac\ub77c\uc774\ub4dc\uac00 \ub3d9\uc791\ud560\ub54c \uc2e4\ud589\ub420 \ud568\uc218
			 * 		elContext: \uc2ac\ub77c\uc774\ub4dc\uac00 \uc81c\uc5b4\ub420 \uc601\uc5ed, div\ub4f1\uc758 element
			 * 		knoWidth: knob element\uc758 \ud06c\uae30
			 * 		barSize: \uc2ac\ub77c\uc774\ub4dc element\uc758 \ud06c\uae30
			 * 		min: \ucd5c\uc18c\uac12(\ub17c\ub9ac\uc801\uc778 \uac12, default 0)
			 *  	max: \ucd5c\ub300\uac12(\ub17c\ub9ac\uc801\uc778 \uac12, default 100)
			 *  	interval: \ud55c\ubc88 \ud074\ub9ad\uc774\ub098 \ub9c8\uc6b0\uc2a4 \ub4dc\ub798\uadf8\ub85c \uc774\ub3d9\ud558\ub294 \uac12(\ub17c\ub9ac\uc801\uc778 \uac12, default 5)
			 * 		defaultValue: \ucd08\uae30 knob\uc774 \uc704\uce58\ud560 \uac12
			 * }
			 */
			this.elContext = config.el;
			this.knobWidth =  config.knobWidth;
			this.isDisabled = _FALSE;
			this.handler = function(value){
				if (!this.isDisabled && typeof config.handler == "function") {
					config.handler(value);
				}
			};

			this.logicObj = {
				'interval': config.interval || 5 ,
				'min': config.min || 0,
				'max': config.max || 100
			};
			this.physicObj = {
				'min':0,
				'width': config.barSize || 100
			};
			this.physicObj.max = this.physicObj.width - this.knobWidth;
			this.physicObj.interval = this.logicObj.interval * this.physicObj.max / this.logicObj.max;

			this.startPos = 0;
			this.startX = 0;
			this.isDrag = _FALSE;
			this.result = 0;

			var elMenu = $tom.collect( this.elContext, "dd.tx-slide" );
			// \uc591\ub05d\ub2e8\uc5d0 min\uac12\uacfc max\uac12\uc774 \ud45c\uc2dc \ub420 \uc218\ub3c4 \uc788\ub2e4.
			$tom.collect( elMenu, "span.tx-slide-min" ).innerHTML = "";
			$tom.collect( elMenu, "span.tx-slide-max" ).innerHTML = "";

			/* default \uac12 \uc14b\ud305\ud558\ub294 \ubd80\ubd84\uc774 \ud544\uc694\ud558\ub2e4? */
			this.bindEvent();
			this.setKnobPosition(config.defaultValue || config.min || 0);
		},
		regenerate: function( value ){
			value = parseInt(value * this.physicObj.width / this.logicObj.max);
			this.setKnobPosition(value);
		},
		bindEvent: function(){
			var elMenu = $tom.collect( this.elContext, "dd.tx-slide" );
			var elPrev = $tom.collect( elMenu, "a.tx-slide-prev" );
			var elNext = $tom.collect( elMenu, "a.tx-slide-next" );
			var elBar = $tom.collect( elMenu, "div.tx-slide-bar" );
			var elKnob = this.elKnob = $tom.collect( elMenu, "div.tx-slide-knob" );

			$tx.observe( elKnob, "mousedown", function(ev){
				this.isDrag = _TRUE;
				this.startPos = this.getKnobPosition();
				this.startX = ev.clientX;
				$tx.stop(ev);
			}.bind(this));

			$tx.observe( elKnob, "mouseup", function(){
				this.isDrag = _FALSE;
			}.bind(this));

			$tx.observe( this.elContext, "mousemove", function(ev){
				if ( this.isDrag ){
					this.setKnobPosition( this.startPos +  ev.clientX - this.startX);
					$tx.stop(ev);
					this.handler( this.result );
				}
			}.bind(this));

			$tx.observe( elPrev, "click", function(ev){
				var count = Math.round(this.physicObj.interval) - 1;
				var that = this;
				var moveLeft = function(){
					var pos = that.getKnobPosition();
					that.setKnobPosition( pos - 1);
					if ( count-- > 0 ) {
						setTimeout(moveLeft, 10 );
					}else{
						that.handler(that.result);
					}
				};
				moveLeft();
				$tx.stop(ev);
			}.bind(this));

			$tx.observe( elNext, "click", function(ev){
				var count = Math.round(this.physicObj.interval);
				var that = this;
				var moveRight = function(){
					var pos = that.getKnobPosition();
					that.setKnobPosition( pos + 1);
					if ( --count > 0 ) {
						setTimeout(moveRight, 10 );
					}else{
						that.handler(that.result);
					}
				};
				moveRight();
				$tx.stop(ev);
			}.bind(this));

			$tx.observe( this.elContext, "mouseup", function(){
				if ( this.isDrag ) {
					this.isDrag = _FALSE;
				}
			}.bind(this));
			$tx.observe( elKnob, "click", function(ev){
				$tx.stop(ev);
			}.bind(this));

			$tx.observe( elBar, "click", function(ev){
				if ( !this.isDrag ) {
					var x = ev.layerX || ev.x;
					this.setKnobPosition( x - this.knobWidth / 2);
					this.handler( this.result );
				}
			}.bind(this));
		},
		getKnobPosition: function(){
			var pos = $tx.getStyle( this.elKnob, "left");
			return pos.parsePx();
		},
		setKnobPosition: function(value){
			value = (value < this.physicObj.max)?value:this.physicObj.max;
			value = (value > this.physicObj.min)?value:this.physicObj.min;
			$tx.setStyle( this.elKnob, {left: value.toPx()});

			this.result = Math.round( value * this.logicObj.interval / this.physicObj.interval );
		},
		setDisable: function(){
			this.isDisabled = _TRUE;
		},
		setEnable: function(){
			this.isDisabled = _FALSE;
		},
		getDisabled: function(){
			return this.isDisabled;
		}
	});


	/**
	 * Trex.DynamicSizer Class
	 * table\uc758 \uac00\ub85c\uc138\ub85c \uc0ac\uc774\uc988\ub97c \ub9c8\uc6b0\ub85c \uc81c\uc5b4\ud560 \uc218 \uc788\ub294 \uc704\uc82f.
	 * @class
	 * @param {Object} config
	  */
	Trex.DynamicSizer = Trex.Class.create({
		initialize: function(config){
			/* config = {
			 * 		el: //\ub2e4\uc774\ub098\ubbf9 \uc0ac\uc774\uc800\uac00 \uc2e4\ub9b4 \uc601\uc5ed
			 * 		clickHandler : \ud074\ub9ad\ub410\uc744\ub54c
			 * 		moveHandler: \uc0ac\uc774\uc988\uac00 \ubcc0\uacbd\ub410\uc744 \ub54c
			 */
			this.config = config;
			this.wrapper = config.el;
			this.elEventContext = tx.div({className:"tx-dynamic-sizer-context"});
			this.currentSize = {row: 0, col: 0};
			this.dynamicSizingEnabled = _TRUE;

			if( !config.moveHandler ){
				config.moveHandler = function(){}
			}
			if( !config.clickHandler ){
				config.clickHandler = function(){}
			}

			this.wrapper.appendChild( this.elEventContext );
			this.previewTable = new Trex.DynamicSizer.PreviewTable({
				parentEl: this.elEventContext,
				mouseOverHandler: this.changeSize.bind(this),
				mouseClickHandler: this.selectSize.bind(this)
			});
		},
		clear: function(){
			this.dynamicSizingEnabled = _TRUE;
			this.changeSize(0,0);
		},
		changeSize: function(row, col){
			if (this.dynamicSizingEnabled) {
				this.currentSize.row = row;
				this.currentSize.col = col;

				this._changeSelectionSize(row, col);
				this.config.moveHandler(row, col);
			}
		},
		_changeSelectionSize: function(row, col){
			this.previewTable.moveSelectionPos(row, col);
		},
		toggleDynamicSizing: function(){
			this.dynamicSizingEnabled = !this.dynamicSizingEnabled;
			if ( this.dynamicSizingEnabled ){
				this.selection.enableResize();
			}else{
				this.selection.disableResize();
			}
		},
		selectSize:function(ev){
			this.config.clickHandler( ev, this.currentSize);
		},
		getCurruentSize: function(){
			return this.currentSize;
		}
	});

    Trex.DynamicSizer.PreviewTable = Trex.Class.create({
        $const:{
            DEFAULT_TD_STYLE:{
            },
            DEFAULT_TABLE_PROPERTY:{
                cellpadding: "0",
                cellspacing: "1"
            },
            MAX_SIZE: { COL:10, ROW:10 }
        },
        initialize: function(config){
            this.config = config;
            this.elTable = _NULL;

            this.elTable = this.generateTable("tx-event");
            this.elSelection = tx.div( {className:"tx-selection"}, this.generateTable("tx-selection") );
            var tablePanel = this.generateTable("tx-panel");

            this.eventBinding();
            config.parentEl.appendChild( this.elTable );
            config.parentEl.appendChild( this.elSelection );
            config.parentEl.appendChild( tablePanel );

            var pos = $tom.getPosition( this.elTable );
            var PROPERTY = Trex.DynamicSizer.PreviewTable.MAX_SIZE;
            this.cellSize = { width: Math.round((pos.width - pos.x) / PROPERTY.COL),
                                height: (pos.height - pos.y) / PROPERTY.ROW }
        },
        generateTable: function(className){
            var tbody = tx.tbody();
            var PROPERTY = Trex.DynamicSizer.PreviewTable;
            for (var i = 0; i < PROPERTY.MAX_SIZE.ROW; i++) {
                var tr = tx.tr();
                for (var j = 0; j < PROPERTY.MAX_SIZE.COL; j++) {
                    var td = tx.td(tx.div( {
                        style: PROPERTY.DEFAULT_TD_STYLE
                    }));
                    td = this.setCoordToAttr(td, j+1, i+1);
                    tr.appendChild(td);
                }
                tbody.appendChild(tr);
            }
            var table = tx.table(PROPERTY.DEFAULT_TABLE_PROPERTY);
            $tx.addClassName( table, className || "" );
            table.appendChild( tbody );
            return table;
        },
        moveSelectionPos: function(row,col){
            var width = ( col * this.cellSize.width).toPx();
            var height = ( row * this.cellSize.height).toPx();
            $tx.setStyle( this.elSelection, { width: width, height:height } );
        },
        setCoordToAttr: function(element, col, row){
            element.setAttribute("col", col);
            element.setAttribute("row", row);
            return element;
        },
        getCoordFromAttr: function(element){
            return {
                col: element.getAttribute("col") || 0,
                row: element.getAttribute("row") || 0
            }
        },
        eventBinding: function(){
            // \uc678\ubd80\uc5d0\uc11c \ubc1b\uc740 event\ud578\ub4e4\ub7ec\ub4e4\ub85c binding\uc2dc\ud0b4
            this.mouseOverHandler = this.config.mouseOverHandler;
            this.mouseClickHandler = this.config.mouseClickHandler;
            var self = this;
            var _mouseOverHandler = function(ev){
                var element = $tx.element(ev) || {};
                var tagName = (element.tagName || "").toUpperCase();
                if (element && tagName == "TD" ) {
                    var coord = self.getCoordFromAttr(element);
                    self.mouseOverHandler(coord.row, coord.col);
                }
                $tx.stop(ev);
            };
            var _mouseClickHandler = function(ev){
                self.mouseClickHandler(ev);
            };
            $tx.observe(this.elTable, "mouseover", _mouseOverHandler);
            $tx.observe(this.elTable, "click", _mouseClickHandler);
        }
    });

    /*---- Trex.ImageScale ------------------------------------------------------*/
    Trex.ImageScale = Trex.Class.create({
        initialize: function(data, handler) {
            if(!data.imageurl) {
                return;
            }
            if(data.actualwidth) {
                return;
            }
            var _loadHandler = function(width, height) {
                data.actualwidth = width;
                data.actualheight = height;
                if(handler) {
                    handler(width, height);
                }
            };

            setTimeout(function() {
                var _tmpImage = new Image();
                _tmpImage.onerror = function() {
                    _tmpImage = _NULL;
                };
                if( _tmpImage.onreadystatechange ) { //IE
                    _tmpImage.onreadystatechange = function() {
                        if(this.readyState == "complete") {
                            _loadHandler(this.width, this.height);
                            _tmpImage = _NULL;
                        }
                    };
                } else {
                    _tmpImage.onload = function() {
                        _loadHandler(this.width, this.height);
                        _tmpImage = _NULL;
                    };
                }
                _tmpImage.src = data.imageurl;
            }, 10);
        }
    });

    function getIconPath(virtualPath) {
        var realPath = TrexConfig.getIconPath(virtualPath);
        return realPath + "";
    }

})(Trex);

/**
 * @fileoverview
 * Class Trex.ImageResizer\ub97c \ud3ec\ud568\ud558\uace0 \uc788\ub2e4. 
 *    
 * @author iamdanielkim
 * 
 */

/**
 * img element\uc5d0 \uc6d0\ud558\ub294 width, height\ub85c \ubcc0\uacbd\ub41c image\ub97c loading\ud55c\ub2e4.
 *  
 * 
 * @example
 *  var imageResizer = new Trex.ImageResizer(el, config);
 *  imageResizer.execResize(imageurl);
 *  
 * @constructor
 * @param {Object} elImage
 * @param {Object} config
 */
Trex.ImageResizer = Trex.Class.create({
	initialize: function(elImage, config) {
		var _elImage = elImage;

		var _maxWidth = config.maxWidth || 200;
		var _maxHeight = config.maxHeight || 200;
		var _defImgUrl = config.defImgUrl;
		var _loadHandler = config.onComplete || function() {};
		
		function doResize(imgEl, imgurl){
			var _resizedHeight, _resizedWidth;
			var _originWidth = imgEl.width;
			var _originHeight = imgEl.height;
			if (_originWidth == _maxWidth && _originHeight == _maxHeight) {
				_resizedWidth = _maxWidth;
				_resizedHeight = _maxHeight;
			} else if (_originWidth < _maxWidth && _originHeight < _maxHeight) {
				_resizedWidth = _originWidth;
				_resizedHeight = _originHeight;
			} else {
				_resizedHeight = _maxHeight;
				_resizedWidth = Math.floor(_maxHeight * (_originWidth / _originHeight));
				if (_resizedWidth > _maxWidth) {
					_resizedWidth = _maxWidth;
					_resizedHeight = Math.floor(_maxWidth * (_originHeight / _originWidth));
				}
			}
			_elImage.width = _resizedWidth;
			_elImage.height = _resizedHeight;
			_elImage.src = imgurl;
			_loadHandler(_resizedWidth, _resizedHeight);
		}
		
		/**
		 * resize\ub97c \uc2e4\ud589\ud55c\ub2e4.
		 * 
		 * @memberOf Trex.ImageResizer.prototype 
		 * @param {Object} imgurl
		 */			
		this.execResize =  function(imgurl) {
			var _tmpImage = new Image();
			_tmpImage.onerror = function() {
				_elImage.width = _maxWidth;
				_elImage.height = _maxHeight;
				_elImage.src = _defImgUrl;
				_tmpImage = _NULL;
			};
			
			if( _tmpImage.onreadystatechange ) { //IE
				_tmpImage.onreadystatechange = function() {
					if(this.readyState == "complete") {
						doResize(_tmpImage, imgurl);
					}
				};
			} else {
				_tmpImage.onload = function(){
					doResize(_tmpImage, imgurl);
				}	
			}
			_tmpImage.src = imgurl;
		};
	}
});



/*jslint nomen: false*/
/*global Trex, $tom, $tx, _FALSE, _NULL, _TRUE */
Trex.TableUtil = {
	/**
	 * isDaumTable
	 * @param {Element} table
	 * @return {boolean}
	 */
	isDaumTable: function (table) {
		return $tx.hasClassName(table, "txc-table");
	},
	/**
	 * cloneNodeForEmptyTd
	 * @param {Element} node
	 */
	cloneNodeForEmptyTd: function (node) {
		var newNode;
		newNode = node.cloneNode(_FALSE);
		Trex.TableUtil.emptyTd(newNode);
		return newNode;
	},
	emptyTd: function (node) {
		node.innerHTML = "&nbsp;";
	},
	/**
	 * splitWidthByColSpan
	 * @param {Element} td
	 */
	splitWidthByColSpan: function (td) {
		var styleWidth;
		if (1 < td.colSpan && td.style.width) {
			styleWidth = parseInt(td.style.width, 10);
			$tom.setStyles(td, {
				width: Math.floor(styleWidth / td.colSpan) + "px"
			}, _TRUE);
		}
	},
	/**
	 * splitHeightByRowSpan
	 * @param {Element} td
	 */
	splitHeightByRowSpan: function (td) {
		var styleHeight;
		if (1 < td.rowSpan && td.style.height) {
			styleHeight = parseInt(td.style.height, 10);
			$tom.setStyles(td, {
				height: Math.floor(styleHeight / td.rowSpan) + "px"
			}, _TRUE);
		}
	},
	/**
	 * collapseCaret
	 * @param {Trex.Canvas.WysiwygPanel} wysiwygPanel
	 * @param {Element} node
	 */
	collapseCaret: function (wysiwygPanel, node) {
		var range;
		try {
			range = wysiwygPanel.getProcessor().createGoogRangeFromNodes(node, 0, node, 0);
			range.select();
		} catch (ignore) {}
		//td space bug from create textnode.
		//wysiwygPanel.getProcessor().moveCaretTo(node);
	},
	/**
     * collapseLastCaret
     * @param {Trex.Canvas.WysiwygPanel} wysiwygPanel
     * @param {Element} node
     */
    collapseLastCaret: function (wysiwygPanel, node) {
        var range;
        try {
            var offset = node.length?node.length:node.childNodes.length;
            range = wysiwygPanel.getProcessor().createGoogRangeFromNodes(node, offset, node, offset);
            range.select();
        } catch (ignore) {}
        //td space bug from create textnode.
        //wysiwygPanel.getProcessor().moveCaretTo(node);
    },
	/**
	 * getClosestByTagNames
	 * @param {Array} tagNames
	 * @param {Element} el
	 * @return {Element}
	 */
	getClosestByTagNames: function (tagNames, el) {
		var tagName;
		if (el && typeof el.tagName === "string") {
			tagName = el.tagName.toLowerCase();
			if (tagName !== "body") {
				if (tagNames.contains(tagName)) {
					return el;
				} else {
					return arguments.callee(tagNames, el.parentNode);
				}
			}
		}
		return _NULL;
	},
	/**
	 * getTableIndexerFromTd
	 * @param {Element} td
	 * @return {Trex.TableUtil.Indexer}
	 */
	getTableIndexerFromTd: function (td) {
		var currentTable;
		currentTable = Trex.TableUtil.getClosestByTagNames(["table"], td);
		return new Trex.TableUtil.Indexer(currentTable);
	},
    /**
     * getCellOffset
     * @param {Element} td
     * @return {Object}
     */
    getCellOffset: function(td){
        var get = function(td, key){
            return td['offset'+key.capitalize()]||parseInt(td[key]||td.style[key],10);
        };
        return {width: get(td,'width'), height: get(td,'height')}
    }
};
//////////////////////////////////////////////////////////
/**
 * Trex.TableUtil.Boundary class
 * @param {Object} indexs (optional)
 */
Trex.TableUtil.Boundary = Trex.Class.create({
	initialize: function (indexs) {
		this.top = -1;
		this.left = -1;
		this.bottom = -1;
		this.right = -1;
		if (indexs) {
			this.set(indexs);
		}
	},
	/**
	 * getTop
	 * @return {number} start row index
	 */
	getTop: function () {
		return this.top;
	},
	/**
	 * getLeft
	 * @return {number} start col index
	 */
	getLeft: function () {
		return this.left;
	},
	/**
	 * getBottom
	 * @return {number} end row index
	 */
	getBottom: function () {
		return this.bottom;
	},
	/**
	 * getRight
	 * @return {number} end col index
	 */
	getRight: function () {
		return this.right;
	},
	/**
	 * setTop
	 * @param {number} index
	 */
	setTop: function (index) {
		this.top = index;
	},
	/**
	 * setLeft
	 * @param {number} index
	 */
	setLeft: function (index) {
		this.left = index;
	},
	/**
	 * setBottom
	 * @param {number} index
	 */
	setBottom: function (index) {
		this.bottom = index;
	},
	/**
	 * setRight
	 * @param {number} index
	 */
	setRight: function (index) {
		this.right = index;
	},
	/**
	 * set
	 * @param {Object} indexs
	 */
	set: function (indexs) {
		if ("top" in indexs) {
			this.setTop(indexs.top);
		}
		if ("left" in indexs) {
			this.setLeft(indexs.left);
		}
		if ("bottom" in indexs) {
			this.setBottom(indexs.bottom);
		}
		if ("right" in indexs) {
			this.setRight(indexs.right);
		}
	},
	/**
	 * isValid
	 * @return {boolean}
	 */
	isValid: function () {
		if (this.top === -1) {
			return _FALSE;
		}
		if (this.left === -1) {
			return _FALSE;
		}
		if (this.bottom === -1) {
			return _FALSE;
		}
		if (this.right === -1) {
			return _FALSE;
		}
		return _TRUE;
	},
	/**
	 * addBoundary
	 * @param {number} rowIndex
	 * @param {number} colIndex
	 * @return {boolean} changed
	 */
	addBoundary: function (rowIndex, colIndex) {
		var changedStart, changedEnd;
		changedStart = this.addStartBoundary(rowIndex, colIndex);
		changedEnd = this.addEndBoundary(rowIndex, colIndex);
		return changedStart || changedEnd;
	},
	/**
	 * merge
	 * @param {Trex.TableUtil.Boundary} boundary
	 * @return {boolean} changed
	 */
	merge: function (boundary) {
		var changedStart, changedEnd;
		changedStart = this.addStartBoundary(boundary.top, boundary.left);
		changedEnd = this.addEndBoundary(boundary.bottom, boundary.right);
		return changedStart || changedEnd;
	},
	/**
	 * addStartBoundary
	 * @private
	 * @param {number} rowIndex
	 * @param {number} colIndex
	 * @return {boolean} changed
	 */
	addStartBoundary: function (rowIndex, colIndex) {
		var changed;
		changed = _FALSE;
		if (this.top === -1 || rowIndex < this.top) {
			this.top = rowIndex;
			changed = _TRUE;
		}
		if (this.left === -1 || colIndex < this.left) {
			this.left = colIndex;
			changed = _TRUE;
		}
		return changed;
	},
	/**
	 * addEndBoundary
	 * @private
	 * @param {number} rowIndex
	 * @param {number} colIndex
	 * @return {boolean} changed
	 */
	addEndBoundary: function (rowIndex, colIndex) {
		var changed;
		changed = _FALSE;
		if (this.bottom === -1 || this.bottom < rowIndex) {
			this.bottom = rowIndex;
			changed = _TRUE;
		}
		if (this.right === -1 || this.right < colIndex) {
			this.right = colIndex;
			changed = _TRUE;
		}
		return changed;
	}
});

//////////////////////////////////////////////////////////
// Indexer \ub294 \uc0ac\ub78c\uc5d0\uac8c \ubcf4\uc774\ub294\ub300\ub85c\uc758 index \ub85c table \uc744 
// \uc870\uc791\ud558\ub294\ub370 \ub3c4\uc6c0\uc744 \uc900\ub2e4. DOM \uc5d0\uc11c\ub294 rowSpan \uacfc 
// colSpan \ub54c\ubb38\uc5d0 \ubcf4\uc774\ub294 index \uc640 \uc77c\uce58\ud558\uc9c0 \uc54a\uae30 \ub54c\ubb38\uc784.
/**
 * Trex.TableUtil.Indexer class
 * @param {Element} table
 */
Trex.TableUtil.Indexer = Trex.Class.create({
	initialize: function (table) {
		this.indexData = _NULL;
		this.table = _NULL;
		
		this.resetIndex();
		this.setTable(table);
		this.makeIndex();
	},
	/**
	 * getRowSize
	 * @return {number}
	 */
	getRowSize: function () {
		return this.indexData.length;
	},
	/**
	 * getColSize
	 * @return {number}
	 */
	getColSize: function () {
		if (0 < this.indexData.length) {
			return this.indexData[0].length;
		}
		return 0;
	},
	/**
	 * getTd
	 * rowIndex \uc640 colIndex \uc5d0 \ub9e4\uce6d\ub418\ub294 td \ub97c \uac00\uc838\uc628\ub2e4.
	 * @param {number} rowIndex
	 * @param {number} colIndex
	 * @return {Elememt} td
	 */
	getTd: function (rowIndex, colIndex) {
		if (this.indexData[rowIndex]) {
			if (this.indexData[rowIndex][colIndex]) {
				return this.indexData[rowIndex][colIndex];
			}
		}
		return _NULL;
	},
	/**
	 * getTdArr
	 * Boundary \uc5d0 \ud3ec\ud568\ub418\ub294 td \ub4e4\uc744 \uac00\uc838\uc628\ub2e4.
	 * @param {Trex.TableUtil.Boundary} boundary
	 * @return {Array} tdArr [td, td, ...] (order by top-left)
	 */
	getTdArr: function (boundary) {
		var result, rowIndex, cells, colIndex;
		result = [];
		rowIndex = boundary.top;
		while (rowIndex <= boundary.bottom) {
			cells = this.indexData[rowIndex];
			colIndex = boundary.left;
			while (colIndex <= boundary.right) {
				if (result.contains(cells[colIndex]) === _FALSE) {
					result.push(cells[colIndex]);
				}
				colIndex += 1;
			}
			rowIndex += 1;
		}
		return result;
	},
    /**
     * getTdArrCol
     * \ud574\ub2f9\ud558\ub294 index\uc5d0 \ud574\ub2f9\ud558\ub294 Col\uc548\uc5d0 \uc788\ub294 td\ub4e4\uc744 \uac00\uc838\uc628\ub2e4.
     * @param {number..} index
     * @return {Array} tdArr [td, td, ...] (order by left-top)
     */
    getTdArrCol: function(){
        var indexs = $A(arguments);
        var res = [];
        var self = this;
        var len = this.getRowSize();
        indexs.each(function(idx){
            for (var i = 0; i < len; i += 1) {
                res.push(self.getTd(i, idx));

            }
        });
        return res.uniq(_FALSE);
    },
    /**
     * getTdArrCol
     * \ud574\ub2f9\ud558\ub294 index\uc5d0 \ud574\ub2f9\ud558\ub294 Col\uc548\uc5d0 \uc788\ub294 td\ub4e4\uc744 \uac00\uc838\uc628\ub2e4.
     * @param {number..} index
     * @return {Array} tdArr [td, td, ...] (order by left-top)
     */
    getTdArrRow: function(){
        var indexs = $A(arguments);
        var res = [];
        var self = this;
        var len = this.getColSize();
        indexs.each(function(idx){
            for (var i = 0; i < len; i += 1) {
                res.push(self.getTd(idx, i));

            }
        });
        return res.uniq(_FALSE);
    },
	/**
	 * getTdArrHasTop
	 * \ud574\ub2f9\ud558\ub294 row index \ub97c top \uc73c\ub85c \uac00\uc9c0\ub294 cell \ub4e4\uc744 \uac00\uc838\uc628\ub2e4. 
	 * @param {number} index
	 * @return {Array} tdArr [td, td, ...] (order by left-top)
	 */
	getTdArrHasTop: function (index) {
		var result, currentCell, adjoiningCell, len, i;
		result = [];
		len = this.getColSize();
		for (i = 0; i < len; i += 1) {
			currentCell = this.getTd(index, i);
			adjoiningCell = this.getTd(index - 1, i);
			this.uniquePushWhenDifferent(result, currentCell, adjoiningCell);
		}
		return result;
	},
	/**
	 * getTdArrHasBottom
	 * \ud574\ub2f9\ud558\ub294 row index \ub97c bottom \uc73c\ub85c \uac00\uc9c0\ub294 cell \ub4e4\uc744 \uac00\uc838\uc628\ub2e4. 
	 * @param {number} index
	 * @return {Array} tdArr [td, td, ...] (order by left-top)
	 */
	getTdArrHasBottom: function (index) {
		var result, currentCell, adjoiningCell, len, i;
		result = [];
		len = this.getColSize();
		for (i = 0; i < len; i += 1) {
			currentCell = this.getTd(index, i);
			adjoiningCell = this.getTd(index + 1, i);
			this.uniquePushWhenDifferent(result, currentCell, adjoiningCell);
		}
		return result;
	},
	/**
	 * getTdArrHasLeft
	 * \ud574\ub2f9\ud558\ub294 row index \ub97c left \ub85c \uac00\uc9c0\ub294 cell \ub4e4\uc744 \uac00\uc838\uc628\ub2e4.
	 * @param {number} index
	 * @return {Array} tdArr [td, td, ...] (order by left-top)
	 */
	getTdArrHasLeft: function (index) {
		var result, currentCell, adjoiningCell, len, i;
		result = [];
		len = this.getRowSize();
		for (i = 0; i < len; i += 1) {
			currentCell = this.getTd(i, index);
			adjoiningCell = this.getTd(i, index - 1);
			this.uniquePushWhenDifferent(result, currentCell, adjoiningCell);
		}
		return result;
	},
	/**
	 * getTdArrHasRight
	 * \ud574\ub2f9\ud558\ub294 row index \ub97c right \ub85c \uac00\uc9c0\ub294 cell \ub4e4\uc744 \uac00\uc838\uc628\ub2e4.
	 * @param {number} index
	 * @return {Array} tdArr [td, td, ...] (order by left-top)
	 */
	getTdArrHasRight: function (index) {
		var result, currentCell, adjoiningCell, len, i;
		result = [];
		len = this.getRowSize();
		for (i = 0; i < len; i += 1) {
			currentCell = this.getTd(i, index);
			adjoiningCell = this.getTd(i, index + 1);
			this.uniquePushWhenDifferent(result, currentCell, adjoiningCell);
		}
		return result;
	},
	
	/**
	 * getBoundary
	 * td \uc5d0 \ud574\ub2f9\ud558\ub294 boundary \ub97c \uad6c\ud55c\ub2e4.
	 * @param {Element} td
	 * @return {Trex.TableUtil.Boundary} boundary
	 */
	getBoundary: function (td) {
		var result, rows, rowLen, rowIndex, cells, cellLen, colIndex;
		result = new Trex.TableUtil.Boundary();
		rows = this.indexData;
		rowLen = rows.length;
		for (rowIndex = 0; rowIndex < rowLen; rowIndex += 1) {
			cells = rows[rowIndex];
			if (cells) {
				cellLen = cells.length;
				for (colIndex = 0; colIndex < cellLen; colIndex += 1) {
					if (cells[colIndex] === td) {
						result.addBoundary(rowIndex, colIndex);
					}
				}
			}
		}
		return result;
	},
	/**
	 * reload
	 * \uc778\ub371\uc2a4 \uac31\uc2e0(\ud14c\uc774\ube14\uc774 \ubcc0\uacbd\ub418\uc5c8\uc744 \ub54c).
	 */
	reload: function () {
		this.resetIndex();
		this.makeIndex();
	},
	/**
	 * uniquePushWhenDifferent
	 * currentCell \uacfc adjoiningCell \uc774 \ub2e4\ub974\uba74 currentCell \ub97c tdArr \uc5d0 \uc911\ubcf5\uc5c6\uc774 push \ud55c\ub2e4.
	 * @private
	 * @param {Array} tdArr
	 * @param {Element} currentCell
	 * @param {Element} adjoiningCell
	 */
	uniquePushWhenDifferent: function (tdArr, currentCell, adjoiningCell) {
		if (currentCell !== adjoiningCell) {
			if (tdArr.contains(currentCell) === _FALSE) {
				tdArr.push(currentCell);
			}
		}
	},
	/**
	 * resetIndex
	 * @private
	 */
	resetIndex: function () {
		this.indexData = [];
	},
	/**
	 * setTable
	 * @private
	 * @param {Element} table
	 */
	setTable: function (table) {
		this.table = table;
	},
	/**
	 * makeIndex
	 * rowSpan \uacfc colSpan \uc744 \ud3bc\uce5c \ud615\ud0dc\uc758 array \uc5d0 table cell \ub4e4\uc744 \ub9e4\uce6d\uc2dc\ud0a8\ub2e4.
	 * @private
	 */
	makeIndex: function () {
		var rows, rowLen, rowIndex, row, cells, cellLen, colIndex, cell;
		rows = this.table.rows;
		rowLen = rows.length;
		for (rowIndex = 0; rowIndex < rowLen; rowIndex += 1) {
			row = rows[rowIndex];
			cells = row.cells;
			cellLen = cells.length;
			for (colIndex = 0; colIndex < cellLen; colIndex += 1) {
				cell = cells[colIndex];
				this.addCellIndex(rowIndex, cell);
			}
		}
	},
	/**
	 * addCellIndex
	 * \ub9cc\ub4e4\uace0 \uc788\ub294 indexData \uc5d0 \ud574\ub2f9 cell \uc5d0 \ub300\ud55c index \ub97c \ucd94\uac00\ud55c\ub2e4.
	 * @private
	 * @param {number} rowIndex
	 * @param {Element} cell
	 */
	addCellIndex: function (rowIndex, cell) {
		var viewIndexOfCell, row, rowSpan, calculatedRowIndex, col, colSpan;
		viewIndexOfCell = this.getNextCellIndex(this.indexData[rowIndex]);
		rowSpan = cell.rowSpan;
		for (row = 0; row < rowSpan; row += 1) {
			calculatedRowIndex = rowIndex + row;
			if (! this.indexData[calculatedRowIndex]) {
				this.indexData[calculatedRowIndex] = [];
			}
			colSpan = cell.colSpan;
			for (col = 0; col < colSpan; col += 1) {
				this.indexData[calculatedRowIndex][viewIndexOfCell + col] = cell;
			}
		}
	},
	/**
	 * getNextCellIndex
	 * arr \ub97c \uc21c\ud658\ud558\uba74\uc11c \ucc98\uc74c\uc73c\ub85c \ub9cc\ub09c \ube48 \uc694\uc18c\uc758 index \ub97c \ubc18\ud658\ud55c\ub2e4.
	 * arr \uac00 \uc5c6\uc73c\uba74 0 \uc744 \ubc18\ud658, \ube48 \uc694\uc18c\uac00 \uc5c6\uc73c\uba74 length \ub97c \ubc18\ud658\ud55c\ub2e4.
	 * @private
	 * @param {Array} arr
	 * @return {number} cell index
	 */
	getNextCellIndex: function (arr) {
		var i, len;
		if (! arr) {
			return 0;
		}
		len = arr.length;
		for (i = 0; i < len; i += 1) {
			if (! arr[i]) {
				break;
			}
		}
		return i;
	}
});

/**
 * XmlHttpRequest\uac1d\uccb4\ub97c \uc0dd\uc131\ud558\uace0 \uc774 \uac1d\uccb4\ub97c \uc774\uc6a9\ud574 ajax request\ub97c \uc218\ud589\ud55c\ub2e4.
 * @class
 */
Trex.I.XHRequester = Trex.Faculty.create(/** @lends Trex.I.XHRequester */{ 
	/**
	 * \ube0c\ub77c\uc6b0\uc838\uc5d0 \ub9de\ub294 XmlHttpRequest \uac1d\uccb4\ub97c \uc0dd\uc131\ud574\uc11c \ub9ac\ud134\ud55c\ub2e4.
	 * @private
	 * @return {Object} XmlHttpRequest object
	 */
	createXMLHttp: function() {
		var _xmlHttp = _NULL;
		try{
			if(_WIN.XMLHttpRequest) {
				_xmlHttp = new XMLHttpRequest();
			} else if (_WIN.ActiveXObject) {
				_xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");
				if(!_xmlHttp) {
					_xmlHttp = new ActiveXObject('Microsoft.XMLHTTP');
				}
			}
			return _xmlHttp;
		}catch(e){
			return _NULL;
		}
	},
	/**
	 * ajax call\ub97c \uc218\ud589\ud55c\ub2e4
	 * @param {String} method - http request\uc758 \ubc29\uc2dd, "get" \ub610\ub294 "post" 
	 * @param {String} url - request\ub97c \ub0a0\ub9b4 url 
	 * @param {Boolean} async - synchronous \uc5ec\ubd80 
	 * @param {Function} successHandler - ajax\uc758 \uc131\uacf5\uc2dc\uc758 \ud578\ub4e4\ub7ec 
	 * @param {Function} failHandler - ajax \uc2e4\ud328\uc2dc\uc774\uc758 \ud578\ub4e4\ub7ec  
	 * @example
	 * this.sendRequest("get","http://www.daum.net/api",true,function(value){alert(value)}, function(){alert('fail');} 
	 */
	sendRequest: function(method, url, param, async, successHandler, failHandler) { 
		if (url == _NULL && url != "") {
			return _NULL;
		}
		
		var _response = _NULL;
		var _xmlHttp = this.createXMLHttp();
		if(_xmlHttp == _NULL) {
			return _NULL;
		}
		
		var handler = function(){
			if (_xmlHttp.status == 200) {
				if (method.toUpperCase() == "HEAD") {
					_response = successHandler(_xmlHttp.getAllResponseHeaders());
				} else {
					_response = successHandler(_xmlHttp.responseText);
				}
			} else {
				_response = failHandler(_xmlHttp.status);
			}
			_xmlHttp = _NULL;
		};
		try{
			if (async) {
				_xmlHttp.onreadystatechange = function(){
					if (_xmlHttp.readyState == 4) {
						handler();			
					}
				};
			}
			if(method.toUpperCase() == "POST") {
				_xmlHttp.open("POST", url, async);
				_xmlHttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=utf-8");
				_xmlHttp.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
                //webkit \uc624\ub958\ubc1c\uc0dd
//				_xmlHttp.setRequestHeader("Content-Length", param.length);
//				_xmlHttp.setRequestHeader("Connetion","close");
				_xmlHttp.send(param);
			} else {
				if(param && param.length > 0) {
					url = url + ((url.indexOf("?") > -1)? "&": "?") + param;
				}
				_xmlHttp.open(method.toUpperCase(), url, async);
				_xmlHttp.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
				_xmlHttp.send(_NULL);
			}
			
			if (!async) {
				handler();
			}
			return _response;
		}catch(e){
			return _NULL; 
		}
	}
});

Trex.Responder = { 
	callbacks: {},
	process: function(/*bytesLoaded, bytesTotal*/) {
		//if(bytesLoaded < 0) {
			// fail
		//} else {
			// progress
		//}
	},
	newKey: function() {
		var _key = "exe_" + Math.floor(Math.random() * 100000);
		if(this[_key]) {
			return this.newKey();
		} else {
			return _key;
		}
	},
	register: function(handler) {
		var _key = this.newKey();
		this.callbacks[_key] = function(response) {
			handler.apply(this, Array.prototype.slice.call(arguments,0));
			this.callbacks[_key] = _NULL;
		}.bind(this);
		return _key;
	}
};

/**
 * \ub3d9\uc801\uc73c\ub85c \uc678\ubd80\uc758 javascript\ud30c\uc77c\uc744 include\ud55c\ub2e4. 
 * @class
 */
Trex.I.JSRequester = Trex.Faculty.create(/** @lends Trex.I.JSRequester */{ 
	/**
	 * \ud2b9\uc815\uc704\uce58\uc758 \uc2a4\ud06c\ub9bd\ud2b8 \ud30c\uc77c\uc744 include \ud55c\ub2e4.
	 * @param {String} url - http request\uc758 \ubc29\uc2dd, "get" \ub610\ub294 "post" 
	 * @param {String} encoding - inlcude\ud560 javascript\uc758 encoding \ud0c0\uc785
	 * @param {Element} context - \ub85c\ub529\ub41c \uc2a4\ud06c\ub9bd\ud2b8\uac00 \ud45c\uc2dc\ub420 dom element
	 * @param {Function} success - ajax\uc758 \uc131\uacf5\uc2dc\uc758 \ud578\ub4e4\ub7ec
	 * @example
	 * this.importScript("http://www.daum.net/api/movie.js?apikey=1234","utf-8", document, function(){alert("hello");} ) 
	 */
	importScript: function(url, encoding, context, success) { 
		if (url == _NULL && url != "") {
			return _NULL;
		}
		encoding = encoding || "utf-8";
		context = context || _DOC;
		try{
			var head = context.getElementsByTagName("head")[0] || context.documentElement;
			var script = context.createElement("script");
			script.type = "text/javascript";
			script.charset = encoding;
			script.src= url;
						
			var done = _FALSE;
			script.onload = script.onreadystatechange = function() {
				if ( !done && (!this.readyState ||
						this.readyState === "loaded" || this.readyState === "complete") ) {
					done = _TRUE;
					if (success) {
						success();
					}

					// Handle memory leak in IE
					script.onload = script.onreadystatechange = _NULL;
					if ( head && script.parentNode ) {
						head.removeChild( script );
					}
				}
			};
			head.insertBefore( script, head.firstChild );
		}catch(e){
			
		}
	}
});
_WIN.$stop = {};
_WIN.$propagate = {};
/**
 * \uc5d0\ub514\ud130\uc5d0 \uc815\uc758\ub41c custom \uc774\ubca4\ud2b8\ub4e4\uc744 \ubc1c\uc0dd\uc2dc\ud0a4\uace0 \ub4f1\ub85d\ub41c \uc774\ubca4\ud2b8 \ud578\ub4e4\ub7ec\ub4e4\uc744 \uc2e4\ud589\uc2dc\ud0a8\ub2e4.
 * custom \uc774\ubca4\ud2b8\ub97c \ubc1c\uc0dd\uc2dc\ud0a4\uac70\ub098 \ud639\uc740 custom \uc774\ubca4\ud2b8 \ubc1c\uc0dd\uc2dc \ud578\ub4e4\ub7ec\ub97c \uc2e4\ud589\uc2dc\ud0a4\uae30 \uc704\ud574\uc11c\ub294 \uc774 \ud074\ub798\uc2a4\ub97c minxin \ubc1b\uc544\uc57c \ud55c\ub2e4. 
 * @class
 */
Trex.I.JobObservable = Trex.Faculty.create(/** @lends Trex.I.JobObservable */{
	/**
	 * @private
	 */
	jobObservers: {},
	/**
	 * custom \uc774\ubca4\ud2b8\uac00 \ubc1c\uc0dd\ud558\ub294\uc9c0\ub97c \uad00\ucc30\ud558\ub294 observer\ub97c \ub4f1\ub85d\ud55c\ub2e4.
	 * @param {String} name - custom \uc774\ubca4\ud2b8\uc758 \uc774\ub984 
	 * @param {Function} observer - custom \uc774\ubca4\ud2b8 \ubc1c\uc0dd\uc2dc \uc2e4\ud589\ub420 handler
	 * @example
	 * canvas.observeJob(Trex.Ev.__CANVAS_HEIGHT_CHANGE, function(){alert('canvas\uc758 \ud06c\uae30\uac00 \ubcc0\ud588\ub124\uc694')}) 
	 * cinema.observeJob("cinema_on_paste", function(){alert('\uc601\ud654\uac00 \ucca8\ubd80\ub418\uc5c8\ub124\uc694')}) 
	 */
	observeJob: function(name, observer) {
		if(!this.jobObservers[name]) {
			this.jobObservers[name] = [];
		}
		this.jobObservers[name].push(observer);
	},
	reserveJob: function(name, observer, delay) {
		delay = delay || 500;
		if(!this.jobObservers[name]) {
			this.jobObservers[name] = [];
		}
		var _self = this;
		this.jobObservers[name].push(function() {
			var args = $A(arguments);
			setTimeout(function() {
				observer.apply(_self, args);
			}, delay);
		});
	},
    removeJob: function(name, observe){
        if(!this.jobObservers[name])
            return;
        if(!observe){
            this.jobObservers[name].length = 0;
        }else {
            for(var i = 0 ; i < this.jobObservers[name].length; i++){
                if(this.jobObservers[name][i]===observe){
                    this.jobObservers[name].splice(i,1);
                }
            }
        }

    },
	/**
	 * custom \uc774\ubca4\ud2b8\ub97c \ubc1c\uc0dd\uc2dc\ud0a8\ub2e4. \uc774\ub54c \ubc1c\uc0dd\uc2dc\ud0a8 \uc774\ubca4\ud2b8\ub294 observerJob\ub97c \ud1b5\ud574 \ub4f1\ub85d\ub41c observer\ub4e4\uc5d0\uac8c \uc804\ud30c\ub41c\ub2e4.
	 * @param {String} name - custom \uc774\ubca4\ud2b8\uc758 \uc774\ub984 
	 * @example
	 * canvas.observeJob(Trex.Ev.__CANVAS_HEIGHT_CHANGE, function(){alert('canvas\uc758 \ud06c\uae30\uac00 \ubcc0\ud588\ub124\uc694')}) 
	 * cinema.observeJob("cinema_on_paste", function(){alert('\uc601\ud654\uac00 \ucca8\ubd80\ub418\uc5c8\ub124\uc694')}) 
	 */
	fireJobs: function(name) {
		var _self = this;
		var args = $A(arguments).slice(1);
		if(!this.jobObservers[name]) {
			return;
		}
        if (_WIN['DEBUG']) {
            this.jobObservers[name].each(function(observer) {
                observer.apply(_self, args);
            });
        } else {
            try {
                this.jobObservers[name].each(function(observer) {
                    observer.apply(_self, args);
                });
            } catch (e) {
                if(e != $stop) { throw e; }
            }
        }

	}
});

/**
 * \uc5d0\ub514\ud130\uc5d0\uc11c custom key\uc774\ubca4\ud2b8\ub4e4\uc744 \ubc1c\uc0dd\uc2dc\ud0a4\uace0 \ub4f1\ub85d\ub41c \uc774\ubca4\ud2b8 \ud578\ub4e4\ub7ec\ub4e4\uc744 \uc2e4\ud589\uc2dc\ud0a8\ub2e4.
 * custom key \uc774\ubca4\ud2b8\ub97c \ubc1c\uc0dd\uc2dc\ud0a4\uac70\ub098 \ud639\uc740 custom key \uc774\ubca4\ud2b8 \ubc1c\uc0dd\uc2dc \ud578\ub4e4\ub7ec\ub97c \uc2e4\ud589\uc2dc\ud0a4\uae30 \uc704\ud574\uc11c\ub294 \uc774 \ud074\ub798\uc2a4\ub97c minxin \ubc1b\uc544\uc57c \ud55c\ub2e4. 
 * @class
 */
Trex.I.KeyObservable = Trex.Faculty.create(/** @lends Trex.I.KeyObservable */{
	/**
	 * @private
	 */
	keyObservers: {},
	/**
	 * custom \uc774\ubca4\ud2b8\uac00 \ubc1c\uc0dd\ud558\ub294\uc9c0\ub97c \uad00\ucc30\ud558\ub294 observer\ub97c \ub4f1\ub85d\ud55c\ub2e4.
	 * @param {Object} keys - \uc774\ubca4\ud2b8\uac00 \ubc1c\uc0dd\ud558\uae38 \uc6d0\ud558\ub294 \ud0a4\uc758 \uc870\ud569 {ctrlKey:T, altKey:F, shiftKey:T, keyCode:17} 
	 * @param {Function} observer - \ud574\ub2f9 \uc774\ubca4\ud2b8 \ubc1c\uc0dd\uc2dc \uc2e4\ud589\ub420 handler
	 * @param {Boolean=} isBubble - \ud574\ub2f9 \uc774\ubca4\ud2b8\uac00 bubble\uc778\uc9c0 \uc5ec\ubd80
	 * @example
	 * canvas.observeKey({ctrlKey:'T', altKey:'F', keyCode:32}, function(){alert('ctrl + 32\ud0a4\uac00 \ub20c\ub838\ub124\uc694.')}) 
	 */
	observeKey: function(keys, observer, isBubble) {
		var _name = function(keys) {
			return (keys.ctrlKey? 'T': 'F') + (keys.altKey? 'T': 'F') + (keys.shiftKey? 'T': 'F') + "_" + keys.keyCode;
		}(keys);
		if(!this.keyObservers[_name]) {
			this.keyObservers[_name] = [];
		}
        if(isBubble){
            observer._bubble = _TRUE;
        }
		this.keyObservers[_name].push(observer);
	},
	/**
	 * \uc0ac\uc6a9\uc790\uac00 \uc815\uc758\ud55c custom key event\ub97c \ubc1c\uc0dd\uc2dc\ud0a8\ub2e4. \uc774\ub54c \ubc1c\uc0dd\uc2dc\ud0a8 \uc774\ubca4\ud2b8\ub294 observerKey\ub97c \ud1b5\ud574 \ub4f1\ub85d\ub41c observer\ub4e4\uc5d0\uac8c \uc804\ud30c\ub41c\ub2e4.
	 * @param {Object} ev - \uc0ac\uc6a9\uc790\uac00 \uc815\uc758\ud55c key\uc758 pushed \uc0c1\ud0dc \uac1d\uccb4
     * @param {Boolean=} isBubble
	 * @example
	 * canvas.fireKyes({ctrlKey:'T', altKey:'F', keyCode:32}), function(){alert('\uc601\ud654\uac00 \ucca8\ubd80\ub418\uc5c8\ub124\uc694')}) 
	 */
	fireKeys: function(ev, isBubble) {
		var _name = function(ev) {
			return (ev.ctrlKey? 'T': 'F') + (ev.altKey? 'T': 'F') + (ev.shiftKey? 'T': 'F') + "_" + ev.keyCode;
		}(ev);
		if(!this.keyObservers[_name]) {
			return;
		}
		var _self = this;
		var eventStopped = _FALSE;
		var stopEventOnce = function() {
			if (!eventStopped) {
				$tx.stop(ev);
				eventStopped = _TRUE;
			}
		};
		this.keyObservers[_name].each(function(observer) {
			try {
				observer.apply(_self, [ev]);
                !(observer._bubble||isBubble)&&stopEventOnce();
			} catch (e1) {
				if(e1 === $stop) {
					stopEventOnce();
				} else if (e1 !== $propagate) {
					
				}
			}
		});
	},
	registerKeyEvent: function(el) {
		try {
			$tx.observe(el, 'keydown', this.fireKeys.bind(this), _TRUE);
		} catch(e) {}
	}
});

/**
 * \ub9c8\uc6b0\uc2a4\ud074\ub9ad\uc774\ub098 \ubc29\ud5a5\ud0a4\ub97c \uc774\uc6a9\ud574 \ud2b9\uc815 \uc5d8\ub9ac\uba3c\ud2b8\uc5d0 \ud3ec\ucee4\uc2a4\uac00 \uac14\uc744 \uacbd\uc6b0 \ub4f1\ub85d\ub41c handler\ub97c \uc2e4\ud589\uc2dc\ud0a8\ub2e4.  
 * @class
 */
Trex.I.ElementObservable = Trex.Faculty.create(/** @lends Trex.I.ElementObservable */{
	elementObservers: {},
	/**
	 * \uc120\ud0dd\ub418\uae38 \uc6d0\ud558\ub294 element\ub97c \ub4f1\ub85d\ud55c\ub2e4 .
	 * @param {Object} layer - \uad00\ucc30\ud558\uae30\ub97c \uc6d0\ud558\ub294 element\uc758 tag name\uacfc class name {tag: 'div', klass: 'txc-textbox'}
	 * @param {Function} observer - \uc6d0\ud558\ub294 \uc5d8\ub9ac\uba3c\ud2b8\uac00 \uc120\ud0dd\ub418\uc5c8\uc744\ub54c \uc2e4\ud589\ub418\uae38 \uc6d0\ud558\ub294 handler  
	 * @example
	 * canvas.observeElement({tag:'div', klass: 'txc-textbox'}), function(){alert("div.txc-textbox\uac00 \uc120\ud0dd\ub418\uc5c8\ub124\uc694.")})
	 */
	observeElement: function(layer, observer) {
		if(layer == _NULL) { //all
			this.observeElement({ tag: "*tx-final-body*"}, observer);
		} else if (layer.length) {
			for (var i = 0; i < layer.length; i++) {
				var item = layer[i];
				this.observeElement(item, observer);
			}
		} else {
			if (!this.elementObservers[layer.tag]) {
				this.elementObservers[layer.tag] = {};
			}
			if (!layer.klass) {
				layer.klass = "*tx-all-class*";
			}
			if (!this.elementObservers[layer.tag][layer.klass]) {
				this.elementObservers[layer.tag][layer.klass] = [];
			}
			this.elementObservers[layer.tag][layer.klass].push(observer);
		}
	},
	/**
	 * \ud2b9\uc815 element\uac00 \uc120\ud0dd\ub418\uc5c8\uc744\ub54c \uadf8 element\uac00 \uc120\ud0dd\ub418\uae38 \uae30\ub2e4\ub9b0 observer\ub4e4\uc5d0\uac8c \uc54c\ub824\uc900\ub2e4. 
	 * \ud574\ub2f9\ud558\ub294 observer\ub4e4\uc740 handler\ub97c \uc2e4\ud589\uc2dc\ud0a8\ub2e4.
	 * @param {Element} node - \uc120\ud0dd\ub41c node
	 * @example
	 * canvas.fireElements(document.body)
	 */
	fireElements: function(node) {
		if(!node) {
			return;
		} 
		var _node = node;
		var args = $A(arguments).slice(1);
		
		var _self = this;
		try {
			var _observers;
			if($tom.kindOf(_node, 'img,hr,table,button,iframe')) {
				_observers = this.collectObserverByElement(_node.nodeName.toLowerCase(), _node.className);
				if(_observers) {
					_observers.each(function(observer) {
						observer.apply(_self, [_node].concat(args));
					});	
				}
			} else {
				while (_node) {
					_observers = this.collectObserverByElement(_node.nodeName.toLowerCase(), _node.className);
					if(_observers) {
						_observers.each(function(observer) {
							observer.apply(_self, [_node].concat(args));
						});	
					}
					if($tom.isBody(_node)) {
						break;
					}
					_node = $tom.parent(_node);
				}
			}
			
		} catch (e) {
			if(e != $stop) { throw e; }
		}
		this.fireFinally();
	},
	fireFinally: function() {
		var _self = this;
		var args = $A(arguments).slice(1);
		var _observers = this.collectObserverByElement("*tx-final-body*");
		if(_observers) {
			_observers.each(function(observer) {
				observer.apply(_self, [_NULL].concat(args));
			});	
		}
	},
	collectObserverByElement: function(tag, klass) {
		if(!this.elementObservers[tag]) {
			return _NULL;
		}

		var _observers = [];
		klass = klass || "";
		if(klass != "") {
			var _classes = klass.split(" ");
			for(var _klass in this.elementObservers[tag]) {
				if(_classes.contains(_klass)) {
					_observers.push(this.elementObservers[tag][_klass]);
				}
			}
		}
		if (this.elementObservers[tag]["*tx-all-class*"]) {
			_observers.push(this.elementObservers[tag]["*tx-all-class*"]);
		}
		return _observers.flatten();
	}
});

Trex.I.MouseoverObservable = Trex.Faculty.create(/** @lends Trex.I.MouseoverObservable */{
	mouseoverObservers: {},
	/**
	 * \uc120\ud0dd\ub418\uae38 \uc6d0\ud558\ub294 element\ub97c \ub4f1\ub85d\ud55c\ub2e4 .
	 * @param {Object} selector - \uad00\ucc30\ud558\uae30\ub97c \uc6d0\ud558\ub294 element\uc758 tag name\uacfc class name {tag: 'div', klass: 'txc-textbox'}
	 * @param {Function} successObserver - \uc6d0\ud558\ub294 \uc5d8\ub9ac\uba3c\ud2b8\uac00 \uc120\ud0dd\ub418\uc5c8\uc744\ub54c \uc2e4\ud589\ub418\uae38 \uc6d0\ud558\ub294 handler
	 * @param {Function} failObserver
	 * @example
	 * canvas.observeElement({tag:'div', klass: 'txc-textbox'}), function(){alert("div.txc-textbox\uac00 \uc120\ud0dd\ub418\uc5c8\ub124\uc694.")})
	 */
	observeMouseover: function(selector, successObserver, failObserver) {
		if (!this.mouseoverObservers[selector]) {
			this.mouseoverObservers[selector] = {
				'success': [],
				'fail': [],
				'flag': _FALSE
			}	
		}
		this.mouseoverObservers[selector]['success'].push(successObserver);
		if ( failObserver ){
			this.mouseoverObservers[selector]['fail'].push(failObserver);
		}
	},
	fireMouseover: function(node) {
		if(!node) { return;	} 
		var _node = node;
		var _self = this;
		
		try {
			for (var i in this.mouseoverObservers){
				this.mouseoverObservers[i].flag = _FALSE;
			}
			while (_node) {
				var _observers = this.collectMouseoverObserver(_node);
				if(_observers.length > 0) {
					var _nodePos = this.getPositionByNode(_node);
					_observers.each(function(observer) {
						observer.apply(_self, [_node, _nodePos]);
					});	
				}
				if($tom.isBody(_node)) {
					break;
				}
				_node = $tom.parent(_node);
			}
		} catch (e) {
			if(e != $stop) { throw e; }
		}
		this.runMouseoverFailHandler();	
	},
	runMouseoverFailHandler: function(){
		var _failHandlers = [];
		for (var i in this.mouseoverObservers){
			if ( !this.mouseoverObservers[i].flag ){
				_failHandlers.push( this.mouseoverObservers[i]['fail'] );
			}
		}
		
		_failHandlers.flatten().each( function(handler){
			handler();
		});
	},
	collectMouseoverObserver: function(node) {
		var _observers = [];
		var klass = node.className || "";
		var tag = node.tagName;
		
		if ( tag ){
			tag = tag.toLowerCase();
			if ( this.mouseoverObservers[tag] ){
				_observers.push( this.mouseoverObservers[tag]['success'] );
				this.mouseoverObservers[tag]['flag'] = _TRUE;
			}
		}
		
		if(klass != "") {
			var _classes = klass.split(" ");
			for(var i = 0, len = _classes.length; i < len; i++ ){
				var key = tag + "." + _classes[i];
				if ( this.mouseoverObservers[key] ) {
					_observers.push(this.mouseoverObservers[key]['success']);
					this.mouseoverObservers[key]['flag'] = _TRUE;
				}
			}
			
		}
		return _observers.flatten();
	}
});

/*---- Trex.I.Runnable ------------------------------------------------------*/
Trex.I.Runnable = Trex.Faculty.create({
	isRunning: _FALSE,
	repeater: _NULL,
	threads: [],
	startThread: function(term) {
		if (this.repeater) {
			this.repeater.clear();
		} else {
			this.repeater = new Trex.Repeater(this.runThread.bind(this));
		}
		this.repeater.start(term);
	},
	stopThread: function() {
		this.repeater.clear();
	},
	runThread: function() {
		if(this.isRunning) {
			return;
		}
		if(this.threads.length > 0) {
			this.isRunning = _TRUE;
			(this.threads.shift())();
			this.isRunning = _FALSE;
		}
	},
	putThread: function(thread, important) {
		if(important) {
			this.threads.unshift(thread);
		} else {
			this.threads.push(thread);
		}
	}
});
TrexMessage.addMsg({
    '@menu.pallete.revert': "\uae30\ubcf8\uc0c9\uc73c\ub85c",
    '@adoptor.label': "\uac00\ub098\ub2e4",
    '@adoptor.transparent': "\ud22c\uba85"
});

Trex.MarkupTemplate.add(
    "menu.colorpallete.text",
    '#{for:items}<li class="tx-menu-list-item" style="background-color:#{color}"><a unselectable="on" style="color:#{text}">#{label}</a></li>#{/for:items}'
);
Trex.MarkupTemplate.add(
    "menu.colorpallete.thumb",
    // TODO forecolor,backcolor\uc5d0\uc11c <li class="tx-menu-list-item" unselectable="on" style="background-color:#FF0000;border:none;#{if:image!=null}background-image:url(#{image})#{/if:image};"></li> \uc774\ub807\uac8c \uacb0\uacfc\uac00 \ub098\uc628\ub2e4.
    '#{for:items}<li class="tx-menu-list-item" unselectable="on" style="background-color:#{color};border:none;#{if:image!=null}background-image:url(#{image})#{/if:image};"></li>#{/for:items}'
);
Trex.MarkupTemplate.add(
    "menu.colorpallete.revert",
    '<p class="tx-pallete-revert"><a unselectable="on" href="javascript:;" title="@menu.pallete.revert">@menu.pallete.revert</a></p>'
);
Trex.I.ColorPallete = Trex.Faculty.create({
    isGradeInit: _FALSE,
    isPickerDisplayed: _FALSE,
    onregenerated: function(config, initValue) {
        this.setColorValueAtInputbox(initValue);
    },
    setColorValueAtInputbox: function(initValue) {
        if ( !initValue ){
            return ;
        }
        if ( typeof initValue != "string" && initValue.toString){
            initValue = initValue.toString();
        }
        var _color = initValue.split("|")[0];
        if ( !Trex.Color.getValidColor(_color) ){
            _color = "#000000";
        }
        var _elValueInput = $tom.collect(this.elInner, 'p.tx-pallete-input input');
        var _elColorDisplay = $tom.collect(this.elInner, 'p.tx-pallete-input span');
        if (initValue && _elValueInput && _elColorDisplay) {
            _elValueInput.value = _color;
            _elColorDisplay.style.backgroundColor = _color;
        }
    },
    hookEvent: function(config) {
        var _elMenu = this.elMenu;
        var _elInner = this.elInner = $tom.collect(_elMenu, 'div.tx-menu-inner');

        var _elPreset = $tom.collect(_elInner, 'ul.tx-pallete-text-list');
        if(config.texts) {
            var _textOptions = config.texts.options;
            Trex.MarkupTemplate.get("menu.colorpallete.text").evaluateToDom({
                'items': _textOptions
            }, _elPreset);
            var _elPresetChilds = $tom.collectAll(_elPreset, "li");
            this.addColorClickEvent(_elPresetChilds, _textOptions);
        } else {
            _elInner.removeChild(_elPreset);
            _elPreset = _NULL;
        }

        if(config.thumbs) {
            var _needTrans = !!config.needTrans;
            var _thumbsOptions = [].concat(config.thumbs.options);
            if(_needTrans) { //\ud22c\uba85\uc774 \ud544\uc694\ud55c \uceec\ub7ec\ud314\ub808\ud2b8\uc77c \uacbd\uc6b0 \ub9c8\uc9c0\ub9c9 \uceec\ub7ec \uc0ad\uc81c
                _thumbsOptions.pop();
                _thumbsOptions.push(Object.extend({}, config.thumbs.transparent));
            }
            var _elThumb = $tom.collect(_elInner, 'ul.tx-pallete-thumb-list');
            Trex.MarkupTemplate.get("menu.colorpallete.thumb").evaluateToDom({
                'items': _thumbsOptions
            }, _elThumb);
            var _elThumbChilds = $tom.collectAll(_elThumb, "li");
            this.addColorClickEvent(_elThumbChilds, _thumbsOptions);
        }

        this.elPicker = $tom.collect(_elInner, "div.tx-pallete-picker");

        var _elButton = $tom.collect(_elInner, 'div.tx-pallete-buttons');
        var _elMore = this.elMore = $tom.collect(_elButton, 'p.tx-pallete-more a');
        $tx.observe(_elMore, "click", this.togglePicker.bind(this));

        if(config.needRevert) {
            $tom.insertFirst(_elButton, Trex.MarkupTemplate.get("menu.colorpallete.revert").evaluateAsDom({}));
            $tx.observe($tom.collect(_elButton, 'p.tx-pallete-revert a'), "click", function(ev) {
                this.onSelect(ev, _NULL);
                this.hide();
            }.bind(this));
        }

        var _elPickerEnter = $tom.collect(this.elInner, "p.tx-pallete-input");
        this.elPreview = $tom.collect(_elPickerEnter, "span");
        var _elInput = this.elInput = $tom.collect(_elPickerEnter, "input");
        var _elEnter = this.elEnter = $tom.collect(_elPickerEnter, "a");
        var _self = this;
        $tx.observe(_elInput, "blur", function(){
            _self.lastValue = _elInput.value;
        });
        $tx.observe(_elEnter, "click", this.onColorEnter.bind(this));
    },
    addColorClickEvent: function(elItemList, textOptions) {
        for (var i=0, end=elItemList.length; i < end; i++) {
            var _item = elItemList[i];
            var _option = textOptions[i]; // both elItemList.length and textOptions.length must be equal.
            $tx.observe(_item, "click", this.onSelect.bindAsEventListener(this, _option.color + (_option.text? '|' + _option.text: '')));
        }
    },
    _generatePicker: function() {
        var _elPicker = this.elPicker;
        var _elPickerBox = $tom.collect(_elPicker, "div.tx-pallete-pickerbox");
        $tx.observe(_elPickerBox, "mouseout", this.onMouseOut.bind(this));

        var _elChromaBar = this.elChromaBar = $tom.collect(_elPickerBox, "div.tx-chromabar");
        $tom.replacePngPath(_elChromaBar);
        $tx.observe(_elChromaBar, 'mousedown', this.onChromDown.bindAsEventListener(this));
        $tx.observe(_elChromaBar, 'mousemove', this.onChromMove.bindAsEventListener(this));
        $tx.observe(_elChromaBar, 'mouseup', this.onChromUp.bindAsEventListener(this));

        this.elHueBar = $tom.collect(_elPickerBox, "div.tx-huebar");
        var _elHueBar = this.elHueBar;

        this.hueDownHandler = this.onHueDown.bindAsEventListener(this);
        this.hueMoveHandler = this.onHueMove.bindAsEventListener(this);
        this.hueUpHandler = this.onHueUp.bindAsEventListener(this);
        this.hueClickHandler = this.onHueClick.bindAsEventListener(this);
        $tx.observe(_elHueBar,'mousedown', this.hueDownHandler);
        $tx.observe(_elHueBar,'click', this.hueClickHandler);

        this.nColWidth = 150;
        this.nColHeight = 120;
        this.nHueHeight = 120;

        this.mRGB = { r:0, g:0, b:0 };
        this.mHSV = { h:0, s:100, v:100 };

        // \ucd08\uae30\ud654
        this.setHueColor('FF0000');
    },
    reinitGrade: function() {
        var posParent = $tx.cumulativeOffset(this.elMenu);
        var position = $tx.positionedOffset(this.elChromaBar);
        this.iChromPos = {
            x: (posParent[0] + position[0]),
            y: (posParent[1] + position[1])
        };
        position = $tx.positionedOffset(this.elHueBar);
        this.iHuePos = {
            x: (posParent[0] + position[0]),
            y: (posParent[1] + position[1])
        };
    },
    onColorEnter: function(ev) {
        var color;
        if(this.elInput.value == TXMSG("@adoptor.transparent")) {
            color = "transparent";
        } else {
            color = Trex.Color.getValidColor(this.elInput.value);
        }
        if(color !== _NULL) {
            this.onSelect(ev, color);
        }
        this.hide();
    },
    previewColor: function(color) {
        this.changeColor(color);
    },
    onMouseOut: function() {
        if(this.lastValue !== _NULL && this.lastValue !== _UNDEFINED && this.mousedownDetected) {
            this.changeColor(this.lastValue);
        }
    },
    changeColor: function(color) {
        color = Trex.Color.getHexColor(color);
        this.elPreview.style.backgroundColor = color;
        if(color == "transparent") {
            this.elInput.value = TXMSG("@adoptor.transparent");
        } else {
            this.elInput.value = color;
        }
    },
    enterColor: function() {
        if(this.elInput.value == TXMSG("@adoptor.transparent")) {
            this.changeColor("transparent");
        } else if(this.elInput.value.length == 7) {
            var color = Trex.Color.getValidColor(this.elInput.value);
            if(color !== _NULL) {
                this.changeColor(color);
            }
        }
    },
    togglePicker: function(ev) {
        var _elMore = this.elMore;
        var _elPicker = this.elPicker;
        if(this.isPickerDisplayed) {
            _elMore.className = "tx-more-down";
            $tx.hide(_elPicker);
        } else {
            _elMore.className = "tx-more-up";
            $tx.show(_elPicker);
            if ($tx.msie6) {
                _elPicker.style.padding = "1px";
                setTimeout(function(){
                    _elPicker.style.padding = "0px";
                }, 0);
            }
            if(!this.isGradeInit) {
                this._generatePicker();
                this.isGradeInit = _TRUE;
                this.reinitGrade(); //position
            }
        }
        this.isPickerDisplayed = !this.isPickerDisplayed;
        $tx.stop(ev);
    },
    getChromCoords: function(ev) {
        var nPosX = (ev.clientX - this.iChromPos.x) + _DOC_EL.scrollLeft;
        var nPosY = (ev.clientY - this.iChromPos.y) + _DOC_EL.scrollTop;

        nPosX = Math.min(this.nColWidth, Math.max(0, nPosX));
        nPosY = Math.min(this.nColHeight, Math.max(0, nPosY));
        return {x: nPosX, y: nPosY};
    },
    getHueCoords: function(ev) {
		var y = ev.offsetY || ev.layerY;
		return Math.min(this.nHueHeight, Math.max(0, y));
    },
    getColorByEvent: function(x, y) {
        var s = (x/(this.nColWidth))*100;
        var v = (1-y/(this.nColHeight))*100;

        var nMargin = 3;
        s = Math.floor(Math.min(Math.max(s, 0), 100));
        if(s < nMargin) {
            s = 0;
        } else if(s > 100 - nMargin) {
            s = 100;
        }
        v = Math.floor(Math.min(Math.max(v, 0), 100));
        if(v < nMargin) {
            v = 0;
        } else if(v > 100 - nMargin) {
            v = 100;
        }

        this.mHSV.s = s;
        this.mHSV.v = v;
        this.mRGB = this.hsv2rgb(this.mHSV.h, this.mHSV.s, this.mHSV.v);

        return this.rgb2hex(this.mRGB.r, this.mRGB.g, this.mRGB.b);
    },
    onChromDown: function() {
        this.mousedownDetected = _TRUE;
    },
    onChromMove: function(ev) {
        if (this.mousedownDetected) {
            var iPos = this.getChromCoords(ev);
            var color = this.getColorByEvent(iPos.x, iPos.y);
            this.previewColor(color);
        }
    },
    onChromUp: function(ev) {
        var iPos = this.getChromCoords(ev);
        var color = this.getColorByEvent(iPos.x, iPos.y);
        this.previewColor(color);
        this.lastValue = color;
        this.mousedownDetected = _FALSE;
    },
    getHueByEvent: function(y) {
        var h = parseInt((y/(this.nHueHeight))*360);
        this.mHSV.h = Math.floor(Math.min(Math.max(h,0), 360));
        var mHueRgb = this.hsv2rgb(this.mHSV.h, 100, 100);
        return this.rgb2hex(mHueRgb.r, mHueRgb.g, mHueRgb.b);
    },
    setHueColor: function(sHueHex) {
        this.elChromaBar.style.backgroundColor = sHueHex;
    },
    onHueDown: function() {
        $tx.observe(_DOC, 'mousemove', this.hueMoveHandler);
        $tx.observe(_DOC, 'mouseup', this.hueUpHandler);
    },
    onHueMove: function(ev) {
		var y = this.getHueCoords(ev);
		var color = this.getHueByEvent(y);
        this.setHueColor(color);
    },
    onHueClick: function(ev) {
		var y = this.getHueCoords(ev);
		var color = this.getHueByEvent(y);
        this.setHueColor(color);
    },
    onHueUp: function() {
        $tx.stopObserving(_DOC, 'mousemove', this.hueMoveHandler);
        $tx.stopObserving(_DOC, 'mouseup', this.hueUpHandler);
    },
    hex2rgb: function(str) {
        this.mRGB.r = (this.toDec(str.substr(0, 1)) * 16) + this.toDec(str.substr(1, 1));
        this.mRGB.g = (this.toDec(str.substr(2, 1)) * 16) + this.toDec(str.substr(3, 1));
        this.mRGB.b = (this.toDec(str.substr(4, 1)) * 16) + this.toDec(str.substr(5, 1));
        return this.mRGB;
    },
    toDec: function(sHex) {
        var sHexChars = "0123456789ABCDEF";
        return sHexChars.indexOf(sHex.toUpperCase());
    },
    rgb2hex: function(r,g,b) {
        r = r.toString(16);
        if (r.length == 1) {
            r = '0' + r;
        }
        g = g.toString(16);
        if (g.length == 1) {
            g = '0' + g;
        }
        b = b.toString(16);
        if (b.length == 1) {
            b = '0' + b;
        }
        return '#'+r+g+b;
    },
    hsv2rgb: function(h,s,v)  {

        h %= 360;
        s /= 100;
        v /= 100;

        var r = 0, g = 0, b = 0;

        if (s === 0) {
            r = Math.floor(v * 255);
            g = Math.floor(v * 255);
            b = Math.floor(v * 255);
        } else {
            var nH = h/60;
            var nI = Math.floor(nH);
            var nV1 = v*(1-s);
            var nV2 = v*(1-s*(nH-nI));
            var nV3 = v*(1-s*(1-(nH-nI)));

            var nR = 0, nG = 0, nB = 0;

            if (nI === 0) {nR = v; nG = nV3; nB = nV1;}
            else if (nI == 1) {nR = nV2; nG = v; nB = nV1;}
            else if (nI == 2) {nR = nV1; nG = v; nB = nV3;}
            else if (nI == 3) {nR = nV1; nG = nV2; nB = v;}
            else if (nI == 4) {nR = nV3; nG = nV1; nB = v;}
            else if (nI == 5) {nR = v; nG = nV1; nB = nV2;}

            r = Math.floor(nR * 255);
            g = Math.floor(nG * 255);
            b = Math.floor(nB * 255);
        }
        return {r:r, g:g, b:b};
    },
    rgb2hsv: function(r,g,b) {
        var nR = ( r / 255 );
        var nG = ( g / 255 );
        var nB = ( b / 255 );

        var h = 0, s = 0, v = 0;

        var nMin = Math.min( nR, nG, nB );
        var nMax = Math.max( nR, nG, nB );
        var nDiff = nMax - nMin;

        v = nDiff;

        if( nDiff === 0 ) {
           h = 0; s = 0;
        } else {
           s = nDiff / nMax;
           var nDiffR = (((nMax-nR)/6) + (nDiff/2)) / nDiff;
           var nDiffG = (((nMax-nG)/6) + (nDiff/2)) / nDiff;
           var nDiffB = (((nMax-nB)/6) + (nDiff/2)) / nDiff;

           if (nR == nMax) {
               h = nDiffB - nDiffG;
           }
           else if (nG == nMax) {
                   h = (1 / 3) + nDiffR - nDiffB;
           }else if (nB == nMax) {
                   h = (2 / 3) + nDiffG - nDiffR;
              }
           if (h < 0) {
               h += 1;
           }
           if (h > 1) {
               h -= 1;
           }
        }
        return { h:h, s:s, v:v };
    }
});


/*---- Trex.Color ------------------------------------------------------*/
Trex.Color = {
    getHexColor: function(color) {
        color = color.trim();
        if(color.indexOf("rgb") < 0) {
            if(color.length > 0 && (color.indexOf("-moz-use") > -1 || color == "transparent")) {
                return "transparent";
            } else {
                return color;
            }
        }

        if (/rgba\s?\((0,\s?){3}0\)/i.test(color)) {
            return "transparent";
        }

        var aColor = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),?\s*\d*\)/i);
        if (!aColor) {
            return color;
        }
        aColor.shift();
        if(aColor.length < 3){
            return color;
        }

        var nCh;
        var sHexColor = "#";
        for(var h=0;h<3;h++) {
            nCh = parseInt(aColor[h].trim()).toString(16).toUpperCase();
            if (nCh.length == 1) {
                sHexColor = sHexColor.concat("0" + nCh);
            }else if (nCh.length > 2) {
                sHexColor = sHexColor.concat("FF");
            }else {
                sHexColor = sHexColor.concat("" + nCh);
            }
        }
        return sHexColor;
    },
    getValidColor: function(color) {
        if(color === _NULL || color == "transparent") {
            return "transparent";
        }
        var m = color.match(/#?([0-9a-f]{6}|[0-9a-f]{3})/i);
        if(m === _NULL || color.length > 8) {
            return _NULL;
        }
        if (m[1].length == 3) {
            return "#" + m[1] + m[1];
        } else {
            return "#" + m[1];
        }
    },
    getOptColor: function(color, opacity) {
        if(!color || color.length != 7 || color.charAt(0) != '#') {
            return "#e5e5e5";
        }
        color = color.substring(1, 7).toLowerCase();
        opacity = isNaN(opacity)? 100: opacity;
        var _optColor = "#";
        var _sch, _och;
        for (var h = 0; h < 3; h++) {
            _sch = parseInt(color.substr(h * 2, 2), 16);
            _och = Math.round(Math.floor((255 -_sch) * (1 - opacity * 0.01) + _sch * (opacity * 0.02))).toString(16);
            if (_och.length == 1) {
                _optColor += "0" + _och;
            } else if (_och.length > 2) {
                _optColor += "ff";
            } else {
                _optColor += _och;
            }
        }
        return _optColor;
    }
};

Trex.I.CookieBaker = Trex.Faculty.create({
	cookieName: _NULL,
	cookieValue: _NULL,
	initCookie: function(name, maxCnt) {
		this.cookieName = name;
		this.cookieValue = function () {
		    var cookies = _DOC.cookie.split(';');
		    for(var i=0; i<cookies.length; i++){
		        var cookie=cookies[i].replace(/^\s+/, '');
		        if (cookie.indexOf(name+'=')==0) return cookie.substring(name.length+1);
		    }
		    return _NULL;
		}() || "";
		this.maxCnt = maxCnt || 3;
	},
	writeCookie: function(value, days){
		var name = this.cookieName, exp;
	    if(days){
            var time = new Date();
            time.setTime(new Date().getTime()+days*24*60*60*1000);
	        exp = '; expires='+time.toGMTString();
	    }else{
	        exp='';
	    }
		if (value === _NULL) {//NOTE: #FTDUEDTR-888
			value = '';
		}
		_DOC.cookie=name+"="+value+exp+"; path=/";
		this.cookieValue = value;
	},
	readCookie: function () {
		if (this.cookieValue === _NULL+'') {//NOTE: #FTDUEDTR-888
			return _NULL;
		}
	    return this.cookieValue;
	},
	eraseCookie: function () {
		var name = this.cookieName;
	    this.writeCookie(name, "", -1);
	},
	extractOptions: function(options, value) {
		var _optionMap = options.toMap('data');
		var _values = [];
		value.split('|').compact().each(function(data) {
			if(_optionMap[data]) {
				_values.push(_optionMap[data]);
			}
		}.bind(this));
		return _values;
	},
	mergeValues: function(value, data) {
		var _values = value.split('|').compact();
		if(_values.contains(data)) {
			return value;
		}
		if(_values.length >= this.maxCnt) {
			_values.pop();
		}
		_values.unshift(data);
		return _values.join('|');
	}
});

/**
 * Created by sungwon on 14. 7. 2.
 */
Trex.I.point = Trex.Faculty.create({
    /**
     * @param {Event} e
     * @returns {Number[]}
     * @private
     */
    _getPointByEvent: function(e){
        var el = $tx.element(e);
        var doc = el.ownerDocument;
        var x = $tx.pointerX(e);
        var y = $tx.pointerY(e);
        if(doc !== this._doc){
            var of = $tx.getOffset(this._panel.el);
            return [x-of.left+(this._win.pageXOffset || this._doc.documentElement.scrollLeft), y-of.top+(this._win.pageYOffset || this._doc.documentElement.scrollTop)];
        }
        return [x,y]
    },/**
     * @param {Number[]} p1
     * @param {Number[]} p2
     * @return {Number[]}
     * @private
     */
    _subtractPoint: function(p1, p2){
        return [ p1[0] - p2[0], p1[1] - p2[1] ];
    },
    _addPoint: function(p1, p2){
        return [ p1[0] + p2[0], p1[1] + p2[1] ];
    },
    _distancePoint: function(p1, p2){
        var point = this._subtractPoint(p1,p2);
        return Math.sqrt(Math.pow(point[0],2) + Math.pow(point[1],2));
    }
});
/**
 * @fileoverview
 * \uc5d0\ub514\ud130\uc5d0\uc11c \uc0ac\uc6a9\ub418\ub294 button\uc758 \ubaa8\uc74c 
 * 
 */

Trex.MarkupTemplate.add(
	'button.itsnew', '<em class="tx-itsnew" title="new">new</em>'
);

Trex.MarkupTemplate.add(
	'button.select.text', '<span>#{data}</span>'
);

/**
 * \uc77c\ubc18\uc801\uc778 \ub3d9\uc791\uc758 \ubc84\ud2bc \uac1d\uccb4\ub85c, \ud2b9\ud654\ub41c \ubc84\ud2bc\uc740 \uc774 \ud074\ub798\uc2a4\ub97c \uc0c1\uc18d\ubc1b\uc544 \uc0ac\uc6a9\ud55c\ub2e4.<br/>
 * \ud574\ub2f9 \uc5d8\ub9ac\uba3c\ud2b8\ub294 \ubbf8\ub9ac DOM\uc5d0 \uc788\uc5b4\uc57c \ud558\uba70, __borderClasses\uc5d0 \uc9c0\uc815\ub41c \ud074\ub798\uc2a4\uc774\ub984\uc744 \uac00\uc838\uc57c\ud55c\ub2e4. 
 * 
 * @class
 * @param {Object} config
 * 
 * @example
 *	<div id="tx_example" class="tx-example tx-btn-lrbg" unselectable="on">
 *		<a title="\uc608\uc81c" class="tx-icon" href="javascript:;">\uc608\uc81c</a>
 *	</div>
 * 
 * 	new Trex.Button({
 * 		id: 'tx_example',
 * 		wysiwygonly: _TRUE,
 * 		sync: false,
 * 		status: false
 * 	});
 */
Trex.Button = Trex.Class.create(/** @lends Trex.Button.prototype */{
	/** @ignore */
	$const: {
		__borderClasses: {	
			'tx-btn-trans': _TRUE,
			'tx-btn-lbg': _TRUE, 
			'tx-btn-bg': _TRUE, 
			'tx-btn-rbg': _TRUE,
			'tx-btn-lrbg': _TRUE,
			'tx-slt-tlbg': _TRUE, 
			'tx-slt-tbg': _TRUE, 
			'tx-slt-trbg': _TRUE, 
			'tx-slt-blbg': _TRUE, 
			'tx-slt-bbg': _TRUE, 
			'tx-slt-brbg': _TRUE, 
			'tx-slt-31bg': _TRUE,
			'tx-slt-31lbg': _TRUE, 
			'tx-slt-31rbg': _TRUE, 
			'tx-slt-70lbg': _TRUE, 
			'tx-slt-70bg': _TRUE, 
			'tx-slt-59bg': _TRUE, 
			'tx-slt-42bg': _TRUE, 
			'tx-slt-56bg': _TRUE, 
			'tx-btn-nlrbg': _TRUE,
			'tx-btn-43lrbg': _TRUE,
			'tx-btn-52lrbg': _TRUE,
			'tx-btn-57lrbg': _TRUE,
			'tx-btn-71lrbg': _TRUE,
			'tx-btn-48lbg': _TRUE, 
			'tx-btn-48rbg': _TRUE, 
			'tx-btn-30lrbg': _TRUE, 
			'tx-btn-46lrbg': _TRUE,
			'tx-btn-67lrbg': _TRUE,
			'tx-btn-49lbg': _TRUE,
			'tx-btn-58bg': _TRUE,
			'tx-btn-46bg': _TRUE,
			'tx-btn-49rbg': _TRUE,
			'tx-btn-widget': _TRUE,
			'tx-btn-widget-tbg': _TRUE,
			'tx-btn-widget-brbg': _TRUE
		},
		addBorderClass: function(className){
			Trex.Button.__borderClasses[className] = _TRUE;
		},
		getBorderClass: function(el){
			var _classes = $tx.classNames(el);
			for(var i =0; i < _classes.length; i++){
				var _class = _classes[i];
				var _matched = Trex.Button.__borderClasses[_class];
				if(_matched){
					return _class;
				}
			}
		}
	},
	/**
	 * \uc0c1\ud0dc\uac00 \uc788\ub294\uc9c0 \uc5ec\ubd80
	 */
	hasState: _NULL,
	/**
	 * disabled \uc0c1\ud0dc\uc778\uc9c0 \uc5ec\ubd80
	 */
	isDisabled: _NULL,
	/**
	 * \uba54\ub274\uac00 \uc788\ub294 \ubc84\ud2bc\uc758 \uacbd\uc6b0 \uc120\ud0dd\ub41c \uac12 (ex: font-family tool\uc5d0\uc11c '\uad81\uc11c'\ub97c \uc120\ud0dd\ud558\uba74 lastValue\ub294 'Gungsuh,\uad81\uc11c'\uc774\ub2e4.)
	 */
	lastValue: _NULL,
	/**
	 * \uba54\ub274\uac00 \uc788\ub294 \ubc84\ud2bc\uc758 \uacbd\uc6b0 \uc120\ud0dd\ub41c \uba54\ub274\ud56d\ubaa9\uc758 \ub808\uc774\ube14
	 */
	lastText: _NULL,
	/**
	 * \ubc84\ud2bc dom element
	 */
	elButton: _NULL,
	/**
	 * \ubc84\ud2bc\uc758 \uc544\uc774\ucf58 dom element
	 */
	elIcon: _NULL,
	/**
	 * \ubc84\ud2bc\uc758 \ubc30\uacbd \uc774\ubbf8\uc9c0 \ud074\ub798\uc2a4\uc774\ub984
	 */
	borderClass: _NULL,
	/**
	 * \ubc84\ud2bc\uc758 \uc2e4\ud589 command function
	 * @function
	 */
	_command: function(){},
	/**
	 * \ubc84\ud2bc\uc744 \uc2e4\ud589\ud558\uba74 \ud638\ucd9c \ub420 command function\uc744 \uc9c0\uc815\ud55c\ub2e4. 
	 * @private
	 * @function
	 */
	setCommand: function(cmd){
		this._command = cmd;
	},
	initialize: function(config) { //only superclass
		var _config = this.config = config;
		if (_config.borderClass) {
			Trex.Button.addBorderClass(_config.borderClass);
		}
		
		this.itsNew = !!_config.itsnew;
		this.hasState = !!_config.status; //pushed status
		this.isDisabled = _FALSE;
		this.lastValue = _config.selectedValue || _NULL;
		
		if ( config.el ){
			this.elButton = config.el;
		}else{
			var _elementId = _config.id || "tx_" + _config.identity;
			this.elButton = $must(_elementId + (_config.initializedId || ""));
		}
		var _elButton = this.elButton;
		
		var _elIcon = this.elIcon = $tom.collect(_elButton, "a");
		if (!_elIcon) {
			throw new Error("[Exception]Trex.Button : can't find elIcon for button '"+ _elementId +"'");
		}
		this.borderClass = Trex.Button.getBorderClass(_elButton);
		
		if(this.oninitialized){
			this.oninitialized.bind(this)(_config);	
		}
		this.generate();
		
		if(this.itsNew) {
			$tom.append(_elIcon, Trex.MarkupTemplate.get('button.itsnew').evaluateAsDom({}));
		}
		
		if (_config.selectedValue && this.setValue) {
			this.setValue(_config.selectedValue);
		}
		if (_config.selectedText && this.setText) {
			this.setText(_config.selectedText);
		}
		if ( _config.selectedState && this.setState ){
			this.setState( _config.selectedState );
		}
	},
	/**
	 * \ubc84\ud2bc\uc758 \uc774\ubca4\ud2b8\uc5d0 handler function \uc744 \uac78\uc5b4\uc900\ub2e4.
	 * @function
	 */
	generate: function() {
		var _elIcon = this.elIcon;
		this.hdlMouseDown = this.onMouseDown.bindAsEventListener(this);
		this.hdlMouseOver = this.onMouseOver.bindAsEventListener(this);
		this.hdlMouseOut = this.onMouseOut.bindAsEventListener(this);
		this.hdlKeydown = this.onKeyDown.bindAsEventListener(this);
		this.hdlClick = this.onClick.bindAsEventListener(this);
		
		$tx.observe(_elIcon, 'mousedown', this.hdlMouseDown);
		$tx.observe(_elIcon, 'mouseover', this.hdlMouseOver);
		$tx.observe(_elIcon, 'mouseout', this.hdlMouseOut);
		$tx.observe(_elIcon, 'keydown', this.hdlKeydown);
		$tx.observe(_elIcon, 'click', this.hdlClick);

		if (this.ongenerated) {
			this.ongenerated.bind(this)(this.config);
		}
	},
	/**
	 * \ubc84\ud2bc\uc5d0 \ucd94\uac00\ub41c \uc774\ubca4\ud2b8\ub97c \uc81c\uac70\ud55c\ub2e4.
	 * @function
	 */
	removeHandler: function(){
		if( !this.hdlMouseDown ){
			return;
		}
		var _elIcon = this.elIcon;
		$tx.stopObserving(_elIcon, 'mousedown', this.hdlMouseDown);
		$tx.stopObserving(_elIcon, 'mouseover', this.hdlMouseOver);
		$tx.stopObserving(_elIcon, 'mouseout', this.hdlMouseOut);
		$tx.stopObserving(_elIcon, 'keydown', this.hdlKeydown);
		$tx.stopObserving(_elIcon, 'click', this.hdlClick);
	},
	/**
	 * \ubc84\ud2bc\uc758 border class \uc774\ub984\uc744 \uac00\uc838\uc628\ub2e4.
	 * @function
	 * @returns {String} css class name \ub610\ub294 'undefined'
	 */
	getCurrentBorderClass: function(el){
		var _classes = $tx.classNames(el);
		
		for(var i =0; i < _classes.length; i++){
			var _class = _classes[i];
			if(_class.indexOf(this.borderClass) != -1){
				return _class; 
			}
		}
		return _UNDEFINED+'';
	},
	/**
	 * \ubc84\ud2bc\uc758 css class \ub97c \ucd08\uae30\uc0c1\ud0dc\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	normalState: function(){
		var _currBorderClass = this.getCurrentBorderClass(this.elButton);
		if(_currBorderClass == this.borderClass) {
			return;
		}
		$tx.removeClassName(this.elButton, _currBorderClass);
		$tx.addClassName(this.elButton, this.borderClass);
	},
	/**
	 * \ubc84\ud2bc\uc758 css class \ub97c mouse over \uc0c1\ud0dc\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	hoveredState: function(){
		var _currBorderClass = this.getCurrentBorderClass(this.elButton);
		$tx.removeClassName(this.elButton, _currBorderClass);
		$tx.addClassName(this.elButton, this.borderClass + '-hovered');
		this.decreaseZindex();
	},
	/**
	 * \ubc84\ud2bc\uc758 css class \ub97c \ub20c\ub824\uc788\ub294 \uc0c1\ud0dc\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	pushedState: function(){
		var _currBorderClass = this.getCurrentBorderClass(this.elButton);
		$tx.removeClassName(this.elButton, _currBorderClass);
		$tx.addClassName(this.elButton, this.borderClass + '-pushed');
	},
	/**
	 * \ubc84\ud2bc\uc758 \ud604\uc7ac \uc0c1\ud0dc\ub97c \ubc18\ud658\ud55c\ub2e4.
	 * @function
	 * @return {String} 'normal', 'pushed', 'hovered'
	 */
	currentState: function(){
		var _currBorderClass = this.getCurrentBorderClass(this.elButton);
		var cs = "normal";
		if(_currBorderClass.indexOf('-pushed') != -1){
			cs = "pushed";
		}else if(_currBorderClass.indexOf('-hovered') != -1){
			cs = "hovered";
		}
		return cs;
	},
	/**
	 * \ubc84\ud2bc\uc774 \ub20c\ub9b0 \uc0c1\ud0dc\uc778\uc9c0 \uc544\ub2cc\uc9c0 \ud310\ub2e8\ud55c\ub2e4.
	 * @function
	 * @return {boolean} \ub20c\ub9b0 \uc0c1\ud0dc(pushed)\uc774\uba74 true, \uc544\ub2c8\uba74 false
	 */
	isPushed: function(){
		return ("pushed" == this.currentState());
	},
	/**
	 * \uba54\ub274\uac00 \uc788\ub294 \ubc84\ud2bc\uc778\uc9c0 \ud310\ub2e8\ud55c\ub2e4.
	 * @function
	 * @return {boolean} \uba54\ub274\uac00 \uc788\uc73c\uba74 true, \uc544\ub2c8\uba74 false
	 */
	hasMenu: function(){
		return this.tool ? !!(this.tool.menu) : _FALSE;
	},
	/**
	 * \ubc84\ud2bc\uc744 \ub204\ub974\uba74 normal state \ub610\ub294 pushed state\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	onMouseDown: function(ev) {
		if(ev){
			$tx.stop(ev);
		}
		if(this.isDisabled) {
			return;
		}
		if(this.hasMenu() || this.hasState){
			if (this._command(ev) === _FALSE) {
				return;
			}
		}else{
			this.evsessionstarted = _TRUE;
		}
		if (this.isPushed()) {
			this.normalState();
		} else {
			this.pushedState();
		}
	},
	/**
	 * \ub9c8\uc6b0\uc2a4 \ucee4\uc11c\ub97c \ubc84\ud2bc\uc601\uc5ed \uc704\uc5d0 \uc62c\ub9ac\uba74 hovered state\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	onMouseOver: function() {
		if(this.isDisabled || this.isPushed()) {
			return;
		}
		this.hoveredState();
	},
	/**
	 * \ub9c8\uc6b0\uc2a4 \ucee4\uc11c\uac00 \ubc84\ud2bc\uc601\uc5ed \ubc14\uae65\uc73c\ub85c \ub098\uac00\uba74 normal state\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	onMouseOut: function() {
		if(this.evsessionstarted){
			this.normalState();
			this.evsessionstarted = _FALSE;
		}
		if(this.isDisabled || this.isPushed()){
			return;
		}
		this.normalState();
	},
	/**
	 * \ubc84\ud2bc\uc744 \ud074\ub9ad\ud558\uba74 command function\uc744 \uc2e4\ud589\ud558\uace0 normal state\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	onClick: function(ev) {
		if(ev){
			$tx.stop(ev);
		}
		if(this.isDisabled) {
			return;
		}	
		if(!this.hasState){
			this._command();
			this.normalState();
			this.evsessionstarted = _FALSE;
		}
	},
	/**
	 * event keyCode\uac00 13\uc774\uba74 onMouseDown(), onClick() \uc744 \uc2e4\ud589\ud55c\ub2e4.
	 * @function
	 */
	onKeyDown: function(ev){
		if(ev.keyCode === 13){
			this.onMouseDown(ev);
			this.onClick(ev);
		}
	},
	/**
	 * command function \uc2e4\ud589 \ud6c4 lastValue, lastText\uc758 \uac12\uc744 \uc5c5\ub370\uc774\ud2b8 \ud55c\ub2e4.
	 * @function
	 */
	updateAfterCommand: function(value, text){
		this.setValueAndText(value, text);
		this.normalState();
	},
	/**
	 * lastValue, lastText\uc758 \uac12\uc744 \uc124\uc815\ud55c\ub2e4.
	 * @function
	 */
	setValueAndText: function(value, text){
		this.setValue(value);
		this.setText(text);
	},
	/**
	 * lastValue \uac12\uc744 \uc124\uc815\ud55c\ub2e4.
	 * @function
	 */
	setValue: function(value) {
		if(value) {
			this.lastValue = value;
		}
	},
	/**
	 * lastText \uac12\uc744 \uc124\uc815\ud55c\ub2e4.
	 * @function
	 */
	setText: function(text) {
		this.lastText = text;
	},
	/**
	 * lastValue \uac12\uc744 \uac00\uc838\uc628\ub2e4.
	 * @function
	 * @return {String}
	 */
	getValue: function() {
		return this.lastValue;
	},
	/**
	 * lastText \uac12\uc744 \uac00\uc838\uc628\ub2e4.
	 * @function
	 * @return {String}
	 */
	getText: function() {
		return this.lastText;
	},
	/**
	 * pushed\uc5d0\uc11c normal state\ub85c \ub610\ub294 \uadf8 \ubc18\ub300\ub85c \uc0c1\ud0dc\ub97c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	setState: function(push) {
		if (push) {
			this.pushedState();
		} else {
			this.normalState();
		}
	},
	/**
	 * \uc544\uc774\ucf58 element \uc758 css class \ub97c \uc124\uc815\ud55c\ub2e4.
	 * @function
	 */
	setClassName: function(className) {
		this.elIcon.className = className;
	},
	/**
	 * \ubc84\ud2bc\uc744 \uc0ac\uc6a9\ubd88\uac00 \uc0c1\ud0dc\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	disable: function() {
		if(this.elButton) {
			this.isDisabled = _TRUE;
			$tx.addClassName(this.elButton, "tx-disable");
		}
	},
	/**
	 * \ubc84\ud2bc\uc744 \uc0ac\uc6a9\uac00\ub2a5 \uc0c1\ud0dc\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	enable: function() {
		if(this.elButton) {
			this.isDisabled = _FALSE;
			$tx.removeClassName(this.elButton, "tx-disable");
		}
	},
	/**
	 * \ubc84\ud2bc\uc744 normal state\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	release: function() {
		if(this.isDisabled) {
			return;
		}
		if(this.hasMenu() || !this.hasState){
			this.normalState();	
		}
	},
	/**
	 * \ubc84\ud2bc\uc758 zindex \ud06c\uac8c \ub9cc\ub4e0\ub2e4.
	 * @function
	 */
	increaseZindex: function(){
		var zIndexValue = 10;
		if( $tom.parent(this.elButton)){
			$tx.setStyle( $tom.parent(this.elButton), { zIndex: zIndexValue});
		}
	},
	/**
	 * \ubc84\ud2bc\uc758 zindex \uc791\uac8c \ub9cc\ub4e0\ub2e4.
	 * @function
	 */
	decreaseZindex: function(){
		var zIndexValue = 4;
		if( $tom.parent(this.elButton)){
			$tx.setStyle( $tom.parent(this.elButton), { zIndex: zIndexValue});
		}
	}
});

/**
 * Trex.Button.Select
 * 
 * @extends Trex.Button
 * @class
 */
Trex.Button.Select = Trex.Class.create(/** @lends Trex.Button.Select.prototype */{
	/** @ignore */
	$extend: Trex.Button,
	/**
	 * \ubc84\ud2bc\uc5d0 \ud654\uc0b4\ud45c \ubc84\ud2bc\uc774 \ub354 \ubd99\uc5b4 \uc788\uc744 \uacbd\uc6b0 \ud654\uc0b4\ud45c \ubc84\ud2bc\uc5d0 event handler function \uc744 \uac78\uc5b4\uc900\ub2e4.
	 * @function
	 */
	ongenerated: function(){
		Trex.MarkupTemplate.get('button.select.text').evaluateToDom({
			'data': $tom.getText(this.elIcon)
		}, this.elIcon);
		this.elText = $tom.collect(this.elIcon, 'span');
		
		var _elArrow = $tom.collect(this.elButton, "a.tx-arrow");
		if(_elArrow) {
			$tx.observe(_elArrow, 'mousedown', this.onMouseDown.bindAsEventListener(this));
			$tx.observe(_elArrow, 'mouseover', this.onArrowMouseOver.bindAsEventListener(this));
			$tx.observe(_elArrow, 'mouseout', this.onArrowMouseOut.bindAsEventListener(this));
			$tx.observe(_elArrow, 'click', this.onClick.bindAsEventListener(this));	
		}
	},
	/**
	 * \uba54\ub274\uc5d0\uc11c \uc120\ud0dd\ub41c \uac12\uc758 \ub808\uc774\ube14\uc744 \uc124\uc815\ud55c\ub2e4.
	 * @function
	 */
	setText: function(text) {
		this.elText.innerText = text;
	},
	/**
	 * \ub9c8\uc6b0\uc2a4 \ucee4\uc11c\ub97c \ubc84\ud2bc\uc601\uc5ed \uc704\uc5d0 \uc62c\ub9ac\uba74 hovered state\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	onArrowMouseOver: function() {
		if(this.isDisabled || this.isPushed()) {
			return;
		}
		this.hoveredState();
	},
	/**
	 * \ub9c8\uc6b0\uc2a4 \ucee4\uc11c\uac00 \ubc84\ud2bc\uc601\uc5ed \ubc14\uae65\uc73c\ub85c \ub098\uac00\uba74 normal state\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	onArrowMouseOut: function() {
		if(this.isDisabled || this.isPushed()) {
			return;
		}
		this.normalState();
	}
});

/**
 * Trex.Button.Splits
 * 
 * @extends Trex.Button
 * @class
 */
Trex.Button.Splits = Trex.Class.create(/** @lends Trex.Button.Splits.prototype */{
	/** @ignore */
	$extend: Trex.Button,
	ongenerated: function(){
		var _elButton = this.elButton;
		var _elArrow = this.elArrow = $tom.collect(_elButton, "a.tx-arrow");
		if(!_elArrow) {
			throw new Error("[Exception]Trex.Button.Splits : not exist element(a.tx-arrow)");
		}
		$tx.observe(_elArrow, 'mousedown', this.onArrowMouseDown.bindAsEventListener(this));
		$tx.observe(_elArrow, 'mouseover', this.onArrowMouseOver.bindAsEventListener(this));
		$tx.observe(_elArrow, 'mouseout', this.onArrowMouseOut.bindAsEventListener(this));
		$tx.observe(_elArrow, 'click', this.onArrowClick.bindAsEventListener(this));
	},
	/**
	 * \ud654\uc0b4\ud45c \ubc84\ud2bc\uc758 css class \ub97c mouse over \uc0c1\ud0dc\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	arrowHoveredState: function(){
		var _currBorderClass = this.getCurrentBorderClass(this.elButton);
		$tx.removeClassName(this.elButton, _currBorderClass);
		$tx.addClassName(this.elButton, this.borderClass + '-arrow-hovered');
	},
	/**
	 * \ud654\uc0b4\ud45c \ubc84\ud2bc\uc758 css class \ub97c pushed \uc0c1\ud0dc\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	arrowPushedState: function(){
		var _currBorderClass = this.getCurrentBorderClass(this.elButton);
		$tx.removeClassName(this.elButton, _currBorderClass);
		$tx.addClassName(this.elButton, this.borderClass + '-arrow-pushed');
	},
	/**
	 * \ubc84\ud2bc\uc744 \ub204\ub974\uba74 \uc0c1\ud0dc\ub97c \ubcc0\uacbd\ud558\uace0 command\ub97c \uc2e4\ud589\ud55c\ub2e4. \ubc84\ud2bc \uc606\uc5d0 \uc788\ub294 \ud654\uc0b4\ud45c\uc758 \uc0c1\ud0dc\ub97c \ubcf8\ub2e4.  
	 * @function
	 */
	onMouseDown: function() {
		if(this.isDisabled) {
			return;
		}
		if(this.isPushed()){
			this._command();
			this.normalState();
			this.commandexecuted = _TRUE;
		}else{
			this.pushedState();
			this.commandexecuted = _FALSE;
			this.evsessionstarted = _TRUE;
		}
	},
	/**
	 * tool\uc758 execute\ub97c \uc2e4\ud589\ud558\uace0 normal state\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	onClick: function(ev) {
		if(ev){
			$tx.stop(ev);	
		}
		if(this.isDisabled) {
			return;
		}
		if(!this.commandexecuted){
			this.tool.execute(this.lastValue, this.lastText);
			this.evsessionstarted = _FALSE;
		}else{
			this.commandexecuted = _FALSE;
		}
		this.normalState();
	},
	/**
	 * \ud654\uc0b4\ud45c\ub97c pushed state \ub85c \ubcc0\uacbd\ud558\uac70\ub098 normal state\ub85c \ubcc0\uacbd\ud55c\ub2e4. 
	 * @function
	 */
	onArrowMouseDown: function() {
		if(this.isDisabled) {
			return;
		}
		if (this._command() === _FALSE) {
			return;
		}
		if(this.isPushed()){
			this.normalState();
		}else{
			this.arrowPushedState();
		}
	},
	/**
	 * @function
	 */
	onArrowClick: function(ev) {
		if(ev){
			$tx.stop(ev);	
		}
		if(this.isDisabled) {
			return;
		}	
	}, 
	/**
	 * \ud654\uc0b4\ud45c \ubc84\ud2bc\uc758 css class \ub97c mouse over \uc0c1\ud0dc\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	onArrowMouseOver: function() {
		if(this.isDisabled || this.isPushed()) {
			return;
		}
		this.arrowHoveredState();
	},
	/**
	 * \ud654\uc0b4\ud45c \ubc84\ud2bc\uc758 css class \ub97c normal \uc0c1\ud0dc\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	onArrowMouseOut: function() {
		if(this.isDisabled || this.isPushed()) {
			return;
		}
		if(this.commandexecuted){
			this.commandexecuted = _FALSE;
		}
		this.normalState();
	}
});

/** 
 * Trex.Button.Toggle 
 * 
 * @extends Trex.Button
 * @class
 */
Trex.Button.Toggle = Trex.Class.create(/** @lends Trex.Button.Toggle.prototype */{
	/** @ignore */
	$extend: Trex.Button,
	/**
	 * pushed \ub610\ub294 normal state\ub85c \ubcc0\uacbd\ud55c\ub2e4.
	 * @function
	 */
	setValue: function(selected) {
		if (selected) {
			this.pushedState();
		} else {
			this.normalState();
		}
	}
});

/** 
 * Trex.Button.Widget 
 * 
 * @extends Trex.Button.Select
 * @class
 */
Trex.Button.Widget = Trex.Class.create(/** @lends Trex.Button.Widget.prototype */{
	/** @ignore */
	$extend: Trex.Button.Select,
	/**
	 * lastText \uac12\uc744 \uc124\uc815\ud55c\ub2e4.
	 * @function
	 */
	setText: function(text) {
		this.elIcon.innerText = text;
		if ( this.lastText ){
			$tx.removeClassName( this.elIcon, this.lastText );
		}
		
		$tx.addClassName( this.elIcon, text );
		this.lastText = text;
	},
	/**
	 * \ubc84\ud2bc\uc5d0 menu\uc640 menu handler\ub97c \uc124\uc815\ud55c\ub2e4.
	 * @function
	 */
	setMenu: function(menu, handler) {
		this.hasState = _TRUE;
		var _button = this;
		
		menu.setCommand(function() { 
			var success = handler.apply(this, arguments);
			_button.updateAfterCommand.apply(_button, arguments);
			return success;
		});
		
		_button.setCommand(
			function() {
				if(!_button.isPushed()) {
					var _lastvalue = _button.getValue();
					menu.show(_lastvalue);
				} else {
					menu.hide();
				}
				return _TRUE;
			}
		);
	}
});

/** 
 * Trex.Button.ColorWidget 
 * 
 * @extends Trex.Button.Widget
 * @class
 */
Trex.Button.ColorWidget = Trex.Class.create(/** @lends Trex.Button.ColorWidget.prototype */{
	/** @ignore */
	$extend: Trex.Button.Widget,
	/**
	 * lastValue \uac12\uc744 \uc124\uc815\ud55c\ub2e4.
	 * @function
	 */
	setValue: function(value){
		$tx.setStyle( this.elIcon.parentNode, {'backgroundColor': value});
		this.lastValue = value;
	},
	/**
	 * do nothing
	 * @function
	 */
	setText: function(){
		// do Nothing
	}
});


/**
 * @fileoverview
 * \uc5d0\ub514\ud130\uc5d0\uc11c \uc0ac\uc6a9\ub418\ub294 menu\uc758 \ubaa8\uc74c
 */

TrexMessage.addMsg({
	'@menu.pallete.enter': "\uc785\ub825",
	'@menu.pallete.more': "\ub354\ubcf4\uae30"
});
/**
 * \uc77c\ubc18\uc801\uc778 \ub3d9\uc791\uc758 \uba54\ub274 \uac1d\uccb4\ub85c, \ud2b9\ud654\ub41c \uba54\ub274\ub294 \uc774 \ud074\ub798\uc2a4\ub97c \uc0c1\uc18d\ubc1b\uc544 \uc0ac\uc6a9\ud55c\ub2e4.<br/>
 * \ud574\ub2f9 \uc5d8\ub9ac\uba3c\ud2b8\ub294 \ubbf8\ub9ac DOM\uc5d0 \uc788\uc5b4\uc57c \ud55c\ub2e4.
 * tool\uc5d0\uc11c \uc0ac\uc6a9\ub41c\ub2e4.
 * 
 * @class
 * @param {Object} config
 * 
 * @example
 *	Trex.Menu.Example = Trex.Class.create({
 *		$extend: Trex.Menu,
 *		ongenerated: function(config) {
 *			//TODO
 *		},
 *		onregenerated: function(config) {
 *			//TODO
 *		}
 * });
 * 
 *	new Trex.Menu({
 *		id: 'tx_example_menu',
 *		options: [
 *			{ label: '\uc635\uc1581', title: '\uc635\uc1581', data: 'option1' },
 *			{ label: '\uc635\uc1582', title: '\uc635\uc1581', data: 'option2' }
 *		]
 *	});
 */
Trex.Menu = Trex.Class.create(/** @lends Trex.Menu.prototype */{
	$mixins: [Trex.I.JobObservable],
	isInit: _FALSE,
	isDisplayed: _FALSE,
	_command: function(){},
	/**
	 * menu\uc5d0 command\ub97c \uc124\uc815\ud55c\ub2e4.
	 * @private
	 * @function
	 */
	setCommand: function(cmd){
		this._command = cmd;
	},
	initialize: function(config) {
		var _config = this.config = config;
		
		var _elMenu;
		if(_config.el) {
			_elMenu = _config.el;
			if(!_elMenu) {
				throw new Error("[Exception]Trex.Menu : not exist element(" + _config.el + ")");
			}
		} else {
			var _elementId = _config.id;
			var _initializedId = ((_config.initializedId)? _config.initializedId: "");
			if (!_elementId) {
				if (!_config.identity) {
					throw new Error("[Exception]Trex.Menu : not exist config - id");
				}
				_elementId = "tx_" + _config.identity + "_menu";
			}
			_elMenu = $tx(_elementId + _initializedId);
			if(!_elMenu) {
				throw new Error("[Exception]Trex.Menu : not exist element(" + _elementId + ")");
			}
		}
		this.elMenu = _elMenu;
		
		if(_config.top){
			_elMenu.style.top = _config.top + 'px';
		}
		if(_config.left){
			_elMenu.style.left = _config.left + 'px';
		}

		if(this.oninitialized) {
			this.oninitialized.bind(this)(config);
		}
		if (this.ongenerated) {
			this.generateHandler = this.ongenerated.bind(this);
		}
		if (this.onregenerated) {
			this.regenerateHandler = this.onregenerated.bind(this);
		}
	},
	/**
	 * menu\ub97c DOM\uc744 \uc0dd\uc131\ud55c\ub2e4.
	 * @function
	 */
	generate: function(initValue) {
		if (this.generateHandler) {
			var _config = this.config;
			this.generateHandler(_config, initValue);
		}
	},
	/**
	 * menu\ub97c \uc7ac\uc0dd\uc131\ud55c\ub2e4.
	 * @function
	 */
	regenerate: function(initValue) {
		if (this.initHandler) {
			this.initHandler();
		}
		if (this.regenerateHandler) {
			var _config = this.config;
			this.regenerateHandler(_config, initValue);
		}
	},
    /**
	 * menu option \uc911\uc5d0\uc11c \uc720\ud6a8\ud55c \uac12\ub9cc \uac78\ub7ec\ub0b8\ub2e4.
	 * @function
	 */
	getValidOptions: function(config) {
        return config.options.findAll(function(option) {
            return !option.expired;
        });
	},
	/**
	 * menu \uc5d0\uc11c \uc120\ud0dd\ub41c \ud56d\ubaa9\uc5d0 \ub300\ud55c command\ub97c \uc2e4\ud589\ud55c\ub2e4.
	 * @function
	 */
	onSelect: function() {
		var args = $A(arguments);
		var ev = args.shift();
		this._command.apply(this, args); //\uac00\ubcc0\uc801\uc778 arguments\ub97c \uc704\ud574
		this.hide();
		$tx.stop(ev);
	},
	/**
	 * menu \uc5d0\uc11c \ucde8\uc18c\ub97c \ub204\ub974\uba74 menu \ub97c \ub2eb\ub294\ub2e4.
	 * @function
	 */
	onCancel: function() {
		if(this.cancelHandler) {
			this.cancelHandler();
		}
		this.hide();
	},
	/**
	 * menu \uac00 \uc5f4\ub9b0 \uc0c1\ud0dc\uc778\uc9c0 \ud655\uc778\ud55c\ub2e4.
	 * @function
	 * @return {boolean} \uc5f4\ub824\uc788\uc73c\uba74 true, \uc544\ub2c8\uba74 false
	 */
	visible: function() {
		return this.isDisplayed;
	},
	/**
	 * menu \ub97c \uc5f0\ub2e4. this.generate() \ub610\ub294 this.regenerate() function\uc744 \ud638\ucd9c\ud55c\ub2e4.
	 * @function
	 */
	show: function(initValue) {
		$tx.show(this.elMenu);
		if(this.isInit) {
			this.regenerate(initValue);
		} else {
			if(!!this.config.listseturl) {
				this.lazyGenerate(initValue);
			} else {
				this.generate(initValue);
				this.isInit = _TRUE;
				this.regenerate(initValue);
			}
		}
		if(this.showSpecial) { //NOTE: \uba54\ub274\uac00 \ubcf4\uc5ec\uc9c8 \ub54c \ucd94\uac00\uc801\uc73c\ub85c \uc2e4\ud589\ud560 \uc561\uc158, ex) URL\ub123\uae30\uc5d0\uc11c focus\ub97c \uc904 \ub54c
			this.showSpecial();
		}
		this.isDisplayed = _TRUE;
		this.fireJobs(Trex.Ev.__MENU_LAYER_SHOW, {
			detail: {
				menu: this
			}
		});
		getLayerBoxHide();
	},
	lazyGenerate: function(initValue) {
		var _menu = this;
		new (Trex.Class.create({
			$mixins: [Trex.I.JSRequester],
			initialize: function() {
				this.importScript(
					_menu.config.listseturl,
					'utf-8',
					_DOC,
					function() {
						_menu.generate();
						_menu.isInit = _TRUE;
						_menu.regenerate(initValue);
					}
				);
			}
		}))();
	},
	/**
	 * menu \ub97c \ub2eb\ub294\ub2e4.
	 * @function
	 */
	hide: function() {
		$tx.hide(this.elMenu);
		this.isDisplayed = _FALSE;
        this.fireJobs(Trex.Ev.__MENU_LAYER_HIDE, {
            detail: {
                menu: this
            }
        });
	},
	/**
	 * menu \ub97c \uc5f4\uac70\ub098 \ub2eb\ub294\ub2e4.
	 * @function
	 */
	toggle: function() {
		if( this.isDisplayed ){
			this.hide();
		}else{
			this.show();
		}
	},
	/**
	 * menu \ub97c \ub2eb\ub294\ub2e4.
	 * @function
	 */
	release: function(ev) {
		if(!this.isInit) {
			return;
		}
		this.hide(ev);
	}
});

Trex.MarkupTemplate.add(
	'menu.select', 
	'<ul class="tx-menu-list" unselectable="on">#{items}</ul>'
);
Trex.MarkupTemplate.add(
	'menu.select.item',
	'<li class="tx-menu-list-item"><a class="#{klass}" href="javascript:;" unselectable="on">#{label}</a></li>'
);

/**
 * Trex.Menu.Select
 * as fontfamily, fontsize
 * 
 * @extends Trex.Menu
 * @class
 * @param {Object} config
 */
Trex.Menu.Select = Trex.Class.create(/** @lends Trex.Menu.Select.prototype */{
	/** @ignore */
	$extend: Trex.Menu,
	/**
	 * menu\ub97c \uc0dd\uc131\ud55c\ub2e4.
	 * @function
	 */
	generate: function() {
		/*
			[{
				label: "string",
				title: "string",
				data: "string",
				klass: "string"
			}]
		*/
		var _config = this.config;
		var _optionz = this.getValidOptions(_config);

		var _elList = this.generateList(_optionz);
		$tom.insertFirst(this.elMenu, _elList);

		if (this.generateHandler) {
			this.generateHandler(_config);
		}
		if (this.ongeneratedList) {
			this.generateList = this.ongeneratedList.bind(this);
		}
		if (this.ongeneratedListItem) {
			this.generateListItem = this.ongeneratedListItem.bind(this);
		}
	},

	/**
	 * menu \uc758 list markup \uc744 \ub9cc\ub4e4\uace0 event handler \ub97c \uc5f0\uacb0\ud55c\ub2e4.
	 * @function
	 */
	generateList: function(optionz) {
		var _elGroup = Trex.MarkupTemplate.get("menu.select").evaluateAsDom({
			'items': this.generateListItem(optionz)
		});
		
		var _elItemList = $tom.collectAll(_elGroup, "li a");
		for (var i=0; i < optionz.length; i++) {
			var _option = optionz[i];
			var _elItem = _elItemList[i];
			$tx.observe(_elItem, "click", this.onSelect.bindAsEventListener(this, _option.data, _option.title));
		}
		return _elGroup;
	},
	/**
	 * menu \uc758 list item markup \uc0dd\uc131\ud55c\ub2e4.
	 * @function
	 * @return {String} HTML markup
	 */
	generateListItem: function(option) {
		var result = [];
		for(var i=0; i < option.length; i++) {
			result.push(Trex.MarkupTemplate.get("menu.select.item").evaluate(option[i]));	
		}
		return result.join("");
	},
	/**
	 * menu \uc758 list item \uc774 \uc120\ud0dd\ub418\uc5c8\uc744 \ub54c command \ub97c \uc2e4\ud589\ud55c\ub2e4.
	 * @function
	 */
	onSelect: function() {
		var _args = $A(arguments);
		var _ev = _args.shift();
		this._command.apply(this, _args); 
		this.hide();
		$tx.stop(_ev);
	}
});

Trex.MarkupTemplate.add(
	'menu.items', [
		'<table unselectable="on"><tbody>',
		'	#{for:row}<tr>',
		'		#{for:col}<td class="tx-menu-list-item">',
		'<a href="javascript:;"><span class="#{klass}">',
		'#{if:image!=""}<img src="#{image}" data="#{data}"/>#{/if:image}',
		'#{if:image=""}#{data}#{/if:image}',
		'</span></a>',
		'		</td>#{/for:col}',
		'	</tr>#{/for:row}',
		'</tbody></table>'
	].join("")
);

Trex.MarkupTemplate.add(
	'menu.list', [
		'<div class="tx-menu-inner">',
		'	<div class="tx-menu-list">',
		'   	#{items}',
		'    </div>',
		'</div>'
	].join("")
);

/**
 * Trex.Menu.List
 * as horizontalrule, lineheight, quote, textbox
 * 
 * @extends Trex.Menu
 * @class
 * @param {Object} config
 */
Trex.Menu.List = Trex.Class.create(/** @lends Trex.Menu.List.prototype */{
	/** @ignore */
	$extend: Trex.Menu,
	/**
	 * menu\ub97c \uc0dd\uc131\ud55c\ub2e4.
	 * @function
	 */
	generate: function() {
		var _config = this.config;
		/*
			[{
				data: "string",
				klass: "string"
			}]
		*/
		var _optionz = this.getValidOptions(_config);
		this.cols = _config.cols || 1;
		this.rows = _config.rows || _optionz.length;

		var _elList = this.generateList(_optionz);
		$tom.insertFirst(this.elMenu, _elList);

		if (this.ongeneratedList) {
			this.generateList = this.ongeneratedList.bind(this);
		}
		if (this.ongeneratedListItem) {
			this.generateListItem = this.ongeneratedListItem.bind(this);
		}
		
		if (this.generateHandler) {
			this.generateHandler(_config);
		}
	},
	/**
	 * menu \uc758 list markup \uc744 \ub9cc\ub4e4\uace0 mouse event handler \ub97c \uc5f0\uacb0\ud55c\ub2e4.
	 * @function
	 */
	generateList: function(options) {
		var _options = Trex.MarkupTemplate.splitList(this.rows, this.cols, options);
		var _elList = Trex.MarkupTemplate.get('menu.list').evaluateAsDom({
			'items': Trex.MarkupTemplate.get('menu.items').evaluate(_options)
		});
		
		$tx.observe(_elList, "click", this.onSelect.bindAsEventListener(this));
		$tx.observe(_elList, 'mouseover', this.onItemMouseOver.bindAsEventListener(this));
		$tx.observe(_elList, 'mouseout', this.onItemMouseOut.bindAsEventListener(this));
		
		return _elList;
	},
	/**
	 * menu \ud56d\ubaa9\uc5d0 mouse over \ud560 \ub54c hover state \uc758 style class \ub97c \uc801\uc6a9\ud55c\ub2e4.
	 * @function
	 */
	onItemMouseOver: function(ev) {
		var _el = $tx.findElement(ev, 'span');
		if (_el.tagName && _el.tagName.toLowerCase() == 'span') {
			$tx.addClassName(_el, "tx-item-hovered");
		}
		$tx.stop(ev);
	},
	/**
	 * menu \ud56d\ubaa9\uc5d0 mouse out \ud560 \ub54c hover state \uc758 style class \ub97c \ud574\uc81c\ud55c\ub2e4.
	 * @function
	 */
	onItemMouseOut: function(ev) {
		var _el = $tx.findElement(ev, 'span');
		if (_el.tagName && _el.tagName.toLowerCase() == 'span') {
			$tx.removeClassName(_el, "tx-item-hovered");
		}
		$tx.stop(ev);
	},
	/**
	 * menu \uc758 \ud56d\ubaa9\uc774 \uc120\ud0dd\ub418\uc5c8\uc744 \ub54c command \ub97c \uc2e4\ud589\ud55c\ub2e4. 
	 * @function
	 */
	onSelect: function(ev) {
		var _el = $tx.findElement(ev, 'span');
		if (_el.tagName && _el.tagName.toLowerCase() == 'span') {
			var _data;
			if(_el.firstChild && _el.firstChild.nodeType == 1 && _el.firstChild.tagName.toLowerCase() == 'img') {
				_data = $tom.getAttribute(_el.firstChild, "data") || "";
			} else {
				_data = _el.innerText;	
			}
			this._command(_data);
			this.hide();
		}
		$tx.stop(ev);
	}
});

Trex.MarkupTemplate.add(
	'menu.matrix', [
		'<div class="tx-menu-inner">',
		'	<ul class="tx-menu-matrix-title">',
		'		#{for:matrices}<li class=""><a href="javascript:;" class="tx-menu-matrix-title-item">#{title}</a></li>#{/for:matrices}',
		'	</ul>',
		'	<div class="tx-menu-matrix-listset">',
		'   	#{for:matrices}<div class="tx-menu-matrix-list #{klass}">',
		'       	#{items}',
		'		</div>#{/for:matrices}',
		'    </div>',
		'</div>'
	].join("")
);

/**
 * Trex.Menu.Matrix
 * as emoticon
 * 
 * @extends Trex.Menu
 * @class
 * @param {Object} config
 */
Trex.Menu.Matrix = Trex.Class.create(/** @lends Trex.Menu.Matrix.prototype */{
	/** @ignore */
	$extend: Trex.Menu,
	/**
	 * menu\ub97c \uc0dd\uc131\ud55c\ub2e4.
	 * @function
	 */
	generate: function() {
		var _config = this.config;
		/*
			rows: number,
			cols: number,
			matrices: [{
				title: "string",
				options: ["string", ...]
			}]

		*/
		var _matrices = this.matrices = _config.matrices.findAll(function(matrix) {
			return !matrix.onlyIE || $tx.msie;
		});
		this.cols = _config.cols || 10;
		this.rows = _config.rows || 5;

		var _elList = this.generateMatrix(_matrices);
		$tom.insertFirst(this.elMenu, _elList);

		if (this.ongeneratedList) {
			this.generateList = this.ongeneratedList.bind(this);
		}
		if (this.ongeneratedListItem) {
			this.generateListItem = this.ongeneratedListItem.bind(this);
		}
			
		if (this.generateHandler) {
			this.generateHandler(_config);
		}

		this.showTab();
	},
	/**
	 * menu\ub97c \uc7ac\uc0dd\uc131\ud55c\ub2e4.
	 * @function
	 */
	regenerate: function() {
		this.showTab();
		if (this.regenerateHandler) {
			var _config = this.config;
			this.regenerateHandler(_config);
		}
	},
	/**
	 * menu\ub97c \uc5f4 \ub54c \ub514\ud3f4\ud2b8 Tab \ud639\uc740 \ucd5c\uadfc\uc5d0 \uc5f4\uc5c8\ub358 Tab \uc744 \ubcf4\uc5ec\uc900\ub2e4. 
	 * @function
	 */
	showTab: function() {
		var listItemToShow = this.lastElList;
		var titleItemToShow = this.lastElTitleItem;
		
		var isFirstTime = (!listItemToShow || !titleItemToShow);
		if (isFirstTime) {
			listItemToShow = this.defaultElListItem;
			titleItemToShow = this.defaultElTitleItem;
		}
		
		this.onTitleClick(_NULL, titleItemToShow, listItemToShow);
	},

	/**
	 * \uaca9\uc790\ubb34\ub2ac \ud615\ud0dc\uc758 menu \ud56d\ubaa9\uc744 \uc0dd\uc131\ud558\uace0 mouse event handler \ub97c \uc5f0\uacb0\ud55c\ub2e4.
	 * @function
	 */
	generateMatrix: function(matrices) {
		var _menu = this;

		var _cols = this.cols;
		var _rows = this.rows;
		matrices.each(function(matrix) {
			var _options = Trex.MarkupTemplate.splitList(_rows, _cols, matrix.options);
			matrix['items'] = Trex.MarkupTemplate.get('menu.items').evaluate(_options);
		});
		
		var _elInner = Trex.MarkupTemplate.get('menu.matrix').evaluateAsDom({
			'matrices': matrices
		});

		var _elLists = $tom.collectAll(_elInner, 'div.tx-menu-matrix-listset div.tx-menu-matrix-list');
		var _elTitles = $tom.collectAll(_elInner, 'ul.tx-menu-matrix-title li');
		
		var defaultIndex = function() {
			for (var i = 0, length = matrices.length; i < length; i++) {
				if (matrices[i].defaultshow) {
					return i;
				}
			}
			return 0;
		}();
		this.defaultElListItem = _elLists[defaultIndex];
		this.defaultElTitleItem = _elTitles[defaultIndex];
		
        for (var i = 0; i < matrices.length; i++) {
            var _elList = _elLists[i];
            $tx.observe(_elList, "click", _menu.onSelect.bindAsEventListener(_menu));
            $tx.observe(_elList, 'mouseover', _menu.onItemMouseOver.bindAsEventListener(_menu));
            $tx.observe(_elList, 'mouseout', _menu.onItemMouseOut.bindAsEventListener(_menu));

            var _elTitle = _elTitles[i];
            $tx.observe(_elTitle, "click", _menu.onTitleClick.bindAsEventListener(_menu, _elTitle, _elList));
        }
		return _elInner;
	},
	/**
	 * menu \uc758 group title tab \uc5d0 \ub300\ud55c event handler\ub97c \uc5f0\uacb0\ud55c\ub2e4.
	 * @function
	 */
	onTitleClick: function(ev, elTitleItem, elList) {
		if (this.lastElList != elList) {
			$tx.show(elList);
			if (this.lastElList) {
				$tx.hide(this.lastElList);
			}
			this.lastElList = elList;

			if (this.lastElTitleItem) {
				$tx.removeClassName(this.lastElTitleItem, 'tx-selected');
			}
			$tx.addClassName(elTitleItem, 'tx-selected');
			this.lastElTitleItem = elTitleItem;
		}
		if (ev) {
			$tx.stop(ev);
		}
	},
	/**
	 * menu \ud56d\ubaa9\uc5d0 mouse over \ud558\uba74 hovered state css class \ub97c \uc801\uc6a9\ud55c\ub2e4.
	 * @function
	 */
	onItemMouseOver: function(ev) {
		var _el = $tx.findElement(ev, 'span');
		if (_el.tagName && _el.tagName.toLowerCase() == 'span') {
			$tx.addClassName(_el,"tx-item-hovered");
		}
		$tx.stop(ev);
	},
	/**
	 * menu \ud56d\ubaa9\uc5d0 mouse out \ud558\uba74 hovered state css class \ub97c \ud574\uc81c\ud55c\ub2e4.
	 * @function
	 */
	onItemMouseOut: function(ev) {
		var _el = $tx.findElement(ev, 'span');
		if (_el.tagName && _el.tagName.toLowerCase() == 'span') {
			$tx.removeClassName(_el, "tx-item-hovered");
		}
		$tx.stop(ev);
	},
	/**
	 * menu \uc758 list item \uc774 \uc120\ud0dd\ub418\uc5c8\uc744 \ub54c command \ub97c \uc2e4\ud589\ud55c\ub2e4.
	 * @function
	 */
	onSelect: function(ev) {
		var _el = $tx.findElement(ev, 'span');
		if (_el.tagName && _el.tagName.toLowerCase() == 'span') {
			this._command(_el.innerText);
			this.hide();
		}
		$tx.stop(ev);
	}
});

Trex.MarkupTemplate.add(
	'menu.colorPallete', [
		'<div class="tx-menu-inner">',
		'<ul class="tx-pallete-text-list"></ul>',
		'<ul class="tx-pallete-thumb-list"></ul>',
		'<p class="tx-pallete-input"><span style="background-color: rgb(7, 3, 3);"></span><input type="text" class="tx-color-value"/><a class="tx-enter">@menu.pallete.enter</a></p>',
		'<div class="tx-pallete-buttons">',
		'	<p class="tx-pallete-more"><a class="tx-more-down" href="javascript:;">@menu.pallete.more</a></p>',
		'</div>',
		'<div class="tx-pallete-picker">',
		'	<div class="tx-pallete-pickerbox">',
		'		<div class="tx-chromabar" style="background-color: rgb(255, 0, 0);"></div><div class="tx-huebar"></div>',
		'	</div>',
		'</div>',
		'</div>'
	].join("")
);

/**
 * Trex.Menu.ColorPallete
 * 
 * @extends Trex.Menu
 * @class
 * @param {Object} config
 */
Trex.Menu.ColorPallete = Trex.Class.create(/** @lends Trex.Menu.ColorPallete.prototype */{
	/** @ignore */
	$extend: Trex.Menu,
	/** @ignore */
	$mixins: [
		Trex.I.ColorPallete
	],
	/**
	 * menu\ub97c \uc0dd\uc131\ud55c\ub2e4.
	 * @function
	 */
	generate: function() {
		var _config = this.config;
		
		var _elMenu = this.elMenu;
		Trex.MarkupTemplate.get("menu.colorPallete").evaluateToDom({}, _elMenu);
		
		var _transCfg = _config.thumbs.transparent;
		_config.thumbs.transparent = Object.extend(_config.thumbs.transparent, {
			image: TrexConfig.getIconPath(_transCfg.image),
			thumb: TrexConfig.getIconPath(_transCfg.thumb),
			thumbImage:  TrexConfig.getIconPath(_transCfg.thumbImage)
		});
		
		if(!this.hookEvent) {
			throw new Error("[Exception]Trex.Menu.ColorPallete : not implement function(hookEvent)");
		}
		this.hookEvent(_config);

		if (this.generateHandler) {
			this.generateHandler(_config);
		}

		this.bindEvents();
	},
	/**
	 * menu \uc758 list item(color) \uc774 \uc120\ud0dd\ub418\uc5c8\uc744 \ub54c command \ub97c \uc2e4\ud589\ud55c\ub2e4.
	 * @function
	 */
	onSelect: function() {
		var _args = $A(arguments);
		var _ev = _args.shift();
		this._command.apply(this, _args);
		this.remainColor(_args);
		this.hide();
		$tx.stop(_ev);
	},
	/**
	 * menu \uc758 list item(color) \uc774 \uc120\ud0dd\ub418\uc5c8\uc744 \ub54c \uc120\ud0dd \ud55c color value \ub97c input box\uc5d0 \ub0a8\uae34\ub2e4.
	 * this.onSelect function \uc5d0\uc11c \ud638\ucd9c\ud55c\ub2e4.
	 * @function
	 */
	remainColor: function(color) {
		if(color) {
			this.setColorValueAtInputbox(color);	
		}
	},
    bindEvents: function() {
        var self = this;
        $tx.observe(this.elMore, 'click', function(ev){
            self.fireJobs(Trex.Ev.__MENU_LAYER_CHANGE_SIZE, {
                detail: {
                    menu: self
                }
            });
        });
    }
});

$tx.msie && Trex.module("add menu layer shield for IE flash object", function(editor, toolbar, sidebar, canvas/*, config*/) {

    /**
     * IE\uc5d0\uc11c object\uc758 wmode=window\uc5d0 \ub300\uc751\ud558\uc5ec iframe\uc744 \uba54\ub274 \ub808\uc774\uc5b4 \ud558\ub2e8\uc5d0 \uc0bd\uc785\ud55c\ub2e4.
     */
    Trex.MarkupTemplate.add(
        'menu.shield', [
            '<div class="tx-menu-back" style="overflow:hidden;position:absolute;border:0;">',
            '<iframe src="about:blank" width="100%" height="100%" frameborder="0"></iframe>',
            '</div>'
        ].join("")
    );

    /**
     * \uac01 \uba54\ub274 \ub808\uc774\uc5b4\uc5d0 \ucd94\uac00\ub418\ub294 \uc694\uc18c
     */
    var MenuShieldEntry = Trex.Class.create({
        initialize: function (id, menuEl) {
            this.id = id;
            this.menuEl = menuEl;
            this.shieldEl = Trex.MarkupTemplate.get('menu.shield').evaluateAsDom({});
        },
        show: function() {
            this.update();
            $tom.insertAt(this.shieldEl, this.menuEl);
            $tx.show(this.shieldEl);
        },
        hide: function() {
            $tx.hide(this.shieldEl);
            $tom.remove(this.shieldEl);
        },
        update: function() {
            var style = {
                "width": this.menuEl.offsetWidth.toPx(),
                "height": this.menuEl.offsetHeight.toPx(),
                "left": $tx.getStyle(this.menuEl, 'left'),
                "top": $tx.getStyle(this.menuEl, 'top')
            };
            $tx.setStyle(this.shieldEl, style);
        },
        destroy: function() {
            this.id = _NULL;
            this.menuEl = _NULL;
            this.shieldEl = _NULL;
        }
    });

    /**
     * \ub808\uc774\uc5b4 \ucd94\uac00/\uc0ad\uc81c/\uac31\uc2e0\uc744 \uc704\ud55c \ucee8\ud2b8\ub864\ub7ec
     */
    var MenuShield = Trex.Class.create({
        initialize: function() {
            this.entry = {};
        },
        show: function(id, menu) {
            var trg = this.entry[id];
            if (!trg) {
                
                var entry = new MenuShieldEntry(id, menu);
                this.entry[id] = trg = entry;
            }
            trg.show();
        },
        hide: function(id) {
            var trg = this.entry[id];
            if (trg) {
                
                trg.hide();
                trg.destroy();
                delete this.entry[id];
            }
        },
        updateAll: function() {
            var cache = this.entry;
            setTimeout(function(){
                for(var p in cache) {
                    if(cache.hasOwnProperty(p)) {
                        cache[p].update();
                    }
                }
            }, 1);
        }
    });

    var shield = new MenuShield();

    function getMenuId(menu) {
        var id;
        try {
            if (menu.config.id) {
                id = menu.config.id + menu.config.initializedId;
            } else {
                id = menu.config.el.className;
            }
        } catch(e) {
            id = 'unknown';
        }
        return id;
    }

    toolbar.observeJob(Trex.Ev.__MENU_LAYER_SHOW, function(ev){
        var menu = ev.detail.menu;
        shield.show(getMenuId(menu), menu.elMenu);
    });

    toolbar.observeJob(Trex.Ev.__MENU_LAYER_HIDE, function(ev){
        var menu = ev.detail.menu;
        shield.hide(getMenuId(menu));
    });

    toolbar.observeJob(Trex.Ev.__MENU_LAYER_CHANGE_SIZE, function(ev){
        shield.updateAll();
    });
});
/**
 * @fileoverview
 * DaumEitor\uc758 Entrypoint\uc5ed\ud560\uc744 \ud558\ub294 source\ub85c Trex.Editor, Editor \ub97c \ud3ec\ud568
 */

/**
 * \uc2e4\uc81c Editor Implementation, \ud558\uc9c0\ub9cc Editor \uc0dd\uc131 \uc2dc\uc5d0\ub294 Class Editor\ub97c \uc0ac\uc6a9\ud55c\ub2e4
 *
 * {@link Editor}
 * @class
 * @param {Object} config
 */
Trex.Editor = Trex.Class.create( /** @lends Trex.Editor.prototype */{
	/** @ignore */
	$mixins: [Trex.I.JobObservable, Trex.I.KeyObservable],
	toolbar: _NULL,
	sidebar: _NULL,
	canvas: _NULL,
	config: _NULL,
    initialConfig: _NULL,
	initialize: function(config) {
        this.initialConfig = config;
		var _editor = this, _config = this.config = TrexConfig.setup(config);
		var _canvas = this.canvas = new Trex.Canvas(_editor, _config);
		var _toolbar = this.toolbar = new Trex.Toolbar(_editor, _config);
		var _sidebar = this.sidebar = new Trex.Sidebar(_editor, _config);
		Trex.invokeInstallation(_editor, _toolbar, _sidebar, _canvas, _config);
		
		/* common key event */
		var _evConfig = _config.events;
		var _keyDownHandler = function(ev) {
			if (_evConfig.useHotKey) {
				_editor.fireKeys(ev);
			}
		};
		$tx.observe(_DOC, "keydown", _keyDownHandler.bindAsEventListener(this), _FALSE);

		_canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function() {
			//for hanmail iframe load log.
			var iframeLoadCompleteTime = new Date().getTime();
			var secTime = Math.round((iframeLoadCompleteTime - Editor.initStartTime) / 100) / 10;
			_editor.fireJobs(Trex.Ev.__IFRAME_LOADING_TIME, secTime);//TODO unresolved
			
			var _initializedId = _editor.getInitializedId();
			var _elLoading = $tx("tx_loading" + _initializedId);
			if (!_elLoading) {
				return;
			}
			if (_canvas.mode != Trex.Canvas.__WYSIWYG_MODE) {
				_canvas.fireJobs(Trex.Ev.__CANVAS_MODE_INITIALIZE, Trex.Canvas.__WYSIWYG_MODE, _canvas.mode);
			}
			$tx.hide(_elLoading);
		});
		Trex.invokeRegisters(_editor, _toolbar, _sidebar, _canvas, _config);
		Trex.invokeModules(_editor, _toolbar, _sidebar, _canvas, _config);
	},
	/**
	 * Get toolbar instance
	 * @see Trex.Toolbar
	 */
	getToolbar: function() {
		return this.toolbar;
	},
	/**
	 * Get sidebar instance
	 * @see Trex.Sidebar
	 */
	getSidebar: function() {
		return this.sidebar;
	},
	/**
	 * Get canvas instance
	 * @see Trex.Canvas
	 */
	getCanvas: function() {
		return this.canvas;
	},
	getUsedWebfont: function() {
		return this.canvas.getUsedWebfont();
	},
	/**
	 * Get config instance
	 */
	getConfig: function() {
		return this.config;
	},
    getInitialConfig: function () {
        return this.initialConfig;
    },
	getParam: function(name) {
		var _params = {}, _config = this.config;
		_config.params.each(function(name) {
			if (_config[name]) {
				_params[name] = _config[name];
			}
		});
		return _params[name];
	},
	getWrapper: function() {
        if (!this.initialConfig.wrapper) {
            throw new Error('`wrapper` config variable should be provided');
        }
		return $must(this.initialConfig.wrapper);
	},
	getInitializedId: function() {
		return this.initialConfig.initializedId || "";
	},
	saveEditor: function() {
		this.setDisableUnloadHandler();
		this.getSaver().submit();
	},
	loadEditor: function(data) {
		this.getSaver().load(data);
	},
	/**
	 * Editor\uc5d0\uc11c \uc791\uc131\ub41c \uc800\uc7a5\ud558\uae30 \uc704\ud574 parsing\ub41c \uae00\uc758 \ub0b4\uc6a9\uc744  \uac00\uc838\uc628\ub2e4.
	 * @see Trex.Canvas#getContent
	 */
	getContent: function() {
		return this.getSaver().getContent();
	},
	/**
	 * Editor\uc5d0 \ucca8\ubd80\ub41c \ucca8\ubd80\ub370\uc774\ud130 \ub9ac\uc2a4\ud2b8\ub97c \uac00\uc838\uc628\ub2e4.
	 * * @see Trex.Sidebar#getAttachments
	 */
	getAttachments: function(type, all) {
		return this.getSaver().getAttachments(type, all);
	},
	/**
	 * Editor\uc5d0 \uc0bd\uc785\ub41c Embed\ub370\uc774\ud130 \ub9ac\uc2a4\ud2b8\ub97c \uac00\uc838\uc628\ub2e4.
	 * * @see Trex.Sidebar#getEmbeddedData
	 */
	getEmbeddedData: function(type) {
		return this.getSaver().getEmbeddedData(type);
	},
	/**
	 * Editor\uc5d0 \ucca8\ubd80\ub41c \uc815\ubcf4\ucca8\ubd80 \ub9ac\uc2a4\ud2b8\ub97c \uac00\uc838\uc628\ub2e4.
	 * * @see Trex.Sidebar#getResults
	 */
	getResults: function(type) {
		return this.getSaver().getResults(type);
	},
	/**
	 * autosaver\uc758 \ud604\uc7ac \uc0ac\uc6a9\uc911\uc778 key\ub97c \uac00\uc838\uc628\ub2e4.
	 * * @see Trex.Autosaver#getCurSeq
	 */
	getAutosaveSeq: function(){
		return (this.getAutoSaver && this.getAutoSaver()) ? this.getAutoSaver().getCurSeq() : "0";
	}
});
// Binds helper functions for Editor
(function() {
	/**
	 * Editor
	 *
	 * @example
	 *  new Editor({
	 *  	txService: 'sampleService',
	 *  	txHost: 'sample.daum.net',
	 *  	txPath: 'sampleService',
	 *  	initializedId: 'stringValue',
	 *  	form: 'tx_editor_form'+"$!initializedId"
	 *  });
	 *
	 * @extends Trex.Editor
	 * @class
	 * @param {Object} config
	 */
	_WIN.Editor = Trex.Class.create({
		/** @ignore */
		$const: {
			__ACTIVE: _FALSE,
			__PANEL_LOADED: _FALSE,
			__EDITOR_LOADED: _FALSE,
			__MULTI_LIST: [],
			__SELECTED_INDEX: 0
		},
        _initEditor: function (_editor, config) {
            Editor.__EDITOR_LOADED = _FALSE;
            Editor.__PANEL_LOADED = _FALSE;
            _editor = new Trex.Editor(config);
            var _initializedId = _editor.getInitializedId();
            if (_initializedId != _NULL) {
                var idx = _initializedId == "" ? 0 : _initializedId;
                Editor.__MULTI_LIST[idx] = _editor;
                Editor.__SELECTED_INDEX = idx;
            }
            Object.extend(Editor, _editor);
            Editor.__EDITOR_LOADED = _TRUE;
            Editor.__ACTIVE = _TRUE;
        },
        initialize: function(config) {
			//for hanmail iframe load log.
			if (Trex.hmailLogging) {
				Trex.hmailLogging(config);
			}
			Editor.initStartTime = new Date().getTime();
			
			var _editor = null;

            if (_WIN['DEBUG']) {
                this._initEditor(_editor, config);
            } else {
                try {
                    this._initEditor(_editor, config);
                } catch (e) {
                    if (_editor) {
                        _editor.fireJobs(Trex.Ev.__RUNTIME_EXCEPTION, e);
                    } else {
                        throw 'failed to initialize editor. caused by ' + e;
                    }
                    throw e;
                }
            }
		}
	});
	/**
	 * \uae00\uc744 \uc218\uc815\ud560 \ub54c \uc800\uc7a5\ub41c \uae00\uc744 \ubd88\ub7ec\uc628\ub2e4.
	 * @param {Object} data - \uc5d0\ub514\ud2b8\uc5d0 \ub85c\ub4dc\ud560 \ub0b4\uc6a9/\ucca8\ubd80\ud30c\uc77c \uac12
	 * @example
	 *  Editor.modify({
	 *  	content:'&lt;p&gt;content example&lt;/p&gt;' or $tx('tx_content')
	 *  	attachments: [
	 *  		{attacher: 'image', 
	 *				data: {
	 *					thumburl: "http://cfile163.uf.daum.net/P150x100/0126A20248BFAFF72D2229",
	 *					imageurl: "http://cfile163.uf.daum.net/image/0126A20248BFAFF72D2229",
	 *					originalurl: "http://cfile163.uf.daum.net/original/0126A20248BFAFF72D2229",
	 *					exifurl: "http://cfile163.uf.daum.net/info/0126A20248BFAFF72D2229",
	 *					attachurl: "http://cfile163.uf.daum.net/attach/0126A20248BFAFF72D2229",
	 *					filename: "Tree.jpg",
	 *					filesize: "155833"
	 *				}
	 *			}]
	 *  });
	 */
	Editor.modify = function(data) {
		if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
			if (this.loadEditor) {
				this.loadEditor(data);
			}
		} else {
			setTimeout(this.modify.bind(this, data), 10);
		}
	};
	/**
	 * Editor \uc0dd\uc131 \ud6c4 \uc790\ub3d9\uc800\uc7a5\ub41c Content\ub97c \ubd88\ub7ec\uc62c \uacbd\uc6b0 \uc0ac\uc6a9\ud55c\ub2e4.
	 * @param {Object} data
	 * @example
	 *  Editor.restore(
	 *  	{content: 'string', 
	 *  	attachments: [{Object}]});
	 */
	Editor.restore = function(data) {
		if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
			if(this.getAutoSaver && this.getAutoSaver()) {
				this.getAutoSaver().load(data);
			}
		} else {
			setTimeout(this.restore.bind(this, data), 10);
		}
	};
	/**
	 * \uae00 \uc800\uc7a5\uc2dc \uc0ac\uc6a9\ud55c\ub2e4.
	 * @example
	 *  &lt;a onclick="Editor.save();return _FALSE;" href="#"&gt;save&lt;/a&gt;
	 */
	Editor.save = function() {
		if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
			if (this.saveEditor) {
				this.saveEditor();
			}
		} else {
			setTimeout(this.saveEditor.bind(this), 10);
		}
		return _FALSE;
	};
	/**
	 * Canvas\uc758 \ucd5c\uadfc focus\uac00 \uc788\ub358 \uc601\uc5ed\uc5d0  focus\ub97c \uc900\ub2e4.
	 * \uc608\ub97c\ub4e4\uc5b4, \uc774\ubbf8\uc9c0\ub97c \ucca8\ubd80\ud558\ub294 \ud31d\uc5c5\ucc3d\uc5d0\uc11c \uc791\uc5c5\uc744 \uc644\ub8cc \ud6c4 \ud31d\uc5c5\ucc3d\uc744 \ub2eb\uace0 \uc5d0\ub514\ud130\uc5d0 \ucd5c\uadfc\uc758 focus\ub97c \uc900\ub2e4.
	 */
	Editor.focus = function() {
		if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
			var _canvas = this.getCanvas();
			if (_canvas) {
				_canvas.focus();
			}
		} else {
			setTimeout(this.focus.bind(this), 10);
		}
		return _FALSE;
	}; 
	/**
	 * Canvas\uc758 \ub9e8 \uc704\uc5d0 focus\ub97c \uc900\ub2e4.
	 * @see Canvas#focusOnTop
	 */
	Editor.focusOnTop = function() {
		if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
			var _canvas = this.getCanvas();
			if (_canvas) {
				_canvas.focusOnTop();
			}
		} else {
			setTimeout(this.focusOnTop.bind(this), 10);
		}
		return _FALSE;
	};
	/**
	 * Canvas\uc758 \ub9e8 \uc544\ub798\uc5d0 focus\ub97c \uc900\ub2e4.
	 * @see Canvas#focusOnBottom
	 */
	Editor.focusOnBottom = function() {
		if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
			var _canvas = this.getCanvas();
			if (_canvas) {
				_canvas.focusOnBottom();
			}
		} else {
			setTimeout(this.focusOnBottom.bind(this), 10);
		}
		return _FALSE;
	};
	/**
	 * Editor\uac00 \uc788\ub294 page\ub97c \ub098\uac08 \uacbd\uc6b0 beforeunload eventlistener\ub97c \uc2e4\ud589 \uc2dc\ud0a4\uc9c0 \ub3c4\ub85d \uc124\uc815\ud55c\ub2e4.
	 * \uc608\ub97c\ub4e4\uba74, Editor\uc5d0\uc11c \uae00\uc744 \uc791\uc131 \uc911\uc5d0 \uc0c8\ub85c\uace0\uce68\ud588\uc744 \uacbd\uc6b0 \uacbd\uace0\ucc3d\uc744 \uc548\ub728\uac8c \ud55c\ub2e4.
	 */
	Editor.permitUnload = function() {
		if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
			this.setDisableUnloadHandler();
		} else {
			setTimeout(this.permitUnload.bind(this), 500);
		}
	};
	/**
	 * Editor\uc640 Iframe\uc774 \uc815\uc0c1\uc801\uc73c\ub85c \uc0dd\uc131 \ub41c\ud6c4 argument\ub85c \uc9c0\uc815\ub41c function\uc744 \uc2e4\ud589 \uc2dc\ud0a8\ub2e4.
	 * @param {Function} fn
	 * @example
	 * 	Editor.onPanelLoadComplete(function(){
	 * 		Editor.focus();
	 * 	});
	 */
	Editor.onPanelLoadComplete = function(fn) {
		if (Editor.__PANEL_LOADED == _TRUE && Editor.__EDITOR_LOADED == _TRUE) {
			if (fn) {
				fn();
			}
		} else {
			setTimeout(Editor.onPanelLoadComplete.bind(Editor, fn), 500);
		}
	};
	/**
	 * \ub3d9\uc77c\ud55c Page\uc5d0 Editor\uac00 \uc5ec\ub7ec\uac1c \uc0dd\uc131\ub42c\uc744 \uacbd\uc6b0, \ub2e4\ub978 Editor\ub97c \uc9c0\uc815\ud55c\ub2e4.
	 * @param {Object} toIndex
	 */
	Editor.switchEditor = function (toIndex) {
		Editor.__SELECTED_INDEX = toIndex;
		Object.extend(Editor, Editor.__MULTI_LIST[toIndex]);
	};
	/* \uc5d0\ub514\ud130\uac00 \uc5ec\ub7ec\uac1c \uc788\uc744 \ub54c async\ub85c \ubd88\ub7ec\uc624\ub294 \ubaa8\ub4c8\uc5d0\uc11c \ud638\ucd9c\ud558\ub294 \uc5d0\ub514\ud130\ub97c \ucc3e\uae30 \uc704\ud568. */
	Editor.editorForAsyncLoad = Editor;
	/* \uc5d0\ub514\ud130\uac00 \uc5ec\ub7ec\uac1c \uc788\uc744 \ub54c \ubaa8\ub4e0 \uc5d0\ub514\ud130\uc5d0 \uc801\uc6a9\ud558\uae30 \uc704\ud568 */
	Editor.forEachEditor = function (fn) {
		var indexName, list= Editor.__MULTI_LIST;
		for (indexName in list) {
			if (list.hasOwnProperty(indexName)) {
				try {
					fn(list[indexName]);
				}catch(e){
					//\uba54\uc77c\uc778 \uacbd\uc6b0 \uc774\uc804 \uc5d0\ub514\ud130\ub97c \uc5c6\uc560\uc11c \uc624\ub958 \ubc1c\uc0dd.
				}
			}
		}
	};
	/**
	 * focus on form
	 * @param {String} name - focus\ub97c \uc904 form\uc758 name \uc18d\uc131 \uac12
	 * @example
	 * 	Editor.focusOnForm("tx_article_title");
	 */
	Editor.focusOnForm = function(name) {
		if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
			_WIN.focus();
			var _form = Editor.getForm();
			if (_form.getElementByName(name)) {
				_form.getElementByName(name).focus();
			}
		} else {
			setTimeout(Editor.focusOnForm.bind(Editor, name), 500);
		}
		return _FALSE;
	};
	/**
	 * \ud30c\uc77c\ud568\uc5d0\uc11c export\ub41c \ub370\uc774\ud130\ub97c \uc5d0\ub514\ud130\uc5d0 \uc0bd\uc785\ud55c\ub2e4. attachment\ub9cc \uc0bd\uc785\ub41c\ub2e4.
	 * @param {Object} data - \uc5d0\ub514\ud2b8\uc5d0 \ub85c\ub4dc\ud560 \ub0b4\uc6a9/\ucca8\ubd80\ud30c\uc77c \uac12
	 * @example
	 *  Editor.fromHdrive(
					[{attacher: 'image', 
		 *				data: {
		 *					thumburl: "http://cfile163.uf.daum.net/P150x100/0126A20248BFAFF72D2229",
		 *					imageurl: "http://cfile163.uf.daum.net/image/0126A20248BFAFF72D2229",
		 *					originalurl: "http://cfile163.uf.daum.net/original/0126A20248BFAFF72D2229",
		 *					exifurl: "http://cfile163.uf.daum.net/info/0126A20248BFAFF72D2229",
		 *					attachurl: "http://cfile163.uf.daum.net/attach/0126A20248BFAFF72D2229",
		 *					filename: "Tree.jpg",
		 *					filesize: "155833"
		 *				}
		 *			}]
	 */
    Editor.fromHdrive = function(data) {
        var attachments = [];
        for (var i = 0; i < data.length; i++) {
            attachments.push(data[i]);
        }
        var modifyData = {
            content: "",
            attachments: attachments
        };

        if (Editor.__PANEL_LOADED && Editor.__EDITOR_LOADED) {
            if (this.loadEditor) {
                this.loadEditor(modifyData);
                var _entries = Editor.getAttachBox().datalist;
                for (var j = 0; j < _entries.length; j++) {
                    _entries[j].execAppend();
                }
            }
        } else {
            setTimeout(this.fromHdrive.bind(this, data), 10);
        }
    };
	Editor.refreshSize = function () {
		this.canvas.fireJobs(Trex.Ev.__CANVAS_WRAP_WIDTH_CHANGE);
		//TODO.azki height..???
	};
	/**
	 * <b>deprecated</b> - use Editor.switchEditor, \ub3d9\uc77c\ud55c Page\uc5d0 Editor\uac00 \uc5ec\ub7ec\uac1c \uc0dd\uc131\ub42c\uc744 \uacbd\uc6b0, \ub2e4\ub978 Editor\ub97c \uc9c0\uc815\ud55c\ub2e4.
	 * @function
	 * @deprecated since ver 1.2, use Editor.switchEditor
	 */
	Editor.prototype.switchEditor = Editor.switchEditor;
	/**
	 * <b>deprecated</b> - use Editor.focusOnForm, focus on form
	 * @function
	 * @deprecated since ver 1.2, Use Editor.focusOnForm
	 */
	Editor.prototype.focusOnForm = Editor.focusOnForm;
})();

/**
 * @fileoverview
 * - Trex.Toolbar
 */

/**
 * Trex.Toolbar Class
 * @class
 * @param {Object} editor
 * @param {Object} config
 */
Trex.Toolbar = Trex.Class.create(/** @lends Trex.Toolbar.prototype */{
	/** @ignore */
	$mixins: [
		Trex.I.JobObservable
	],
	/**
	 * Toolbar Dom Element
	 */
	el: _NULL,
	/**
	 * Tools List
	 */
	tools: _NULL,
	initialize: function(editor, rootConfig) {
		this.canvas = editor.getCanvas();
		
		var _initializedId =  rootConfig.initializedId || "";
		this.el = $must("tx_toolbar_basic" + _initializedId, "Trex.Toolbar");
	},
	/**
	 * Toolbar\uc758 tool\uc744 \ube44\ud65c\uc131\ud654 \uc2dc\ud0a8\ub2e4. 
	 * @function
	 * @example
	 * 	Editor.getToolbar().disableToolbar();
	 */
	disableToolbar: function(){
		var _tools = this.tools;
		for (var _name in _tools) {
			if (_tools[_name].button) {
				_tools[_name].button.disable();
			}
		}
	},
	/**
	 * \ud604\uc7ac toolbar\uc758 \uc0c1\ud0dc\ub97c serializing\ud55c\ub2e4. 
	 * @function
	 * @returns {object}
	 */
	serializeToolValues : function(){
		var _tools = this.tools;
		var result = {};
		for(var name in _tools){
			var _tool = _tools[name];
			result[name] = _tool.button.lastValue;
		}
		return result;
	},
	widgetSeq:0,
	makeWidget: function(button, menu, handler) {
		var _toolbar = this;
		var _canvas = this.canvas;
		var _dummyToolClass = new (function() {
			this.identity = 'widget' + (++_toolbar.widgetSeq);
			this.wysiwygonly = _TRUE;
			this.menuFoldAuto = _TRUE;
			this.canvas = _canvas;
			this.toolbar = _toolbar;
		})();
		
		Trex.Tool.prototype.weave.bind(_dummyToolClass)(
			button, 
			menu, 
			handler
		);
		
		this.tools[_dummyToolClass.identity] = _dummyToolClass;
		return _dummyToolClass;
	}
});

Trex.install("editor.getTool",
	function(editor, toolbar) {
		var _tools = toolbar.tools = {};
		
		/**
		 * memberOf Editor.prototype
		 * @param {Object} name
		 */
		editor.getTool = function(name) {
			if(_tools[name] != _NULL) {
				return _tools[name];
			} else if(arguments.length == 0){
				return _tools;
			}else{
				return _NULL;
			}
		};
	}
);

Trex.register("new tools",
	function(editor, toolbar, sidebar, canvas, config) {
		var _tools = toolbar.tools;
		
		var _initializedId = config.initializedId || ""; 
		for(var item in Trex.Tool) {
			var _name = Trex.Tool[item]['__Identity'];
			if(_name){
				var cfg = TrexConfig.getTool(_name, config);
				cfg.initializedId = _initializedId;
				if (Trex.available(cfg, _name + _initializedId)) {
					_tools[_name] = new Trex.Tool[item](editor, toolbar, cfg);
				}
			}
		}
		if(!!canvas.config.readonly) {
			toolbar.disableToolbar();
		}
	}
);

Trex.module("bind events with tools",
	function(editor, toolbar, sidebar, canvas) {
		var _tools = toolbar.tools;
		
		var disableToolOnMobile = function () {
			var isMobile, name, tool, btn;
			isMobile = $tx.ios || $tx.android;
			if (!isMobile) {
				return;
			}
			for (name in _tools) {
				tool = _tools[name];
				if (tool.disabledonmobile) {
					btn = tool.button;
					btn.disable();
				}
			}
		};
		disableToolOnMobile();
		
		var _changeMode = function(from, to){
			if (from == to) {
				return;
			}
			for (var _name in _tools) {
				var _tool = _tools[_name];
				var _btn = _tool.button;
				if (Trex.Canvas.__WYSIWYG_MODE == to) {
					_btn.enable();
				} else if (Trex.Canvas.__WYSIWYG_MODE == from) {
					if (_tool.wysiwygonly) {
						_btn.disable();
					} else {
						_btn.enable();
					}
				}
			}
			getLayerBoxHide();
			disableToolOnMobile();
		};
		canvas.observeJob(Trex.Ev.__CANVAS_MODE_CHANGE, _changeMode);
		canvas.observeJob(Trex.Ev.__CANVAS_MODE_INITIALIZE, _changeMode);
		
		var _releaseTools = function(identity) {
			for(var _name in _tools) {
				var _tool = _tools[_name];
				if(identity != _tool.identity) {
					if (_tool.button) {
						_tool.button.release();
						_tool.button.decreaseZindex();
					}
					if(_tool.menu && _tool.menuFoldAuto) {
						_tool.menu.release();
					}
				}
			}
		};
		canvas.observeJob(Trex.Ev.__CANVAS_PANEL_CLICK, _releaseTools);
		canvas.observeJob(Trex.Ev.__CANVAS_SOURCE_PANEL_CLICK, _releaseTools);
		canvas.observeJob(Trex.Ev.__CANVAS_TEXT_PANEL_CLICK, _releaseTools);
		
		toolbar.observeJob(Trex.Ev.__TOOL_CLICK, _releaseTools);

		canvas.observeKey({ // Esc
			ctrlKey: _FALSE,
			altKey: _FALSE,
			shiftKey: _FALSE,
			keyCode: 27
		}, _releaseTools);

		editor.observeKey({ // Esc
			ctrlKey: _FALSE,
			altKey: _FALSE,
			shiftKey: _FALSE,
			keyCode: 27
		}, _releaseTools);
		
		$tx.observe(_DOC, 'click', 
			function(e){
				var _el = $tx.element(e);
				var _class = [	'tx-sidebar', 'tx-toolbar-basic' ,'tx-toolbar-advanced', 
					'tx-sidebar-boundary', 'tx-toolbar-boundary', 'tx-toolbar-boundary'];
				if (Trex.Util.getMatchedClassName(_el, _class)) {
					_releaseTools("-");
				}	
			}
		, _FALSE);

        var _shouldCloseMenus = function () {
            editor.fireJobs(Trex.Ev.__SHOULD_CLOSE_MENUS);
        };
        toolbar.observeJob(Trex.Ev.__TOOL_CLICK, _shouldCloseMenus);
	}
);

/**
 * Tool \ud074\ub798\uc2a4\uc758 \ucd94\uc0c1 \ubd80\ubaa8\ud074\ub798\uc2a4\ub85c \uac01\uac01\uc758 tool\ub4e4\uc740 \uc774 \ud074\ub798\uc2a4\ub97c \uc0c1\uc18d\ubc1b\uc544\uc57c \ud558\uace0, 
 * 'oninitialized' \ud568\uc218\ub97c \uad6c\ud604\ud574\uc57c\ud55c\ub2e4.
 * 
 * @abstract
 * @class
 * @param {Object} editor
 * @param {Object} toolbar
 * @param {Object} config
 * 
 * @example
 *	Trex.Tool.Example = Trex.Class.create({
 *		$const: {
 *			__Identity: 'example'
 *		},
 *		$extend: Trex.Tool,
 *		oninitialized: function(config) {
 *			var _tool = this;
 *			
 *			this.weave.bind(this)(
 *				new Trex.Button(this.buttonCfg),
 *				new Trex.Menu(this.menuCfg),
 *				function(data) {
 *					//TODO
 *				}
 *			);
 *		}
 *	});
 */
Trex.Tool = Trex.Class.draft(/** @lends Trex.Tool.prototype */{
	/**
	 * tool identifier. \uc720\uc77c\ud574\uc57c\ud55c\ub2e4.
	 * @private
	 */
	identity: _NULL,
	/**
	 * button \uac1d\uccb4
	 */
	button: _NULL,
	/**
	 * menu \uac1d\uccb4
	 */
	menu: _NULL,
	initialize: function(editor, toolbar, config) {
		if(!this.constructor.__Identity) {
			throw new Error("[Exception]Trex.Tool : not implement const(__Identity)");
		}
		this.identity = this.constructor.__Identity;

		if(!editor) {
			throw new Error("[Exception]Trex.Tool : not exist argument(editor)");
		}
		/** 
		 * editor \uac1d\uccb4 
		 * @private
		 */
		this.editor = editor;
		/** 
		 * toolbar \uac1d\uccb4 
		 * @private
		 */
		this.toolbar = toolbar;
		/** 
		 * canvas \uac1d\uccb4
		 * @private 
		 */
		this.canvas = editor.getCanvas();
		/** 
		 * \ud574\ub2f9 tool \uc124\uc815\uac12 
		 * @private
		 */
		this.config = config;
		this.wysiwygonly = ((config.wysiwygonly != _NULL)? config.wysiwygonly: _TRUE);
		this.menuFoldAuto = ((config.menuFoldAuto != _NULL)? config.menuFoldAuto: _TRUE);
		if (config.disabledonmobile != _NULL) {
			this.disabledonmobile = config.disabledonmobile;
		}
		
		/** 
		 * \ubc84\ud2bc\uc744 \uc0dd\uc131\ud560 \ub54c \ud544\uc694\ud55c \uc124\uc815\uac12
		 * @private 
		 */
		this.buttonCfg = TrexConfig.merge({
			id: "tx_" + this.identity
		}, config);
		
		/** 
		 * \uba54\ub274\ub97c \uc0dd\uc131\ud560 \ub54c \ud544\uc694\ud55c \uc124\uc815\uac12
		 * @private 
		 */
		this.menuCfg = TrexConfig.merge({
			id: "tx_" + this.identity + "_menu"
		}, config);
		
		this.oninitialized.bind(this)(config);
	},
	/**
	 * tool \uac1d\uccb4\ub97c \ucd08\uae30\ud654\ud558\ub294 \ub9c8\uc9c0\ub9c9 \ub2e8\uacc4\uc5d0\uc11c \ud638\ucd9c\ub418\ub294 \ud568\uc218\ub85c,
	 * tool \ud074\ub798\uc2a4\ub97c \uc0c1\uc18d\ubc1b\ub294 tool\uc5d0\uc11c \ubc18\ub4dc\uc2dc \uad6c\ud604\ud574\uc57c \ud55c\ub2e4.
	 * 
	 * @abstract
	 * @private
	 * @function
	 */ 
	oninitialized: function() {
		throw new Error("[Exception]Trex.Tool : not implements function(oninitialized)");
	},
	/**
	 * \ubcf4\ud1b5 tool\uc740 \ubc84\ud2bc\uacfc \uba54\ub274\ub85c \uad6c\uc131\ub418\ub294\ub370, \uc774 \ud568\uc218\uc5d0\uc11c \uadf8 \ub458 \uc0ac\uc774\uc758 \uc5f0\uacb0\uc744 \ud574\uc900\ub2e4.<br/>
	 * menu\uac00 \uc5c6\uc73c\uba74 \ubc84\ud2bc\uc744 \ud074\ub9ad\ud560 \ub54c execHandler\uac00 \uc2e4\ud589\ub418\uace0,
	 * menu\uac00 \uc788\uc73c\uba74 \ubc84\ud2bc\uc744 \ud074\ub9ad\ud560 \ub54c menu\uac00 \ubcf4\uc774\uba70, 
	 * menu\uc5d0\uc11c \ud2b9\uc815 \uac12\uc744 \uc120\ud0dd\ud558\uba74 \uadf8 \uac12\uc744 \uac00\uc9c0\uace0 execHandler\uac00 \uc2e4\ud589\ub41c\ub2e4.
	 * 
	 * @function
	 * @private
	 * @param {Object} button - \ubc84\ud2bc \uac1d\uccb4
	 * @param {Object} menu - \uba54\ub274 \uac1d\uccb4 optional
	 * @param {Function} execHandler
	 * @param {Function} initHandler - optional
	 * 
	 * @example
	 *	this.weave.bind(this)(
	 *		new Trex.Button(this.buttonCfg),
 	 *		new Trex.Menu(this.menuCfg),
	 *		function(data) {
	 *			//TODO
	 *		});
	 *	}
	 */
	weave: function(button, menu, execHandler, initHandler) {
		var _tool = this;
		var _identity = this.identity;
		var _toolbar = this.toolbar;
		var _canvas = this.canvas;
		
		this.button = button;
		button.tool = this;
		var cmd = _NULL;
		if(!menu){
			button.setCommand(
				cmd = function(){
					_toolbar.fireJobs(Trex.Ev.__TOOL_CLICK, _identity);
                    return execHandler.apply(_tool, arguments);
				}
			);
		}else{
			this.menu = menu;
			menu.tool = this;
			
			menu.initHandler = initHandler || function(){};
			menu.cancelHandler = function(){ button.setState(_FALSE); };
		
			menu.setCommand(
				cmd = function() { 
					var args = arguments;
					var success = execHandler.apply(_tool, args);
					//handler\uc5d0\uc11c $stop \uc744 \ubc18\ud658\ud558\uba74 \ubc84\ud2bc \uac12\uc744 \uba54\ub274\uc5d0\uc11c \uc120\ud0dd\ud55c \uac12\uc73c\ub85c \uc548\ubc14\uafc8..
					if (success === $stop) {
						button.normalState.apply(button, args);
					} else {
						button.updateAfterCommand.apply(button, args);
					}
					return success;
				}
			);
			button.setCommand(
				function(ev) {
					_toolbar.fireJobs(Trex.Ev.__TOOL_CLICK, _identity, ev);
					if(!button.isPushed()) {
						var _lastvalue = button.getValue();
						button.increaseZindex();
						menu.show(_lastvalue);
					} else {
						menu.hide();
						if ($tx.msie) {
							var _processor = _canvas.getProcessor();
							if (_processor.restoreRange) {
								setTimeout(function () {
									_processor.restoreRange();
								}, 0);
							}
						}
					}
					return _TRUE;
				}
			);

            menu.observeJob(Trex.Ev.__MENU_LAYER_SHOW, function(ev){
                _toolbar.fireJobs(Trex.Ev.__MENU_LAYER_SHOW, ev);
            });
            menu.observeJob(Trex.Ev.__MENU_LAYER_HIDE, function(ev){
                _toolbar.fireJobs(Trex.Ev.__MENU_LAYER_HIDE, ev);
            });
            menu.observeJob(Trex.Ev.__MENU_LAYER_CHANGE_SIZE, function(ev){
                _toolbar.fireJobs(Trex.Ev.__MENU_LAYER_CHANGE_SIZE, ev);
            });
		}
		this.execute = cmd;
	},
	/**
	 * \uc5f0\uacb0\ub41c \ubc84\ud2bc\uacfc \uba54\ub274 \ub808\uc774\uc5b4\uc640\uc758 \uad00\uacc4\ub97c \ubaa8\ub450 \ud574\uc81c\ud55c\ub2e4.
	 * \uc77c\ubc18\uc801\uc740 \uacbd\uc6b0\uc5d0\ub294 \ud544\uc694\ud558\uc9c0 \uc54a\uace0 async\ub97c \uc704\ud55c tool\uc5d0\ub9cc weave \uad6c\ubb38 \uc0c1\uc704\uc5d0 \ucd94\uac00\ud55c\ub2e4.
	 * @function
	 */
	resetWeave: function(){
		if(this.button) {
			this.button.removeHandler();
			this.button.normalState();
			this.button = _NULL;
		}
		if(this.menu)
			this.menu = _NULL;
		if(this.execute)
			this.execute = _NULL;
	},
	/**
	 * \ud65c\uc131\ud654 \uc0c1\ud0dc\ub97c \uac15\uc81c\ud55c\ub2e4. 
	 * async tool \uc5d0\uc11c \ud074\ub9ad\ud6c4 \uc790\ub3d9 \ud65c\uc131\ud654\ub97c \uc704\ud568.
	 * @function
	 */
	forceActivate: function(){
		if( this.button && this.menu ){
			this.button.pushedState();
			this.button.increaseZindex();
			this.menu.show();
		}
	},
    bindKeyboard: function(keys, execHandler) {
        var toolbar = this.toolbar;
        var identity = this.identity;
        this.canvas.observeKey(keys, function(ev) {
            execHandler(ev);
            toolbar.fireJobs(Trex.Ev.__TOOL_SHORTCUT_KEY, identity);
        });
    }
});

Trex.AsyncTool = Trex.Class.draft(/** @lends Trex.Tool.prototype */{
	$extend: Trex.Tool,
	oninitialized: function() {
		this.loaded = false;
		throw new Error("[Exception]Trex.AsyncTool : not implements function(oninitialized)");
	},
	onLoadModule: function() {
		var self = this;
        var url = this.config.asyncUrl;
		if (/^(?:\/\/)|(?:\w+:\/\/)/.test(url) === false) {
			url = this.getJSBasePath() + url;
		}
        if (EditorJSLoader.getOption('environment') == 'development') {
            var d = (new Date()).getTime();
            if (url.indexOf('?') === -1) {
                url += '?dummy=' + d;
            } else {
                url += '&dummy=' + d;
            }
        }
		Editor.editorForAsyncLoad = this.editor;
		EditorJSLoader.asyncLoadModule({
    		url: TrexConfig.getUrl(url),
    		callback: function(){
    			self.loaded = true;
    		}
    	});
	},
    getJSBasePath: function() {
        var basePath;
        try {
            basePath = EditorJSLoader.getJSBasePath("editor.js");
        } catch (e) {
            basePath = EditorJSLoader.getJSBasePath();
        }
        return basePath;
    }
});


Trex.I.Tool = {};
Trex.I.Tool.QueryStyle = {};
Trex.I.Tool.QueryStyle.Standard = Trex.Mixin.create({
    queryNodeStyle: function(currentNode, cssPropertyName, queryCommandName, matchTagName) {
        return $tx.getStyle(currentNode, cssPropertyName).include(queryCommandName);
    }
});

Trex.I.Tool.QueryStyle.Gecko = Trex.Mixin.create({
    queryNodeStyle: function(currentNode, cssPropertyName, queryCommandName, matchTagName) {
        var tempNode = currentNode;
        var isInclude = _FALSE;
        while(tempNode && !$tom.isBody(tempNode) && !isInclude) {
            if ($tom.isTagName(tempNode, matchTagName)) {
                isInclude = _TRUE;
            } else {
                isInclude = $tx.getStyle(currentNode, cssPropertyName).include(queryCommandName);
            }

            // move to parent
            tempNode = tempNode.parentNode;
        }
        return isInclude;
    }
});

/**
 * @fileoverview 
 * Trex.Sidebar, Trex.EntryBox, Trex.Entry, Trex.Actor\ub97c \ud3ec\ud568\ud558\uace0 \uc788\ub2e4.  
 */

/**
 * \uc5d0\ub514\ud130\uc640 \uc678\ubd80 component\uc0ac\uc774\uc758 \uc5f0\ub3d9\uc744 \ud558\ub294 class
 * 
 * @class
 * @param {object} editor
 * @param {object} config
 */
Trex.Sidebar = Trex.Class.create({
	/** @ignore */
	$const: {
		__REG_ENTRY_ATTR_PAIR_Q: new RegExp("([\\w]+)=\"([^\"]+)\"", "g"),
		__REG_ENTRY_ATTR_PAIR_NQ: new RegExp("([\\w]+)=([\\w]+)", "g")
	},
	/** @ignore */
	$mixins: [
		Trex.I.JobObservable
	],
	entryboxRegistry: _NULL,
	initialize: function(editor) {
		var _canvas = editor.getCanvas();

		this.entryboxRegistry = {};
		this.getFields = function() {
			var fields = [];
			for(var i in this.entryboxRegistry){
				var entrybox = this.entryboxRegistry[i];
				fields = fields.concat(entrybox.getFields());
			}
			return fields;
		};

		this.syncSidebar = function() {
			var _content = _canvas.getContent();
			for(var i in this.entryboxRegistry){
				this.entryboxRegistry[i].syncBox(_content);
			}
		};
		this.emptyEntries = function() {
			for(var i in this.entryboxRegistry){
				this.entryboxRegistry[i].empty();
			}
		};

		_canvas.observeJob(Trex.Ev.__CANVAS_PANEL_DELETE_SOMETHING, function() {
			this.syncSidebar();
		}.bind(this));
	}
});


/**
 * Trex.entryBox
 * @class
 */
Trex.EntryBox = Trex.Class.draft({
	/** @ignore */
	$mixins: [
		Trex.I.JobObservable
	],
	autoSeq: 0,
	datalist: [],
	initialize: function() {
		throw new Error("[Exception]Trex.EntryBox : not implements function(initialize)");
	},
	newSeq: function() {
		return (++this.autoSeq);
	},
	syncSeq: function(existedSeq) {
		this.autoSeq = (existedSeq > this.autoSeq)? existedSeq: this.autoSeq;
		return existedSeq;
	},
	empty: function() {
		this.fireJobs(Trex.Ev.__ENTRYBOX_ALL_ENTRY_REMOVED);
		this.datalist = [];
	},
	append: function(entry) {
		this.datalist.push(entry);
		this.fireJobs(Trex.Ev.__ENTRYBOX_ENTRY_ADDED, entry);
	},
	modify: function(entry) {
		this.fireJobs(Trex.Ev.__ENTRYBOX_ENTRY_MODIFIED, entry);
	},
	remove: function(entry) {
		entry.deletedMark = _TRUE;
		this.fireJobs(Trex.Ev.__ENTRYBOX_ENTRY_REMOVED, entry);
	},
	syncBox: function(content) {
		this.datalist.each(function(entry) {
			entry.execSync(content);
		});
	},
	getFields: function() {
		var _fields = [];
		this.datalist.each(function(entry) {
			_fields.push(entry.getField());
		});
		return _fields.findAll(function(field) {
			return (field != _NULL);
		});
	},
	getEntries: function(name) {
		if(!name) { //all file
			return this.datalist;
		} 
		var _entries = [];
		this.datalist.each(
			function(entry){
				if(entry.type == name){
					_entries.push(entry);
				}
			}
		);
		return _entries;
	}
});

/**
 * Trex.Entry
 * @class 
 */
Trex.Entry = Trex.Class.draft({
	/** @ignore */
	$mixins: [
		Trex.I.JobObservable
	],
	existStage: _FALSE,
	deletedMark: _FALSE,
	initialize: function(/*actor, canvas, entryBox, config*/) {
		throw new Error("[Exception]Trex.Entry : not implements function(initialize)");
	},
	setExistStage: function(existStage) {
		this.existStage = existStage;
	},
	execRegister: function() {
		this.register();
		this.entryBox.append(this);
		this.setExistStage(_TRUE);
	},
	execReload: function() {
		if(this.reload) {
			this.reload();
		} 
		this.entryBox.append(this);
		this.exchangeHandlerAtReload();
	},
	execRemove: function() {
		this.remove();
		this.entryBox.remove(this);
	},
	execReplace: function(oldReg) { 
		this.replace(oldReg);
		this.entryBox.modify(this);
		this.setExistStage(_TRUE);
	},
	execAppend: function() {
		this.register();
		this.setExistStage(_TRUE);
	},
	execSync: function(content) {
		this.setExistStage(this.checkExisted(content));
	},
	checkExisted: function(content) {
		if(this.canvas.isWYSIWYG()) {
			return (content.search(this.regHtml) > -1);
		} else {
			return (content.search(this.regText) > -1);
		}
	},
	getChangedContent: function(content, rex, str, param) {
		var _existStage = _FALSE;
		if(content.search(rex) > -1) {
			_existStage = _TRUE;
			if (this.actor.canResized) { 
				content = this.getChangedContentWithAttr(content, rex, str, param);
			} else {
				content = content.replace(rex, str);
			}
		}
		this.setExistStage(_existStage);
		return content;
	},
	getChangedContentFromHtml: function(content) {
		return this.getChangedContent(content, this.regHtml, this.dispText, ["id", "class"]);
	},
	getChangedContentToHtml: function(content) {
		return this.getChangedContent(content, this.regText, this.dispHtml);
	},
	getChangedContentAtSave: function(content) { //Only HTML
		return this.getChangedContent(content,  this.regHtml, this.saveHtml, ["id", "class"]);
	},
	getChangedContentAtLoad: function(content) { //Only HTML
		return this.getChangedContent(content, this.regLoad, this.dispHtml);
	},
	getChangedContentWithAttr: function(content, reg, disp, excepts) {
		excepts = excepts || [];
		var _attrMap = Trex.Util.getAllAttributes(disp);
				
		var _getChangedTag = function(source) {
			var _tag = Trex.Util.getMatchValue(/<([a-z]*)/i, disp, 1);
			var _attr = ["<"+_tag.toLowerCase()];
			var _overMap = Trex.Util.getAllAttributes(source);

			for(var _name in _attrMap) {
				if (["width", "height"].contains(_name)) {
					if(!_overMap[_name]) {
						_attr.push(_name + "=\"" + _attrMap[_name] + "\"");
					}
				} else {
					_attr.push(_name + "=\"" + _attrMap[_name] + "\"");
				}
			}
			
			for(var _name in _overMap) {
				if(!excepts.contains(_name)) {
					if (["width", "height"].contains(_name)) {
						_attr.push(_name + "=\"" + _overMap[_name] + "\"");
					} else if(!_attrMap[_name]) {
						_attr.push(_name + "=\"" + _overMap[_name] + "\"");
					}
				}
			}
			_attr.push("/>");
			return _attr.join(" "); 
		};
		
		var _orgContent = content;
		var _matchs;
		reg.lastIndex = 0;
		while ((_matchs = reg.exec(_orgContent)) != _NULL) {
			var _textOrg = _matchs[0];
			var _dispTrans = _getChangedTag(_textOrg);
			var _regOrg = _textOrg.getRegExp();
			content = content.replace(new RegExp(_regOrg, "gmi"), _dispTrans);
		}
		return content;
	},
	getField: function() {
		if(!this.field) {
			return _NULL;
		}
		return {
			name: this.field.name, 
			value: [this.field.value, this.existStage].join('|')
		};
	},
	exchangeHandlerAtReload: function(){}
});

/**
 * Trex.Actor
 * @class
 */
Trex.Actor = Trex.Class.draft({
	/** @ignore */
	$mixins: [
		Trex.I.JobObservable
	],
	isDisabled: _FALSE,
	initialize: function(/*config, canvas*/) {
		throw new Error("[Exception]Trex.Actor : not implements function(initialize)");
	},
	execAttach: function(data, type) {
		var _entry = this.createEntry(this.getDataForEntry(data), type);
		_entry.execRegister();
		this.canvas.fireJobs('canvas.' + (type || this.constructor.__Identity) + '.added', _entry);
	},
	getDatalist: function(){
		return this.entryBox.getEntries(this.name);
	},
	execReattach: function(data, type) {
		var datalist = this.getDatalist();
		var parsedData = this.getDataForEntry(data);
		if(datalist.length < 1) {
			var _entry = this.createEntry(parsedData, type);
			_entry.execRegister();
		} else {
			var _entry = datalist[0];
			var _oldReg = {
				regHtml: _entry.regHtml,
				regText: _entry.regText
			};
			_entry.setProperties(parsedData);
			_entry.execReplace(_oldReg);
		}
	},
    execReload: function(data, content, type) {
        var _dataForEntry = this.getDataForEntry(data, content);
        if (_dataForEntry) { // FTDUEDTR-1361
            var _entry = this.createEntry(_dataForEntry, type);
            _entry.execReload();
        }
    },
	existEntry: function() {
        var list = this.getDatalist().findAll(function(entry) {
            return entry.deletedMark != _TRUE;
        });
		return list.length !== 0;
	},
	getFirstEntryData: function() {
        var list = this.getDatalist().findAll(function(entry) {
            return entry.deletedMark != _TRUE;
        });
		return ((list.length == 0)? _NULL: list[0].data);
	}
});

Trex.install("editor.getDocParser",
	function(editor, toolbar, sidebar, canvas, config){
		var _docparser = new Trex.Docparser(editor, sidebar, config);
		editor.getDocParser = function() {
			return _docparser;
		};
	}
);

Trex.Docparser =Trex.Class.create( {
		initialize : function(editor, sidebar,  config){
			this.editor = editor;
			this.sidebar = sidebar;
			this.config = config;
		},
		filters: {},
		/**
		 * register contents converting filter 
		 * 
		 * 	original = DB\uc5d0 \uc800\uc7a5\ub418\ub294 \ucee8\ud150\uce20
		 * 	html = wysiwyg \ubaa8\ub4dc\uc5d0\uc11c \ubcf4\uc774\ub294 \ucee8\ud150\uce20
		 * 	source = source \ubaa8\ub4dc\uc5d0\uc11c \ubcf4\uc774\ub294 \ucee8\ud150\uce20
		 * 	text = text \ubaa8\ub4dc\uc5d0\uc11c \ubcf4\uc774\ub294 \ucee8\ud150\uce20
		 * 
		 * @example
		 * editor.getDocParser().registerFilter(
				'filter/converting', {
					'text@load': function(contents){ // orginal -> text
						return contents;
					},
					'source@load': function(contents){ // orginal -> source
						return contents;
					},
					'html@load': function(contents){ // orginal -> html
						return contents;
					},
					'text4save': function(contents){ // text -> orginal 
						return contents;
					},
					'source4save': function(contents){ // source -> orginal 
						return contents;
					},
					'html4save': function(contents){ // html -> orginal 
						return contents;
					},
					'text2source': function(contents){ // text -> source
						return contents;
					},
					'text2html': function(contents){ // text -> html
						return contents;
					},
					'source2text': function(contents){ // source -> text
						return contents;
					},
					'source2html': function(contents){ // source -> html
						return contents;
					},
					'html2text': function(contents){ // html -> text
						return contents;
					},
					'html2source': function(contents){ // html -> source
						return contents;
					}
				}
			);
		 */
		registerFilter: function(name, filter){
			this.filters[name] = filter;
		},
		getFilter: function(name){
			return this.filters[name];
		},
		executeFilters: function (cmd, contents) {
			var filters = this.filters;
			["before " + cmd, cmd, "after " + cmd].each(function (cmd) {
				var name, filter;
				for (name in filters) {
					if (filters.hasOwnProperty(name)) {
						filter = filters[name];
						if (filter[cmd]) {
							contents = filter[cmd](contents);	
						}
					}
				}
			});
			return contents;
		},
		getContentsAtChangingMode: function(contents, oldMode, newMode) {
			if (oldMode == newMode) {
				return contents;
			}
			contents = contents.trim() || "";
			return this.executeFilters(oldMode.concat("2").concat(newMode), contents);
		},
		convertAtLoad: function(contents, editorMode, inputMode) { // For Display
			/*
			 * DB\uc5d0 \uc800\uc7a5\ub41c \ucee8\ud150\uce20
			 *  > original, text
			 */
			if(inputMode == 'original') { //original \ucee8\ud150\uce20 \ubcc0\ud658
				contents = this.executeFilters(editorMode.concat('@load'), contents);
			} else { //\uadf8\uc678 \ubaa8\ub4dc, \uc790\ub3d9\uc800\uc7a5\uc740 \ubcc0\ud658\uc5c6\uc774 \uc800\uc7a5\ub428.
				if(editorMode != inputMode) {
					contents = this.executeFilters(inputMode.concat("2").concat(editorMode), contents);
				}
			}
			return contents;
		},
		convertAtSave: function(contents, editorMode, outputMode) { // For Save
			if (outputMode == 'original') { //original \ucee8\ud150\uce20 \ubcc0\ud658
				contents = this.executeFilters(editorMode.concat('4save'), contents);
			} else { //\uadf8\uc678 \ubaa8\ub4dc, \uc790\ub3d9\uc800\uc7a5\uc740 \ubcc0\ud658\uc5c6\uc774 \uc800\uc7a5\ub428.
				if (editorMode != outputMode) {
					contents = this.executeFilters(editorMode.concat("2").concat(outputMode), contents);
				}
			}
			return contents;
		},
		/* \uc678\ubd80\uc5d0\uc11c \ucc38\uc870\ud560 \ucee8\ud150\uce20 \ubcc0\ud658 \ud544\ud130\uba85 \uc2dc\uc791 */
		text2source: function(contents) {
			return this.executeFilters("text2source", contents);
		},
		text2html: function(contents) {
			if (contents === "") {
				return $tom.EMPTY_PARAGRAPH_HTML;
			}
			return this.executeFilters("text2html", contents);
		},
		source2text: function(contents) {
			return this.executeFilters("source2text", contents);
		},
		source2html: function(contents) {
			if (contents === "") {
				return $tom.EMPTY_PARAGRAPH_HTML;
			}
			return this.executeFilters("source2html", contents);
		},
		html2text: function(contents) {
			return this.executeFilters("html2text", contents);
		},
		html2source: function(contents) {
			return this.executeFilters("html2source", contents);
		}
		/* \uc678\ubd80\uc5d0\uc11c \ucc38\uc870\ud560 \ucee8\ud150\uce20 \ubcc0\ud658 \ud544\ud130\uba85 \ub05d */
	} 
);

Trex.install("editor.getEntryProxy",
	function(editor, toolbar, sidebar, canvas, config){
		var _entryproxy = new Trex.EntryProxy(editor, sidebar, config);
		editor.getEntryProxy = function() {
			return _entryproxy;
		};
	}
);

Trex.EntryProxy =Trex.Class.create( {
	initialize : function(editor, sidebar,  config){
		this.editor = editor;
		this.sidebar = sidebar;
		this.config = config;
	},
	/**
	 * For loadEntriesAtRestore, loadEntriesAtModify
	 */
	commands: {},
	registerCommand: function(name, command){
		this.commands[name] = command;
	},
	getcommand: function(name){
		return this.commands[name];
	},
	executeCommand: function(cmd, data){
		for(var i in this.commands){
			var command = this.commands[i];
			if(command[cmd]){
				command[cmd](data);	
			}
		}
	},
	setAttachments: function(attachments, contents) { //NOTE: data format = JSON
		attachments = attachments || [];
		contents = contents || "";
		
		var _entrybox = this.editor.getAttachBox();
		_entrybox.empty();
		
		var _actors = this.sidebar.getAttacher();
		attachments.each(function(attachment){
            try {
                var _actor = _actors[attachment.attacher];
                if(_actor) {
                    _actor.execReload(attachment.data, contents, attachment.type);
                }
            } catch(ignore) {
                // \ucca8\ubd80\ub370\uc774\ud130 \uc77c\ubd80\ub97c \uc815\uc0c1\uc801\uc73c\ub85c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.
                
            }
		});
	},
	getAttachments: function(attachments, all) {
		all = !!all;
		var _attachments = [];
		attachments.each(function(attachment){
			if(attachment.deletedMark) {
				return;
			}
			if(all || attachment.existStage) {
				_attachments.push({
					type: attachment.type,
					attacher: attachment.actor.name,
					existStage: attachment.existStage,
					data: Object.extend(attachment.data, {
						tmpSeq: attachment.dataSeq
					}) //html mode
				});
			}
		});
		return _attachments;
	}
} );
	



Trex.install("editor.getForm",
	function(editor, toolbar, sidebar, canvas, config){
		var _formproxy = new Trex.FormProxy(editor, sidebar, config);
		editor.getForm = function() {
			return _formproxy;
		};
	}
);

Trex.FormProxy =Trex.Class.create( {
	initialize : function(editor, sidebar,  config){
		this.editor = editor;
		this.sidebar = sidebar;
		this.config = config;
		
		var _elForm = this.elForm = _DOC.forms[config.form] || _DOC.getElementById(config.form);
		if(!_elForm) {
			throw new Error("[Exception]Trex.Form : not exist element - " + config.form);
		}

		_elForm.onsubmit = function() {
			return _FALSE;
		};
	},
	submit: function() {
		this.elForm.submit();
	},
	createField: function(elField) {
		this.elForm.appendChild(elField);
	},
	getElements: function() {
		return this.elForm.elements;
	},
	getElementByName: function(name) {
		return this.elForm[name];
	},
	getFormField: function() {
		var _formfield = {};
		
		var _fields = this.getElements();
		var _field;
		for(var i=0; i<_fields.length; i++) {
			_field = _fields[i];
			if(!["select", "input", "textarea"].contains(_field.tagName.toLowerCase())) {
				continue;
			}
			if(!_field.name && !_field.id) {
				continue;
			}
			if(_field.tagName.toLowerCase() == "select") {
				if (_field.selectedIndex > 0) {
					_formfield[_field.name] = _field.options[_field.selectedIndex].value;
				}
			} else {
				if(_field.type == "radio" && !_field.checked) {
				} else if(_field.type == "checkbox" && !_field.checked) {
				} else {
					_formfield[_field.name || _field.id] = _field.value;
				}
			}
		}
		return _formfield;
	},
	setFormField: function(formfield){
		if(!formfield) {
			return;
		}
		var _fields = this.getElements();
		var _field;
		var _value;
		for(var i=0; i<_fields.length; i++) {
			_field = _fields[i];
			if(!["select", "input", "textarea"].contains(_field.tagName.toLowerCase())) {
				continue;
			}
			if(_field.name === _NULL || _field.name.length === 0) {
				continue;
			}
			if(!formfield[_field.name]) {
				continue;
			}
			_value = formfield[_field.name];
			if(_field.tagName.toLowerCase() == "select") {
				for(var j=0; j<_field.options.length; j++) {
					if(_field.options[j].value == _value) {
						_field.options[j].selected = _TRUE;
						break;
					}
				}
			} else {
				if(_field.type == "radio" || _field.type == "checkbox") {
					if(_field.value == _value) {
						_field.checked = _TRUE;
					}
				} else {
					_field.value = _value;
				}
			}
		}
	}
});
		
Trex.install("editor.getSaver & editor.getDataAsJSON & editor.setDataByJSON",
	function(editor, toolbar, sidebar, canvas, config){
		var _saver = new Trex.Save(editor, toolbar, sidebar, canvas, config);
		editor.getSaver = function() {
			return _saver;
		};
		
		editor.getDataAsJSON = function() {
			var _content = canvas.getContent(); // getContent() of current mode
			var _validator = new Trex.Validator();
			if(!_validator.exists(_content)) {
				return _NULL;
			}
			return {
				'inputmode': canvas.getCurrentPanel().getName(),
				'content': _content,
				'attachments': function() {
					var _attachments = sidebar.getAttachments(); // all getAttachments()
					return editor.getEntryProxy().getAttachments(_attachments, _TRUE);
				}(),
				'resultBox': function() {
					var _resultBox = editor.getResultBox();
					var datas = [];
					_resultBox.datalist.each(function(entry){
						datas.push(entry.data);
					});
					return datas;
				}(),
				'formfield': editor.getForm().getFormField()
			};
		};
		
		editor.setDataByJSON = function(jsonData) {
			if(!jsonData) {
				return;
			}
			var _editorMode = canvas.mode;
			var _inputMode = jsonData.inputmode || _editorMode;
			if (_inputMode == 'original') { //save
			} else if(_inputMode != _editorMode) {
				canvas.fireJobs(Trex.Ev.__CANVAS_MODE_INITIALIZE, _editorMode, _inputMode);
				canvas.changeMode(_inputMode);
			}
			
			var _content = jsonData.content;
			
			if(jsonData.attachments) {
				editor.getEntryProxy().setAttachments(jsonData.attachments, _content);
			}
				
			if(_content) {
				_content = editor.getDocParser().convertAtLoad(_content, _editorMode, _inputMode); //onlyHTML
				canvas.initContent(_content);
			}
			
			if (jsonData.resultBox) {
				jsonData.resultBox.each(function(data){
					var _actor;
					_actor = sidebar.searchers[data._meta.type];
					if (_actor) {
						_actor.execReload(data, _content);
					}
				});
			}
			
			sidebar.syncSidebar(); //sync
			
			if(jsonData.formfield) {
				editor.getForm().setFormField(jsonData.formfield);
			}
		};
	}
);

Trex.Save = Trex.Class.create({
	editor: _NULL,
	toolbar: _NULL,
	sidebar: _NULL,
	canvas: _NULL,
	config: _NULL,
	form: _NULL,
	initialize: function(editor, toolbar, sidebar, canvas, config) {
		this.editor = editor;
		this.toolbar = toolbar;
		this.sidebar = sidebar;
		this.canvas = canvas;
		this.config = config;
		this.form = editor.getForm();
		this.docparser = editor.getDocParser();
		this.entryproxy = editor.getEntryProxy();
	},
	save: function() {
		try {
			if (typeof validForm == "function") {
				if (!validForm(this.editor)) {
					return _FALSE;
				}
			}
			if (typeof setForm == "function") {
				if (!setForm(this.editor)) {
					return _FALSE;
				}
			}
			return _TRUE;
		} catch(e) {
			this.editor.fireJobs(Trex.Ev.__RUNTIME_EXCEPTION, e);
			return _FALSE;
		}
	},
	submit: function() {
		if(this.save()) {
			this.editor.fireJobs(Trex.Ev.__ON_SUBMIT, this.editor);
			if ( this.config.save && typeof this.config.save.onSave == "function" ){
				var externalSaveHandler = this.config.save.onSave;
				externalSaveHandler();
			} else {
				this.form.submit();
			}
		}		
	},
	getContent: function(outputMode) {
		var _canvas = this.canvas;

		//\uc5d0\ub514\ud130\ubaa8\ub4dc, \ucd9c\ub825\ubaa8\ub4dc
		var _editorMode = _canvas.mode;
		var _outputMode = outputMode || "original";
		
		var _content = _canvas.getContent(); // getContent() of current mode
		_content = this.docparser.convertAtSave(_content, _editorMode, _outputMode);
		
		return _content;
	},
	getAttachments: function(type, all) {
		all = all || _FALSE;
		var _attachments = this.sidebar.getAttachments(type); // all getAttachments()
		return this.entryproxy.getAttachments(_attachments, all);
	},
	getEmbeddedData: function(type) {
		return this.sidebar.getEmbeddedData(type);
	},
	getResults: function(type) {
		return this.sidebar.getResults(type);
	},
	/*
		data = {
			content: "string",
			inputmode: "string",
			attachments: [{
				attacher: "string",
				data: {object}
			}]
		}
	*/
	load: function(jsonData) { //NOTE: data format = JSON
		jsonData = {
			'inputmode': (!jsonData.inputmode || jsonData.inputmode == 'html')? 'original': jsonData.inputmode,
			'content': function() {
				var _contentObj = jsonData.content;
				if (typeof _contentObj == "string") {
					return jsonData.content;
				} else if (_contentObj && _contentObj.nodeType && (_contentObj.nodeType == 1)) {
					return jsonData.content.value;
				} else {
					return '';
				}
			}(),
			'attachments': jsonData.attachments
		};
        this.editor.fireJobs(Trex.Ev.__EDITOR_LOAD_DATA_BEGIN, jsonData);
		if (!jsonData) {
			throw new Error("[Exception]Trex.Save : not exist argument(data)");
		}
		if (typeof loadForm == "function") {
			loadForm(this.editor, jsonData);
		}
		
		try { //#FTDUEDTR-1111
			this.setDataByJSONToEditor(jsonData);
		} catch (error) {
			alert(' - Error: ' + error.message + '\n\uc18c\uc2a4\ubcf4\uae30 \ubaa8\ub4dc\ub85c \uc804\ud658\ud569\ub2c8\ub2e4.\n\uc798\ubabb\ub41c HTML\uc774 \uc788\ub294\uc9c0 \ud655\uc778\ud574\uc8fc\uc138\uc694.');
			jsonData.inputmode = Trex.Canvas.__HTML_MODE;
            try {
                this.setDataByJSONToEditor(jsonData);
            } catch(ignore) {}
		}
		
		if (typeof postLoad == "function") {
			postLoad(this.editor, jsonData);
		}
        this.editor.fireJobs(Trex.Ev.__EDITOR_LOAD_DATA_END);
	},
	setDataByJSONToEditor: function (jsonData) {
		this.editor.setDataByJSON(jsonData);
	},
	makeField: function() {
		var _sidebar = this.sidebar;
		var _form = this.form;

		//NOTE: create field content
		var _content = this.getContent();
		_form.createField(tx.textarea({ name: "tx_content", style: { display: "none" } }, _content));

		//NOTE: create field attach
		var _fields = _sidebar.getFields();
		_fields.each(function(field) {
			_form.createField(tx.input({ type: "hidden", name: field.name, value: field.value }));
		});
	}

});


Trex.module("new Trex.Resizer",
	function(editor, toolbar, sidebar, canvas, config){
		var _initializedId = config.initializedId || ""; 
		var cfg = TrexConfig.get("resizer", config);
		var _resizer = _NULL;
		
		editor.setMinHeight = function(h) {
			return _resizer.setMinHeight(h);
		};
		editor.restoreMinHeight = function() {
			return _resizer.restoreMinHeight();
		};
		if (Trex.available(cfg, "resizer" + _initializedId)) {
			_resizer = new Trex.Resizer(editor, cfg);
		}
	}
);
TrexConfig.add({
	'resizer': {
		minHeight: 200
	}
});
Trex.Resizer = Trex.Class.create({
	$const: {
		__Identity: 'resizer'
	},
	$mixins: [
		Trex.I.JobObservable
	],
	initialize: function(editor, config) {
		var _presentHeight = 0;
		if(!editor) {
			return;
		}
		this.config = config;
		
		var _initializedId = editor.getInitializedId();
		var _elBar = this.elBar = $tx("tx_resizer" + _initializedId);
		if(!_elBar) {
			return;
		}
		if($tx.msie_ver == '5.5'){
			_elBar.setAttribute('align', 'center');
		}
		
		this.resizeHeightAtService = function( height ) { //NOTE: \uc5d0\ub514\ud130\ub97c \ub9ac\uc0ac\uc774\uc988\ud558\uace0 \ub098\uc11c \uc2e4\ud589\ud560 \uc11c\ube44\uc2a4 \ucf5c\ubc31
			if(typeof resizeHeight == "function") {
				resizeHeight( height );
			}
		};
		this.resizingHeightAtService = function( height ) { //NOTE: \uc5d0\ub514\ud130\ub97c \ub9ac\uc0ac\uc774\uc988\ud558\ub294 \uc911\uc5d0 \uc2e4\ud589\ud560 \uc11c\ube44\uc2a4 \ucf5c\ubc31 ex) iframe \uae38\uc774 \ub298\ub9ac\uae30
			if(typeof resizingEditorHeight == "function") { 
				resizingEditorHeight( height ); 
			} 
		};
		this.minDragHeight = config.minHeight;
		var _wysiwygDoc;
		this.startDrag = function(ev) {
			var _canvas = editor.getCanvas();
			var _panel = _canvas.getCurrentPanel();
			if(_panel == _NULL) {
				return;
			}

			var _position = _panel.getPosition();
			this.panelHeight = _position.height;
			this.dragStartPosY = ev.clientY;
			this.isDragging = _TRUE;
			$tx.observe(_DOC, 'mousemove', this.documentDraggingHandler);
			$tx.observe(_DOC, 'mouseup', this.stopDragHandler);
			if(_panel.getName() == Trex.Canvas.__WYSIWYG_MODE) {
				this.panelTop = _position.y;
				_wysiwygDoc = _panel.getDocument();
				if(_wysiwygDoc == _NULL) {
					return;
				}
				_canvas.fireJobs('canvas.height.beforechange');
				$tx.observe(_wysiwygDoc, 'mousemove', this.wysiwygDraggingHandler);
				$tx.observe(_wysiwygDoc, 'mouseup', this.stopDragHandler);
			}
			$tx.stop(ev);
		};

		this.stopDrag = function(ev){
			var _canvas = editor.getCanvas();
			var _panel = _canvas.getCurrentPanel();
			if(_panel == _NULL) {
				return;
			}
			this.isDragging = _FALSE;

			$tx.stopObserving(_DOC, 'mousemove', this.documentDraggingHandler);
			$tx.stopObserving(_DOC, 'mouseup', this.stopDragHandler);
			if(_wysiwygDoc == _NULL) {
				return;
			}
			$tx.stopObserving(_wysiwygDoc, 'mousemove', this.wysiwygDraggingHandler);
			$tx.stopObserving(_wysiwygDoc, 'mouseup', this.stopDragHandler);
			_wysiwygDoc = _NULL;
			
			this.resizeHeightAtService(_presentHeight);
			_canvas.fireJobs('canvas.height.afterchange');
			$tx.stop(ev);
		};

		this.dragingAtDocument = function(ev) {
			var _canvas = editor.getCanvas();
			if (this.isDragging) {
				var _panel = _canvas.getCurrentPanel();
				if(_panel == _NULL) {
					return;
				}
				try {
					var _height = Math.max((this.panelHeight + ev.clientY - this.dragStartPosY), this.minDragHeight.parsePx()).toPx();
					_panel.setPanelHeight(_height);
					_presentHeight = _height;
					_canvas.fireJobs('canvas.height.change', _height);
					this.resizingHeightAtService(_height);
				} catch(e) {
					
				}
			}
			$tx.stop(ev);
		};

		this.dragingAtWysiwyg = function(ev) {
			var _canvas = editor.getCanvas();
			if (this.isDragging) {
				var _panel = _canvas.getCurrentPanel();
				if(_panel == _NULL) {
					return;
				}
				try {
                    var _scrollTop = _DOC.body.scrollTop || _DOC_EL.scrollTop || _WIN.pageYOffset;
                    var canvasPos = _canvas.getCanvasPos(); // canvas \uc704\uce58\ub97c \uc870\uc815\ud558\uc9c0 \uc54a\uc544\uc11c \ub192\uc774 \uc798\ubabb \uacc4\uc0b0\ud55c \ubd80\ubd84 \uc218\uc815 #FTDUEDTR-1317
                    var _height = Math.max((this.panelHeight + ev.clientY + canvasPos.y - this.dragStartPosY + this.panelTop - _scrollTop), this.minDragHeight.parsePx()).toPx();
                    //var _height = Math.max((this.panelHeight + ev.clientY - this.dragStartPosY + this.panelTop - _scrollTop), this.minDragHeight.parsePx()).toPx();
                    _panel.setPanelHeight(_height);
                    _canvas.fireJobs('canvas.height.change', _height);
                } catch (e) {
					
				}
			}
			$tx.stop(ev);
		};

		this.startDragHandler = this.startDrag.bindAsEventListener(this);
		this.stopDragHandler = this.stopDrag.bindAsEventListener(this);
		this.documentDraggingHandler = this.dragingAtDocument.bindAsEventListener(this);
		this.wysiwygDraggingHandler = this.dragingAtWysiwyg.bindAsEventListener(this);
		this.isDragging = _FALSE;

		$tx.observe(_elBar, 'mousedown', this.startDragHandler);

		var _canvas = editor.getCanvas();
		_canvas.observeJob(Trex.Ev.__CANVAS_FULL_SCREEN_CHANGE, function() {
			$tx.hide(_elBar);
		});

		_canvas.observeJob(Trex.Ev.__CANVAS_NORMAL_SCREEN_CHANGE, function() {
			$tx.show(_elBar);
		});

	},
	setMinHeight: function(height) {
		return this.minDragHeight = height.toPx();
	},
	restoreMinHeight: function() {
		return this.minDragHeight = this.config.minHeight || 200;
	}
});
!function() {

    var ELEMENT_NODE = _WIN['Node'] ? Node.ELEMENT_NODE : 1;
    var TEXT_NODE = _WIN['Node'] ? Node.TEXT_NODE : 3;


    /**
     * Paste\ub97c \uac00\ub85c\ucc44\uc11c \ucd94\uac00\ub420 HTML \ubc0f Text\ub97c \uc815\uc81c\ud558\ub294 \uae30\ub2a5
     *
     */
    Trex.Paste = {
        I: {},
        isMSSelection: typeof _WIN.getSelection != 'function',
        MODE_OFF: 'off',
        MODE_HTML: 'html',
        MODE_TEXT: 'text'
    };

    /**
     * pasteContent\ub97c \ubcf4\uc644\ud558\ub294 processor(BETA)
     * \ud574\ub2f9 \uae30\ub2a5\uc744 \ucda9\ubd84\ud788 \ud14c\uc2a4\ud2b8&\uac80\uc99d&\uc0ac\uc6a9 \ud6c4 \uae30\uc874\uc758 processor\uc758 pasteContent\ub97c \ub300\uccb4\ud558\ub294 \ubc29\ud5a5\uc73c\ub85c \ud55c\ub2e4.
     */
    Trex.Paste.I.ProcessorBETA = Trex.Mixin.create({
        initialize: function(editor, canvas) {
            this.editor = editor;
            this.canvas = canvas;

            this.processor = null;
        },
        getProcessor: function() {
            if (!this.processor) {
                this.processor = this.canvas.getProcessor();
            }
            return this.processor;
        },
        /**
         * html\uc744 \ud3b8\uc9d1\ud654\uba74\uc5d0 \ubd99\uc5ec\ub123\ub294\ub2e4.
         *
         * @param html
         */
        pasteContent: function(html) {
            var processor = this.getProcessor();
            var range = processor.createGoogRange();

            var anchorNode = this._getAnchorNodeByRange(range);

            var _tmpNode = processor.create('div');
            html = html.replace(/<\/p>\s+/gi, '</p>');
            html = html.replace(/<br class="Apple-interchange-newline">\s*/g, '');// for chrome clipboard.getData()..
            html = html.replace(/<\/(span|font|i|b|strong|center|i)>[\r\n]+/g, '<\/$1> ');
            html = this.cleanPasteHtml(html);
            _tmpNode.innerHTML = html;

            var targetNodes = $tom.children(_tmpNode);

            var isOnlyTextNode = _FALSE;
            var isAllInlineNode = _TRUE;
            for (var i = 0, m = targetNodes.length; i < m; i++) {
                var node = targetNodes[i];
                if (m == 1 && node.nodeType === TEXT_NODE) {
                    isOnlyTextNode = _TRUE;
                    break;
                } else {
                    if ($tom.isBlock(node)) {
                        isAllInlineNode = _FALSE;
                        break;
                    }
                }
            }

            if (isOnlyTextNode) {
                this._pasteTextOnly(targetNodes, range);
            } else {
                this._pasteHtmlAndText(targetNodes, range, isAllInlineNode, anchorNode);
            }
            this.removeDummyText();
        },
        /**
         * html\uc744 \uc720\ud6a8\ud55c \ub9c8\ud06c\uc5c5\uc73c\ub85c \ubcc0\ud615\uc774 \ud544\uc694\ud558\ub2e4\uba74 \uc774 \uba54\uc18c\ub4dc\ub97c \uad6c\ud604\ud558\ub3c4\ub85d \ud55c\ub2e4.
         *
         * @param html
         * @returns {*}
         */
        cleanPasteHtml: function(html) {
            var dom = this.getProcessor().create('div');
            dom.innerHTML = html;
            return dom.innerHTML;
        },

        /**
         * caret\uc758 \uc774\ub3d9 \ubc0f \ub178\ub4dc \uc0bd\uc785\uc758 \ubcf4\uc870\uc5ed\uc744 \uc704\ud574 word_joiner\uc744 \uc0dd\uc131\ud55c\ub2e4.
         * \uae30\uc874\uc5d0 \uc0dd\uc131\ub418\uc5b4 \uc788\ub358 \uac1d\uccb4\uac00 \uc788\ub2e4\uba74 \uc7ac\ud65c\uc6a9 \ud558\ub3c4\ub85d \ud55c\ub2e4.
         *
         * @returns {Text}
         */
        getDummyText: function() {
            if (!this.dummyText) {
                this.dummyText = this.getProcessor().doc.createTextNode(Trex.__WORD_JOINER);
            }
            return this.dummyText;
        },
        /**
         * caret\uc6a9 word_joiner\ub97c \uc81c\uac70\ud55c\ub2e4.
         */
        removeDummyText: function() {
            if (this.dummyText) {
                $tom.remove(this.dummyText);
                this.dummyText = _NULL;
            }
        },

        /**
         * caret\uc774 \uc704\uce58\ud55c \ub178\ub4dc\ub97c \uae30\uc900\uc73c\ub85c \uc0c1\uc704 \ub178\ub4dc\uae4c\uc9c0 tree\ub97c 2\ubd84\ud560 \ud55c\ub2e4.
         *
         * @param topNode
         * @param range
         * @returns {{previousNode: (_NULL|*), nextNode: (_NULL|*)}}
         */
        divideTree: function(topNode, range) {
            if ($tom.isBody(topNode)) {
                return {
                    previousNode: null,
                    nextNode: null
                }
            }

            var processor = this.canvas.getProcessor();
            range = range || processor.createGoogRange();

            var pNode = _NULL,
                nNode = _NULL;

            var copyRange;

            // range \uae30\uc900 '\uc774\uc804' \ud2b8\ub9ac\ub178\ub4dc\ub97c \ubcf5\uc0ac > \ub07c\uc6cc\ub123\uae30
            copyRange = processor.createGoogRangeFromNodes(topNode, 0, range.getFocusNode(), range.getFocusOffset());
            var pHtml = copyRange.getPastableHtml().trim();
            if (pHtml !== '') {
                pNode = topNode.cloneNode(false);
                pNode.innerHTML = pHtml;
                $tom.insertAt(pNode, topNode);

                if (pNode.childNodes.length == 1 && $tom.isElement(pNode.childNodes[0]) && pNode.tagName == pNode.childNodes[0].tagName) {
                    pNode = $tom.unwrap(pNode);
                }
                copyRange = processor.createGoogRangeFromNodes(topNode, 0, range.getFocusNode(), range.getFocusOffset());
                copyRange.select();
                var text = copyRange.getText();
                if (text !== '') {
                    copyRange.removeContents();
                }
            }

            // \ub07c\uc6cc\ub123\ub294 \ub178\ub4dc \uc0ac\uc774\uc5d0 \uce90\ub7ff\uc744 \uc774\ub3d9\uc2dc\ud0a4\uae30 \uc704\ud55c \uc784\uc2dc\ub178\ub4dc \ucd94\uac00
            var caretNode = this.getDummyText();
            $tom.insertAt(caretNode, topNode);

            var caretRange = processor.createGoogRangeFromNodes(caretNode, caretNode.length, caretNode, caretNode.length);
            caretRange.select();
            var savedCaret = caretRange.saveUsingCarets();

            // range \uae30\uc900 '\ub2e4\uc74c' \ud2b8\ub9ac\ub178\ub4dc\ub97c topNode\uc5d0\uc11c '\uc774\uc804' \ud2b8\ub9ac\ub178\ub4dc\uc5d0 \ud574\ub2f9\ud558\ub294 range\ub97c \uc81c\uac70\ud558\uc5ec \uc644\uc131
            var nHtml = topNode.innerHTML.trim();
            if (nHtml !== '') {
                topNode.innerHTML = nHtml;
                nNode = topNode;
            } else {
                // \ube48\ud0dc\uadf8\ub9cc \uc874\uc7ac\ud558\ubbc0\ub85c topNode\ub97c \uc81c\uac70\ud574 \uc900\ub2e4
                $tom.remove(topNode);
            }

            // \uce90\ub7ff \uc774\ub3d9\uc744 \uc704\ud55c \uc784\uc2dc \ub178\ub4dc\ub85c range \uc774\ub3d9
            savedCaret.restore();

            return {
                previousNode: pNode,
                nextNode: nNode
            };
        },

        _pasteTextOnly: function (targetNodes, range) {
            var textNode = targetNodes[0];
            range.insertNode(textNode);

            range = this.getProcessor().createGoogRangeFromNodes(textNode, $tom.getLength(textNode), textNode, $tom.getLength(textNode));
            var savedCaret = range.saveUsingCarets();
            savedCaret.restore();
            return range;
        },

        _removeNodeIfContentIsEmpty: function(node) {
            var text = (node && (node.textContent || node.innerText));
            if (node && text && (text.trim() === '')) {
                $tom.remove(node);
            }
        },

        _pasteHtmlAndText: function (targetNodes, range, isAllInlineNode, anchorNode) {
            if (!range) {
                return;
            }
            var processor = this.getProcessor();

            // anchorNode\uac00 p\ud0dc\uadf8 \uc774\uac70\ub098 p\ud0dc\uadf8\ub97c \ud3ec\ud568\ud55c \ud558\uc704\ub178\ub4dc\ub77c\uba74 \uc0c1\uc704\uc758 p\ub97c \ucc3e\uc544\uc11c \ubc18\uc73c\ub85c \ucabc\uac20\ub2e4
            // \ub2e8, p\ud0dc\uadf8\uac00 \uc5c6\uc744 \uc218 \uc788\ub294\ub370 body\ud558\uc704 \ub808\ubca8\uc758 node\ub97c \ucc3e\uac70\ub098 \uc2e0\uaddc\ub85c \uc0dd\uc131\ud558\ub294 \ubc29\ubc95\uc744 \uc0ac\uc6a9\ud558\ub3c4\ub85d \ud55c\ub2e4.
            var markerContainer = processor.create('div');
            var dividedResult;

            if (isAllInlineNode === _FALSE && anchorNode.nodeType === ELEMENT_NODE) {
                dividedResult = this.divideTree(anchorNode, range);
                this._removeNodeIfContentIsEmpty(dividedResult.previousNode);
                this._removeNodeIfContentIsEmpty(dividedResult.nextNode);
                range = processor.createGoogRange();
                range.insertNode(markerContainer);
                this.removeDummyText();
            } else {
                range.insertNode(markerContainer);
            }


            // range\ub97c marker\uc758 \uac00\uc7a5 \ub9c8\uc9c0\ub9c9\uc73c\ub85c \uc704\uce58\uc774\ub3d9\ud558\uace0 node\ub97c \uc0bd\uc785\ud55c\ub2e4.
            var childNodes;
            targetNodes.each(function (node) {
                childNodes = markerContainer.childNodes.length;
                range = processor.createGoogRangeFromNodes(markerContainer, childNodes, markerContainer, childNodes);
                range.select();
                if (node.nodeType === TEXT_NODE) {
                    var p = processor.create('p');
                    p.appendChild(node);
                    markerContainer.appendChild(p);
                } else {
                    markerContainer.appendChild(node);
                }
            });

            // marker\ub97c unwrapping \uc2dc\ud0a4\uace0
            var lastNode = $tom.bottom(markerContainer);
            if (lastNode == markerContainer) {
                lastNode = markerContainer.childNodes[markerContainer.childNodes.length-1];
            }
            $tom.unwrap(markerContainer);

            // range \uc774\ub3d9
            if ($tom.isElement(lastNode)) {
                var txtNode = processor.doc.createTextNode(Trex.__WORD_JOINER);
                $tom.insertAt(txtNode, lastNode);
                $tom.insertAt(lastNode, txtNode);
                range = processor.createGoogRangeFromNodes(txtNode, 0, txtNode, $tom.getLength(txtNode));
                range.removeContents();
            } else {
                // text\uc778 \uacbd\uc6b0 \ud574\ub2f9 text\uc758 \ub05d\uc5d0 \uc704\uce58\ud558\uac8c range\ub97c \ubcc0\uacbd
                range = processor.createGoogRangeFromNodes(lastNode, $tom.getLength(lastNode), lastNode, $tom.getLength(lastNode));
            }

            range.select();
            return range;
        },
        _getAnchorNodeByRange: function (range) {
            if (!range) {
                return;
            }
            var anchorNode = range.getFocusNode();

            while (anchorNode) {

                var parentNode = anchorNode.parentNode;
                if ($tom.kindOf(parentNode, 'p,div')) {
                    // \uc0c1\uc704 \ub178\ub4dc\uae4c\uc9c0 \ud3ec\ud568\ud574\uc11c \ub9ac\ud134
                    anchorNode = parentNode;
                    break;
                } else if ($tom.isBody(parentNode) || $tom.kindOf(parentNode, '%innergroup') || $tom.isBlock(parentNode)) {
                    // \uc911\ub2e8
                    break;
                } else if ($tom.kindOf(parentNode, '%text,%inline')){
                    // \uacc4\uc18d\uc9c4\ud589

                } else {
                    // 1.
                    // 2.
                    // \uc911\ub2e8
                    break;
                }

                anchorNode = parentNode;
            }

            return anchorNode;
        }
    });

    Trex.Paste.I.ProcessorBETATridentLegacy = Trex.Mixin.create({
        cleanPasteHtml: function(html) {
            // TODO: invalid markup\uc5d0 \ub300\ud55c \ubcf4\uc644\ucc98\ub9ac\uac00 \ud544\uc694\ud558\ub2e4.
            return html;
//            return HTMLParser(html).cleanHTML;
        },
        _pasteTextOnly: function (targetNodes, range_notused) {
            var processor = this.getProcessor();
            var range = processor.doc.selection.createRange();
            range.pasteHTML(targetNodes[0].nodeValue);
        },
        _pasteHtmlAndText: function (targetNodes, range, isAllInlineNode, anchorNode) {
            var processor = this.getProcessor();

            // anchorNode\uac00 p\ud0dc\uadf8 \uc774\uac70\ub098 p\ud0dc\uadf8\ub97c \ud3ec\ud568\ud55c \ud558\uc704\ub178\ub4dc\ub77c\uba74 \uc0c1\uc704\uc758 p\ub97c \ucc3e\uc544\uc11c \ubc18\uc73c\ub85c \ucabc\uac20\ub2e4
            // \ub2e8, p\ud0dc\uadf8\uac00 \uc5c6\uc744 \uc218 \uc788\ub294\ub370 body\ud558\uc704 \ub808\ubca8\uc758 node\ub97c \ucc3e\uac70\ub098 \uc2e0\uaddc\ub85c \uc0dd\uc131\ud558\ub294 \ubc29\ubc95\uc744 \uc0ac\uc6a9\ud558\ub3c4\ub85d \ud55c\ub2e4.
            if (isAllInlineNode === _FALSE && anchorNode.nodeType === ELEMENT_NODE) {
                var dividedResult = this.divideTree(anchorNode, range);
                range = processor.createGoogRange();
                this._removeNodeIfContentIsEmpty(dividedResult.previousNode);
                this._removeNodeIfContentIsEmpty(dividedResult.nextNode);
            }

            targetNodes.each(function(node) {
                range.collapse(false);
                if (node.nodeType === TEXT_NODE) {
                    var p = processor.create('p');
                    p.appendChild(node);
                    range.insertNode(p);
                } else {
                    range.insertNode(node);
                }
            });

            range.collapse(false);
        }
    });


    Trex.Paste.Helper = Trex.Class.create({
        $mixins: [
            Trex.Paste.I.ProcessorBETA,
            Trex.Paste.isMSSelection ? Trex.Paste.I.ProcessorBETATridentLegacy : {}
        ]
    });

    Trex.Paste.I.CleanerStandard = Trex.Mixin.create({
        $const: {
            __Identity: 'cleaner-standard'
        },
        filters: {},
        initialize: function (editor, canvas) {
            this.editor = editor;
            this.canvas = canvas;
        },
        /**
         * \ubd88\ud544\uc694\ud55c \ud0dc\uadf8\uc758 \uc81c\uac70\ub97c \uc2e4\ud589\ud55c\ub2e4.
         *
         * @param originalHtml
         * @returns {String} filteredHtml
         */
        execute: function (originalHtml) {
            var self = this;
            var html = originalHtml;

            // \ud544\ud130\ub9c1 \uc2dc\uc791
            html = this.defaultFilterBegin(html);
            html = this.filterOptional(html);
            // \ucd94\uac00 \ud544\ud130\ub9c1
            for (var filter in this.filters) {
                var filterCallback = this.filters[filter];
                if (this.filters.hasOwnProperty(filter) && typeof filterCallback === 'function') {
                    html = filterCallback.call(self, html);
                }
            }
            // \ud544\ud130\ub9c1 \uc885\ub8cc
            html = this.defaultFilterEnd(html);
            return html;
        },
        defaultFilterBegin: function (html) {
            html = html.replace(/>\s+</g, '><');// \ud0dc\uadf8\uac04 \uacf5\ubc31 \uc81c\uac70
//            html = html.replace(/[\n|\r]/g, '');// \uc904\ubc14\uafc8 \uc81c\uac70 #1
            html = html.replace(/(<[a-z]+[^>]*>)/gi, '\n$1');// \ud0dc\uadf8 \uc81c\uac70\ub97c \uc704\ud55c \uc904\ubc14\uafc8 \ubb38\uc790 \ucd94\uac00
            html = html.replace(/\n<head>.*<\/head>/gi, '');// head\ud0dc\uadf8 \uc81c\uac70
            html = html.replace(/<\/?(html|body|meta)[^>]*>/gi, '');
            html = html.replace(/<!--/g, '\n<!--');// \uc8fc\uc11d \uc81c\uac70\ub97c \uc704\ud55c \uc904\ubc14\uafc8 \ubb38\uc790 \ucd94\uac00
            html = html.replace(/\n<!--.*-->/g, '');// \uc8fc\uc11d \uc81c\uac70
            html = html.replace(/<p[^>]*>/gi, '<p>');// p\ud0dc\uadf8\uc5d0 \uc18d\uc131 \uc81c\uac70
            html = html.replace(/<(font|span[^>]*)>/gi, '<$1>');// \ube48 \ud0dc\uadf8 \uc81c\uac70
            html = html.replace(/\n<(font|span)[^>]*>\s*<\/\1>/gi, '');// \ube48 \ud0dc\uadf8 \uc81c\uac70
            html = html.replace(/(\d+)?\.(\d+)([a-z]+)/gi, function (matched, p1, p2, p3) {
                p1 = p1 || '0';
                var val = Math.round(parseFloat(p1 + '.' + p2));
                return val + p3;
            });// 0.65pt, .5pt \uac19\uc774 \uc18c\uc218\uc810 style\uac12\uc744 \uc815\uc218\ud654 \ubcc0\ud658
            return html;
        },
        defaultFilterEnd: function (html) {
//            html = html.replace(/[\n|\r]/g, '');// \uc904\ubc14\uafc8 \uc81c\uac70 #2
            return html;
        },
        filterOptional: function (html) {
            // NOTE: \ube0c\ub77c\uc6b0\uc800\ubcc4\ub85c overwrite\ub97c \uc704\ud55c \ud568\uc218
            html = html.replace(/<p>&nbsp;<\/p>/gi, $tom.EMPTY_PARAGRAPH_HTML);
            return html;
        },
        /**
         * \uc678\ubd80\uc5d0\uc11c \ud544\ud130\ub97c \ucd94\uac00
         * @param name
         * @param callback
         */
        addFilter: function (name, callback) {
            this.filters[name] = callback;
        },
        /**
         * \uc678\ubd80\uc5d0\uc11c \ucd94\uac00\ud55c \ud544\ud130\ub97c \uc81c\uac70
         * @param name
         */
        removeFilter: function (name) {
            this.filters[name] = _NULL;
            delete this.filters[name];
        }
    });

    /**
     * \ucd5c\uc2e0 IE\ub97c \uc704\ud55c \ud655\uc7a5 \ud074\ub798\uc2a4
     */
    Trex.Paste.I.CleanerTridentStandard = Trex.Mixin.create({
        $const: {
            __Identity: 'cleaner-trident-standard'
        },
        filterOptional: function (html) {
            html = html.replace(/<p><br[^>]*><\/p>/gi, $tom.EMPTY_PARAGRAPH_HTML);
            return html;
        }
    });

    /**
     * \uad6c\ud615 IE\ub97c \uc704\ud55c \ud655\uc7a5 \ud074\ub798\uc2a4
     */
    Trex.Paste.I.CleanerTridentLegacy = Trex.Mixin.create({
        $const: {
            __Identity: 'cleaner-trident-legacy'
        },
        filterOptional: function (html) {
            html = html.replace(/<p><br[^>]*><\/p>/gi, $tom.EMPTY_PARAGRAPH_HTML);
            return html;
        }
    });

    Trex.Paste.Cleaner = Trex.Class.create({
        $mixins: [
            Trex.Paste.I.CleanerStandard,
            ($tx.msie && Trex.Paste.isMSSelection ? Trex.Paste.I.CleanerTridentLegacy : {}),
            ($tx.msie && !Trex.Paste.isMSSelection ? Trex.Paste.I.CleanerTridentStandard : {})
        ]
    });


    /**
     * Paste standard \ubaa8\ub4c8
     */
    Trex.Paste.I.Standard = Trex.Mixin.create({
        $const: {
            __Identity: 'paste-standard'
        },
        isTextOnly: _FALSE,
        isEnable: _FALSE,
        isPasteProcessing: _FALSE,
        initialize: function (editor, canvas, cleaner, helper) {
            this.editor = editor;
            this.canvas = canvas;
            this.cleaner = cleaner;
            this.helper = helper;

            this.doc = _NULL;
            this.processor = _NULL;

            this.bindEvents();
        },
        bindEvents: function () {
            var self = this;
            this.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_PASTE, function (ev) {
                if (self.isEnable) {
                    if (!self.isPasteProcessing) {
                        self.onNativePaste(ev);
                    } else {
                        self.preventPasteDefault(ev);
                    }
                }
            });
        },
        onNativePaste: function (ev) {
            if (!this.canvas.isWYSIWYG()) {
                return _FALSE;
            }

            var dummy = this.getPasteDummy();
            if (dummy) {
                this.preventPasteDefault(ev);
                return _FALSE;
            }

            var clipboardData = ev.clipboardData;
            if (clipboardData && clipboardData.getData) {
                
                return this.pasteByClipboardGetData(ev);
            } else {
                
                return this.pasteByRedirection(ev);
            }
        },
        /**
         * \ubd99\uc5ec\ub123\uae30 \uacb0\uacfc\ub97c off/html/text \uc0c1\ud0dc 3\uac00\uc9c0 \uc911 1\uac1c\ub85c \ubcc0\uacbd\ud55c\ub2e4.
         * @param pasteMode
         */
        switchMode: function(pasteMode) {
            switch(pasteMode) {
                case Trex.Paste.MODE_HTML:
                    this.isTextOnly = _FALSE;
                    this.isEnable = _TRUE;
                    break;
                case Trex.Paste.MODE_TEXT:
                    this.isTextOnly = _TRUE;
                    this.isEnable = _TRUE;
                    break;
                case Trex.Paste.MODE_OFF:
                default:
                    this.isTextOnly = _FALSE;
                    this.isEnable = _FALSE;
            }
        },
        getMode: function() {
            if (!this.isTextOnly && this.isEnable) {
                return Trex.Paste.MODE_HTML;
            } else if (this.isTextOnly && this.isEnable) {
                return Trex.Paste.MODE_TEXT;
            } else {
                return Trex.Paste.MODE_OFF;
            }
        },
        /**
         * paste\uac00 \uc2e4\ud589\ub418\ub294 wysiwyg document \uac1d\uccb4
         * @returns {Object} document \uac1d\uccb4
         */
        getDocument: function () {
            if (!this.doc) {
                this.doc = this.canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE).getDocument();
            }
            return this.doc;
        },
        /**
         * clipboard\uc758 \ub0b4\uc6a9\uc744 \uc784\uc2dc \uc800\uc7a5\ud558\ub294 node
         * @returns {HTMLElement}
         */
        getPasteDummy: function () {
            return this.getDocument().getElementById('pasteDummy');
        },
        getProcessor: function() {
            if (!this.processor) {
                this.processor = this.canvas.getProcessor();
            }
            return this.processor;
        },
        /**
         * \uc774\ubca4\ud2b8 \uae30\ubcf8 \uae30\ub2a5\uc744 \uc81c\ud55c\ud55c\ub2e4.
         * @param {Object} ev
         */
        preventPasteDefault: function (ev) {
            if (ev.preventDefault) {
                ev.preventDefault();
                ev.stopPropagation();
            } else {
                ev.returnValue = _FALSE;
                ev.cancelBubble = _FALSE;
            }
        },
        pasteByClipboardGetData: function (ev) {
            this.preventPasteDefault(ev);

            this.isPasteProcessing = _TRUE;
            var clipboardData = ev.clipboardData;

            var types = $A(clipboardData.types);
            var html = '';
            var self = this;
            if (!this.isTextOnly && types.include('text/html')) {
                html = clipboardData.getData('text/html');
            } else if (types.include('text/plain')) {
                html = clipboardData.getData('text/plain');
            } else {
                html = '???';
            }

            this.removeRangeContents();
            this.saveRange();

            this.restoreRange();
            this.pasteHTML(this.cleaner.execute(html));
            this.isPasteProcessing = _FALSE;
        },
        pasteByRedirection: function (ev) {
            var self = this;
            this.isPasteProcessing = _TRUE;

            this.removeRangeContents();
            this.saveRange();
            var dummy = this.createPasteDummy();
            this.appendPasteDummy(dummy);
            this.setRangeToDummy(dummy);
            this.execPasteCommand();

            setTimeout(function () {
                self.restoreRange();
                self.copyContentToOriginalRange(dummy);
                self.isPasteProcessing = _FALSE;
            }, 1);

        },
        copyContentToOriginalRange: function (dummyNode) {
            var dummy = dummyNode || this.getPasteDummy();
            if (!dummy) {
                throw new Error('paste-dummy node is not found');
                return;
            }

            var cleanHtml = this.isTextOnly ? dummy.innerText : this.cleaner.execute(dummy.innerHTML);
            this.pasteHTML(cleanHtml);
        },
        createPasteDummy: function (tagName) {
            tagName = tagName || 'div';// default div;

            var node = this.getDocument().createElement(tagName);
            node.id = 'pasteDummy';
            node.innerHTML = Trex.__WORD_JOINER;
            node.style.position = 'absolute';
            node.style.overflow = 'hidden';
            node.style.left = '-999em';
            node.style.top = '0';
            node.style.width = '100%';
            node.style.height = '200px';
            node.style.background = 'gray';
            return node;
        },
        appendPasteDummy: function (dummyNode) {
            var doc = this.getDocument();
            doc.body.appendChild(dummyNode);
        },
        removePasteDummy: function() {
            var dummy = this.getPasteDummy();
            if (dummy) {
                $tom.remove(dummy);
                dummy  = _NULL;
            }
        },
        setRangeToDummy: function (dummyNode) {
            var doc = this.getDocument();
            var dummy = dummyNode || this.getPasteDummy();

            var processor = this.canvas.getProcessor();
            dummy.focus();
            processor.createGoogFromNodeContents(dummy).select();
        },
        execPasteCommand: function () {
            try {
                this.getDocument().execCommand('paste');
            } catch (e) {
                
                return _FALSE;
            }
            return _TRUE;
        },
        removeRangeContents: function() {
            var range = this.canvas.getProcessor().createGoogRange();
            if (range) {
                range.removeContents();
            }
        },
        saveRange: function() {
            var range = this.canvas.getProcessor().createGoogRange();
            if (range) {
                this.savedCaret = range.saveUsingCarets();
            }
        },
        restoreRange: function() {
            if (!this.savedCaret.isDisposed()) {
                this.savedCaret.restore();
            }
        },
        pasteHTML: function(html) {
            var self = this;
            this.canvas.execute(function (processor) {
                self.processor = processor;
                self.helper.pasteContent(html);
                self.removePasteDummy();
            });
        }
    });

    /**
     * Paste trident \ubaa8\ub4c8
     */

    Trex.Paste.I.TridentStandard = Trex.Mixin.create({
        $const: {
            __Identity: 'paste-trident-standard'
        },
        createPasteDummy: function (tagName) {
            tagName = tagName || 'div';
            var node = this.getDocument().createElement(tagName);
            node.id = 'pasteDummy';
            node.innerHTML = Trex.__WORD_JOINER;
            node.style.position = 'absolute';
            node.style.overflow = 'hidden';
            node.style.left = '-999em';
            node.style.top = '0';
            node.style.width = '100%';
            node.style.height = '200px';
            node.style.background = 'gray';
            node.setAttribute('contentEditable', _TRUE);// contentEditable \uc18d\uc131\uc744 \ubd80\uc5ec\ud55c\ub2e4
            ['beforedeactivate', 'focusin', 'focusout', 'paste'].each(function (name){
                    $tx.observe(node, name, function(e){
                        $tx.stopPropagation(e);
                    });
            });
            return node;
        },
        appendPasteDummy: function (dummyNode) {
            var doc = this.getDocument();
            doc.body.appendChild(dummyNode);
            //ie11 \uc740 body \ubc11\uc5d0\ub2e4 \uc0dd\uc131\ud574\uc57c \uc815\uc0c1\ub3d9\uc791 \ub41c\ub2e4.
        },
        pasteByRedirection: function (ev) {
            var self = this;
            this.isPasteProcessing = _TRUE;

            // IE\ub294 paste\uae30\ubcf8 \ub3d9\uc791\uc744 \ubb34\uc870\uac74 \ub9c9\ub294\ub2e4.
            this.preventPasteDefault(ev);

            this.removeRangeContents();
            this.saveRange();
            var dummy = this.createPasteDummy();
            this.appendPasteDummy(dummy);
            this.setRangeToDummy(dummy);
            this.execPasteCommand();

            setTimeout(function () {
                self.restoreRange();
                self.copyContentToOriginalRange(dummy);
                self.isPasteProcessing = _FALSE;
            }, 10);

        }
    });

    Trex.Paste.I.TridentLegacy = Trex.Mixin.create({
        $const: {
            __Identity: 'paste-trident-legacy'
        },
        createPasteDummy: function (tagName) {
            tagName = tagName || 'body';
            var node = this.getDocument().createElement(tagName);
            node.id = 'pasteDummy';
            node.innerHTML = Trex.__WORD_JOINER;
            node.style.position = 'absolute';
            node.style.overflow = 'hidden';
            node.style.left = '-999em';
            node.style.top = '0';
            node.style.width = '100%';
            node.style.height = '200px';
            node.style.background = 'gray';
            node.setAttribute('contentEditable', _TRUE);// contentEditable \uc18d\uc131\uc744 \ubd80\uc5ec\ud55c\ub2e4
            ['beforedeactivate', 'focusin', 'focusout', 'paste'].each(function (name){
                $tx.observe(node, name, function(e){
                    $tx.stopPropagation(e);
                });
            });
            return node;
        },
        appendPasteDummy: function (dummyNode) {
            var doc = this.getDocument();
            doc.body.parentNode.appendChild(dummyNode);
        },
        pasteByRedirection: Trex.Paste.I.TridentStandard.pasteByRedirection,
        setRangeToDummy: function (dummyNode) {
            var dummy = dummyNode || this.getPasteDummy();

            var range = dummy.createTextRange();
            range.moveToElementText(dummy);
            range.collapse(_TRUE);
            range.moveStart("character", 0);
            range.moveEnd("character", 0);
            range.execCommand('paste', _NULL, _FALSE);
        },
        execPasteCommand: function () {
            // setRangeToDummy\uc5d0\uc11c range.execCommand\ub97c \ud55c\ubc88\uc5d0 \uc2e4\ud589\ud558\uac8c \ub418\uc5b4 execPasteCommand\uc758 \ud560 \uc77c\uc740 \uc5c6\ub2e4.
        }
    });


    /**
     * Paste gecko windows\uc6a9 \ubaa8\ub4c8
     * - 2014.06.19 : windows\uc6a9 ff\ub294 "text/html"\uc774 \uc815\uc0c1 \ub3d9\uc791\ud558\uc9c0 \uc54a\uace0 \uc788\uc5b4\uc11c clipboardData \uac1d\uccb4\ub97c \uc774\uc6a9 \ud560 \uc218 \uc5c6\ub2e4.
     * - 2014.07.10 : windows\uc6a9 ff\uc758 "text/html" \ubabb \ubd88\ub7ec\uc624\ub294 \ubb38\uc81c\uac00 \ud574\uacb0\ub418\uc5b4 \ub2e4\uc2dc \uae30\ubcf8\uc73c\ub85c onNativePaste\ub97c \uc0ac\uc6a9\ud558\ub3c4\ub85d \ud55c\ub2e4.
     */
    Trex.Paste.I.GeckoForWindows = Trex.Mixin.create({
        $const: {
            __Identity: 'paste-gecko-for-windows'
        },
        onNativePaste: function (ev) {
            if (!this.canvas.isWYSIWYG()) {
                return _FALSE;
            }

            var dummy = this.getPasteDummy();
            if (dummy) {
                this.preventPasteDefault(ev);
                return _FALSE;
            }

                
                return this.pasteByRedirection(ev);
        },
        execPasteCommand: function () {
            // empty method
        }
    });

    Trex.Paste.Paster = Trex.Class.create({
        $mixins: [
            Trex.Paste.I.Standard,
            ($tx.msie && Trex.Paste.isMSSelection ? Trex.Paste.I.TridentLegacy : {}),
            ($tx.msie && !Trex.Paste.isMSSelection ? Trex.Paste.I.TridentStandard : {}),
            ($tx.os_win && $tx.gecko ? Trex.Paste.I.GeckoForWindows : {})
        ]
    });

    Trex.install("editor.getPaster",
        function (editor, toolbar, sidebar, canvas, config) {
            var cleaner = new Trex.Paste.Cleaner(editor, canvas);
            var pasteProcessor = new Trex.Paste.Helper(editor, canvas);
            var paster = new Trex.Paste.Paster(editor, canvas, cleaner, pasteProcessor);


            editor.getPaster = function () {
                return paster;
            };

            editor.getPasteCleaner = function () {
                return paster.cleaner;
            };

            editor.getPasteProcessor = function() {
                return pasteProcessor;
            };
        }
    );
}();

Trex.register("filter > paste",
    function(editor, toolbar, sidebar, canvas, config) {
        if(!($tx.msie && !Trex.Paste.isMSSelection))
            return;
        function removePasteBin(contents){
            var d = document.createElement('div');
            d.style.display = 'none';
            d.innerHTML = contents;
            document.body.appendChild(d);
            var el = document.getElementById('pasteDummy');
            if(el && $tom.findAncestor(el, function(node){
                    return node === d;
                }, function(node){
                    return $tom.isBody(node)||node.parentNode == _NULL;
                })){
                $tom.remove(el);
            }
            var res = d.innerHTML;
            $tom.remove(d);
            return res;
        }

        var _docparser = editor.getDocParser();
        _docparser.registerFilter(
            'filter/paste', {
                'source@load': function(contents){
                    return contents;
                },
                'html@load': function(contents){
                    return contents;
                },
                'source4save': function(contents){
                    return contents;
                },
                'html4save': function(contents){
                    return removePasteBin(contents);
                },
                'text4save': function(contents){
                    return contents;
                },
                'html2text': function(contents) {
                    return removePasteBin(contents);
                },
                'source2text': function(contents) {
                    return contents;
                },
                'source2html': function(contents){
                    return contents;
                },
                'html2source': function(contents){
                    return removePasteBin(contents);
                }
            });
    });
/*
 \uc54c\ub824\uc9c4 \ubb38\uc81c\ub4e4
 -
 \ub35c \uc911\uc694\ud55c \ubb38\uc81c\ub4e4
 - layout\uc5d0 \uc5ec\ub7ec \uac1c\uc758 \uc774\ubbf8\uc9c0\ub97c \ud55c\uaebc\ubc88\uc5d0 \uc62c\ub9b0 \uacbd\uc6b0\uc5d0,  saveHistory \ud558\uc9c0 \uc54a\uc74c
 - table resize \ub97c \ud55c \ud6c4\uc5d0 saveHistory \ud558\uc9c0 \uc54a\uc74c / modified+\ub9c8\uc6b0\uc2a4\ud074\ub9ad \uc870\ud569\uc77c \ub54c, saveHistory\ub97c \ud558\ub294 \ub85c\uc9c1\uc73c\ub85c \uc778\ud574 saveHistory\uac00 \ub420 \uc218 \uc788\ub294 \uacbd\uc6b0\uac00 \uc788\uc74c, but \uc644\ubcbd\ud558\uc9c0 \uc54a\uc74c
 - backspace / delete \ub4e0 \uc5ec\ub7ec \ubc88 \ub20c\ub800\uc744 \ub54c\uc5d0 \ud55c \ubc88\ub9cc saveHistory\ud558\uace0 \uc2f6\ub2e4.
 */

Trex.I.History = {};
Trex.I.History.Standard = {
    getRangeData: function () {
        throw Error("Unimplemented abstract method");
    },
    restoreRange: function (rangeData){
        throw Error("Unimplemented abstract method");
    }
};

Trex.I.History.Webkit = {
    getRangeData: function() {
        var p = this.canvas.getProcessor(),
            txSel = p.getTxSel(),
            rangeCount = txSel.getSel().rangeCount;
        var start, end;

        if (rangeCount) {
            var range = txSel.getSel().getRangeAt(0);
            var preSelectionRange = range.cloneRange();
            preSelectionRange.selectNodeContents(this.canvas.getCurrentPanel().getDocument().body);
            preSelectionRange.setEnd(range.startContainer, range.startOffset);
            start = preSelectionRange.toString().length;
            end = start + range.toString().length;
        } else {
            start = 0;
            end = 0;
        }

        return {
            start: start,
            end: end
        };
    },
    restoreRange: function(savedSel){
        var win = this.canvas.getCurrentPanel().getWindow();
        var doc = win.document;
        var containerEl = doc.body;
        var charIndex = 0, range = doc.createRange();
        range.setStart(containerEl, 0);
        range.collapse(true);
        var nodeStack = [containerEl], node, foundStart = false, stop = false;

        while (!stop && (node = nodeStack.pop())) {
            if (node.nodeType == 3) {
                var nextCharIndex = charIndex + node.length;
                if (!foundStart && savedSel.start >= charIndex && savedSel.start <= nextCharIndex) {
                    range.setStart(node, savedSel.start - charIndex);
                    foundStart = true;
                }
                if (foundStart && savedSel.end >= charIndex && savedSel.end <= nextCharIndex) {
                    range.setEnd(node, savedSel.end - charIndex);
                    stop = true;
                }
                charIndex = nextCharIndex;
            } else {
                var i = node.childNodes.length;
                while (i--) {
                    nodeStack.push(node.childNodes[i]);
                }
            }
        }

        var sel = win.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
    }
};

Trex.I.History.Trident = {
    getRangeData: function() {
        if (!this.canvas.isWYSIWYG()) {
            return;
        }
        var doc = this.canvas.getCurrentPanel().getDocument();
        var containerEl = doc.body;
        //refactory \ud544\uc694.
        try{
            var selectedTextRange = doc.selection.createRange();
        }catch(e){
            return {
                start:0,
                end:0
            }
        }
        var preSelectionTextRange = doc.body.createTextRange();
        preSelectionTextRange.moveToElementText(containerEl);
        try {
            preSelectionTextRange.setEndPoint("EndToStart", selectedTextRange);
            var start = preSelectionTextRange.text.length;

            return {
                start: start,
                end: start + selectedTextRange.text.length
            }
        }catch(e){

        }

        var onepoint = preSelectionTextRange.text.length;
        return {
            start: onepoint,
            end: onepoint
        }
    },
    restoreRange: function(savedSel) {
        if (!this.canvas.isWYSIWYG()) {
            return;
        }
        var doc = this.canvas.getCurrentPanel().getDocument();
        var containerEl = doc.body;
        var textRange = doc.body.createTextRange();
        textRange.moveToElementText(containerEl);
        textRange.collapse(true);
        textRange.moveEnd("character", savedSel.end);
        textRange.moveStart("character", savedSel.start);
        textRange.select();
    }
};

/**
 * @fileoverview default history class for redo/undo
 *
 * @author iamdanielkim
 */

/**
 * @namespace
 */
(function(){
    function keepMaxLength(list, maxLength) {
        while (list.length >= maxLength) {
            list.shift();
        }
    }

	var MAX_UNDO_COUNT = 20;

	/**
	 * @class
	 */
	Trex.History = Trex.Class.create({
        $mixins: [
            Trex.I.History.Standard,
            (($tx.msie_nonstd)? Trex.I.History.Trident: Trex.I.History.Webkit)
        ],
        maxUndoCount: MAX_UNDO_COUNT,
        canvas: _NULL,
        undoMementoList: _NULL,
        redoMementoList: _NULL,
        currentMemento: _NULL,
        contentModified: _FALSE,
        initialize: function(canvas){
            this.canvas = canvas;
            this.setupHistory();
            this.bindKeyEvent(canvas);
        },
        bindKeyEvent: function(canvas) {
            var self = this;
            canvas.observeJob('canvas.panel.undo', function() {
                self.undoHandler();
            });
            canvas.observeJob('canvas.panel.redo', function() {
                self.redoHandler();
            });
        },
        setupHistory: function() {
            this.initHistory({ content: $tom.EMPTY_PARAGRAPH_HTML, scrollTop: 0 });
        },
        canUndo: function() {
            return this.undoMementoList.length > 0;
        },
        canRedo: function() {
            return this.redoMementoList.length > 0;
        },
        setCurrentMemento: function(memento) {
            this.currentMemento = memento;
        },
        undoHandler: function() {
            var self = this;
            self.saveHistoryIfEdited();
            if (!self.canUndo()) {
                return;
            }

            var undoMemento = self.undoMementoList.pop();
            undoMemento.undo();
            self.redoMementoList.push(undoMemento);

            self.setCurrentMemento(undoMemento);
        },
        redoHandler: function() {
            var self = this;
            self.saveHistoryIfEdited();
            if (!self.canRedo()) {
                return;
            }

            var redoMemento = self.redoMementoList.pop();
            redoMemento.redo();
            self.undoMementoList.push(redoMemento);

            self.setCurrentMemento(redoMemento);
        },
        initHistory: function(data) {
            var self = this;
            self.undoMementoList = [];
            self.redoMementoList = [];

            var newMemento = new Memento();
            var initialData = Object.extend({ content: $tom.EMPTY_PARAGRAPH_HTML, scrollTop: 0 }, data);
            newMemento.addUndoData(initialData);
            newMemento.addHandler(self.getTextHandler());
            self.setCurrentMemento(newMemento);
        },
        saveHistory: function(before, after, handler) {
            var self = this;
            var undoMementoList = self.undoMementoList;
            var currentMemento = self.currentMemento;

            self.redoMementoList = [];

            if (arguments.length == 3) {
                currentMemento.addUndoRedData(before, after, handler);
            }
            var textData = self.getTextData();
            currentMemento.addRedoData(textData);
            keepMaxLength(undoMementoList, self.maxUndoCount);
            undoMementoList.push(currentMemento);

            var newMemento = new Memento();
            newMemento.addHandler(self.getTextHandler());
            newMemento.addUndoData(textData);
            self.setCurrentMemento(newMemento);

            self.contentModified = _FALSE;
        },
        injectHistory: function(before, after, handler) {
            if (!this.canUndo()) {
                return;
            }
            var undoMementoList = this.undoMementoList;
            var lastMemento = undoMementoList[undoMementoList.length - 1];
            lastMemento.addUndoRedData(before, after, handler);
        },
        saveHistoryIfEdited: function() {
            if (this.contentModified) {
                this.saveHistory();
            }
        },
        saveHistoryByKeyEvent: function(event) {
            var key = {
                code: event.keyCode,
                ctrl: event.ctrlKey || (event.keyCode === 17),
                alt: event.altKey || (event.keyCode === 18),
                shift: event.shiftKey || (event.keyCode === 16)
            };

            if (key.code == 229) {                // ignore mouse click in ff.
                return;
            }

            var self = this;
            if (key.code == Trex.__KEY.ENTER || key.code == Trex.__KEY.SPACE || key.code == Trex.__KEY.TAB) {
                self.saveHistoryIfEdited();
            } else if (key.code == Trex.__KEY.DELETE || key.code == Trex.__KEY.BACKSPACE) {
                self.saveHistory();
            } else if ((key.code == Trex.__KEY.PASTE || key.code == Trex.__KEY.CUT) && key.ctrl) {
                self.saveHistory();
            } else if (((key.code > 32 && key.code < 41) && key.shift) || (key.code == 65 && key.ctrl)) {   // shift + arrow,  home, end,  etc..  / select all
                self.saveHistoryIfEdited();
            } else if (key.ctrl || key.alt || (key.shift && key.code == 16)) {
                // content isn't modified
            } else {
                self.contentModified = _TRUE;
            }
        },
        getTextHandler: function() {
            var canvas = this.canvas;
            var self = this;
            return function(data) {
                canvas.setContent(data.content);

                var DEFAULT_RESRORE_RANGE = {start: 0, end: 0};
                var range = data.range || DEFAULT_RESRORE_RANGE;
                self.restoreRange(range);

                if ($tx.msie_nonstd) {
                    // #FTDUEDTR-1122
                    setTimeout(function() {
                        canvas.setScrollTop(data.scrollTop);
                    }, 0);
                }
            }
        },
        getTextData:function() {
            return {
                content: this.canvas.getContent(),
                scrollTop: this.canvas.getScrollTop(),
                range: this.getRangeData()
            }
        }
    });

    var Memento = Trex.Class.create({
        initialize: function() {
            this.before = {};
            this.after = {};
            this.handlers = [];
        },
        addUndoRedData: function(before, after, handler) {
            Object.extend(this.before, before);
            Object.extend(this.after, after);
            this.handlers.push(handler);
        },
        addHandler: function(handler) {
            this.handlers.push(handler);
        },
        addUndoData: function(data) {
            Object.extend(this.before, data);
        },
        addRedoData: function(data) {
            Object.extend(this.after, data);
        },
        undo: function() {
            var self = this;
            self.handlers.each(function(handler) {
                handler(self.before);
            });
        },
        redo: function() {
            var self = this;
            self.handlers.each(function(handler) {
                handler(self.after);
            });
        }
    });
})();
/**
 * @fileOverview
 * \ucee8\ud150\uce20\ub97c \uac00\uc9c0\uace0 \uc788\ub294 \ud3b8\uc9d1 \uc601\uc5ed\uc744 \uc218\uc815, \uad00\ub9ac\ud558\ub294 Trex.Canvas \uad00\ub828 Source\ub85c
 * \ub300\ubd80\ubd84 \uac01 panel\ub4e4\uc5d0\uac8c \ud589\ub3d9\ub4e4\uc744 \uc704\uc784\ud55c\ub2e4.
 * \ud3b8\uc9d1 \uc601\uc5ed = panel = TextPanel, HtmlPanel, WysiwygPanel
 */
(function(Trex) {
    var QUERY_TRIGGER_KEYCODES = new $tx.Set(13, 8, 32, 33, 34, 37, 38, 39, 40, 46);
    var shouldTriggerQuery = function(keyCode) {
        return QUERY_TRIGGER_KEYCODES.contains(keyCode);
    };

    TrexConfig.add({
        "canvas": {
            doctype: "auto", // edge
            mode: ["text", "html", "source"],
            styles: {
                color: "#333333",
                fontFamily: "Dotum",
                fontSize: "9pt",
                backgroundColor: "#ffffff",
                lineHeight: "1.5",
                padding: "8px"
            },
			pMarginZero: true,
            selectedMode: "html",
            readonly: _FALSE,
            initHeight: 400,
            minHeight: 200,
            ext: 'html',
            param: "",
            newlinepolicy: "p",
            showGuideArea: _TRUE,
            convertingText: _TRUE,
			escapeTextModeContents: _TRUE,
			removeTextModeBr: _FALSE,
            respectVisibilityInDesign: _TRUE,
            dropZone: {
                use:_FALSE,
                useImageUpload: _TRUE,
                useFileUpload: _FALSE
            }
        }
    }, function(root) {
        var _config = TrexConfig.get('canvas', root);
        var _evConfig = root.events;
        _config.initializedId = root.initializedId || '';
        _config.useHotKey = _evConfig.useHotKey;
        var _switcher = TrexConfig.getTool('switcher', root);
        if (Trex.available(_switcher, "switcher" + _config.initializedId)) {
            _config.mode = _switcher.options.pluck("data");
        }
        var _fontfamily = TrexConfig.getTool('fontfamily', root);
        if (Trex.available(_fontfamily, "fontfamily" + _config.initializedId)) {
            if(_fontfamily.webfont && _fontfamily.webfont.use) {
                _config.webfont = _fontfamily.webfont;
                _config.webfont.options.each(function(element) {
                    element.url = TrexConfig.getUrl(element.url);
                });
            }
        }
        var _resizer = TrexConfig.get('resizer', root);
        if (_resizer) {
            _config.minHeight = _resizer.minHeight;
        }
        /**
         * \uc5d0\ub514\ud130\ud1b5\ud569 \ubc84\uc804\uc73c\ub85c \ud55c\uba54\uc77c \ubc30\ud3ec\uc2dc\uc5d0\ub294
         * \uc717\uc904 \uc8fc\uc11d\ud574\uc81c, \uc544\ub7ab\uc904 \uc0ad\uc81c
         */
        //_config.wysiwygUrl = TrexConfig.getUrl(["#host#path/pages/daumx/", "wysiwyg_", (_config.serviceWysiwyg || "" ), ((_config.doctype == "html") ? "html" : "xhtml"), ".", (_config.ext ? _config.ext : "html"), "?prefix=" + root.initializedId, "&", _config.param].join(""));
        _config.wysiwygUrl = TrexConfig.getUrl([(_config.wysiwygPath || "#host#path/pages/daumx/"), "wysiwyg_", (_config.serviceWysiwyg || "" ), ((_config.doctype == "html") ? "html" : "xhtml"), ".", (_config.ext ? _config.ext : "html"), "?prefix=" + root.initializedId, "&", _config.param].join(""));

        /**
         * doctype \uacb0\uc815\uae30\uc900
         */
        if (_config.doctype == 'auto') {
            if ($tx.msie && $tx.msie_quirks) {
                _config.doctype = 'quirks';
            } else {
                _config.doctype = 'edge';
            }
        }

    });

    TrexConfig.add({
        "size": {

        }
    });
    /**
     * \ucee8\ud150\uce20\ub97c \uac00\uc9c0\uace0 \uc788\ub294 \ud3b8\uc9d1 \uc601\uc5ed\uc744 \uc218\uc815, \uad00\ub9ac\ud558\ub294 Trex.Canvas \uac1d\uccb4\ub85c <br/>
     * \ub300\ubd80\ubd84 \uac01 panel\ub4e4\uc5d0\uac8c \ud589\ub3d9\ub4e4\uc744 \uc704\uc784\ud55c\ub2e4. <br/>
     * \uac01\uac01\uc758 panel\ub4e4\uc740 \ud574\ub2f9 Processor\ub4e4\uc744 \ud3ec\ud568\ud55c\ub2e4. <br/>
     * \ud3b8\uc9d1 \uc601\uc5ed = panel = TextPanel, HtmlPanel, WysiwygPanel
     *
     * @class
     * @extends Trex.I.JobObservable Trex.I.KeyObservable
     * @param {Object} editor
     * @param {Object} config
     */
    Trex.Canvas = Trex.Class.create( /** @lends Trex.Canvas.prototype */{
        /** @ignore */
        $const: {
            /** @name Trex.Canvas.__TEXT_MODE */
            __TEXT_MODE: "text",
            /** @name Trex.Canvas.__HTML_MODE */
            __HTML_MODE: "source",
            /** @name Trex.Canvas.__WYSIWYG_MODE */
            __WYSIWYG_MODE: "html",
            __WYSIWYG_PADDING: 8,
            __IMAGE_PADDING: 5
        },
        /** @ignore */
        $mixins: [Trex.I.JobObservable, Trex.I.KeyObservable, Trex.I.ElementObservable, Trex.I.MouseoverObservable],
        /** Editor instance */
        editor: _NULL,
        /** Canvas Dom element, Generally $tx('tx_canvas') */
        elContainer: _NULL,
        /** Canvas Config */
        config: _NULL,
        /** History Instance for redo/undo */
        history: _NULL,
        /**
         * Panels \uac1d\uccb4
         * @private
         * @example
         * 	canvas.panels['html']
         * 	canvas.panels['source']
         * 	canvas.panels['text']
         */
        panels: _NULL,
        initialize: function(editor, rootConfig) {

            this.editor = editor;
            var _config = this.config = TrexConfig.get('canvas', rootConfig);
            var _initializedId = ((rootConfig.initializedId) ? rootConfig.initializedId : "");

            this.elContainer = $tx("tx_canvas" + _initializedId);
            this.wysiwygEl = $tx("tx_canvas_wysiwyg_holder" + _initializedId);
            this.sourceEl = $tx("tx_canvas_source_holder" + _initializedId);
            this.textEl = $tx("tx_canvas_text_holder" + _initializedId);

            this.initConfig(rootConfig);
            this.createPanel();
            this.history = new Trex.History(this, _config);
            this.setCanvasSize({
                height: _config.initHeight
            });
        },
        initConfig: function(rootConfig) {
            var _config = this.config;
            /**
             * root config\ub97c \uc5bb\uc5b4\uc628\ub2e4.
             * @private
             * @returns {Object} root config
             */
            this.getRootConfig = function() {
                return rootConfig;
            };

            /**
             * Canvas\uc758 config\ub97c \uac00\uc838\uc628\ub2e4.
             * @returns {Object} config
             */
            this.getConfig = function() {
                return _config;
            };

            /**
             * wysiwyg panel\uc758 \uc2a4\ud0c0\uc77c config\ub97c \uac00\uc838\uc628\ub2e4.
             * @param {String} name - \uc2a4\ud0c0\uc77c\uba85 optional
             * @returns {Object} \uc2a4\ud0c0\uc77c config
             * @example
             *  canvas.getStyleConfig();
             */
            this.getStyleConfig = function(name) {
                if(name) {
                    return _config.styles[name];
                } else {
                    return _config.styles;
                }
            };
			
			var _sizeConfig = TrexConfig.get('size', rootConfig);
			this.measureWrapWidth = function() {
                _sizeConfig.wrapWidth = this.getContainerWidth(); // TODO FTDUEDTR-1214
            };
			this.measureWrapWidth();
	        if(!_sizeConfig.contentWidth) {
                _sizeConfig.contentWidth = _sizeConfig.wrapWidth;
            }
            _sizeConfig.contentPadding = _config.styles.padding.parsePx(); //15

            /**
             * canvas size \uad00\ub828 config\ub97c \uc5bb\uc5b4\uc628\ub2e4.
             * @returns {Object} size config
             */
            this.getSizeConfig = function() {
                return _sizeConfig;
            };
        },
        getContainerWidth: function() {
            return $tx.getDimensions(this.elContainer).width;
        },
        /**
         * Panels \uac1d\uccb4\ub4e4\uc744 \ucd08\uae30\ud654\ud55c\ub2e4.
         * @private
         */
        createPanel: function() {
            var _canvas = this;
            var _config = this.config;
            this.panels = {};
            this.mode = _config.selectedMode || Trex.Canvas.__WYSIWYG_MODE;
            if (this._isForceTextMode()) {
                this.mode = Trex.Canvas.__TEXT_MODE;
            }
            var _panelCreater = {
                "text": function(_config) {
                    return new Trex.Canvas.TextPanel(_canvas, _config);
                },
                "source": function(_config) {
                    return new Trex.Canvas.HtmlPanel(_canvas, _config);
                },
                "html": function(_config) {
                    return new Trex.Canvas.WysiwygPanel(_canvas, _config);
                }
            };
            _config.mode.each(function(name) {
                if (_panelCreater[name]) {
                    _canvas.panels[name] = _panelCreater[name](_config);
                }
            });
            for(var _p in _canvas.panels) {
                if (this.mode == _p) {
                    _canvas.panels[_p].show();
                } else {
                    _canvas.panels[_p].hide();
                }
            }
            _canvas.observeJob('canvas.panel.iframe.load', function(panelDoc) {
                _canvas.fireJobs(Trex.Ev.__IFRAME_LOAD_COMPLETE, panelDoc);
            });
        },
        _isForceTextMode: function() {
            // \uae30\uc874\uc5d0\ub294 \uc544\ub798\uc758 \uc870\uac74\uc774\uc5c8\uc73c\ub098 \ubaa8\ubc14\uc77c\uc5d0\uc11c\uc758 \ud638\ud658\uc740 \uc544\uc9c1 \ubb38\uc81c\uac00 \ub9ce\uc544 \uc81c\ud55c\ud568. 20140430
            // ($tx.ios && $tx.ios_ver < 5) || ($tx.android && $tx.android_ver < 3)
            return $tx.ios || $tx.android;
        },
        /**
         * Canvas\uc758 mode\ub97c \ubc14\uafb8\ub294\uac83\uc73c\ub85c, \ud604\uc7ac \ud65c\uc131\ud654\ub418\uc5b4\uc788\ub294 panel\uc744 \ubcc0\uacbd\ud55c\ub2e4.
         * @param {String} newMode - \ubcc0\uacbd \ud560 mode\uc5d0 \ud574\ub2f9\ud558\ub294 \ubb38\uc790\uc5f4
         * @example
         *  editor.getCanvas().changeMode('html');
         *  editor.getCanvas().changeMode('source');
         *  editor.getCanvas().changeMode('text');
         */
        changeMode: function(newMode) {
            var _editor = this.editor;
            var oldMode = this.mode;
            if (oldMode == newMode) {
                return;
            }
            if (this._isForceTextMode() && oldMode == Trex.Canvas.__TEXT_MODE) {
                return;
            }
            var _oldPanel = this.panels[oldMode];
            var _newPanel = this.panels[newMode];
            if (!_oldPanel || !_newPanel) {
                throw new Error("[Exception]Trex.Canvas : not suppored mode");
            }
            var _oldContent = _oldPanel.getContent();
            var _content = _editor.getDocParser().getContentsAtChangingMode(_oldContent, oldMode, newMode);
            if (oldMode == Trex.Canvas.__WYSIWYG_MODE) { //NOTE: #FTDUEDTR-366
				if ($tx.msie_ver === 8) {
					_oldPanel.hide();
				} //prevent black screen from youtube iframe. #FTDUEDTR-1272
				_oldPanel.setContent("");
                try {
                    this.focusOnTop();
                }catch(e){}
            }
			try { //#FTDUEDTR-1111
            	_newPanel.setContent(_content);
			} catch (error) {
				alert(' - Error: ' + error.message + '\n\uc5d0\ub514\ud130 \ud0c0\uc785 \ubcc0\uacbd\uc5d0 \uc2e4\ud328\ud558\uc600\uc2b5\ub2c8\ub2e4.\n\uc798\ubabb\ub41c HTML\uc774 \uc788\ub294\uc9c0 \ud655\uc778\ud574\uc8fc\uc138\uc694.');
				_oldPanel.setContent(_oldContent);
				_oldPanel.show();
				return;
			}
            this.mode = newMode;
            this.fireJobs(Trex.Ev.__CANVAS_MODE_CHANGE, oldMode, newMode);
            _newPanel.setPanelHeight(_oldPanel.getPanelHeight());
            _newPanel.show();
            _oldPanel.hide();
            // FF2 bug:: When display is none,  designMode can't be set to on
            try {
                if (newMode == "html" && !this.getPanel("html").designModeActivated && $tx.gecko) {
                    this.getPanel("html").el.contentDocument.designMode = "on";
                    this.getPanel("html").designModeActivated = _TRUE;
                }
            } catch (e) {
                throw e;
            }
        },
        /**
         * \ud604\uc7ac panel\uc5d0 \ud3ec\ucee4\uc2a4\ub97c \uc900\ub2e4.
         */
        focus: function() {
            this.panels[this.mode].focus();
        },
        /**
         * \ubcf8\ubb38\uc758 \ucc98\uc74c\uc73c\ub85c \uce90\ub7ff\uc744 \uc62e\uae34\ub2e4. - Only Wysiwyg
         */
        focusOnTop: function() {
            this.getProcessor().focusOnTop();
        },
        /**
         * \ubcf8\ubb38\uc758 \ub9c8\uc9c0\ub9c9\uc73c\ub85c \uce90\ub7ff\uc744 \uc62e\uae34\ub2e4. - Only Wysiwyg
         */
        focusOnBottom: function() {
            this.getProcessor().focusOnBottom();
        },
        /**
         * canvas\uc758 position\uc744 \uac00\uc838\uc628\ub2e4.
         * @returns {Object} position = { x: number, y:number }
         */
        getCanvasPos: function() {
            var _position = $tx.cumulativeOffset(this.elContainer);
            return {
                'x': _position[0],
                'y': _position[1]
            };
        },
        /**
         * canvas\uc758 height\ub97c \ubcc0\uacbd\ud55c\ub2e4.
         * @param {String} size (px)
         * @example
         *  canvas.setCanvasSize({
         *  	height: "500px"
         *  });
         */
        setCanvasSize: function(size) {
            if (this.panels[this.mode] && size.height) {
                this.panels[this.mode].setPanelHeight(size.height);
            } else {
                throw new Error("[Exception]Trex.Canvas : argument has no property - size.height ");
            }
        },
        /**
         * @Deprecated use isWYSIWYG()
         */
        canHTML: function() {
            return this.isWYSIWYG();
        },
        isWYSIWYG: function () {
            return this.mode === Trex.Canvas.__WYSIWYG_MODE;
        },
        /**
         * panel \uac1d\uccb4\ub97c \uac00\uc838\uc628\ub2e4.
         * @param {String} mode - \uac00\uc838\uc62c panel \ubaa8\ub4dc\uba85
         * @returns {Object} - parameter\uc5d0 \ud574\ub2f9\ud558\ub294 Panel
         * @example
         * 	this.getPanel('html').designModeActivated = true;
         */
        getPanel: function(mode) {
            if (this.panels[mode]) {
                return this.panels[mode];
            } else {
                return _NULL;
            }
        },
        /**
         * \ud604\uc7ac \ud65c\uc131\ud654\ub418\uc5b4\uc788\ub294 panel \uac1d\uccb4\ub97c \uac00\uc838\uc628\ub2e4.
         * @returns {Object} - \ud65c\uc131\ud654\ub418\uc5b4\uc788\ub294 panel \uac1d\uccb4
         */
        getCurrentPanel: function() {
            if (this.panels[this.mode]) {
                return this.panels[this.mode];
            } else {
                return _NULL;
            }
        },
        /**
         * \ud604\uc7ac \ud65c\uc131\ud654\ub418\uc5b4\uc788\ub294 panel\uc758 processor\uc744 \uac00\uc838\uc628\ub2e4.
         * @returns {Object} - \ud65c\uc131\ud654\ub418\uc5b4\uc788\ub294 panel\uc758 processor \uac1d\uccb4
         */
        getProcessor: function(mode) {
            if ( !mode ){
                return this.panels[this.mode].getProcessor();
            }else{
                return this.panels[mode].getProcessor();
            }
        },
        /**
         * \ubcf8\ubb38\uc758 \ub0b4\uc6a9\uc744 \uac00\uc838\uc628\ub2e4
         * @returns {String}
         */
        getContent: function() {
            var _content = this.panels[this.mode].getContent();
            if(_content) {
                _content = _content.replace(Trex.__WORD_JOINER_REGEXP, ""); //NOTE: \uc11c\ube44\uc2a4\uc758 DB charset\uc774 euc-kr \uacc4\uc5f4\uc77c \uacbd\uc6b0 \ubb38\uc81c\uac00 \uc788\uc74c.
            }
            return _content;
        },
        /**
         * \ud604\uc7ac Wysiwyg \uc601\uc5ed\uc758 \uc218\uc9c1 \uc2a4\ud06c\ub864 \uac12\uc744 \uc5bb\uc5b4\uc628\ub2e4. - Only Wysiwyg
         * @function
         * @returns {Number} \uc218\uc9c1 \uc2a4\ud06c\ub864 \uac12
         * @see Trex.Canvas.WysiwygPanel#getScrollTop
         */
        getScrollTop: function() {
            if(!this.isWYSIWYG()) {
                return 0;
            }
            return this.panels[this.mode].getScrollTop();
        },
        /**
         * Wysiwyg \uc601\uc5ed\uc758 \uc218\uc9c1 \uc2a4\ud06c\ub864 \uac12\uc744 \uc14b\ud305\ud55c\ub2e4. - Only Wysiwyg
         * @function
         * @param {Number} scrollTop - \uc218\uc9c1 \uc2a4\ud06c\ub864 \uac12
         * @see Trex.Canvas.WysiwygPanel#setScrollTop
         */
        setScrollTop: function(scrollTop) {
            if(!this.isWYSIWYG()) {
                return;
            }
            this.panels[this.mode].setScrollTop(scrollTop);
        },
        /**
         * \ud604\uc7ac \ud65c\uc131\ud654\ub41c panel\uc5d0 \ucee8\ud150\uce20\ub97c \uc8fc\uc5b4\uc9c4 \ubb38\uc790\uc5f4\ub85c \uc218\uc815\ud55c\ub2e4.
         * @param {String} content - \ucee8\ud150\uce20
         */
        setContent: function(content) {
            this.panels[this.mode].setContent(content);
            this.includeWebfontCss(content);
        },
        /**
         * panel\uc5d0 \ucee8\ud150\uce20\ub97c \uc8fc\uc5b4\uc9c4 \ubb38\uc790\uc5f4\ub85c \ucd08\uae30\ud654\ud55c\ub2e4.
         * @param {String} content - \ucee8\ud150\uce20
         */
        initContent: function(content) {
            this.history.initHistory({
                'content': content
            });
            this.panels[this.mode].setContent(content);
            this.includeWebfontCss(content);
            this.fireJobs(Trex.Ev.__CANVAS_DATA_INITIALIZE, Trex.Canvas.__WYSIWYG_MODE, _NULL);
			/* //NOTE: \uba54\uc77c\uc740 \uc218\uc815\uc774 \uc5c6\uc74c. \ub2f5\uc7a5 \uc804\ub2ec\uc758 \uacbd\uc6b0\uc5d0\ub294 \ubcf8\ubb38 \uc0c1\ub2e8\uc5d0 \ud3ec\ucee4\uc2f1\uc774 \uac00\ub3c4\ub85d.
            if ( $tx.gecko ){
                var me = this;
                setTimeout( function(){
                    me.focusOnBottom();
                },500)
            }else{
                this.focusOnBottom();
            }
			*/
        },
        /**
         * \ucee8\ud150\uce20\ub97c \ud30c\uc2f1\ud558\uc5ec \uc0ac\uc6a9\ub418\uace0 \uc788\ub294 \uc6f9\ud3f0\ud2b8\uac00 \uc788\uc73c\uba74, \uc6f9\ud3f0\ud2b8 css\ub97c \ub85c\ub529\ud55c\ub2e4. - Only Wysiwyg
         * @param {string} content
         * @see Trex.Canvas.WysiwygPanel#includeWebfontCss
         */
        includeWebfontCss: function(content) {
            if(!this.isWYSIWYG()) {
                return;
            }
            return this.panels[this.mode].includeWebfontCss(content);
        },
        /**
         * \ubcf8\ubb38\uc5d0 \uc0ac\uc6a9\ub41c \uc6f9\ud3f0\ud2b8\uba85 \ubaa9\ub85d\uc744 \ub9ac\ud134\ud55c\ub2e4. - Only Wysiwyg
         * @function
         * @returns {Array} \uc0ac\uc6a9\ud558\uace0 \uc788\ub294 \uc6f9\ud3f0\ud2b8\uba85 \ubaa9\ub85d
         * @see Trex.Canvas.WysiwygPanel#getUsedWebfont
         */
        getUsedWebfont: function() {
            if(!this.isWYSIWYG()) {
                return [];
            }
            return this.panels[this.mode].getUsedWebfont();
        },
        /**
         * \uc790\ubc14\uc2a4\ud06c\ub9bd\ud2b8\ub97c \ub3d9\uc801\uc73c\ub85c \uc2e4\ud589\ud55c\ub2e4 - Only Wysiwyg
         * @param {String} scripts - \uc790\ubc14\uc2a4\ud06c\ub9bd\ud2b8 \ubb38\uc790\uc5f4
         */
        runScript: function(scripts) {
            if(!this.isWYSIWYG()) {
                return [];
            }
            this.panels[this.mode].runScript(scripts);
        },
        /**
         * \uc790\ubc14\uc2a4\ud06c\ub9bd\ud2b8 \uc18c\uc2a4\ub97c \ub85c\ub529\ud558\uc5ec \ub3d9\uc801\uc73c\ub85c \uc2e4\ud589\ud55c\ub2e4 - Only Wysiwyg
         * @param {String} url - \uc790\ubc14\uc2a4\ud06c\ub9bd\ud2b8 url
         */
        importScript: function(url, callback) {
            if(!this.isWYSIWYG()) {
                return [];
            }
            this.panels[this.mode].importScript(url, callback);
        },
        /**
         * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \uc0c1\ud0dc \uac12\uc744 \uc54c\uae30\uc704\ud574 \uc8fc\uc5b4\uc9c4 \ud568\uc218\ub97c \uc2e4\ud589\uc2dc\ud0a8\ub2e4. - Only Wysiwyg
         * @param {Function} handler - \uc8fc\uc5b4\uc9c4 \ud568\uc218
         * @example
         * 		var _data = canvas.query(function(processor) {
         *			return processor.queryCommandState('bold');
         *		});
         */
        query: function(handler) {
            if(!this.isWYSIWYG()) {
                return _NULL;
            }
            var _processor = this.getProcessor();
            /* Block Scrolling
             if($tx.msie) {
             _processor.focus();
             }
             */
            return handler(_processor);
        },
        /**
         * \uc120\ud0dd\ub41c \uc601\uc5ed\uc5d0 \uc8fc\uc5b4\uc9c4 handler\ub97c \uc2e4\ud589\uc2dc\ud0a8\ub2e4.
         * @param {Function} handler - \uc8fc\uc5b4\uc9c4 \ud568\uc218
         * @example
         * 		canvas.execute(function(processor) {
         *			processor.execCommand('bold', _NULL);
         *		});
         */
        execute: function(handler) {
	        var _history = this.history;
	        var _processor = this.getProcessor();
	        if (this.isWYSIWYG()) {
		        this.getPanel('html').ensureFocused();
		        if (_processor.restoreRange) {
			        setTimeout(function () { //NOTE: #FTDUEDTR-435
				        _processor.restoreRange();
				        handler(_processor);
			            _history.saveHistory();
				        _processor.restore();
			        }, 0);
		        } else {
				_processor.focus();
			        handler(_processor);
			        _history.saveHistory();
			        _processor.restore();
		        }
	        } else {
		        handler(_processor);
	        }
        },
        /**
         * caret\uc744 \uc8fc\uc5b4\uc9c4 \uc704\uce58\ub85c \uc774\ub3d9\ud55c\ub2e4. - Only Wysiwyg <br/>
         * aaa.bbb - bbb\ub77c\ub294 \ud074\ub798\uc2a4\ub97c \uac00\uc9c4 aaa \ub178\ub4dc\uc758 \ub2e4\uc74c\uc5d0 \ucee4\uc11c\ub97c \uc774\ub3d9\ud55c\ub2e4.
         * @param {String} scope
         */
        moveCaret: function(scope) {
            if(!scope) {
                return;
            }
            if(!this.isWYSIWYG()) {
                return;
            }
            this.getProcessor().moveCaretWith(scope);
        },
        /**
         * \uc120\ud0dd\ud55c \uc601\uc5ed\uc5d0 HTML \ucee8\ud150\uce20\ub97c \uc0bd\uc785\ud55c\ub2e4.
         * @param {String} content - \uc0bd\uc785\ud558\uace0\uc790 \ud558\ub294 HTML \ucee8\ud150\uce20
         * @param {Boolean} newline - \ud604\uc7ac \uc601\uc5ed\uc5d0\uc11c \ud55c\uc904\uc744 \ub744\uc6b4 \ud6c4 \uc0bd\uc785\ud560\uc9c0 \uc5ec\ubd80 true/_FALSE
         * @param {Object} wrapStyle - wrapper \ub178\ub4dc\uc5d0 \uc801\uc6a9\ud560 \uc2a4\ud0c0\uc77c, <br/>
         * 					newline\uc774 true \uc77c \uacbd\uc6b0\uc5d0\ub9cc \uc758\ubbf8\ub97c \uac16\ub294\ub2e4.
         */
        pasteContent: function(content, newline, wrapStyle) {
            newline = newline || _FALSE;
            this.execute(function(processor) {
                processor.pasteContent(content, newline, wrapStyle);
            });
        },
        /**
         * \uc120\ud0dd\ud55c \uc601\uc5ed\uc5d0 \ub178\ub4dc\ub97c \uc0bd\uc785\ud55c\ub2e4. - Only Wysiwyg
         * @param {Array|Element} node - \uc0bd\uc785\ud558\uace0\uc790 \ud558\ub294 \ub178\ub4dc \ubc30\uc5f4 \ub610\ub294 \ub178\ub4dc
         * @param {Boolean} newline - \ud604\uc7ac \uc601\uc5ed\uc5d0\uc11c \ud55c\uc904\uc744 \ub744\uc6b4 \ud6c4 \uc0bd\uc785\ud560\uc9c0 \uc5ec\ubd80 true/_FALSE
         * @param {Object} wrapStyle - wrapper \ub178\ub4dc\uc5d0 \uc801\uc6a9\ud560 \uc2a4\ud0c0\uc77c, <br/>
         * 					newline\uc774 true \uc77c \uacbd\uc6b0\uc5d0\ub9cc \uc758\ubbf8\ub97c \uac16\ub294\ub2e4.
         */
        pasteNode: function(node, newline, wrapStyle) {
            if (!this.isWYSIWYG()) {
                return;
            }
            newline = newline || _FALSE;
            this.execute(function(processor) {
                processor.pasteNode(node, newline, wrapStyle);
            });
        },
        /**
         * \ud604\uc7ac \ud65c\uc131\ud654\ub41c panel\uc5d0 \uc2a4\ud0c0\uc77c\uc744 \uc801\uc6a9\ud55c\ub2e4.
         * @param {Object} styles - \uc801\uc6a9\ud560 \uc2a4\ud0c0\uc77c
         */
        addStyle: function(styles) {
            this.panels[this.mode].addStyle(styles);
        },
        /**
         * \uc2a4\ud0c0\uc77c\uba85\uc73c\ub85c \ud604\uc7ac \ud65c\uc131\ud654\ub41c panel\uc758 \uc2a4\ud0c0\uc77c \uac12\uc744 \uc5bb\uc5b4\uc628\ub2e4.
         * @param {String} name - \uc2a4\ud0c0\uc77c\uba85
         * @returns {String} \ud574\ub2f9 \uc2a4\ud0c0\uc77c \uac12
         */
        getStyle: function(name) {
            return this.panels[this.mode].getStyle(name);
        },
        /**
         * \ud2b9\uc815 \ub178\ub4dc\uc758 Wysiwyg \uc601\uc5ed\uc5d0\uc11c\uc758 \uc0c1\ub300 \uc704\uce58\ub97c \uc5bb\uc5b4\uc628\ub2e4. - Only Wysiwyg
         * @function
         * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
         * @returns {Object} position \uac1d\uccb4 = {
         *								x: number,
         *								y: number,
         *								width: number,
         *								height: number
         *						}
         */
        getPositionByNode: function(node) {
            if(!this.isWYSIWYG()) {
                return {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };
            }
            return this.panels[this.mode].getPositionByNode(node);
        },



        onKeyDown: function(event) {
            var p = this.getProcessor();
            var doc = this.getCurrentPanel().getDocument();
            function getNodeAndOffsetAtSel(){
                var rng = goog.dom.Range.createFromBrowserSelection(doc.getSelection? doc.getSelection():p.getSel());
                if(!rng) return _NULL;
                var node = rng.getStartNode();
                var offset = rng.getStartOffset();
                return {node: node,
                    offset: offset}
            }
            var where = getNodeAndOffsetAtSel();
            this.fireJobs(Trex.Ev.__CANVAS_PANEL_KEYDOWN, event);
            var prev = null;
            if(event.keyCode == Trex.__KEY.BACKSPACE && where && p.isCollapsed() && (prev = $tom.prevNodeUntilTagName(where.node, where.offset, 'table')) && $tom.isTagName(prev, 'table')){
                $tx.stop(event);
                this.fireJobs(Trex.Ev.__CANVAS_PANEL_BACKSPACE_TABLE, prev);
            }
            if (this.config.useHotKey) {
                this.fireKeys(event);
            }
        },

        onKeyUp: function(event) {
            var keyCode = event.keyCode+'';

            if (shouldTriggerQuery(keyCode)) {
                this.getProcessor().clearDummy();
            }

            this.history.saveHistoryByKeyEvent(event);

            try {
                this.mayAttachmentChanged = _TRUE;
                this.fireJobs(Trex.Ev.__CANVAS_PANEL_KEYUP, event);
                if (this.isWYSIWYG() && shouldTriggerQuery(keyCode)) {
                    this.triggerQueryStatus();
                }
                if (keyCode === Trex.__KEY.DELETE || keyCode === Trex.__KEY.BACKSPACE) { //NOTE: (Del/Backspace) keys\ub97c \ub20c\ub7ec \ubcf8\ubb38\uc5d0\uc11c \ubb34\uc5c7\uc778\uac00\uac00 \uc0ad\uc81c\ub418\uc5c8\ub2e4\uace0 \uc0dd\uac01\ub420 \uacbd\uc6b0 \ucca8\ubd80\ub4e4\uc758 \uc2f1\ud06c\ub97c \ud655\uc778\ud55c\ub2e4.
                    this.fireJobs(Trex.Ev.__CANVAS_PANEL_DELETE_SOMETHING);
                }
            } catch(ignore) {
            }
        },
        /**
         * @function
         */
        onMouseOver: (function(){
            var fn = function(event) {
                try {
                    this.fireMouseover($tx.element(event));
                    this.fireJobs(Trex.Ev.__CANVAS_PANEL_MOUSEOVER, event);
                } catch (ignore) {
                }
            };
            return $tx.msie_nonstd? fn :$tx.throttle(fn, 50);
        })(),

        onMouseMove: (function(){
            var fn = function(event) {
                try {
                    this.fireJobs(Trex.Ev.__CANVAS_PANEL_MOUSEMOVE, event);
                } catch (ignore) {
                    
                }
            };
            return $tx.msie_nonstd? fn :$tx.throttle(fn, 50);
        })(),

        onMouseOut: (function(){
            var fn = function(event) {
                try {
                    this.fireJobs(Trex.Ev.__CANVAS_PANEL_MOUSEOUT, event);
                } catch (ignore) {
                }
            };
            return $tx.msie_nonstd? fn : $tx.throttle(fn, 50);
        })(),
        onMouseDown: function(event) {
            this.getProcessor().clearDummy();
            try {
                this.fireElements($tx.element(event));
            } catch(ignore) {
                
            }
            this.fireJobs(Trex.Ev.__CANVAS_PANEL_MOUSEDOWN, event);
            var history = this.history;
            history.saveHistoryIfEdited();
        },

        onMouseUp: function(event) {
            try {
                var self = this;
                self.fireJobs(Trex.Ev.__CANVAS_PANEL_MOUSEUP, event);
                setTimeout(function() {
                    var googRange = self.getProcessor().createGoogRange();
                    if (googRange) {
                        self.fireJobs(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, googRange);
                    }
                }, 20);
            } catch(ignore) {
                
            }
        },

        mayAttachmentChanged: _FALSE,

        onClick: function(event) {
            this.fireJobs(Trex.Ev.__CANVAS_PANEL_CLICK, event);
        },

        onDoubleClick: function(event) {
            this.fireJobs(Trex.Ev.__CANVAS_PANEL_DBLCLICK, event);
        },

        onDragOver: function(event) {
            this.fireJobs(Trex.Ev.__CANVAS_PANEL_DRAGOVER, event);
        },

        onDragEnter: function(event) {
            this.fireJobs(Trex.Ev.__CANVAS_PANEL_DRAGENTER, event);
        },

        onDragLeave: function(event) {
            this.fireJobs(Trex.Ev.__CANVAS_PANEL_DRAGLEAVE, event);
        },

        onDrop: function(event) {
            this.fireJobs(Trex.Ev.__CANVAS_PANEL_DROP, event);
        },

        onScroll: (function(){
            var fn = function(event) {
                this.fireJobs(Trex.Ev.__CANVAS_PANEL_SCROLLING, event);
            };
            return $tx.msie_nonstd? fn : $tx.throttle(fn, 50);
        })(),
		
		onPaste: function(event) {
			this.fireJobs(Trex.Ev.__CANVAS_PANEL_PASTE, event);
		},

        // TODO rename query status \ub77c\ub294 \ub9d0 \ub9d0\uace0 \ub2e4\ub978 \ub9d0 \uc5c6\uc744\uae4c?
        triggerQueryStatus: function() {
            this.cancelReservedQueryStatusTrigger();
            this.reserveQueryStatusTrigger();
        },

        reserveQueryStatusTrigger: function() {
            var self = this;
            this.reservedQueryStatusTrigger = setTimeout(function() {
                var googRange = self.getProcessor().createGoogRange();
                if (googRange) {
                    self.fireJobs(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, googRange);
                    self.fireElements(self.getProcessor().getNode());
                }
            }, 20); // IE\uc758 \uacbd\uc6b0 canvas.execute \uc5d0\uc11c setTimeout \ucc98\ub9ac \ud558\uae30 \ub54c\ubb38\uc5d0, execute \ub4a4\uc5d0 \ubd80\ub974\ub294 syncProperty\uac00 \uadf8 \ub4a4\uc5d0 \uc2e4\ud589\ub418\uac8c \ud558\ub824\uace0 20ms \ub51c\ub808\uc774 \uc900\ub2e4....
        },

        cancelReservedQueryStatusTrigger: function() {
            if (this.reservedQueryStatusTrigger) {
                clearTimeout(this.reservedQueryStatusTrigger);
            }
        },

        /**
         * @depreacated use canvas.triggerQueryStatus();
         */
        syncProperty: function() {
            this.triggerQueryStatus();
        }
    });

})(Trex);

Trex.module("bind canvas events for close external menus",
	function(editor, toolbar, sidebar, canvas/*, config*/) {
		var _shouldCloseMenus = function () {
			editor.fireJobs(Trex.Ev.__SHOULD_CLOSE_MENUS);
		};
		canvas.observeJob(Trex.Ev.__CANVAS_PANEL_CLICK, _shouldCloseMenus);
		canvas.observeJob(Trex.Ev.__CANVAS_SOURCE_PANEL_CLICK, _shouldCloseMenus);
		canvas.observeJob(Trex.Ev.__CANVAS_TEXT_PANEL_CLICK, _shouldCloseMenus);
	}
);

Trex.module("make getter for 'iframeheight' and 'iframetop' size",
    function(editor, toolbar, sidebar, canvas/*, config*/) {
        var _iframeHeight = 0;
        var _iframeTop = 0;

        function resetIframeAttributes() {
            var _wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
            _iframeHeight = _wysiwygPanel.getPanelHeight().parsePx();
            var _position = $tom.getPosition(_wysiwygPanel.el);
            _iframeTop = _position.y;
        }

        // canvas resize
        canvas.observeJob(Trex.Ev.__CANVAS_HEIGHT_CHANGE, function(height) {
            resetIframeAttributes();
        });
        canvas.observeJob(Trex.Ev.__CANVAS_FULL_SCREEN_CHANGE, function() {
            resetIframeAttributes();
        });
        canvas.observeJob(Trex.Ev.__CANVAS_NORMAL_SCREEN_CHANGE, function() {
            resetIframeAttributes();
        });
        canvas.observeJob('canvas.apply.background', function() {
            resetIframeAttributes();
        });
        canvas.observeJob('canvas.apply.letterpaper', function() {
            resetIframeAttributes();
        });
        canvas.reserveJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function() {
            resetIframeAttributes();
        },300);

        // attachbox change ui
        var attachbox = editor.getAttachBox();
        attachbox.observeJob(Trex.Ev.__ATTACHBOX_FULLSCREEN_SHOW, function() {
            resetIframeAttributes();
        });
        attachbox.observeJob(Trex.Ev.__ATTACHBOX_FULLSCREEN_HIDE, function() {
            resetIframeAttributes();
        });

        // window resize
        $tx.observe(_WIN, 'resize', function(){
            resetIframeAttributes();
        });

        // create interface
        canvas.getIframeHeight = function(){
            return _iframeHeight;
        };
        canvas.getIframeTop = function(){
            return _iframeTop;
        };
    }
);

Trex.module("sync attachment data periodically", function(editor, toolbar, sidebar, canvas/*, config*/) {
    setTimeout(function() {
        setInterval(function() {
            if (canvas.mayAttachmentChanged) {
                // TODO \uad73\uc774 event \ub97c \uc774\uc6a9\ud560 \ud544\uc694\uc5c6\uc774 \ubc14\ub85c \ud638\ucd9c\ud574\uc918\ub3c4 \ub420 \uac83 \uac19\ub2e4.
                canvas.fireJobs(Trex.Ev.__CANVAS_PANEL_DELETE_SOMETHING);
                canvas.mayAttachmentChanged = _FALSE;
            }
        }, 3000);
    }, 10000);
});

Trex.module("synchronize the font style when caret is in end of paragraph", function(editor, toolbar, sidebar, canvas/*, config*/) {
    // only gecko #FTDUEDTR-1415
    $tx.gecko && canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEUP, function(ev){
        if (canvas.isWYSIWYG()) {
            var clickEl = ev.target;
            var isParagraph = clickEl instanceof HTMLParagraphElement;
            var isHtml = clickEl instanceof HTMLHtmlElement;
            if (!isParagraph && !isHtml) {
                return;
            }

            var processor = canvas.getProcessor();
            var x = ev.pageX,
                y = ev.pageY;

            var caret = processor.doc.caretPositionFromPoint(x, y);
            var node = caret && caret.offsetNode;
            var des = node && $tom.descendants(node, '#text');
            if (!des || !des.length) {
                return;
            }

            var lastTextNode = des[des.length-1];
            if (lastTextNode) {
                var newRange = processor.createGoogRangeFromNodes(lastTextNode, lastTextNode.length, lastTextNode, lastTextNode.length);
                newRange.select();
            }
        }
    });
});

// FTDUEDTR-1431
Trex.module("apply respectVisibilityInDesign for old IE", function(editor, toolbar, sidebar, canvas, config) {
    var isOldIE = ($tx.msie && ($tx.msie_docmode < 9));
    isOldIE && canvas.observeJob(Trex.Ev.__CANVAS_MODE_CHANGE, function(oldMode, newMode){
        changeVisibilityValue();
    });
    isOldIE && canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function(ev){
        changeVisibilityValue();
    });

    var COMMAND_API = 'RespectVisibilityInDesign';
    function changeVisibilityValue() {
        if (canvas.isWYSIWYG()) {
            var processor = canvas.getProcessor();
            var state = processor.doc.queryCommandState(COMMAND_API);
            var configFlag = canvas.config.respectVisibilityInDesign;

            if (state != configFlag) {
                processor.doc.execCommand(COMMAND_API, false, configFlag);
                
            }
        }
    }
});
/**
 * @fileOverview
 * \uac01 panel\uc758 \ucee8\ud150\uce20\ub97c \uc218\uc815, \uad00\ub9ac\ud558\uae30 \uc704\ud55c \ucd94\uc0c1 \ud074\ub798\uc2a4 \uad00\ub828 Source
 */

/**
 * \uac01 panel\uc758 \ucee8\ud150\uce20\ub97c \uc218\uc815, \uad00\ub9ac\ud558\uae30 \uc704\ud55c \ud074\ub798\uc2a4\ub85c <br/>
 * WysiwygPanel, HtmlPanel, TextPanel\uc5d0\uc11c \uc0c1\uc18d\ubc1b\uc544 \uc0ac\uc6a9\ud55c\ub2e4. <br/>
 *
 * @abstract
 * @class
 * @param {Object} canvas
 * @param {Object} config - canvas\uc758 config
 */
Trex.Canvas.BasedPanel = Trex.Class.draft(/** @lends Trex.Canvas.BasedPanel.prototype */{
	initialize: function(canvas, config) {
		this.config = config;
		this.canvas = canvas;
		
		this.elHolder = this.getHolder(config);
		this.el = this.getPanel(config);
		if(!this.el) {
			throw new Error("[Exception]Trex.Canvas.Panel : panel element is not founded");
		}

		var _name = this.constructor.__MODE;
		/**
		 * panel\uc758 \uc774\ub984\uc744 \ub9ac\ud134\ud55c\ub2e4. 
		 * @function
		 * @returns {String} 'html'
		 */
		this.getName = function() { return _name; };
		
		this.lastHeight = _NULL;
	},
	/**
	 * \ucee8\ud150\uce20 \uc601\uc5ed\uc5d0 \ud3ec\ucee4\uc2a4\ub97c \uc900\ub2e4.
	 * @function
	 */
	focus: function() {
		this.el.focus();
	},
	/**
	 * panel\uc744 \ubcf4\uc774\uac8c\ud55c\ub2e4.
	 * @function
	 */
	show: function() {
		try{
			$tx.show(this.elHolder);
		}catch(e){}
	},
	/**
	 * panel\uc744 \uac10\ucd98\ub2e4.
	 * @function
	 */
	hide: function() {
		try{
			$tx.hide(this.elHolder);
		}catch(e){}
	},
	/**
	 * \uc2a4\ud0c0\uc77c\uba85\uc73c\ub85c \ucee8\ud150\uce20 \uc601\uc5ed\uc758 \uc2a4\ud0c0\uc77c \uac12\uc744 \uc5bb\uc5b4\uc628\ub2e4.
	 * @function
	 * @param {String} name - \uc2a4\ud0c0\uc77c\uba85
	 * @returns {String} \ud574\ub2f9 \uc2a4\ud0c0\uc77c \uac12
	 */
	getStyle: function(name) {
		if(this.el.style[name]) {
			return this.el.style[name];
		} else {
			return _NULL;
		}
	},
	/**
	 * \ucee8\ud150\uce20 \uc601\uc5ed\uc5d0 \uc2a4\ud0c0\uc77c\uc744 \uc801\uc6a9\ud55c\ub2e4.
	 * @function
	 * @param {Object} styles - \uc801\uc6a9\ud560 \uc2a4\ud0c0\uc77c
	 */
	addStyle: function(styles) {
		for(var name in styles) {
			if(this.el.style[name]) {
				this.el.style[name] = styles[name];
			}
		}
	},
	/**
	 * panel \uc601\uc5ed\uc758 x,y \uc704\uce58\uc640 \ub113\uc774, \ub192\uc774 \uac12\uc744 \uc5bb\uc5b4\uc628\ub2e4.
	 * @function
	 * @returns {Object} position \uac1d\uccb4 = {
	 *								x: number,
	 *								y: number,
	 *								width: number,
	 *								height: number
	 *						}
	 */
	getPosition: function(){
		return $tom.getPosition(this.el);
	},
	/**
	 * panel \uc601\uc5ed\uc758 \ub192\uc774\ub97c \uc5bb\uc5b4\uc628\ub2e4.
	 * @function
	 * @returns {String} textarea \uc601\uc5ed\uc758 \ub192\uc774 (px)
	 */
	getPanelHeight: function() { 
		return $tom.getHeight(this.el).toPx(); 
	},
	/**
	 * panel \uc601\uc5ed\uc758 \ub192\uc774\ub97c \uc14b\ud305\ud55c\ub2e4.
	 * @function
	 * @param {Number} height - textarea \uc601\uc5ed\uc758 \ub113\uc774 (px)
	 */
	setPanelHeight: function(height) {
		height = height.toPx();
		if(this.lastHeight == height) {
			return;
		}
		$tom.setHeight(this.el, height);
		this.lastHeight = height;
	}
});

(function() {
    /**
     * WYSIWYG \ud3b8\uc9d1 \uc601\uc5ed\uc5d0 \ud574\ub2f9\ud558\ub294 <iframe> \uc744 \ucd08\uae30\ud654\ud55c\ub2e4.
     * document.write \ubc29\uc2dd\uc744 \uc774\uc6a9\ud558\uc5ec iframe\uc744 \ucd08\uae30\ud654 \ud558\uba70, \uc6a9
     * IE + document.domain \uc774 \uc9c0\uc815\ub41c \uacbd\uc6b0 document.domain \uc774 \uc9c0\uc815\ub41c iframe(catalyst)\uc744 \uba3c\uc800 \ub85c\ub529\ud558\uc5ec
     * iframe \uc5d0 \uc811\uadfc\uac00\ub2a5\ud558\ub3c4\ub85d \ucc98\ub9ac \ud55c \ud6c4, document.write \ub97c \uc2e4\ud589\ud55c\ub2e4.
     * @private
     * @class
     */
    Trex.WysiwygIframeLoader = Trex.Class.create({
        initialize: function(iframe, iframeUrl, doctype) {
            this.iframe = iframe;
	        this.iframeUrl = iframeUrl;
			this.doctype = '';
			switch (doctype) {
			case "edge":
			case "loose":
			case "strict":
				this.doctype = doctype;
//			case "quirks":
			}
        },

        load: function(callback) {
            try {
                this.loadLocalIframe(callback, this.doctype);
            } catch (e) {
                this.reloadUsingCatalyst(callback);
            }
        },

        loadLocalIframe: function(callback, doctype) {
            var doc = this.iframe.contentWindow.document;
            doc.open();
			switch (doctype) {
			case "edge":
				doc.write(DOCTYPE_edge);
				break;
			case "loose":
				doc.write(DOCTYPE_loose);
				break;
			case "strict":
				doc.write(DOCTYPE_strict);
				break;
			}
            doc.write(wysiwygHTML);
            doc.close();
            // \ud558\uc704 \ud638\ud658\uc744 \uc704\ud558\uc5ec delay \ucc98\ub9ac\ud55c\ub2e4. \uae30\uc874 iframe observer \ub4e4\uc774 loading \uc774 \ube44\ub3d9\uae30\ub77c \uac00\uc815\ud558\uace0 \uc791\uc131\ub418\uc5b4\uc788\ub2e4.
            setTimeout(function() {
                callback(doc);
            }, 0);
        },

        reloadUsingCatalyst: function(callback) {
            //
            var self = this;
            _WIN.__tx_wysiwyg_iframe_load_complete = function() {
                self.loadLocalIframe(callback, ''); //\uc774 \uc2dc\uc810\uc5d0\uc120 \uc5b4\ucc28\ud53c doctype \uc744 \uc124\uc815\ud560 \uc218 \uc5c6\uc74c.
            };
	        if (!this.iframeUrl) {
		        var basePath = this.getIframePagePath();
				var doctype = this.doctype;
				switch (doctype) {
				case "edge":
				case "loose":
				case "strict":
					this.iframeUrl = basePath + "trex/iframe_loader_catalyst_" + doctype + ".html";
					break;
				default:
					this.iframeUrl = basePath + "trex/iframe_loader_catalyst.html";
				}
	        }

            var explicitDocumentDomain = (document.location.hostname != document.domain);
            if (explicitDocumentDomain) {
                this.iframeUrl = this.iframeUrl + ((this.iframeUrl.indexOf("?") > -1) ? "&" : "?") + "xssDomain=" + document.domain;
            }
            this.iframe.src = this.iframeUrl;
        },

        getIframePagePath: function() {
            return EditorJSLoader.getPageBasePath('editor.js');
        },

        // \uc61b\ub0a0 \uc2a4\ud0c0\uc77c
        loadRemoteIframe: function() {
            var iframe = this.el;
            iframe.setAttribute("src", this.canvasConfig.wysiwygUrl);
        }
    });


    function absolutizeURL(url) {
        var location = _DOC.location;
        if (/^(https?:|file:|)\/\//.test(url)) {
        } else if (url.indexOf("/") === 0) {
            url = "//" + location.host + ":" + (location.port || "80") + url;
        } else {
            var href = location.href;
            var cutPos = href.lastIndexOf("/");
            url = href.substring(0, cutPos + 1) + url;
        }
        return url;
    }

    var cssBasePath = absolutizeURL(EditorJSLoader.getBasePath()) + 'theme/' + TrexConfig.get("txSkin") + '/css/';
    document.write('<link rel="stylesheet" href="' + cssBasePath + 'editor.css" type="text/css"></link>');
	
	var DOCTYPE_edge = '<!DOCTYPE html>';
	var DOCTYPE_loose = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">';
	var DOCTYPE_strict = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">';
	
    var wysiwygHTML =
            '<html lang="ko"><head>' +
            '<meta http-equiv="Content-Type" content="text/html; charset=utf-8">' +
            '<title>Editor Wygiwyg Panel</title>' +
            '<script id="txScriptForEval"></script>' +
            '<link rel="stylesheet" href="' + cssBasePath + 'wysiwyg.css" type="text/css"></link>' +
            '<link rel="stylesheet" href="' + cssBasePath + 'view.css" type="text/css"></link>' +
            '<style id="txStyleForSetRule"></style>' +
            '</head>' +
            '<body class="tx-content-container">' +
            $tom.EMPTY_PARAGRAPH_HTML +
            '</body></html>';

})();

(function() {
    /**
     * \uc6f9\ud3f0\ud2b8\ub97c \ub85c\ub529\ud558\uae30 \uc704\ud55c \ud074\ub798\uc2a4\ub85c WysiwygPanel \ub0b4\ubd80\uc5d0\uc11c\ub9cc \uc0ac\uc6a9\ub41c\ub2e4.
     * @private
     * @class
     */
    Trex.WebfontLoader = Trex.Class.create({
        initialize: function(doc, config) {
            this.doc = doc;
            this.styleCnt = 0;
            this.defWebfont = config.styles.fontFamily;
            this.useWebfont = (config.webfont && config.webfont.use);
            this.webfontCfg = config.webfont || [];
            this.elStyleSheet = this.getStyleSheet();
        },

        load: function(content) {
            if (!$tx.msie) {
                return;
            }
            if (!content) {
                return;
            }
            if (!this.useWebfont) {
                return;
            }

            var _matchs = [];
            content += " // font-family:" + this.defWebfont;
            content.replace(/font-family\s*:\s*(\w*)/gi, function(full, name) {
                _matchs.push(name);
                return full;
            });
            if (_matchs.length == 0) {
                return;
            }

            var _loader = this;
            setTimeout(function() {
                var _matchedSource = _matchs.uniq().join("||");
                _loader.webfontCfg.options.each(function(item) {
                    if (item.url && _matchedSource.indexOf(item.data) > -1) {
                        _loader.imports(item);
                    }
                });
            }, 10);
        },

        getUsed: function() {
            if (!$tx.msie) {
                return [];
            }
            var _result = [];
            if (!this.useWebfont) {
                return _result;
            }
            this.webfontCfg.options.each(function(item) {
                if (!item.url) {
                    _result.push(item.data);
                }
            });
            return _result;
        },

        getStyleSheet: function() {
            return this.doc.styleSheets[this.styleCnt++];
        },

        imports: function(item) {
            try {
                this.elStyleSheet.addImport(item.url, 2);
            } catch(e) {
                this.elStyleSheet = this.getStyleSheet();
                this.elStyleSheet.addImport(item.url, 2);
            }
            item.url = _NULL;
        }
    });
})();
(function() {
    var __SCROLL_WIDTH = 16;
    /**
     * wysiwyg \uc601\uc5ed\uc5d0\uc11c\uc758 \ud2b9\uc815 \ub178\ub4dc\uc758 \uc0c1\ub300 \uc704\uce58\ub97c \uacc4\uc0b0\ud558\uae30 \uc704\ud55c \ud074\ub798\uc2a4\ub85c WysiwygPanel \ub0b4\ubd80\uc5d0\uc11c\ub9cc \uc0ac\uc6a9\ub41c\ub2e4.
     * @private
     * @class
     */
    Trex.WysiwygRelative = Trex.Class.create({
        initialize: function(iframe) {
            this.iframe = iframe;
        },
        getRelative: function(node) {
            var _relatives = { x:0, y:0, width:0, height:0 };
            var doc = this.iframe.contentWindow.document;
            if (node) {
                var _position = $tom.getPosition(node, _TRUE);
                var _frameHeight = $tom.getHeight(this.iframe);
                var _scrollTop = $tom.getScrollTop(doc);

                if (_position.y + _position.height < _scrollTop || _position.y > _scrollTop + _frameHeight) {
                    return _relatives;
                } else {
                    var _frameLeft = 0; //Holder \uae30\uc900
                    var _frameTop = 0; //Holder \uae30\uc900
                    var _frameWidth = $tom.getWidth(this.iframe);
                    var _scrollLeft = $tom.getScrollLeft(doc);

                    _relatives.x = _frameLeft + ((_scrollLeft > 0) ? 0 : _position.x);
                    _relatives.width = Math.min(_frameWidth - _position.x - __SCROLL_WIDTH, _position.width - ((_scrollLeft > 0) ? _scrollLeft - _position.x : 0));
                    _relatives.height = _position.height;
                    _relatives.y = _position.y - _scrollTop + _frameTop;
                }
            }
            return _relatives;
        }
    });
})();
(function() {
    Trex.WysiwygEventBinder = Trex.Class.create({
        initialize: function(win, doc, canvas) {
            this.win = win;
            this.doc = doc;
            this.canvas = canvas;
        },

        bindEvents : function() {
            this.translateDocumentEventToCanvas("keyup", 'onKeyUp');
            this.translateDocumentEventToCanvas('keydown', 'onKeyDown');
            this.translateDocumentEventToCanvas('mouseover', 'onMouseOver');
            this.translateDocumentEventToCanvas('mousemove', 'onMouseMove');
            this.translateDocumentEventToCanvas('mouseout', 'onMouseOut');
            this.translateDocumentEventToCanvas('click', 'onClick');
            this.translateDocumentEventToCanvas('dblclick', 'onDoubleClick');
            this.translateDocumentEventToCanvas('dragover', 'onDragOver');
            this.translateDocumentEventToCanvas('dragenter', 'onDragEnter');
            this.translateDocumentEventToCanvas('dragleave', 'onDragLeave');
            this.translateDocumentEventToCanvas('drop', 'onDrop');
            this.translateDocumentEventToCanvas('mousedown', 'onMouseDown');
            this.translateDocumentEventToCanvas('mouseup', 'onMouseUp');
            this.translateWindowEventToCanvas('scroll', 'onScroll');
			this.translateBodyEventToCanvas('paste', 'onPaste');

            this.triggerQueryStatusWhenTenConsecutiveKeyPressesDetected();
        },

        translateDocumentEventToCanvas: function(eventName, canvasMethodName) {
            this.translateEventToCanvas(this.doc, eventName, canvasMethodName);
        },

        translateWindowEventToCanvas: function(eventName, canvasMethodName) {
            this.translateEventToCanvas(this.win, eventName, canvasMethodName);
        },
		
		translateBodyEventToCanvas: function(eventName, canvasMethodName) {
            this.translateEventToCanvas(this.doc.body, eventName, canvasMethodName);
        },
		
        translateEventToCanvas: function(element, eventName, canvasMethodName) {
            var canvas = this.canvas;
            $tx.observe(element, eventName, function(e) {
                canvas[canvasMethodName](e);
            }, _FALSE);
        },

        triggerQueryStatusWhenTenConsecutiveKeyPressesDetected: function() {
            var canvas = this.canvas;
            observeTenConsecutiveKeyPresses(this.doc, function() {
                canvas.triggerQueryStatus();
            });
        }
    });

    var observeTenConsecutiveKeyPresses = function(element, handler) {
        var count = 0, previousKeyCode = -1,
                keyPressEvent = 'keydown';//($tx.msie || $tx.webkit) ? "keydown" : "keypress";

        $tx.observe(element, keyPressEvent, function(event) {
            var newKeyCode = event.keyCode;
            if (!shouldIgnore(newKeyCode) && previousKeyCode !== newKeyCode) {
                if (count >= 9) {
                    handler();
                    count = 0;
                } else {
                    count++;
                }
                previousKeyCode = newKeyCode;
            }
        }, _FALSE);
    };

    var shouldIgnore = function(keyCode) {
        return QUERY_TRIGGER_IGNORE_KEYCODES.contains(keyCode);
    };

    var QUERY_TRIGGER_IGNORE_KEYCODES = new $tx.Set(8, 16, 17, 18, 32, 33, 34, 37, 38, 39, 40, 46, 229/* hangul */);

})();

(function() {
	/**
	 * wysiwyg \uc601\uc5ed\uc758 \ucee8\ud150\uce20\ub97c \uc218\uc815, \uad00\ub9ac\ud558\uae30 \uc704\ud55c \ud074\ub798\uc2a4\ub85c,
	 * \ud3b8\uc9d1 \uc601\uc5ed\uc5d0 \ud574\ub2f9\ud558\ub294 iframe \uac1d\uccb4\uc5d0 \uc811\uadfc\ud558\uc5ec \uc774\ubca4\ud2b8\ub97c \ubd80\uc5ec\ud558\uac70\ub098 \uc18d\uc131 \uac12\ub4e4\uc744 \uc77d\uac70\ub098 \ubcc0\uacbd\ud55c\ub2e4.
	 *
	 * @class
	 * @extends Trex.Canvas.BasedPanel
	 * @param {Object} canvas
	 * @param {Object} config - canvas\uc758 config
	 */
	Trex.Canvas.WysiwygPanel = Trex.Class.create(/** @lends Trex.Canvas.WysiwygPanel.prototype */{
		/** @ignore */
		$extend: Trex.Canvas.BasedPanel,


		/** @ignore */
		$const: {
			/** @name Trex.Canvas.WysiwygPanel.__MODE */
			__MODE: Trex.Canvas.__WYSIWYG_MODE,
			EVENT_BINDING_DELAY: 500
		},


		initialize: function(canvas, canvasConfig) {
			this.$super.initialize(canvas, canvasConfig);

			this.canvasConfig = canvasConfig;
			this.iframe = this.el;
			this.wysiwygWindow = this.iframe.contentWindow;
			this.onceWysiwygFocused = false;

			var self = this;
			var iframeLoader = new Trex.WysiwygIframeLoader(this.iframe, canvasConfig.wysiwygCatalystUrl, canvasConfig.doctype);
			iframeLoader.load(function(doc) {
				self.wysiwygDoc = doc;

				self.initializeSubModules(doc);
				installHyperscript(self.wysiwygWindow, self.wysiwygDoc);
				self.makeEditable();
				self.applyBodyStyles(self.canvasConfig.styles);
				self.applyCustomCssText(self.canvasConfig.customCssText);
				self.clearContent();
				self.bindEvents(canvas);
				Editor.__PANEL_LOADED = _TRUE;

				$tx.observe(self.wysiwygWindow, 'focus', function onWysiwygFocused() {
					if (!self.onceWysiwygFocused) {
						self.onceWysiwygFocused = true;
					}
				});
                if ($tx.msie_nonstd) {
                    var htmlEl = self.wysiwygDoc.getElementsByTagName('html');
                    if (htmlEl && htmlEl[0]) {
                        $tx.observe(htmlEl[0], 'click', function (event) {
                            var target = $tx.element(event);
                            if (canvas.canHTML() && htmlEl[0] == target) {
                                self.focus();
                            }
                        });
                    }
                }
				canvas.fireJobs(Trex.Ev.__IFRAME_LOAD_COMPLETE, doc);
			});

		},
        _bodyHeight : 0,
        _bodyContentHeight : 0,

		initializeSubModules: function(doc) {
			var win = this.wysiwygWindow;
			this.processor = new Trex.Canvas.ProcessorP(win, doc);
			this.webfontLoader = new Trex.WebfontLoader(doc, this.canvasConfig);
		},


		/**
		 * WYSIWYG \uc601\uc5ed iframe\uc744 \ud3b8\uc9d1 \uac00\ub2a5\ud55c \uc0c1\ud0dc\ub85c \ubcc0\uacbd\ud55c\ub2e4.
		 */
		makeEditable: function () {
			if (this.canvasConfig.readonly) {
				return;
			}

			if (this.wysiwygDoc.body.contentEditable) {
				this.wysiwygDoc.body.contentEditable = _TRUE;
                if ($tx.gecko) {
                    this.wysiwygDoc.execCommand("enableInlineTableEditing", _FALSE, _FALSE);
                    this.wysiwygDoc.execCommand("enableObjectResizing",  _FALSE, _FALSE);
                }
			} else {
				var self = this;
				setTimeout(function () {
					try {
						self.wysiwygDoc.designMode = "On";
						if ($tx.gecko) {
							self.wysiwygDoc.execCommand("enableInlineTableEditing", _FALSE, _FALSE);
							self.wysiwygDoc.execCommand("enableObjectResizing",  _FALSE, _FALSE);
						}
					} catch (e) {
						self.designModeActivated = _FALSE;
					}
				}, 10);
			}
		},

		/**
		 * panel\uc758 \uc774\ub984\uc744 \ub9ac\ud134\ud55c\ub2e4.
		 * @function
		 * @returns {String} 'html'
		 */
		getName: function() {
			return this.constructor.__MODE;
		},


		/**
		 * wysiwyg \uc601\uc5ed\uc758 window \uac1d\uccb4\ub97c \ub118\uaca8\uc900\ub2e4.
		 * @function
		 * @returns {Element} wysiwyg \uc601\uc5ed\uc758 window \uac1d\uccb4
		 */
		getWindow: function() {
			return this.wysiwygWindow;
		},


		/**
		 * wysiwyg \uc601\uc5ed\uc758 document \uac1d\uccb4\ub97c \ub118\uaca8\uc900\ub2e4.
		 * @function
		 * @returns {Element} wysiwyg \uc601\uc5ed\uc758 document \uac1d\uccb4
		 */
		getDocument: function() {
			return this.wysiwygDoc;
		},


		/**
		 * wysiwyg \uc601\uc5ed\uc5d0 \uc4f0\uc5ec\uc9c4 \ucee8\ud150\uce20\ub97c \uc5bb\uc5b4\uc628\ub2e4.
		 * @function
		 * @returns {String} \ucee8\ud150\uce20 \ubb38\uc790\uc5f4
		 */
		getContent: function() {
			return this.wysiwygDoc.body.innerHTML;
		},


		/**
		 * wysiwyg \uc601\uc5ed\uc758 \ucee8\ud150\uce20\ub97c \uc8fc\uc5b4\uc9c4 \ubb38\uc790\uc5f4\ub85c \uc218\uc815\ud55c\ub2e4.
		 * @function
		 * @param {String} contentHTML - \ucee8\ud150\uce20
		 */
		setContent: function(contentHTML) {
			contentHTML = this.doPreFilter(contentHTML);
			this.setBodyHTML(contentHTML);
			this.doPostFilter(this.wysiwygDoc.body);
		},

		doPreFilter: function(contentHTML) {
			if (contentHTML) {
				contentHTML = removeWordJoiner(contentHTML);
				contentHTML = preventRemovingNoScopeElementInIE(contentHTML);
			}
			return contentHTML;
		},

		setBodyHTML: function(content) {
			this.wysiwygDoc.body.innerHTML = content || $tom.EMPTY_PARAGRAPH_HTML;
		},

		doPostFilter: function(body) {
			makeEmptyParagraphVisibleInIE(body);
		},


		/**
		 * \ud3b8\uc9d1 \ubb38\uc11c body\uc758 HTML\uc744 \ubaa8\ub450 \uc9c0\uc6b0\uace0 \uae30\ubcf8 \ub9c8\ud06c\uc5c5\uc744 \uc138\ud305\ud55c\ub2e4.
		 */
		clearContent: function() {
			this.setContent("");
		},


		/**
		 * \ud604\uc7ac wysiwyg \uc601\uc5ed\uc758 \uc218\uc9c1 \uc2a4\ud06c\ub864 \uac12\uc744 \uc5bb\uc5b4\uc628\ub2e4.
		 * @function
		 * @returns {Number} \uc218\uc9c1 \uc2a4\ud06c\ub864 \uac12
		 */
		getScrollTop: function() {
			return $tom.getScrollTop(this.wysiwygDoc);
		},


		/**
		 * wysiwyg \uc601\uc5ed\uc758 \uc218\uc9c1 \uc2a4\ud06c\ub864 \uac12\uc744 \uc14b\ud305\ud55c\ub2e4.
		 * @function
		 * @param {Number} scrollTop - \uc218\uc9c1 \uc2a4\ud06c\ub864 \uac12
		 */
		setScrollTop: function(scrollTop) {
			$tom.setScrollTop(this.wysiwygDoc, scrollTop);
		},


		/**
		 * \ud604\uc7ac wysiwyg \uc601\uc5ed\uc758 \uc218\ud3c9 \uc2a4\ud06c\ub864 \uac12\uc744 \uc5bb\uc5b4\uc628\ub2e4.
		 * @function
		 * @returns {Number} \uc218\ud3c9 \uc2a4\ud06c\ub864 \uac12
		 */
		getScrollLeft: function() {
			return $tom.getScrollLeft(this.wysiwygDoc);
		},


		/**
		 * \uc0dd\uc131\ub41c Processor \uac1d\uccb4\ub97c \ub9ac\ud134\ud55c\ub2e4.
		 * @function
		 * @returns {Object} Processor \uac1d\uccb4
		 */
		getProcessor: function() {
			return this.processor;
		},


		/**
		 * \ub9cc\uc57d processor \uac1d\uccb4\uac00 \uc900\ube44\ub418\uc5c8\ub2e4\uba74 processor \uac1d\uccb4\ub97c argument\ub85c \ub118\uae30\uba70 \uc8fc\uc5b4\uc9c4 \ud568\uc218\ub97c \uc218\ud589\ud55c\ub2e4.
		 * @param fn {function} processor \uac1d\uccb4\ub97c argument\ub85c \ubc1b\uc544 \uc2e4\ud589\ud560 \ud568\uc218
		 */
		ifProcessorReady: function(fn) {
			if (this.processor) {
				fn(this.processor);
			}
		},


		/**
		 * \uc2a4\ud0c0\uc77c\uba85\uc73c\ub85c wysiwyg \uc601\uc5ed\uc758 \uc2a4\ud0c0\uc77c \uac12\uc744 \uc5bb\uc5b4\uc628\ub2e4.
		 * @function
		 * @param {String} name - \uc2a4\ud0c0\uc77c\uba85
		 * @returns {String} \ud574\ub2f9 \uc2a4\ud0c0\uc77c \uac12
		 */
		getStyle: function(name) {
			return $tx.getStyle(this.wysiwygDoc.body, name);
		},


		/**
		 * wysiwyg \uc601\uc5ed\uc5d0 \uc2a4\ud0c0\uc77c\uc744 \uc801\uc6a9\ud55c\ub2e4.
		 * @function
		 * @param {Object} styles - \uc801\uc6a9\ud560 \uc2a4\ud0c0\uc77c
		 */
		addStyle: function(styles) {
			$tx.setStyleProperty(this.wysiwygDoc.body, styles);
		},


		/**
		 * \uc8fc\uc5b4\uc9c4 \ubb38\uc11c\uc758 body element \uc5d0 CSS \uc18d\uc131\uc744 \uc9c0\uc815\ud55c\ub2e4. \ub2e8 \ud3f0\ud2b8 \uad00\ub828 \uc18d\uc131\uc740 \uc81c\uc678\ud55c\ub2e4.
		 * @param doc {HTMLDocument}
		 * @param styles {Object} key: value \ud615\ud0dc\uc758 CSS property \ubaa8\uc74c
		 */
		setBodyStyle: function(doc, styles) {
			var excluded = excludeNotAllowed(styles);
			$tx.setStyleProperty(doc.body, excluded);
		},


		/**
		 * \uc8fc\uc5b4\uc9c4 \ubb38\uc11c\uc5d0 \ud3f0\ud2b8 \uad00\ub828 CSS \uc18d\uc131\uc744 \uc9c0\uc815\ud55c\ub2e4
		 * @param doc {HTMLDocument}
		 * @param styles {Object} key: value \ud615\ud0dc\uc758 CSS property \ubaa8\uc74c
		 */
		setFontStyle: function(doc, styles) {
			var extendedStyles = Object.extend(styles, {
				'browser': $tx.browser,
				'pMarginZero': this.canvasConfig.pMarginZero ? "true" : "false"
			});
			var cssText = new Template([
				"#{if:pMarginZero=='true'}p { margin:0; padding:0; }#{/if:pMarginZero}",
				"body, td, button { color:#{color}; font-size:#{fontSize}; font-family:#{fontFamily}; line-height:#{lineHeight}; }",
				"a, a:hover, a:link, a:active, a:visited { color:#{color}; }",
				"div.txc-search-border { border-color:#{color}; }",
				"div.txc-search-opborder { border-color:#{color}; }",
				"img.tx-unresizable { width: auto !important; height: auto !important; }",
				"button a { text-decoration:none #{if:browser=='firefox'}!important#{/if:browser}; color:#{color} #{if:browser=='firefox'}!important#{/if:browser}; }"
			].join("\n")).evaluate(extendedStyles);
			$tx.applyCSSText(doc, cssText);
		},


		applyBodyStyles: function(styles) {
			var doc = this.wysiwygDoc;
			try {
				this.setFontStyle(doc, styles);
				this.setBodyStyle(doc, styles);
			} catch(e) {
			}
		},
		
		applyCustomCssText: function (cssText) {
			if (!cssText) {
				return;
			}
			var doc = this.wysiwygDoc;
			try {
				$tx.applyCSSText(doc, cssText);
			} catch (ignore) {}
		},
		
		setRule: function (selector, value) {
			var styleElem, sheet, rules;
			try {
				styleElem = this.wysiwygDoc.getElementById("txStyleForSetRule");
				sheet = styleElem.sheet ? styleElem.sheet : styleElem.styleSheet;
				rules = sheet.cssRules ? sheet.cssRules : sheet.rules;
				if (sheet.insertRule) { // all browsers, except IE before version 9
					if (0 < rules.length) {
						sheet.deleteRule(0);
					}
					if (selector) {
						sheet.insertRule(selector + "{" + value + "}", 0);
					}
				} else { // Internet Explorer before version 9
					if (sheet.addRule) {
						if (0 < rules.length) {
							sheet.removeRule(0);
						}
						if (selector) {
							sheet.addRule(selector, value, 0);
						}
					}
				}
			} catch (ignore) {}
		},

		/**
		 * iframe\uc5d0\uc11c \ubc1c\uc0dd\ud558\ub294 \uac01\uc885 event \ub4e4\uc744 observing \ud558\uae30 \uc2dc\uc791\ud55c\ub2e4.
		 */
		bindEvents: function(canvas) {
			var eventBinder = new Trex.WysiwygEventBinder(this.wysiwygWindow, this.wysiwygDoc, canvas, this.processor);
			setTimeout(function() {
				eventBinder.bindEvents();
			}, this.constructor.EVENT_BINDING_DELAY); // why delay 500ms?
		},


		/**
		 * panel \uc5d8\ub9ac\uba3c\ud2b8\ub97c \uac00\uc9c0\uace0 \uc628\ub2e4.
		 * @function
		 */
		getPanel: function(config) {
			var id = config.initializedId || "";
			return $must("tx_canvas_wysiwyg" + id, "Trex.Canvas.WysiwygPanel");
		},
        //#1454
        setHeightBody: function(height){
            var body = this.wysiwygWindow.document.body;
            var marginPaddingTop = parseInt($tx.getStyle(body, 'margin-top')) + parseInt($tx.getStyle(body, 'padding-top'));
            var marginPaddingBottom = parseInt($tx.getStyle(body, 'margin-bottom')) + parseInt($tx.getStyle(body, 'padding-bottom'));
            height = parseInt(height) - marginPaddingTop - marginPaddingBottom;
            body.style.height = height.toPx();
            this._bodyHeight = height;
        },

        setPanelHeight: function(height) {
            var self = this;
            function timesTry(n){
                if(n === 0) return;
                try{
                    self.setHeightBody(height);
                }catch(e){
                    setTimeout(timesTry.bind(this, n-1), 30);
                }
            }
            //\ucd08\uae30\ud654 \uc911\uc5d0 body\uac00 \ucd08\uae30\ud654 \ub418\uc9c0 \uc54a\uc558\uae30 \ub54c\ubb38\uc5d0 body\uac00 \uc624\ub958\ub0a0 \ud655\ub960\uc774 \uc788\uc74c. 10\ubc88 \uc2dc\ub3c4 \ud558\ub294 \ub85c\uc9c1 \ucd94\uac00
            timesTry(10);
            self.$super.setPanelHeight(height);
        },


		/**
		 * panel \uc5d8\ub9ac\uba3c\ud2b8\ub97c \uac10\uc2f8\uace0 \uc788\ub294 wrapper \uc5d8\ub9ac\uba3c\ud2b8\ub97c \uac00\uc9c0\uace0 \uc628\ub2e4.
		 * @function
		 */
		getHolder: function(config) {
			var id = config.initializedId || "";
			return $must("tx_canvas_wysiwyg_holder" + id, "Trex.Canvas.WysiwygPanel");
		},


		/**
		 * wysiwyg \uc601\uc5ed\uc5d0 \ud3ec\ucee4\uc2a4\ub97c \uc900\ub2e4.
		 * @function
		 */
		focus: function() {
			this.ifProcessorReady(function(processor) {
				processor.focus();
			});
		},

		ensureFocused: function () {
			if (!this.onceWysiwygFocused) {
				this.onceWysiwygFocused = true;
				this.focus();
			}
		},

		/**
		 * wysiwyg panel\uc744 \ubcf4\uc774\uac8c\ud55c\ub2e4.
		 * @function
		 */
		show: function() {
			this.$super.show();
			this.ifProcessorReady(function(processor) {
				setTimeout(function() {
					try {
						processor.focusOnTop(); //\ud55c\uba54\uc77c\uc5d0\uc11c \ubaa8\ub4dc \ubcc0\uacbd\uc2dc focus \uc81c\uc77c \uc704\ub85c \uac00\uac8c\ud568.. (\uc8fc\uc758: \ud604\uc7ac \ub2e4\ub978 \uc11c\ube44\uc2a4\ub294 Bottom \uc73c\ub85c \ub418\uc5b4\uc788\uc74c)
					} catch(e) {
					}
				}, 100);
			});
		},


		/**
		 * wysiwyg panel\uc744 \uac10\ucd98\ub2e4.
		 * @function
		 */
		hide: function() {
			this.ifProcessorReady(function(processor) {
				processor.blur();
			});
			this.$super.hide();
		},


		/**
		 * \ucee8\ud150\uce20\ub97c \ud30c\uc2f1\ud558\uc5ec \uc0ac\uc6a9\ub418\uace0 \uc788\ub294 \uc6f9\ud3f0\ud2b8\uac00 \uc788\uc73c\uba74, \uc6f9\ud3f0\ud2b8 css\ub97c \ub85c\ub529\ud55c\ub2e4.<br/>
		 * \ub85c\ub529\uc18d\ub3c4\ub97c \ud5a5\uc0c1\uc2dc\ud0a4\uae30 \uc704\ud574 \ubcf8\ubb38\uc744 \ud30c\uc2f1\ud558\uc5ec \uc6f9\ud3f0\ud2b8\ub97c \uc0ac\uc6a9\ud560 \uacbd\uc6b0\uc5d0\ub9cc \ub3d9\uc801\uc73c\ub85c \uc6f9\ud3f0\ud2b8 CSS\ub97c \ud638\ucd9c\ud55c\ub2e4.
		 * @function
		 * @param {String} content - \ucee8\ud150\uce20
		 */
		includeWebfontCss: function(content) {
			this.webfontLoader.load(content);
		},


		/**
		 * \ubcf8\ubb38\uc5d0 \uc0ac\uc6a9\ub41c \uc6f9\ud3f0\ud2b8\uba85 \ubaa9\ub85d\uc744 \ub9ac\ud134\ud55c\ub2e4.
		 * @function
		 * @returns {Array} \uc0ac\uc6a9\ud558\uace0 \uc788\ub294 \uc6f9\ud3f0\ud2b8\uba85 \ubaa9\ub85d
		 */
		getUsedWebfont: function() {
			return this.webfontLoader.getUsed();
		},


		/**
		 * \ud2b9\uc815 \ub178\ub4dc\uc758 wysiwyg \uc601\uc5ed\uc5d0\uc11c\uc758 \uc0c1\ub300 \uc704\uce58\ub97c \uc5bb\uc5b4\uc628\ub2e4.
		 * @function
		 * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
		 * @returns {Object} position \uac1d\uccb4 { x: number, y: number, width: number, height: number }
		 */
		getPositionByNode: function(node) {
			var wysiwygRelative = new Trex.WysiwygRelative(this.iframe);
			return wysiwygRelative.getRelative(node);
		}
	});

	function excludeNotAllowed(style) {
		var notAllowed = ["color", "fontSize", "fontFamily", "lineHeight"];
		var excluded = Object.clone(style);
		for (var i = 0; i < notAllowed.length; i++) {
			delete excluded[notAllowed[i]];
		}
		return excluded;
	}

	function removeWordJoiner(content) {
		return content.replace(Trex.__WORD_JOINER_REGEXP, "");
	}

	/*
	 * NOTE: FTDUEDTR-900
	 */
	function preventRemovingNoScopeElementInIE(markup) {
		if ($tx.msie) {
			markup = markup.replace(/(<script|<style)/i, Trex.__WORD_JOINER + "$1");
		}
		return markup;
	}

	/*
	 * IE\uc5d0\uc11c \ube48 p \uc5d8\ub9ac\uba3c\ud2b8\ub294 \ub192\uc774\ub97c \uac16\uc9c0 \uc54a\uace0 \ud654\uba74\uc5d0 \ud45c\uc2dc\ub418\uc9c0 \uc54a\ub294\ub2e4. \ub530\ub77c \ube48 \ubb38\ub2e8 \ud45c\uc2dc\ub97c \uc704\ud558\uc5ec <P>&nbsp;</P> \ub97c
	 * \uc0ac\uc6a9\ud558\ub294 \ub370, \ud3b8\uc9d1\uc2dc\uc5d0\ub294 &nbsp;\uac00 \ube48\uce78 \ud55c\uce78\uc73c\ub85c\uc11c \uc790\ub9ac\ub97c \ucc28\uc9c0\ud558\uc5ec \uac78\ub9ac\uc801 \uac70\ub9ac\ubbc0\ub85c \uc774\ub97c \uc81c\uac70\ud558\uc5ec \uc900\ub2e4.
	 * \uc774\uc640 \uac19\uc774 contentEditable \ud658\uacbd\uc5d0\uc11c &nbsp; \ub97c \uc8fc\uc5c8\ub2e4\uac00 \ube7c\uba74 \ube48 \uc5d8\ub9ac\uba3c\ud2b8\uc784\uc5d0\ub3c4 \ubd88\uad6c\ud558\uace0 \ubb38\ub2e8\uc73c\ub85c\uc11c \ub192\uc774\ub97c \uc720\uc9c0\ud55c\ub2e4.
	 *
	 * \uc758\ubb38 1.
	 *  \uadf8\ub7f0\ub370 LI\ub294 \uc65c \ud558\ub294 \uac78\uae4c -_-^
	 * \uc758\ubb38 2.
	 *	<P></P> \ub97c \ud558\ub098\uc758 \ubb38\ub2e8\uc73c\ub85c \uc5ec\uae30\uace0 \ub192\uc774\ub97c \uc7a1\uc544\uc8fc\ub294 \uac8c \ub9de\uc744\uae4c? \uae00 \uc870\ud68c\uc2dc\uc5d0\ub294 \ud45c\uc2dc \ub418\uc9c0 \uc54a\uc744\ud150\ub370...
	 *	\ud3b8\uc9d1\uc2dc\uc640 \uc870\ud68c\uc2dc \ubd88\uc77c\uce58 \ubc1c\uc0dd\ud55c\ub2e4.
	 *	\ucc38\uace0 \uc774\uc288 #FTDUEDTR-1121
	 * \uc758\ubb38 3.
	 *	\uc800\uc7a5\uc2dc \ube48 \ubb38\ub2e8\uc5d0 &nbsp;\ub97c \ub2e4\uc2dc \ub123\uc5b4\uc8fc\ub294 \ub4ef \ud55c\ub370, \uc5b4\ub514\uc11c \ud574\uc8fc\ub294 \uac78\uae4c
	 * @param body
	 */
	function makeEmptyParagraphVisibleInIE(body) {
		if ($tx.msie_nonstd) {
			var pNodes = $tom.collectAll(body, 'p,li');
			for (var i = 0, len = pNodes.length; i < len; i++) {
				var node = pNodes[i];
				if ($tom.getLength(node) === 0 && node.tagName.toLowerCase() !== 'p') { //#FTDUEDTR-1121
					try {
						node.innerHTML = '&nbsp;';
					} catch(ignore) {
					}
				}
				if ($tom.getLength(node) === 1 && node.innerHTML === '&nbsp;') {
					node.innerHTML = '';
				}
			}
		}
	}
})();

Trex.module("canvas set focus on mousedown event. only IE.",
    function(editor, toolbar, sidebar, canvas, config) {
        if (!$tx.msie_std) {
            return;
        }

        canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEUP, function(ev){
            if ($tx.isLeftClick(ev)) {
                var tagName = $tx.element(ev).tagName;
                if (tagName.toLocaleLowerCase() == 'html') {
                    canvas.focusOnBottom();
                }
            }
        });
});

Trex.module("auto body resize",
    function(editor, toolbar, sidebar, canvas, config){
        canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function() {
            var beforeHTML = '';
            var bodyHeight = 0;
            var _panel = canvas.getPanel('html');
            bodyHeight = _panel._bodyHeight;
            canvas.observeJob('canvas.height.change', function(h){
                bodyHeight = parseInt(_panel._bodyHeight);
            });

            function _resize(){
                if(!canvas.isWYSIWYG()) return;
                var _doc = _panel.getDocument();
                var _body = _doc.body;
                var _html = _body.innerHTML;
                if(beforeHTML === _html) return;
                beforeHTML = _html;
                _body.style.height = '';
                var _h = $tx.getDimensions(_body).height;
                _panel._bodyContentHeight = _h;
                if(_h<bodyHeight) {
                    _body.style.height = bodyHeight.toPx();
                }
            }
            setInterval(_resize, 200);
        });
    }
);



/**
 * @fileOverview
 * \uc774 \ud074\ub798\uc2a4\ub294 BasedPanel \uc744 \uc0c1\uc18d\ubc1b\ub294\ub2e4.
 * \ub610\ud55c TextPanel \uacfc HtmlPanel \uac00 \uc774 \ud074\ub798\uc2a4\ub97c \uc0c1\uc18d\ud55c\ub2e4.
 */

/**
 * TextareaPanel
 *
 * @class
 * @extends Trex.Canvas.BasedPanel
 * @param {Object} canvas
 * @param {Object} config - canvas\uc758 config
 */
Trex.Canvas.TextareaPanel = Trex.Class.create(/** @lends Trex.Canvas.TextareaPanel.prototype */{
	/** @ignore */
	$extend: Trex.Canvas.BasedPanel,
	/** @ignore */
	initialize: function(canvas, config) {
		this.$super.initialize(canvas, config);
		
		var _processor = new Trex.Canvas.TextAreaProcessor(this.el);
		/**
		 * \uc0dd\uc131\ub41c Processor \uac1d\uccb4\ub97c \ub9ac\ud134\ud55c\ub2e4.
		 * @function
		 * @returns {Object} Processor \uac1d\uccb4
		 */
		this.getProcessor = function() {
			return _processor;
		};
		
		this.lastHeight = (this.lastHeight - 9*2).toPx();//"382px";
		if ( !!config.readonly ){
			this.setReadOnly();
		}
	},
	/**
	 * panel\uc744 \ubcf4\uc774\uac8c\ud55c\ub2e4.
	 * @function
	 */
	show: function() {
		this.$super.show();
		var _elHolder = this.elHolder;
		var _processor = this.getProcessor();
		setTimeout(function(){
			try {
				_processor.focusOnTop(); //\ubaa8\ub4dc \ubcc0\uacbd\uc2dc focus \uc81c\uc77c \uc704\ub85c \uac00\uac8c\ud568..
			} catch (ignore) {}
			if ($tx.msie6) { //NOTE: #FTDUEDTR-174
				_elHolder.style.padding = "1px";
				setTimeout(function(){
					_elHolder.style.padding = "0px";
				}, 0);
			}			
		}, 100);
	},
	/**
	 * \ucee8\ud150\uce20 \uc601\uc5ed\uc758 \ucee8\ud150\uce20\ub97c \uc8fc\uc5b4\uc9c4 \ubb38\uc790\uc5f4\ub85c \uc218\uc815\ud55c\ub2e4. 
	 * @function
	 * @param {String} content - \ucee8\ud150\uce20
	 */
	setContent: function(content) {
		this.el.value = content;
	},
	/**
	 * \ucee8\ud150\uce20 \uc601\uc5ed\uc5d0 \uc4f0\uc5ec\uc9c4 \ucee8\ud150\uce20\ub97c \uc5bb\uc5b4\uc628\ub2e4. 
	 * @function
	 * @returns {String} \ucee8\ud150\uce20 \ubb38\uc790\uc5f4
	 */
	getContent: function() {
		return this.el.value;
	},
	/**
	 * panel \uc601\uc5ed\uc758 \ub192\uc774\ub97c \uc5bb\uc5b4\uc628\ub2e4.
	 * @function
	 * @returns {String} textarea \uc601\uc5ed\uc758 \ub192\uc774 (px)
	 */
	getPanelHeight: function() { 
		return ($tom.getHeight(this.el).parsePx() + 2).toPx(); 
	},
	/**
	 * panel \uc601\uc5ed\uc758 \ub192\uc774\ub97c \uc14b\ud305\ud55c\ub2e4.
	 * @function
	 * @param {Number} width - textarea \uc601\uc5ed\uc758 \ub113\uc774 (px)
	 */
	setPanelHeight: function(height) {
		this.$super.setPanelHeight((height.parsePx() - 2).toPx());
	},
	/**
	 * panel\uc758 readonly\ub97c \uc18d\uc131\uc744 setting\ud568\uc73c\ub85c\uc368 \uae00\uc4f0\uae30\ub97c \uc81c\ud55c\ud55c\ub2e4.
	 * @function
	 */
	setReadOnly: function(){
		this.el.readOnly = _TRUE;
	}
});
/**
 * @fileOverview
 * Textarea (source, text) \uc601\uc5ed\uc758 \ucee8\ud150\uce20\ub97c \uc218\uc815, \uad00\ub9ac\ud558\uae30 \uc704\ud55c HtmlPanel \uad00\ub828 Source
 */

/**
 * HTML\ubaa8\ub4dc(\uc18c\uc2a4\ubaa8\ub4dc)\uc758 \ucee8\ud150\uce20\ub97c \uc218\uc815, \uad00\ub9ac\ud558\uae30 \uc704\ud55c \ud074\ub798\uc2a4
 *
 * @class
 * @extends Trex.Canvas.BasedPanel
 * @param {Object} canvas
 * @param {Object} config - canvas\uc758 config
 */
Trex.Canvas.HtmlPanel = Trex.Class.create(/** @lends Trex.Canvas.HtmlPanel.prototype */{
	/** @ignore */
	$extend: Trex.Canvas.TextareaPanel,
	/** @ignore */
	$const: {
		/** @name Trex.Canvas.HtmlPanel.__MODE */
		__MODE: Trex.Canvas.__HTML_MODE
	},
	initialize: function(canvas, config) {
		this.$super.initialize(canvas, config);
		this.bindEvents();

		if($tx.msie_ver == '8') { //NOTE: #FTDUEDTR-963
			this.el.setAttribute('style', 'width: 500px; min-width: 100%; max-width: 100%;');
		}
        if (!config.styles.notApplyBgColorOnSourceMode) {
            if ( config.styles.backgroundColor ){
                $tx.setStyle( this.el, {
                    backgroundColor: config.styles.backgroundColor
                });
            }
            if ( config.styles.color ){
                $tx.setStyle( this.el, {
                    color: config.styles.color
                });
            }
        }
	},
	bindEvents: function() {
		var _handlers = {
			keydown: function(ev){
				this.canvas.fireJobs(Trex.Ev.__CANVAS_SOURCE_PANEL_KEYDOWN, ev);
			},
			keyup: function(){
				var processor = this.canvas.getProcessor();
				if (processor && processor.savePosition) {
					processor.savePosition();
				}
			},
			mousedown: function(ev){
				this.canvas.fireJobs(Trex.Ev.__CANVAS_SOURCE_PANEL_MOUSEDOWN, ev);
			},
			mouseup: function(){
				var processor = this.canvas.getProcessor();
				if (processor && processor.savePosition) {
					processor.savePosition();
				}
			},
			click: function(ev) {
				this.canvas.fireJobs(Trex.Ev.__CANVAS_SOURCE_PANEL_CLICK, ev);	
			}
		};
		for(var _eventType in _handlers){
			$tx.observe(this.el, _eventType, _handlers[_eventType].bind(this), _TRUE);
		}
	},
	/**
	 * panel \uc5d8\ub9ac\uba3c\ud2b8\ub97c \uac00\uc9c0\uace0 \uc628\ub2e4.
	 * @function
	 */
	getPanel: function(config) {
		var _initializedId = ((config.initializedId)? config.initializedId: "");
		return $must("tx_canvas_source" + _initializedId, "Trex.Canvas.HtmlPanel");
	},
	/**
	 * panel \uc5d8\ub9ac\uba3c\ud2b8\ub97c \uac10\uc2f8\uace0 \uc788\ub294 wrapper \uc5d8\ub9ac\uba3c\ud2b8\ub97c \uac00\uc9c0\uace0 \uc628\ub2e4.
	 * @function
	 */
	getHolder: function(config) {
		var _initializedId = ((config.initializedId)? config.initializedId: "");
		return $must("tx_canvas_source_holder" + _initializedId, "Trex.Canvas.HtmlPanel");
	},
	/**
	 * \ucee8\ud150\uce20 \uc601\uc5ed\uc758 \ucee8\ud150\uce20\ub97c \uc8fc\uc5b4\uc9c4 \ubb38\uc790\uc5f4\ub85c \uc218\uc815\ud55c\ub2e4. 
	 * @function
	 * @param {String} content - \ucee8\ud150\uce20
	 */
	setContent: function(content) {
		var validator = new Trex.Validator();
		if (validator.exists(content)) {
			this.$super.setContent(content);
		} else {
			this.$super.setContent("");
		}
	}
});
/**
 * @fileOverview
 * Textarea (source, text) \uc601\uc5ed\uc758 \ucee8\ud150\uce20\ub97c \uc218\uc815, \uad00\ub9ac\ud558\uae30 \uc704\ud55c TextPanel \uad00\ub828 Source
 */

/**
 * \ud14d\uc2a4\ud2b8\ubaa8\ub4dc\uc758 \ucee8\ud150\uce20\ub97c \uc218\uc815, \uad00\ub9ac\ud558\uae30 \uc704\ud55c \ud074\ub798\uc2a4
 *
 * @class
 * @extends Trex.Canvas.BasedPanel
 * @param {Object} canvas
 * @param {Object} config - canvas\uc758 config
 */
Trex.Canvas.TextPanel = Trex.Class.create(/** @lends Trex.Canvas.TextPanel.prototype */{
	/** @ignore */
	$extend: Trex.Canvas.TextareaPanel,
	/** @ignore */
	$const: {
		/** @name Trex.Canvas.TextPanel.__MODE */
		__MODE: Trex.Canvas.__TEXT_MODE
	},
	initialize: function(canvas, config) {
		this.$super.initialize(canvas, config);
		this.bindEvents();
	},
	bindEvents: function() {
		var _handlers = {
			keydown: function(){},
			keyup: function(){},
			mousedown: function(){},
			mouseup: function(){},
			click: function(ev) {
				this.canvas.fireJobs(Trex.Ev.__CANVAS_TEXT_PANEL_CLICK, ev);
			}			
		};
		for(var _eventType in _handlers){
			$tx.observe(this.el, _eventType, _handlers[_eventType].bind(this), _TRUE);
		}
	},
	/**
	 * panel \uc5d8\ub9ac\uba3c\ud2b8\ub97c \uac00\uc9c0\uace0 \uc628\ub2e4.
	 * @function
	 */
	getPanel: function(config) {
		var _initializedId = ((config.initializedId)? config.initializedId: "");
		return $must("tx_canvas_text" + _initializedId, "Trex.Canvas.TextPanel");
	},
	/**
	 * panel \uc5d8\ub9ac\uba3c\ud2b8\ub97c \uac10\uc2f8\uace0 \uc788\ub294 wrapper \uc5d8\ub9ac\uba3c\ud2b8\ub97c \uac00\uc9c0\uace0 \uc628\ub2e4.
	 * @function
	 */
	getHolder: function(config) {
		var _initializedId = ((config.initializedId)? config.initializedId: "");
		return $must("tx_canvas_text_holder" + _initializedId, "Trex.Canvas.TextPanel");
	}
});

Trex.module("interrupt enter key action @ text panel",
	function(editor, toolbar, sidebar, canvas) {
		var _newlinepolicy = canvas.config.newlinepolicy;
		var _insertbr = canvas.config.insertbr;
		if (_newlinepolicy == "br" && _insertbr) {
			canvas.observeJob(Trex.Ev.__CANVAS_SOURCE_PANEL_KEYDOWN, function(ev){
				if (canvas.isWYSIWYG()) {
					return;
				}
				canvas.getProcessor().controlEnter(ev);
			});
		}	
	}
);

/**
 * @fileOverview
 * Wysiwyg \uc601\uc5ed\uc758 DOM \uc870\uc791\uc744 \ud558\uae30\uc804\uc5d0 \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \uc2dc\uc791\uacfc \ub05d\uc5d0 marker\ub97c \uc0bd\uc785\ud558\uc5ec 
 * DOM \uc870\uc791\uc744 \ubcf4\ub2e4 \uc6a9\uc774\ud558\uac8c \ud558\ub294 \uac1d\uccb4\ub85c Processor#execWithMarker \uc5d0\uc11c \uc0ac\uc6a9\ub41c\ub2e4. 
 */
Trex.I.Marker = {};

Trex.I.Marker.Standard = /** @lends Trex.Canvas.Marker.prototype */{
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \uc2dc\uc791\uacfc \ub05d\uc5d0 marker\ub97c \uc0bd\uc785\ud55c\ub2e4.
	 * @example
	 * 	marker.paste();
	 */
	paste: function() {
		var _rng = this.processor.getRange();
		
		var _endContainer = _rng.endContainer;
		var _startContainer = _rng.startContainer; 
		if (_endContainer.nodeType == 9) { //NOTE: #FTDUEDTR-919
			_endContainer = this.processor.doc.body;
			_startContainer = this.processor.doc.body;
		}
		
		var _endMarker = this.endMarker = this.processor.create('span', { id: "tx_end_marker" });
		var _endOffset = _rng.endOffset;
		
		if (_endContainer.nodeType == 3) {
			_endContainer.splitText(_endOffset);
			_endContainer.parentNode.insertBefore(_endMarker, _endContainer.nextSibling);
		} else {
			_endContainer.insertBefore(_endMarker, _endContainer.childNodes[_endOffset]);
		}
		
		var _startMarker = this.startMarker = this.processor.create('span', { id: "tx_start_marker" });
		var _startOffset = _rng.startOffset; 
		
		if(_startContainer.nodeType == 3) {
			_startContainer.splitText(_startOffset); 
			_startContainer.parentNode.insertBefore(_startMarker, _startContainer.nextSibling);
		} else {
			_startContainer.insertBefore(_startMarker, _startContainer.childNodes[_startOffset]);
		}
	},
	/**
	 * \uc0bd\uc785\ub41c \ub9c8\ucee4\ub97c \uc81c\uac70\ud55c\ub2e4.
	 * @example
	 * 	marker.remove();
	 */
	remove: function() {
		$tom.remove(this.startMarker);
		$tom.remove(this.endMarker);
	}
};


Trex.I.Marker.Trident = /** @lends Trex.Canvas.Marker.prototype */{
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \uc2dc\uc791\uacfc \ub05d\uc5d0 marker\ub97c \uc0bd\uc785\ud55c\ub2e4.
	 * @example
	 * 	marker.paste();
	 */
	paste: function() {
		this.clear();
		
		var _rng = this.processor.getRange();
		var _cnxt = this.processor.doc.body;
		
		var _rng1 = _rng.duplicate();
		_rng1.collapse(_TRUE);
		_rng1.pasteHTML('<span id="tx_start_marker"></span>');
		this.startMarker = $tom.collect(_cnxt, '#tx_start_marker');
		
		var _rng2 = _rng.duplicate();
		_rng2.collapse(_FALSE); 
		_rng2.pasteHTML('<span id="tx_end_marker"></span>');
		this.endMarker = $tom.collect(_cnxt, '#tx_end_marker');
	},
	/**
	 * @private
	 * \uae30\uc874\uc5d0 \uc0bd\uc785\ub41c \ub9c8\ucee4\ub97c \ubaa8\ub450 \uc81c\uac70\ud55c\ub2e4.
	 * @example
	 * 	marker.remove();
	 */
	clear: function() {
		var _cnxt = this.processor.doc.body;
		$tom.remove($tom.collect(_cnxt, '#tx_start_marker'));
		$tom.remove($tom.collect(_cnxt, '#tx_end_marker'));
	},
	/**
	 * \uc0bd\uc785\ub41c \ub9c8\ucee4\ub97c \uc81c\uac70\ud55c\ub2e4.
	 * @example
	 * 	marker.remove();
	 */
	remove: function() {
		$tom.remove(this.startMarker);
		$tom.remove(this.endMarker);
	}
};

/**
 * Wysiwyg \uc601\uc5ed\uc758 DOM \uc870\uc791\uc744 \ud558\uae30\uc804\uc5d0 \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \uc2dc\uc791\uacfc \ub05d\uc5d0 marker\ub97c \uc0bd\uc785\ud558\uc5ec  <br/>
 * DOM \uc870\uc791\uc744 \ubcf4\ub2e4 \uc6a9\uc774\ud558\uac8c \ud558\ub294 \uac1d\uccb4\ub85c  <br/>
 * browser\uc5d0 \ub530\ub77c \ud544\uc694\ud55c \ud568\uc218\ub4e4\uc744 mixin\ud55c\ub2e4. <br/>
 * Processor#execWithMarker \uc5d0\uc11c\ub9cc \uc0ac\uc6a9\ub41c\ub2e4.<br/>
 * 
 * @example
 * 		var _marker = new Trex.Canvas.Marker(processor);
 *		processor.bookmarkTo();
 *		try {
 *			_marker.paste();
 *			_marker.backup();
 *			handler(_marker);
 *		} catch(e) {
 *		} finally {
 *			_marker.remove();
 *		}	
 * @class
 * @param {Object} processor - Processor \uac1d\uccb4
 */
Trex.Canvas.Marker = Trex.Class.create(/** @lends Trex.Canvas.Marker.prototype */{
	/** @ignore */
	$mixins: [
		(($tx.msie_nonstd)? Trex.I.Marker.Trident: Trex.I.Marker.Standard)
	],
	initialize: function(processor) {
		this.processor = processor;
	},
	/**
	 * \ub9c8\ucee4\ub97c \uc0bd\uc785\ud55c \ud6c4 \ubd81\ub9c8\ud06c\ub97c \uc218\uc815\ud55c\ub2e4.
	 * @example
	 * 	marker.backup();
	 */
	backup: function() {
		this.processor.bookmarkWithMarker(this);
	},
	/**
	 * @private
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc774 collapse\uc778\uc9c0 \uc5ec\ubd80\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Boolean} - \uc120\ud0dd\ub41c \uc601\uc5ed\uc774 collapse\uc778\uc9c0 \uc5ec\ubd80
	 * @example
	 * 	marker.checkCollapsed();
	 */
	checkCollapsed: function() {
		return ($tom.next(this.startMarker) == this.endMarker); //collapsed
	}
});


/**
 * @fileOverview
 * native selection, range \uac1d\uccb4\ub97c wrapping \ud55c \uac1d\uccb4\ub85c Processor \uc5d0\uc11c \uc8fc\ub85c \uc0ac\uc6a9\ub41c\ub2e4. 
 */
Trex.I.Selection = {};
Trex.I.Selection.Standard = /** @lends Trex.Canvas.Selection.prototype */{
	/**
	 * native selection object\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Object} - native selection object
	 * @example
	 * 	txSelection.getSel();
	 */
	getSel: function(){
		return this.win.getSelection();
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ud14d\uc2a4\ud2b8 \ub370\uc774\ud130\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {String} - \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ud14d\uc2a4\ud2b8 \ub370\uc774\ud130
	 * @example
	 * 	txSelection.getText();
	 */
	getText: function() {
		return this.getSel().toString();
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ub178\ub4dc\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Element} - \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ub178\ub4dc
	 * @example
	 * 	txSelection.getNode();
	 */
	getNode: function() {
		var _rng = this.getRange();
		if (_rng) {
			var _startContainer = _rng.startContainer;
			if (_startContainer.nodeType == 1) {
				if ($tom.isBody(_startContainer)) {
					return (_startContainer);
				} else {
					return (_startContainer.childNodes[_rng.startOffset]);
				}
			} else {
				return (_startContainer.parentNode);
			}
		} else {
			return _NULL;
		}
	},
	/**
	 * native range \ub97c \uc0dd\uc131\ud55c\ub2e4.
	 * @returns {Object} - native range \uac1d\uccb4
	 * @example
	 * 	txSelection.createRange();
	 */
	createRange: function() {
		return this.doc.createRange();
	},
	/**
	 * native text range \ub97c \uc0dd\uc131\ud55c\ub2e4.
	 * @returns {Object} - native text range \uac1d\uccb4
	 * @example
	 * 	txSelection.createTextRange();
	 */
	createTextRange: function() {
		return this.doc.createRange();
	},
	/**
	 * native range object\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Object} - native range \uac1d\uccb4
	 * @example
	 * 	txSelection.getRange();
	 */
	getRange: function(collapse) {
		var _sel = this.getSel();
		if (_sel && _sel.rangeCount > 0) {
			if (collapse == _NULL) {
				if (_sel.rangeCount == 1) { //\ub2e8\uc77c Range = \uc77c\ubc18\uc801\uc778 \uacbd\uc6b0
					return _sel.getRangeAt(0);
				} else { //\ubcf5\uc218 Range -> \ub2e8\uc77c Range\ub85c \ubcc0\ud658
					return this.mergeRange(_sel);
				}
			} else { //Range\ub97c collapse\ud560 \uacbd\uc6b0
				var _rng = _sel.getRangeAt(0);
				_rng.collapse(collapse);
				return _rng;
			}
		} else { //Range\uac00 \uc5c6\uc744 \uacbd\uc6b0
			return this.doc.createRange();
		}
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 collapse \uc5ec\ubd80(\uc120\ud0dd\ub41c \uc601\uc5ed\uc774 \uc788\ub294\uc9c0 \uc5ec\ubd80)\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Boolean} - collapse \uc5ec\ubd80
	 * @example
	 * 	txSelection.isCollapsed();
	 */
	isCollapsed: function() {
		var _sel = this.getSel();
		return (_sel && _sel.isCollapsed);
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc744 collapse \uc2dc\ud0a8\ub2e4.
	 * @param {Boolean} toStart - \uc704\uce58, \uc2dc\uc791 = true
	 * @example
	 * 	txSelection.collapse(true);
	 */
	collapse: function(toStart) {
		var _sel = this.getSel();
		if (_sel && _sel.rangeCount > 0) {
			var _rng = _sel.getRangeAt(0);
			_rng.collapse(toStart);
		}
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ucee8\ud2b8\ub864 \ub178\ub4dc(img,object,hr,table,button)\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Element} - \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ub178\ub4dc
	 * @example
	 * 	txSelection.getControl();
	 */
	getControl: function() {
		var _sel = this.getSel();
		var _node;
		if ($tx.opera) {
			/* @opera IMG \uc120\ud0dd\uc2dc isCollapsed \uac00 true \ub418\ub294 \ubb38\uc81c\uac00 \uc788\uc74c. */
			_node = _sel.anchorNode.childNodes[_sel.anchorOffset];
			if (_node == _NULL) {
				return _NULL;
			}
			if(_sel.isCollapsed && _node.tagName != "IMG") {
				return _NULL;	
			}
		}
		else {
			if(_sel.isCollapsed) {
				return _NULL;	
			}
			_node = _sel.anchorNode.childNodes[_sel.anchorOffset];
		}
		if($tom.kindOf(_node, '%control')) {
			return _node;
		} else {
			return _NULL;
		}
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc774 \ucee8\ud2b8\ub864 \ub178\ub4dc\uc778\uc9c0 \uc5ec\ubd80\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Boolean} - \ucee8\ud2b8\ub864 \ub178\ub4dc\uc778\uc9c0 \uc5ec\ubd80
	 * @example
	 * 	txSelection.hasControl();
	 */
	hasControl: function() {
		return (this.getControl() != _NULL);
	},
	/**
	 * \ucee8\ud2b8\ub864 \ub178\ub4dc\ub97c \uc120\ud0dd\ud55c\ub2e4.
	 * @param {Element} node - \ucee8\ud2b8\ub864 \ub178\ud2b8 
	 * @example
	 * 	txSelection.selectControl(node);
	 */
	selectControl: function(node) {
		var _rng = this.createRange();
		_rng.selectNode(node);
		var _sel = this.getSel();
		_sel.removeAllRanges();
		_sel.addRange(_rng);
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc774 \ud14d\uc2a4\ud2b8 \ub370\uc774\ud130 \uc601\uc5ed\uc758 \uc5b4\ub5a4 \uc704\uce58\uc778\uc9c0\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Number} - \ud14d\uc2a4\ud2b8 \ub370\uc774\ud130 \uc601\uc5ed\uc758 \uc5b4\ub5a4 \uc704\uce58\uc778\uc9c0 <br/>
	 * 					\ube48 \ud14d\uc2a4\ud2b8\uc77c \uacbd\uc6b0 : $tom.__POSITION.__EMPTY_TEXT : -2<br/>
	 * 					\ud14d\uc2a4\ud2b8\uc758 \ucc98\uc74c : $tom.__POSITION.__START_OF_TEXT : -1<br/>
	 * 					\ud14d\uc2a4\ud2b8\uc758 \uc911\uac04 : $tom.__POSITION.__MIDDLE_OF_TEXT : 0<br/>
	 * 					\ud14d\uc2a4\ud2b8\uc758 \ub9c8\uc9c0\ub9c9 : $tom.__POSITION.__END_OF_TEXT : 1
	 * @example
	 * 	txSelection.compareTextPos();
	 */
	compareTextPos: function() {
		var _rng = this.getRange();
		if (_rng) {
			var _startContainer = _rng.startContainer;
			if (_startContainer.nodeType == 3) {
				if ( _startContainer.textContent.trim().length == 0 ){
					return $tom.__POSITION.__EMPTY_TEXT;
				}else if(_rng.startOffset == 0 ) {
					return $tom.__POSITION.__START_OF_TEXT;
				} else if(_rng.startOffset == _startContainer.textContent.length) {
					return $tom.__POSITION.__END_OF_TEXT;
				} else {
					return $tom.__POSITION.__MIDDLE_OF_TEXT;
				}
			}
		}
		return $tom.__POSITION.__END_OF_TEXT;
	},
	/**
	 * @private
	 * selection\uc5d0 \ubcf5\uc218\uc758 range\uac00 \uc788\uc744 \uacbd\uc6b0 range\ub97c \ud569\uce5c\ub514\u314f.
	 * @returns {Object} - native range \uac1d\uccb4
	 * @example
	 * 	txSelection.mergeRange(sel);
	 */
	mergeRange: function(sel) {
		try {
			var _ranges = [];
			for(var i=0,_length=sel.rangeCount; i<_length; i++) {
				_ranges.push(sel.getRangeAt(i));
			}
			sel.removeAllRanges();
			
			var _startNode = _ranges[0].startContainer.childNodes[_ranges[0].startOffset];
			var _endNode = _ranges[_length - 1].endContainer.childNodes[_ranges[_length - 1].endOffset - 1];
			
			var _rng = this.doc.createRange();
			try {
				_rng.setStart(_startNode, 0);
			} catch (e) {
				_rng.collapse(_TRUE);
			}
			try {
				_rng.setEnd(_endNode, _endNode.childNodes.length);
			} catch (e) {}
			
			sel.addRange(_rng);
			return sel.getRangeAt(0);
		} catch(e) {
			return sel.getRangeAt(0);
		}
	},
	/**
	 * @private
	 * \ud2b9\uc815 \uc704\uce58\ub85c range\uc758 \uc2dc\uc791\uc704\uce58\ub97c \uc9c0\uc815\ud55c\ub2e4.
	 * @param {Object} rng - native range \uac1d\uccb4
	 * @param {Element} node - \ud2b9\uc815 \ubd80\ubaa8 \ub178\ub4dc
	 * @param {Number} offset - \ub178\ub4dc\uc758 \uc635\uc14b
	 * @example
	 * 	txSelection.setStart(range, node, 1);
	 */
	setStart: function(rng, node, offset) {
		try {
			rng.setStart(node, offset);
		} catch (e) {
			rng.collapse(_TRUE);
			rng.setStart(node, offset);
		}
	},
	/**
	 * @private
	 * \ud2b9\uc815 \uc704\uce58\ub85c range\uc758 \ub05d\uc704\uce58\ub97c \uc9c0\uc815\ud55c\ub2e4.
	 * @param {Object} rng - native range \uac1d\uccb4
	 * @param {Element} node - \ud2b9\uc815 \ubd80\ubaa8 \ub178\ub4dc
	 * @param {Number} offset - \ub178\ub4dc\uc758 \uc635\uc14b
	 * @example
	 * 	txSelection.setEnd(range, node, 1);
	 */
	setEnd: function(rng, node, offset) {
		try {
			rng.setEnd(node, offset);
		} catch (e) {
			rng.collapse(_FALSE);
			rng.setEnd(node, offset);
		}
	},
	/**
	 * \uc8fc\uc5b4\uc9c4 range\ub97c \uc120\ud0dd\ud55c\ub2e4.
	 * @returns {Object} - native selection \uac1d\uccb4
	 * @example
	 * 	txSelection.selectRange(range);
	 */
	selectRange: function(rng) {
		var _sel = this.getSel();
		_sel.removeAllRanges(); 
		_sel.addRange(rng); 
	}
};

	
Trex.I.Selection.Trident = /** @lends Trex.Canvas.Selection.prototype */{
	/**
	 * native selection object\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Object} - native selection object
	 * @example
	 * 	txSelection.getSel();
	 */
	getSel: function(){
		return this.doc.selection;
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ud14d\uc2a4\ud2b8 \ub370\uc774\ud130\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {String} - \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ud14d\uc2a4\ud2b8 \ub370\uc774\ud130
	 * @example
	 * 	txSelection.getText();
	 */
	getText: function() {
		return this.getSel().createRange().text;
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ub178\ub4dc\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Element} - \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ub178\ub4dc
	 * @example
	 * 	txSelection.getNode();
	 */
	getNode: function() {
		var _sel = this.getSel();
		var _type = _sel.type.toLowerCase();
		if (_type === "control") {
			return (_sel.createRange().item(0));
		} else {
			return (_sel.createRange().parentElement());
		}
	},
	/**
	 * native range \ub97c \uc0dd\uc131\ud55c\ub2e4.
	 * @returns {Object} - native range \uac1d\uccb4
	 * @example
	 * 	txSelection.createRange();
	 */
	createRange: function() {
		var _sel = this.getSel();
		return _sel.createRange();
	},
	/**
	 * native text range \ub97c \uc0dd\uc131\ud55c\ub2e4.
	 * @returns {Object} - native text range \uac1d\uccb4
	 * @example
	 * 	txSelection.createTextRange();
	 */
	createTextRange: function() {
		return this.doc.body.createTextRange();
	},
	/**
	 * native range object\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Object} - native range \uac1d\uccb4
	 * @example
	 * 	txSelection.getRange();
	 */
	getRange: function(collapse){
		var _sel = this.getSel();
		var _type = _sel.type.toLowerCase();
		if (_type == "none") {
			return _sel.createRange() ? _sel.createRange() : function(){
				var _rng = this.doc.body.createTextRange();
				_rng.collapse(_TRUE);
				_rng.select();
				return _rng;
			}();
		}
		if (collapse == _NULL) {
			return _sel.createRange();
		} else {
			if (_type === "text") {
				var _rng = _sel.createRange();
				_rng.collapse(collapse);
				_rng.select();
				return _sel.createRange();
			} else {
				if (_type === "control") {
					_sel.empty();
				}
				return _sel.createRange();
			}
		}
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 collapse \uc5ec\ubd80(\uc120\ud0dd\ub41c \uc601\uc5ed\uc774 \uc788\ub294\uc9c0 \uc5ec\ubd80)\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Boolean} - collapse \uc5ec\ubd80
	 * @example
	 * 	txSelection.isCollapsed();
	 */
	isCollapsed: function() {
		var _sel = this.getSel();
		var _type = _sel.type.toLowerCase();
		if(_type === "none") {
			return _TRUE;
		} else if(_type === "control") {
			return _TRUE;
		} else if(_type === "text") {
			var _rng = _sel.createRange();
            return _rng.compareEndPoints('StartToEnd', _rng) == 0;
		} else {
			return _TRUE;
		}
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc744 collapse \uc2dc\ud0a8\ub2e4.
	 * @param {Boolean} toStart - \uc704\uce58, \uc2dc\uc791 = true
	 * @example
	 * 	txSelection.collapse(true);
	 */
	collapse: function(toStart) {
		var _sel = this.getSel();
		var _type = _sel.type.toLowerCase();
		if(_type === "text") {
			var _rng = _sel.createRange();
			_rng.collapse(toStart);
			_rng.select();
			return _sel.createRange();
		} else {
			if(_type === "control") {
				_sel.empty();
			}
			return _sel.createRange();
		}
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ucee8\ud2b8\ub864 \ub178\ub4dc(img,object,hr,table,button)\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Element} - \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ub178\ub4dc
	 * @example
	 * 	txSelection.hasControl();
	 */
	getControl: function() {
		var _sel = this.getSel();
		var _type = _sel.type.toLowerCase();
		if (_type === "control") {
			var _node = _sel.createRange().item(0);
			if($tom.kindOf(_node, '%control')) {
				return _node;
			} else {
				return _NULL;
			}
		} else {
			return _NULL;
		}
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc774 \ucee8\ud2b8\ub864 \ub178\ub4dc\uc778\uc9c0 \uc5ec\ubd80\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Boolean} - \ucee8\ud2b8\ub864 \ub178\ub4dc\uc778\uc9c0 \uc5ec\ubd80
	 * @example
	 * 	txSelection.hasControl();
	 */
	hasControl: function() {
		var _sel = this.getSel();
		var _type = _sel.type.toLowerCase();
		if (_type === "control") {
			return _TRUE;
		} else {
			return _FALSE;
		}
	},
	/**
	 * \ucee8\ud2b8\ub864 \ub178\ub4dc\ub97c \uc120\ud0dd\ud55c\ub2e4.
	 * @param {Element} node - \ucee8\ud2b8\ub864 \ub178\ud2b8 
	 * @example
	 * 	txSelection.selectControl(node);
	 */
	selectControl: function(node) {
		var _rng = this.doc.body.createControlRange();
		_rng.add(node);
		_rng.select();
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc774 \ud14d\uc2a4\ud2b8 \ub370\uc774\ud130 \uc601\uc5ed\uc758 \uc5b4\ub5a4 \uc704\uce58\uc778\uc9c0\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Number} - \ud14d\uc2a4\ud2b8 \ub370\uc774\ud130 \uc601\uc5ed\uc758 \uc5b4\ub5a4 \uc704\uce58\uc778\uc9c0 <br/>
	 * 					\ud14d\uc2a4\ud2b8\uc758 \ucc98\uc74c : $tom.__POSITION.__START_OF_TEXT : -1<br/>
	 * 					\ud14d\uc2a4\ud2b8\uc758 \uc911\uac04 : $tom.__POSITION.__MIDDLE_OF_TEXT : 0<br/>
	 * 					\ud14d\uc2a4\ud2b8\uc758 \ub9c8\uc9c0\ub9c9 : $tom.__POSITION.__END_OF_TEXT : 1
	 * @example
	 * 	txSelection.compareTextPos();
	 */
	compareTextPos: function() {
		var _sel = this.getSel();
		var _type = _sel.type.toLowerCase();
		if(_type === "none") {
			var _rng = _sel.createRange();
			var _rng2 = _rng.duplicate();
			_rng2.moveToElementText(_rng.parentElement());
			if ( _rng2.text.trim().replace(Trex.__WORD_JOINER_REGEXP, "").length == 0 ){
				return $tom.__POSITION.__EMPTY_TEXT;
			} else if(_rng.compareEndPoints('StartToStart', _rng2) == 0) {
				return $tom.__POSITION.__START_OF_TEXT;
			} else if(_rng.compareEndPoints('EndToEnd', _rng2) == 0) {
				return $tom.__POSITION.__END_OF_TEXT;
			} else {
				return $tom.__POSITION.__MIDDLE_OF_TEXT;
			}
		}
		return $tom.__POSITION.__END_OF_TEXT;
	},
	/**
	 * @private
	 * @reference http://msdn.microsoft.com/en-us/library/ms536745(VS.85).aspx
		StartToEnd - Move the start of the TextRange object to the end of the specified oTextRange parameter.
		StartToStart - Move the start of the TextRange object to the start of the specified oTextRange parameter.
		EndToStart - Move the end of the TextRange object to the start of the specified oTextRange parameter.
		EndToEnd - Move the end of the TextRange object to the end of the specified oTextRange parameter.
	 */
	transTextRange: function(rng, node, offset, toStart) {
		var _pntRng = this.createTextRange();
		
		var _pntNode = this.win.span(Trex.__WORD_JOINER);
		$tom.insertAt(_pntNode, node);
		_pntRng.moveToElementText(_pntNode);
		$tom.remove(_pntNode);
		
		_pntRng.collapse(_TRUE);
		_pntRng.moveStart('character', offset);
			
		if (toStart) {
			rng.setEndPoint('StartToStart', _pntRng);
		} else {
			rng.setEndPoint('EndToEnd', _pntRng);
		}
		
		return rng;
	},
	/**
	 * @private
	 * \ud2b9\uc815 \uc704\uce58\ub85c range\uc758 \uc2dc\uc791\uc704\uce58\ub97c \uc9c0\uc815\ud55c\ub2e4.
	 * @param {Object} rng - native range \uac1d\uccb4
	 * @param {Element} node - \ud2b9\uc815 \ubd80\ubaa8 \ub178\ub4dc
	 * @param {Number} offset - \ub178\ub4dc\uc758 \uc635\uc14b
	 * @example
	 * 	txSelection.setStart(range, node, 1);
	 */
	setStart: function(rng, node, offset) {
		try {
			this.transTextRange(rng, node, offset, _TRUE);
		} catch (e) {
			
		}
		return rng;
	},
	/**
	 * @private
	 * \ud2b9\uc815 \uc704\uce58\ub85c range\uc758 \ub05d\uc704\uce58\ub97c \uc9c0\uc815\ud55c\ub2e4.
	 * @param {Object} rng - native range \uac1d\uccb4
	 * @param {Element} node - \ud2b9\uc815 \ubd80\ubaa8 \ub178\ub4dc
	 * @param {Number} offset - \ub178\ub4dc\uc758 \uc635\uc14b
	 * @example
	 * 	txSelection.setEnd(range, node, 1);
	 */
	setEnd: function(rng, node, offset) {
		try {
			this.transTextRange(rng, node, offset, _FALSE);
		} catch (e) {
			
		}
		return rng;
	},
	/**
	 * \uc8fc\uc5b4\uc9c4 range\ub97c \uc120\ud0dd\ud55c\ub2e4.
	 * @returns {Object} - native selection \uac1d\uccb4
	 * @example
	 * 	txSelection.selectRange(range);
	 */
	selectRange: function(rng) {
		rng.select();
	}
};

Trex.I.Selection.TridentStandard = {
    /**
     * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ucee8\ud2b8\ub864 \ub178\ub4dc(img,object,hr,table,button)\ub97c \ub9ac\ud134\ud55c\ub2e4.
     * @returns {Element} - \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ub178\ub4dc
     * @example
     * 	txSelection.getControl();
     */
    getControl: function() {
		//ie11\uc5d0\uc11c img\ud0dc\uadf8\ub97c \uc774\ub3d9\uc2dc\uc5d0 \ub2e4\uc2dc getControl\uc744 \ud558\uba74 anchorNode\uc5d0 \uc788\ub294\uac8c \uc544\ub2c8\ub77c focusNode\uc5d0 \uc788\ub2e4.
        var _sel = this.getSel();
        if(_sel.isCollapsed) {
            return null;
        }
		var selNode, selOffset;
		selOffset = $tom.isElement(selNode = _sel.anchorNode)?_sel.anchorOffset:$tom.isElement(selNode = _sel.focusNode)?_sel.focusOffset-1:_NULL;
        if (selOffset !== _NULL) {
            var _node = selNode.childNodes[selOffset];
            if ($tom.kindOf(_node, '%control')) {
                return _node;
            } else {
                return null;
            }
        }
        //button,img
        var _prevNode = $tom.previous(_sel.focusNode);
        var _nextNode = $tom.next(_sel.anchorNode);
        if(_prevNode == _nextNode) {
            return ($tom.kindOf(_prevNode, '%control')&&_prevNode)||$tom.first(_prevNode, '%control');
        } else {
            return null;
        }
    },
    /**
     * \ucee8\ud2b8\ub864 \ub178\ub4dc\ub97c \uc120\ud0dd\ud55c\ub2e4.
     * @param {Element} node - \ucee8\ud2b8\ub864 \ub178\ud2b8
     * @example
     * 	txSelection.selectControl(node);
     */
    selectControl: function(node) {
		var _rng;
		if(this.doc.body.createControlRange) {
			_rng = this.doc.body.createControlRange();
			_rng.add(node);
			_rng.select();
		}else {
			_rng = this.createRange();
			_rng.selectNode(node);
			var _sel = this.getSel();
			_sel.removeAllRanges();
			_sel.addRange(_rng);
		}
    }
};


Trex.I.Selection.Gecko = {
	
};

Trex.I.Selection.Webkit = {
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ucee8\ud2b8\ub864 \ub178\ub4dc(img,object,hr,table,button)\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Element} - \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ub178\ub4dc
	 * @example
	 * 	txSelection.getControl();
	 */
	getControl: function() {
		var _sel = this.getSel();
		if(_sel.isCollapsed) {
			return _NULL;	
		}
		if ($tom.isElement(_sel.anchorNode)) {
			var _node = _sel.anchorNode.childNodes[_sel.anchorOffset];
			if ($tom.kindOf(_node, '%control')) {
				return _node;
			} else {
				return _NULL;
			}
		}
		//button
		var _prevNode = $tom.previous(_sel.focusNode);
		var _nextNode = $tom.next(_sel.anchorNode);
		if(_prevNode == _nextNode) {
			return $tom.first(_prevNode, '%control');
		} else {
			return _NULL;
		}
	},
	/**
	 * \ucee8\ud2b8\ub864 \ub178\ub4dc\ub97c \uc120\ud0dd\ud55c\ub2e4.
	 * @param {Element} node - \ucee8\ud2b8\ub864 \ub178\ud2b8 
	 * @example
	 * 	txSelection.selectControl(node);
	 */
	selectControl: function(node) {
		var _rng = this.createRange();
		_rng.selectNode(node);
		var _sel = this.getSel();
		_sel.removeAllRanges();
		_sel.addRange(_rng);
	}
};

Trex.I.Selection.Presto = {
	
};

/**
 * native selection, range \uac1d\uccb4\ub97c wrapping \ud55c \uac1d\uccb4\ub85c <br/>
 * browser\uc5d0 \ub530\ub77c \ud544\uc694\ud55c \ud568\uc218\ub4e4\uc744 mixin\ud55c\ub2e4. <br/>
 * \uc8fc\ub85c Processor\uc640 \uc5f0\uad00\ub41c \uac1d\uccb4\uc5d0\uc11c \ud638\ucd9c\ud558\uba70, <br/>
 * processor.getTxSel()\ub97c \ud1b5\ud574\uc11c txSelection\ub97c \uc5bb\uc5b4\uc11c \uc0ac\uc6a9\ud55c\ub2e4. <br/>
 * native selection \uacfc \uad6c\ubd84\uc9d3\uae30 \uc704\ud574\uc11c txSelection\ub85c \uba85\uba85\ud55c\ub2e4.
 *
 * @class
 * @param {Object} processor - Processor \uac1d\uccb4
 */
Trex.Canvas.Selection = Trex.Class.create(/** @lends Trex.Canvas.Selection.prototype */{
	/** @ignore */
	$mixins: [
		Trex.I.Selection.Standard,
		(($tx.msie_nonstd)? Trex.I.Selection.Trident: {}),
        (($tx.msie_std)? Trex.I.Selection.TridentStandard: {}),
		(($tx.gecko)? Trex.I.Selection.Gecko: {}),
		(($tx.webkit)? Trex.I.Selection.Webkit: {}),
		(($tx.presto)? Trex.I.Selection.Presto: {})
	],
	initialize: function(processor) {
		this.processor = processor;
		this.win = processor.win;
		this.doc = processor.doc;
	}
});


/**
 * @fileOverview
 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc744 \ubd81\ub9c8\ud06c\ud558\uc5ec 
 * \ud3ec\ucee4\uc2a4\ub41c document\uac00 \ubcc0\uacbd\ub418\uac70\ub098 DOM \uc870\uc791\uc744 \ud558\ub354\ub77c\ub3c4 \uc120\ud0dd \uc601\uc5ed\uc774 \uc720\uc9c0\ub418\ub3c4\ub85d \ud55c\ub2e4.
 * Processor \uc5d0\uc11c \uc8fc\ub85c \uc0ac\uc6a9\ub41c\ub2e4. 
 */

/**
 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc744 \ubd81\ub9c8\ud06c\ud558\uc5ec <br/> 
 * \ud3ec\ucee4\uc2a4\ub41c document\uac00 \ubcc0\uacbd\ub418\uac70\ub098 DOM \uc870\uc791\uc744 \ud558\ub354\ub77c\ub3c4 \uc120\ud0dd \uc601\uc5ed\uc774 \uc720\uc9c0\ub418\ub3c4\ub85d \ud558\ub294 \uac1d\uccb4\ub85c <br/>
 * native range \uac1d\uccb4\uc5d0 \uc788\ub294 5\uac00\uc9c0 \ud504\ub85c\ud37c\ud2f0\ub9cc \uc800\uc7a5\ud55c\ub2e4. <br/>
 * \uc8fc\ub85c Processor\uc640 \uc5f0\uad00\ub41c \uac1d\uccb4\uc5d0\uc11c \ud638\ucd9c\ud558\uba70, <br/>
 * processor.getBookmark()\ub97c \ud1b5\ud574\uc11c bookmark\ub97c \uc5bb\uc5b4\uc11c \uc0ac\uc6a9\ud55c\ub2e4.<br/>
 * 
 * @class
 */
Trex.Canvas.Bookmark = Trex.Class.create(/** @lends Trex.Canvas.Bookmark.prototype */{
	startContainer: _NULL,
	startOffset: 0,
	endContainer: _NULL,
	endOffset: 0,
	initialize: function(processor) {
		this.processor = processor;
		this.win = processor.win;
		this.doc = processor.doc;
		this.dummy = function() {
			return processor.newDummy();
		};
	},
	/**
	 * \uc2dc\uc791\uc704\uce58\uc640 \ub05d\uc704\uce58\ub97c \ub3d9\uc77c\ud558\uac8c \ubd81\ub9c8\ud06c\ub97c \uc218\uc815\ud55c\ub2e4.
	 * @param {Boolean} toStart - \uc704\uce58, \uc2dc\uc791 = true
	 * @example
	 * 	bookmark.collapse(true);
	 */
	collapse: function (toStart) {
		if (toStart) {
			this.updateEnd(this.startContainer, this.startOffset);
		} else {
			this.updateStart(this.endContainer, this.endOffset);
		}
	},
	/**
	 * native range \uac1d\uccb4\ub85c \ubd81\ub9c8\ud06c\ub97c \uc218\uc815\ud55c\ub2e4.
	 * @param {Object} rng - native range \uac1d\uccb4
	 * @example
	 * 	bookmark.save(range);
	 */
	save: function(rng) {
		this.updateStart(rng.startContainer, rng.startOffset);
		this.updateEnd(rng.endContainer, rng.endOffset);
	},
	/**
	 * \ud2b9\uc815 \ub178\ub4dc\uc758 \uc55e\uacfc \ub4a4\ub85c \ubd81\ub9c8\ud06c\ub97c \uc218\uc815\ud55c\ub2e4. 
	 * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
	 * @example
	 * 	bookmark.saveAroundNode(node);
	 */
	saveAroundNode: function (node) {
		this.updateStartBefore($tom.top(node));
		this.updateEndAfter($tom.bottom(node));
	},
	/**
	 * \ud2b9\uc815 \ub178\ub4dc\uc758 \ucc98\uc74c\uc73c\ub85c \ubd81\ub9c8\ud06c\ub97c \uc218\uc815\ud55c\ub2e4.
	 * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
	 * @example
	 * 	bookmark.saveIntoFirst(node);
	 */
	saveIntoFirst: function(node) {
		var _node = $tom.top(node);
		this.updateEndBefore(_node);
		this.collapse(_FALSE);
	},
	/**
	 * \ud2b9\uc815 \ub178\ub4dc\uc758 \ub9c8\uc9c0\ub9c9\uc73c\ub85c \ubd81\ub9c8\ud06c\ub97c \uc218\uc815\ud55c\ub2e4.
	 * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
	 * @example
	 * 	bookmark.saveIntoLast(node);
	 */
	saveIntoLast: function(node) {
		var _node = $tom.bottom(node);
		this.updateEndBefore(_node);
		this.collapse(_FALSE);
	},
	/**
	 * \ud2b9\uc815 \ub178\ub4dc\uc758 \uc774\uc804\uc73c\ub85c \ubd81\ub9c8\ud06c\ub97c \uc218\uc815\ud55c\ub2e4.
	 * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
	 * @example
	 * 	bookmark.saveNextTo(node);
	 */
	savePreviousTo: function(node) {
		if($tom.previous(node)) {
			var _node = $tom.top($tom.previous(node));
			this.updateEndAfter(_node);
		} else {
			this.updateEndBefore(node);
		}
		this.collapse(_FALSE);
	},
	/**
	 * \ud2b9\uc815 \ub178\ub4dc\uc758 \ub2e4\uc74c\uc73c\ub85c \ubd81\ub9c8\ud06c\ub97c \uc218\uc815\ud55c\ub2e4.
	 * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
	 * @example
	 * 	bookmark.saveNextTo(node);
	 */
	saveNextTo: function(node) {
		if($tom.next(node)) {
			var _node = $tom.top($tom.next(node));
			this.updateEndBefore(_node);
		} else {
			this.updateEndAfter(node);
		}
		this.collapse(_FALSE);
	},
	/**
	 * marker node\ub85c \ubd81\ub9c8\ud06c\ub97c \uc218\uc815\ud55c\ub2e4.
	 * @param {Object} marker - marker \uac1d\uccb4
	 * @example
	 * 	bookmark.saveWithMarker(marker);
	 */
	saveWithMarker: function(marker) {
		if (marker.checkCollapsed()) { //collapsed
			this.updateEndAfter(marker.endMarker);
			this.collapse(_FALSE);
		} else {
			this.updateStartBefore(marker.startMarker);
			this.updateEndAfter(marker.endMarker);
		}
	},
	/**
	 * txSelection\uac00\uc9c0\uace0 \uc800\uc7a5\ub41c \ubd81\ub9c8\ud06c\ub97c \uc120\ud0dd\ud55c\ub2e4. 
	 * @param {Object} txSelection - txSelection \uac1d\uccb4
	 * @example
	 * 	bookmark.select(txSelection);
	 */
	select: function(txSel) {
		if (this.isValid()) {
			var _rng = txSel.createTextRange();
			try {
				txSel.setStart(_rng, this.startContainer, this.startOffset);
				txSel.setEnd(_rng, this.endContainer, this.endOffset);
			} catch (e) {
				
			}
			txSel.selectRange(_rng);
		}
		this.reset();
	},
    isValid: function() {
        return this.isValidStartContainer() && this.isValidEndContainer();
    },
    isValidStartContainer: function() {
        return this.doc.body === $tom.body(this.startContainer);
    },
    isValidEndContainer: function() {
        return this.doc.body === $tom.body(this.endContainer);
    },
	/**
	 * @private
	 * \uc2dc\uc791 \uad00\ub828 \ud504\ub85c\ud37c\ud2f0\ub97c \ud2b9\uc815 \uc704\uce58\ub85c \uc9c0\uc815\ud55c\ub2e4.
	 * @param {Element} node - \ud2b9\uc815 \ubd80\ubaa8 \ub178\ub4dc
	 * @param {Number} offset - \ub178\ub4dc\uc758 \uc635\uc14b
	 * @example
	 * 	bookmark.updateStart(node, 1);
	 */
	updateStart: function(node, offset) {
		this.startContainer = node;
		this.startOffset = offset;
	},
	/**
	 * @private
	 * \uc2dc\uc791 \uad00\ub828 \ud504\ub85c\ud37c\ud2f0\ub97c \ud2b9\uc815 \uc704\uce58\ub85c \uc774\uc804\uc73c\ub85c \uc9c0\uc815\ud55c\ub2e4.
	 * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
	 * @example
	 * 	bookmark.updateStartBefore(node);
	 */
	updateStartBefore: function(node) {
		var _tNode = this.dummy();
		$tom.insertAt(_tNode, node);
			
		this.startContainer = _tNode;
		this.startOffset = 0;
	},
	/**
	 * @private
	 * \uc2dc\uc791 \uad00\ub828 \ud504\ub85c\ud37c\ud2f0\ub97c \ud2b9\uc815 \uc704\uce58\ub85c \ub2e4\uc74c\uc73c\ub85c \uc9c0\uc815\ud55c\ub2e4.
	 * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
	 * @example
	 * 	bookmark.updateStartAfter(node);
	 */
	updateStartAfter: function(node) {
		var _tNode = this.dummy();
		$tom.insertNext(_tNode, node);
			
		this.startContainer = _tNode;
		this.startOffset = 0;
	},
	/**
	 * @private
	 * \ub05d \uad00\ub828 \ud504\ub85c\ud37c\ud2f0\ub97c \ud2b9\uc815 \uc704\uce58\ub85c \uc9c0\uc815\ud55c\ub2e4.
	 * @param {Element} node - \ud2b9\uc815 \ubd80\ubaa8 \ub178\ub4dc
	 * @param {Number} offset - \ub178\ub4dc\uc758 \uc635\uc14b
	 * @example
	 * 	bookmark.updateEnd(node, 1);
	 */
	updateEnd: function(node, offset) {
		this.endContainer = node;
		this.endOffset = offset;
	},
	/**
	 * @private
	 * \ub05d \uad00\ub828 \ud504\ub85c\ud37c\ud2f0\ub97c \ud2b9\uc815 \uc704\uce58\ub85c \uc774\uc804\uc73c\ub85c \uc9c0\uc815\ud55c\ub2e4.
	 * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
	 * @example
	 * 	bookmark.updateEndBefore(node);
	 */
	updateEndBefore: function(node) {
		var _tNode = this.dummy();
		if (node.nodeName && node.nodeName.toUpperCase() == "P" && !node.nodeValue) { // Note: \ub9c8\uc9c0\ub9c9 \uc870\uac74( !node.nodeValue)\uc740 \ubb34\uc758\ubbf8\ud55c\ub370..
			$tom.append(node, _tNode);
		}else {
			$tom.insertAt(_tNode, node);
		}
		
		this.endContainer = _tNode;
		this.endOffset = _tNode.length;
	},
	/**
	 * @private
	 * \ub05d \uad00\ub828 \ud504\ub85c\ud37c\ud2f0\ub97c \ud2b9\uc815 \uc704\uce58\ub85c \ub2e4\uc74c\uc73c\ub85c \uc9c0\uc815\ud55c\ub2e4.
	 * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
	 * @example
	 * 	bookmark.updateEndAfter(node);
	 */
	updateEndAfter: function(node) {
		var _tNode = this.dummy();
		$tom.insertNext(_tNode, node);
		
		this.endContainer = _tNode;
		this.endOffset = _tNode.length;
	},
	/**
	 * @private
	 * \ubd81\ub9c8\ud06c\ub97c \ucd08\uae30\ud654\ud55c\ub2e4.
	 * @returns {Boolean} - collapse \uc5ec\ubd80
	 * @example
	 * 	bookmark.reset();
	 */
	reset: function() {
		this.startContainer = _NULL;
		this.startOffset = 0;
		this.endContainer = _NULL;
		this.endOffset = 0;
	}
});
	
Trex.Canvas.TextAreaProcessor = Trex.Class.create({
	$mixins: [ ],
	initialize: function(textarea) {
		this.el = textarea;
	},
	focus: function() {
		this.el.focus();
	},
	blur: function() {
		_WIN.focus();
	},
    /**
     * \ubcf8\ubb38\uc758 \ucc98\uc74c\uc73c\ub85c \uce90\ub7ff\uc744 \uc62e\uae34\ub2e4.
     * @example
     * 	processor.focusOnTop();
     */
    focusOnTop: function() {
        var textarea = this.el;
        textarea.focus();
        this._selectCharacter(0, 0);
        textarea.scrollTop = 0;
    },
    focusOnBottom: function() {
        var textarea = this.el;
        textarea.focus();
        var len = textarea.value.length;
        this._selectCharacter(len, len);
        textarea.scrollTop = textarea.scrollHeight;
    },
	savePosition: function() {
        // \uc65c \uc0ac\uc6a9\ub418\uc5c8\ub294\uc9c0 \uc758\ubb38.. this.currentPos\uac00 \uc4f0\uc774\ub294 \uacf3\uc774 \uc5c6\uc74c. #FTDUEDTR-1395
//		if (this.el.createTextRange) {
//			this.currentPos = _DOC.selection.createRange().duplicate();
//		}
	},
	controlEnter: function() {
		var _processor = this;
		_processor.insertTag("<br/>", "");
	},
	insertTag: function(prefix, postfix) {
		this.pasteContent(prefix + postfix);
		return _TRUE;
	},
	pasteContent: function( content/*, newLine, wrapStyle*/){
		this.el.value += content;
	},
    _selectCharacter: function(startChar, endChar) {
        var textarea = this.el;
        if (textarea.setSelectionRange) { // standard
            textarea.select();
            textarea.setSelectionRange(startChar, endChar);

        } else if (textarea.createTextRange) { // IE
            var range = textarea.createTextRange();
            range.collapse(_TRUE);
            range.moveStart("character", startChar);
            range.moveEnd("character", endChar);
            range.select();
        }
    }
});

/**
 * @fileOverview
 * Wysiwyg \uc601\uc5ed\uc758 \ucee8\ud150\uce20\ub97c \uc870\uc791\ud558\uae30 \uc704\ud574 \uc0ac\uc6a9\ub418\ub294 \uacf5\ud1b5\ub418\ub294 Processor \uc815\uc758
 */
Trex.I.Processor = {};
Trex.I.Processor.Standard = /** @lends Trex.Canvas.Processor.prototype */{
	txSelection: _NULL,
    isRangeInsideWysiwyg: _FALSE,
    lastRange: _NULL,
    savedRange: _NULL,
	initialize: function(win, doc) {
		this.win = win;
        /**
         * @type {HTMLDocument}
         */
		this.doc = doc;

		this.txSelection = new Trex.Canvas.Selection(this);
		this.bookmark = new Trex.Canvas.Bookmark(this);
	},
	/**
	 * Trex.Canvas.Selection \uac1d\uccb4\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Object} - Trex.Canvas.Selection \uac1d\uccb4
	 * @example
	 * 	processor.getTxSel();
	 */
	getTxSel: function() {
		return this.txSelection;
	},
	/**
	 * native selection object\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Object} - native selection \uac1d\uccb4
	 * @example
	 * 	processor.getSel();
	 */
	getSel: function(){
		return this.txSelection.getSel();
	},
	/**
	 * native range object\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Object} - native range \uac1d\uccb4
	 * @example
	 * 	processor.getRange();
	 */
	getRange: function() {
		return this.txSelection.getRange();
	},
	/**
	 * Trex.Canvas.Bookmark \uac1d\uccb4\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Object} - Trex.Canvas.Bookmark \uac1d\uccb4
	 * @example
	 * 	processor.getBookmark();
	 */
	getBookmark: function() {
		return this.bookmark;
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 collapse \uc5ec\ubd80(\uc120\ud0dd\ub41c \uc601\uc5ed\uc774 \uc788\ub294\uc9c0 \uc5ec\ubd80)\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Boolean} - collapse \uc5ec\ubd80
	 * @see Trex.Canvas.Selection#isCollapsed
	 * @example
	 * 	processor.isCollapsed();
	 */
	isCollapsed: function() {
		return this.txSelection.isCollapsed();
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ub178\ub4dc\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Element} - \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ub178\ub4dc
	 * @see Trex.Canvas.Selection#getNode
	 * @example
	 * 	processor.getNode();
	 */
	getNode: function() {
		return this.txSelection.getNode();
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ucee8\ud2b8\ub864 \ub178\ub4dc(img,object,hr,table,button)\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Element} - \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ub178\ub4dc
	 * @see Trex.Canvas.Selection#getControl
	 * @example
	 * 	processor.getControl();
	 */
	getControl: function(){
		return this.txSelection.getControl();
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc774 \ucee8\ud2b8\ub864 \ub178\ub4dc\uc778\uc9c0 \uc5ec\ubd80\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Boolean} - \ucee8\ud2b8\ub864 \ub178\ub4dc\uc778\uc9c0 \uc5ec\ubd80
	 * @see Trex.Canvas.Selection#hasControl
	 * @example
	 * 	processor.hasControl();
	 */
	hasControl: function(){
		return this.txSelection.hasControl();
	},
	/**
	 * \ucee8\ud2b8\ub864 \ub178\ub4dc\ub97c \uc120\ud0dd\ud55c\ub2e4.
	 * @param {Element} node - \ucee8\ud2b8\ub864 \ub178\ud2b8
	 * @example
	 * 	txSelection.selectControl(node);
	 */
	selectControl: function(node){
		return this.txSelection.selectControl(node);
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ud14d\uc2a4\ud2b8 \ub370\uc774\ud130\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {String} - \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 \ud14d\uc2a4\ud2b8 \ub370\uc774\ud130
	 * @see Trex.Canvas.Selection#getText
	 * @example
	 * 	processor.getText();
	 */
	getText: function(){
		return this.txSelection.getText();
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc774 \ud14d\uc2a4\ud2b8 \ub370\uc774\ud130 \uc601\uc5ed\uc758 \uc5b4\ub5a4 \uc704\uce58\uc778\uc9c0\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @returns {Number} - \ud14d\uc2a4\ud2b8 \ub370\uc774\ud130 \uc601\uc5ed\uc758 \uc5b4\ub5a4 \uc704\uce58\uc778\uc9c0 <br/>
	 * 					\ud14d\uc2a4\ud2b8\uc758 \ucc98\uc74c : $tom.__POSITION.__START_OF_TEXT : -1<br/>
	 * 					\ud14d\uc2a4\ud2b8\uc758 \uc911\uac04 : $tom.__POSITION.__MIDDLE_OF_TEXT : 0<br/>
	 * 					\ud14d\uc2a4\ud2b8\uc758 \ub9c8\uc9c0\ub9c9 : $tom.__POSITION.__END_OF_TEXT : 1
	 * @see Trex.Canvas.Selection#compareTextPos
	 * @example
	 * 	processor.compareTextPos();
	 */
	compareTextPos: function() {
		return this.txSelection.compareTextPos();
	},
	/**
	 * \ud604\uc7ac \uc120\ud0dd\ub41c \uc601\uc5ed\uc5d0\uc11c \uc870\uac74\uc5d0 \ub9de\ub294 \ub178\ub4dc\ub97c \ub9ac\ud134\ud55c\ub2e4.
	 * @param {Function, String} filter - \uc870\uac74\uc744 \ub098\ud0c0\ub0b4\ub294 \ud568\uc218 \ub610\ub294 \ubb38\uc790\uc5f4
	 * @returns {Element} - \uc870\uac74\uc5d0 \ub9de\ub294 \ub178\ub4dc
	 * @example
	 * 	processor.findNode(function() { return 'p,div'; });
	 * 	processor.findNode('%paragraph');
	 */
	findNode: function(filter) {
		try {
			return $tom.find(this.getNode(), filter);
		} catch(e) {
			return _NULL;
		}
	},
	/*-------- processor - query style start --------*/
	/**
	 * \ud2b9\uc815\ud55c \ub178\ub4dc\uc758 \ud2b9\uc815\ud55c \uc2a4\ud0c0\uc77c \uac12\uc744 \uc5bb\uc5b4\uc628\ub2e4.
	 * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
	 * @param {String} styleName - \uc2a4\ud0c0\uc77c \uba85
	 * @returns {String} - \uc2a4\ud0c0\uc77c \uac12
	 * @example
	 * 	processor.queryStyle(node, 'textAlign');
	 */
	queryStyle: function(node, styleName) {
		if(!node) {
			return _NULL;
		}
		styleName = ((styleName == 'float')? ((node.style.styleFloat === _UNDEFINED)? 'cssFloat': 'styleFloat'): styleName);
		if(node.style && node.style[styleName]) {
			return node.style[styleName];
		} else if(node.currentStyle && node.currentStyle[styleName]) {
			return node.currentStyle[styleName];
		} else if(_WIN.getComputedStyle) {
            var targetNode = node;
            while($tom.isText(targetNode)){
                targetNode = targetNode.parentNode;
            }
			var _cssStyle = this.doc.defaultView.getComputedStyle(targetNode, _NULL);
			return ((_cssStyle)? _cssStyle[styleName] : _NULL);
		}
		return _NULL;
	},
	/**
	 * \ud2b9\uc815\ud55c \ub178\ub4dc\uc758 \ud2b9\uc815\ud55c \uc18d\uc131 \uac12\uc744 \uc5bb\uc5b4\uc628\ub2e4.
	 * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
	 * @param {String} attrName - \uc18d\uc131 \uba85
	 * @returns {String} - \uc18d\uc131 \uac12
	 * @example
	 * 	processor.queryAttr(node, 'align');
	 */
	queryAttr: function(node, attrName) {
		if(!node) {
			return _NULL;
		}
		return $tom.getAttribute(node, attrName);
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 native queryCommandState \uac12\uc744 \uc5bb\uc5b4\uc628\ub2e4.
	 * @param {String} command - \ucee4\ub9e8\ub4dc \uba85
	 * @returns {Boolean} - \ud574\ub2f9 \uc601\uc5ed\uc774 \ucee4\ub9e8\ub4dc \uc0c1\ud0dc\uc778\uc9c0 \uc5ec\ubd80
	 * @example
	 * 	processor.queryCommandState('bold');
	 */
	queryCommandState: function(command) {
		try {
			return this.doc.queryCommandState(command);
		} catch(e) { return _FALSE; }
	},
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 native queryCommandValue \uac12\uc744 \uc5bb\uc5b4\uc628\ub2e4.
	 */
	queryCommandValue: function(command) {
		try {
			return this.doc.queryCommandValue(command);
		} catch(e) {
			return "";
		}
	},
	/*-------- processor - query style end --------*/
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc5d0 native execCommand\ub97c \uc2e4\ud589\uc2dc\ud0a8\ub2e4.
	 * @param {String} command - \ucee4\ub9e8\ub4dc \uba85
	 * @param {String} data - \ub370\uc774\ud130 \uac12
	 * @example
	 * 	processor.execCommand('forecolor', '#333');
	 */
	execCommand: function(command, data) {
		if ($tx.gecko) {
			// Firefox\ub294 styleWithCSS \uae30\ubcf8\uac12\uc774 true
			try {
				this.doc.execCommand('styleWithCSS', _FALSE, _FALSE);
			} catch(e) {}
		}
		try {
			this.doc.execCommand(command, _FALSE, data);
		} catch(e) {}
	},
	/*-------- processor - marker start --------*/
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc5d0 \uc8fc\uc5b4\uc9c4 handler\ub97c \uc2e4\ud589\uc2dc\ud0a8\ub2e4.
	 * \uc8fc\ub85c \uc678\ubd80\uc5d0\uc11c processor\ub97c \uc774\uc6a9\ud574 DOM\uc870\uc791\uc744 \ud560 \uacbd\uc6b0\uc5d0 \uc0ac\uc6a9\ub41c\ub2e4.
	 * @param {Funtion} handler - \ud574\ub2f9 \uc601\uc5ed\uc5d0 \uc2e4\ud589\ud560 \ud568\uc218
	 * @example
	 * 	processor.execWithMarker(function(marker) {
	 *		$tom.insertAt(node, marker.endMarker);
	 *  });
	 */
	execWithMarker: function(handler) {
		var _marker = new Trex.Canvas.Marker(this);
		this.bookmarkTo();
		try {
			_marker.paste();
			_marker.backup();
			handler(_marker);
		} catch(e) {
			
		} finally {
			_marker.remove();
		}
	},
	/*-------- processor - marker end --------*/
	/*--------------------- focus, movecaret ----------------------*/
	/**
	 * wysiwyg \uc601\uc5ed\uc5d0 \ud3ec\ucee4\uc2a4\ub97c \uc900\ub2e4.
	 * @example
	 * 	processor.focus();
	 */
	focus: function() {
		this.doc.body.focus();
	},
	/**
	 * wysiwyg \uc601\uc5ed\uc5d0 \ud3ec\ucee4\uc2a4\ub97c \ube80\ub2e4.
	 * @example
	 * 	processor.blur();
	 */
	blur: function() {
		_WIN.focus(); //NOTE: by focused on parent window, editor will be blured
	},
	/**
	 * \ubcf8\ubb38\uc758 \ucc98\uc74c\uc73c\ub85c \uce90\ub7ff\uc744 \uc62e\uae34\ub2e4.
	 * @example
	 * 	processor.focusOnTop();
	 */
	focusOnTop: function() {
		this.focus();
		this.selectFirstText(this.doc.body);
		this.doc.body.scrollTop = 0; //NOTE: only html, not xhtml
	},
	selectFirstText: function(node) {
		var firstNode = $tom.top(node);
		var range = this.createGoogRangeFromNodes(firstNode, 0, firstNode, 0);
		range.select();
	},
	/**
	 * \ubcf8\ubb38\uc758 \ub9c8\uc9c0\ub9c9\uc73c\ub85c \uce90\ub7ff\uc744 \uc62e\uae34\ub2e4.
	 * @example
	 * 	processor.focusOnBottom();
	 */
	focusOnBottom: function() {
		this.focus();
		this.moveCaretTo(this.doc.body, _FALSE);
		this.doc.body.scrollTop = this.doc.body.scrollHeight; //NOTE: only html, not xhtml
	},
	/**
	 * \ud2b9\uc815 \ub178\ub4dc\ub85c \uce90\ub7ff\uc744 \uc62e\uae34\ub2e4.
	 * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
	 * @param {Boolean} toStart - \uc704\uce58, \uc2dc\uc791 = true
	 * @example
	 * 	processor.moveCaretTo(node, true);
	 */
	moveCaretTo: function(node, toStart) {
		if(!node) {
			return;
		}
        this.focus();
		this.bookmarkInto(node, toStart);
		this.bookmark.select(this.txSelection);
	},
	/**
	 * \ud2b9\uc815 \ub178\ub4dc\uc758 \ubc14\uae65\uc73c\ub85c \uce90\ub7ff\uc744 \uc62e\uae34\ub2e4.
	 * @param {String} scope - \ud2b9\uc815 \ub178\ub4dc \ud328\ud134
	 * @example
	 * 	processor.moveCaretWith(scope);
	 */
	moveCaretWith: function(scope) {
		if(!scope) { return; }
		var _elOuter = this.findNode(scope);
		if(_elOuter) {
            this.focus();
			this.bookmark.saveNextTo(_elOuter);
			this.bookmark.select(this.txSelection);
		}
	},
	/**
	 * \ud2b9\uc815 \ub178\ub4dc\ub97c \uac10\uc2f8 \uc120\ud0dd\ud55c\ub2e4.
	 * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
	 * @example
	 * 	processor.selectAround(node);
	 */
	selectAround: function(node) {
		if(!node) {
			return;
		}
        this.focus();
		this.bookmark.saveAroundNode(node);
		this.bookmark.select(this.txSelection);
	},
	/**
	 * \ud2b9\uc815 \ub178\ub4dc\uc758 \uc548\uc73c\ub85c \ubd81\ub9c8\ud06c\ub97c \uc218\uc815\ud55c\ub2e4.
	 * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
	 * @example
	 * 	processor.bookmarkInto(node);
	 */
	bookmarkInto: function(node, toStart) {
		if(!node) {
			return;
		}
		toStart = (toStart == _NULL)? _TRUE: toStart;
		if(toStart) {
			this.bookmark.saveIntoFirst(node);
		} else {
			this.bookmark.saveIntoLast(node);
		}
	},
	/**
	 * \ud2b9\uc815 \ub178\ub4dc\uc758 \uc774\uc804\uc73c\ub85c \ubd81\ub9c8\ud06c\ub97c \uc218\uc815\ud55c\ub2e4.
	 * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
	 * @example
	 * 	processor.bookmarkToPrevious(node);
	 */
	bookmarkToPrevious: function(node) {
		if(!node) {
			return;
		}
		this.bookmark.savePreviousTo(node);
	},
	/**
	 * \ud2b9\uc815 \ub178\ub4dc\uc758 \ub2e4\uc74c\uc73c\ub85c \ubd81\ub9c8\ud06c\ub97c \uc218\uc815\ud55c\ub2e4.
	 * @param {Element} node - \ud2b9\uc815 \ub178\ub4dc
	 * @example
	 * 	processor.bookmarkToNext(node);
	 */
	bookmarkToNext: function(node) {
		if(!node) {
			return;
		}
		this.bookmark.saveNextTo(node);
	},
	/**
	 * execute\ud558\uae30 \uc804 range\ub97c \ubd81\ub9c8\ud06c\ud55c\ub2e4.
	 * @example
	 * 	processor.bookmark();
	 */
	bookmarkTo: function(rng) {
		rng = rng || this.txSelection.getRange();
		this.bookmark.save({
			startContainer: rng.startContainer,
			startOffset: rng.startOffset,
			endContainer: rng.endContainer,
			endOffset: rng.endOffset
		});
	},
	/**
	 * marker\uc5d0 \ub530\ub77c \ubd81\ub9c8\ud06c\ub97c \uc218\uc815\ud55c\ub2e4.
	 * @example
	 * 	processor.bookmarkWithMarker(marker);
	 */
	bookmarkWithMarker: function(marker) {
		this.bookmark.saveWithMarker(marker);
	},
	/**
	 * \uc800\uc7a5\ud55c range\ub97c \uc120\ud0dd\ud55c\ub2e4.
	 * @example
	 * 	processor.restore();
	 */
	restore: function() {
		this.bookmark.select(this.txSelection);
	},
	/*------------ execute action ------------*/
	/**
	 * \uc778\uc790\uc5d0 \ub530\ub77c \ub178\ub4dc\ub97c \uc0dd\uc131\ud55c\ub2e4.
	 * @param {String, Object, Element} argument - \uac00\ubcc0 arguments<br/>
	 * 			{String} name : 1st String\uc740 \ub178\ub4dc\uba85  <br/>
	 * 			{Object} attributes : \uc801\uc6a9\ud560 \uc18d\uc131\ub4e4  <br/>
	 * 			{Element, String, Number} children : \uc790\uc2dd \ub178\ub4dc
	 * @example
	 * 	processor.create('div', { 'className': 'txc-textbox' });
	 */
	create: function() {
		var name = arguments[0];
		var _node = this.newNode(name);
		for (var i = 1; i < arguments.length; i++) {
			var arg = arguments[i];
			if (arg.nodeType) {
				$tom.append(_node, arg);
			} else if (typeof(arg) == 'string' || typeof(arg) == 'number') {
				_node.innerHTML += arg;
			} else if (typeof(arg) == 'array') {
				for (var j = 0; j < arg.length; j++) {
					$tom.append(_node, arg[j]);
				}
			} else {
				$tom.applyAttributes(_node, arg);
			}
		}
		return _node;
	},
	/**
	 * \uc120\ud0dd\ud55c \uc601\uc5ed\uc5d0 \ub178\ub4dc\ub97c \uc0bd\uc785\ud55c\ub2e4.
	 * @param {Array,Element} nodes - \uc0bd\uc785\ud558\uace0\uc790 \ud558\ub294 \ub178\ub4dc \ubc30\uc5f4 \ub610\ub294 \ub178\ub4dc
	 * @param {Boolean} newline - \ud604\uc7ac \uc601\uc5ed\uc5d0\uc11c \ud55c\uc904\uc744 \ub744\uc6b4 \ud6c4 \uc0bd\uc785\ud560\uc9c0 \uc5ec\ubd80
	 * @param {Object} wrapStyle - wrapper \ub178\ub4dc\uc5d0 \uc801\uc6a9\ud560 \uc2a4\ud0c0\uc77c, <br/>
	 * 					newline\uc774 true \uc77c \uacbd\uc6b0\uc5d0\ub9cc \uc758\ubbf8\ub97c \uac16\ub294\ub2e4.
	 * @example
	 * 	processor.pasteNode([node, node], true, { 'style': { 'textAlign': 'center' } });
	 */
	pasteNode: function(nodes, newline, wrapStyle) {
		if(!nodes) {
			return;
		}
		if(!nodes.length) {
			nodes = [].concat(nodes);
		}

		this.txSelection.collapse(_FALSE);
		if(newline) {
			/* order
			 * (curNode) > wpNode > dvNode
			 */
			var _curNode, _wpNode, _dvNode;

			var _processor = this;
			this.execWithMarker(function(marker) {
				_dvNode = $tom.divideParagraph(marker.endMarker);
				var _detected = $tom.kindOf(_dvNode, 'p,li,dd,dt,h1,h2,h3,h4,h5,h6');
				if(_detected) {
					_curNode = $tom.previous(_dvNode);
					_wpNode = $tom.clone(_dvNode);
				} else {
					_dvNode = _processor.newNode('p');
					$tom.insertAt(_dvNode, marker.endMarker);
					_wpNode = _processor.newNode('p');
				}
				$tom.insertAt(_wpNode, _dvNode);
				nodes.each(function(node) {
					$tom.append(_wpNode, node);
				});
				if(wrapStyle) {
					$tom.applyAttributes(_wpNode, wrapStyle);
				}
                // #FTDUEDTR-1442
                if (nodes.length == 1) {
                    var firstChildNode = nodes[0];
                    var disableBlockTag = $tom.kindOf(firstChildNode, 'table,hr,blockquote,pre,h1,h2,h3,h4,h5,h6,div');
                    var isParagraphTag = $tom.isTagName(_wpNode, 'p');
                    if (disableBlockTag && isParagraphTag) {
                        firstChildNode.style.marginLeft = _wpNode.style.marginLeft;
                        $tom.unwrap(_wpNode);
                    }
                }
			});
			if(_curNode) {
				if(!$tom.hasData(_curNode)) {
					this.stuffNode(_curNode);
				}
			}
			this.stuffNode(_dvNode);
			this.bookmark.saveIntoFirst(_dvNode);
		} else {
            var self = this;
            this.executeUsingCaret(function(range, savedCaret) {
                var startCaret = savedCaret.getCaret(_FALSE),
                    endCaret = savedCaret.getCaret(_FALSE);
                var targetNode = $tx.msie_nonstd ? startCaret : _NULL;
                nodes.each(function(node) {
                    range.insertNode(node, targetNode);
                });
                if (endCaret && endCaret.nextSibling) {
                    self.moveCaretTo(endCaret.nextSibling, 0);
                }
            });
		}
		return nodes[0];
	},
	/**
	 * \uc120\ud0dd\ud55c \uc601\uc5ed\uc5d0 HTML \ucee8\ud150\uce20\ub97c \uc0bd\uc785\ud55c\ub2e4.
	 * @param {String} html - \uc0bd\uc785\ud558\uace0\uc790 \ud558\ub294 HTML \ucee8\ud150\uce20
	 * @param {Boolean} newline - \ud604\uc7ac \uc601\uc5ed\uc5d0\uc11c \ud55c\uc904\uc744 \ub744\uc6b4 \ud6c4 \uc0bd\uc785\ud560\uc9c0 \uc5ec\ubd80 true/false
	 * @param {Object} wrapStyle - wrapper \ub178\ub4dc\uc5d0 \uc801\uc6a9\ud560 \uc2a4\ud0c0\uc77c, <br/>
	 * 					newline\uc774 true \uc77c \uacbd\uc6b0\uc5d0\ub9cc \uc758\ubbf8\ub97c \uac16\ub294\ub2e4.
	 * @example
	 * 	processor.pasteNode('<img src="\uc774\ubbf8\uc9c0\uacbd\ub85c"/>', true, { 'style': { 'textAlign': 'center' } });
	 */
	pasteContent: function(html, newline, wrapStyle) {
		var _tmpNode = this.create('div');
		_tmpNode.innerHTML = html;
		var _dataNodes = $tom.children(_tmpNode);
		return this.pasteNode(_dataNodes, newline, wrapStyle);
	},
	/**
	 * \uc8fc\uc5b4\uc9c4 \ub178\ub4dc\ub97c \uc0c8\ub85c\uc6b4 \ub178\ub4dc\ub85c \uad50\uccb4\ud55c\ub2e4.
	 * @param {Element} node - \uae30\uc874 \ub178\ub4dc
	 * @param {String} tag - \uc0c8\ub85c\uc6b4 \ub178\ub4dc \uba85
	 * @param {Object} attributes - \uc0c8\ub85c\uc6b4 \ub178\ub4dc\uc5d0 \uc801\uc6a9\ud560 \uc18d\uc131\ub4e4
	 * @returns {Element} - \uc0dd\uc131\ud55c \ub178\ub4dc
	 * @example
	 * 	processor.replace(p, 'li');
	 */
	replace: function(node, tag, attributes) {
		this.bookmark.saveAroundNode(node);
		return $tom.replace(node, this.create(tag, attributes));
	},
	/**
	 * \uc120\ud0dd\ud55c \uc601\uc5ed\uc548\uc5d0 \uc788\ub294 \ub178\ub4dc \uc911\uc5d0 \ud328\ud134\uc744 \ub9cc\uc871\ud558\ub294 \ube14\ub7ed \ub178\ub4dc\ub4e4\uc744 \ub9ac\ud134\ud55c\ub2e4.
	 * @param {Array} filter - \uc218\uc9d1\ud560 \ub178\ub4dc \ud328\ud134 \uc870\uac74
	 * @returns {Array} - \uc120\ud0dd\ud55c \uc601\uc5ed\uc548\uc5d0 \uc788\ub294 \ub178\ub4dc \uc911\uc5d0 \ud328\ud134\uc744 \ub9cc\uc871\ud558\ub294 \ub178\ub4dc\ub4e4
	 * @example
	 * 	processor.blocks(function() {
			return '%paragraph';
		});
	 */
	blocks: function(filter) {
		var _nodes = [];
		var _patterns = filter();
		if (this.hasControl()) {
			var _control = this.getControl();
			if ($tom.kindOf(_control.parentNode, _patterns)) {
				_nodes.push(_control.parentNode);
			}
		} else {
			var _processor = this;
			this.execWithMarker(function(marker) {
				var _itr = _processor.getBlockRangeIterator(_patterns, marker.startMarker, marker.endMarker);
				var _node;
				while (_itr.hasNext()) {
					_node = _itr.next();
					if ($tom.kindOf(_node, '#tx_start_marker,#tx_end_marker')) {
						//ignore
					} else {
						_nodes.push(_node);
					}
				}
			});
		}
		return _nodes;
	},
	/**
	 * \uc120\ud0dd\ud55c \uc601\uc5ed\uc548\uc5d0 \uc788\ub294 \ub178\ub4dc \uc911\uc5d0 \ud328\ud134\uc744 \ub9cc\uc871\ud558\ub294 \uc778\ub77c\uc778 \ub178\ub4dc\ub4e4\uc744 \ub9ac\ud134\ud55c\ub2e4.
	 * @param {Array} filter - \uc218\uc9d1\ud560 \ub178\ub4dc \ud328\ud134 \uc870\uac74
	 * @returns {Array} - \uc120\ud0dd\ud55c \uc601\uc5ed\uc548\uc5d0 \uc788\ub294 \ub178\ub4dc \uc911\uc5d0 \ud328\ud134\uc744 \ub9cc\uc871\ud558\ub294 \ub178\ub4dc\ub4e4
	 * @example
	 * 	processor.inlines(function(type) {
			if(type === 'control') {
				return 'hr,table';
			}
			return '%inline';
		});
	 */
	inlines: function(filter) {
		var _nodes = [];
		var _patterns = filter();

		var _processor = this;
		var _createInline = function() {
			return _processor.create($tom.inlineOf());
		};

		if (this.hasControl()) {
			var _control = this.getControl();
			if ($tom.kindOf(_control, _patterns)) {
				_nodes.push(_control);
			} else {
				var _iNode = _createInline();
				$tom.insertNext(_iNode, _control);
				$tom.append(_iNode, _control);
			}
		} else {
			this.execWithMarker(function(marker) {
				if (marker.checkCollapsed()) { //collapsed
					var _iNode = _createInline();
					$tom.append(_iNode, _processor.newDummy());
					$tom.insertNext(_iNode, marker.startMarker);
					_processor.bookmarkTo({
						startContainer: _iNode,
						startOffset: 1,
						endContainer: _iNode,
						endOffset: 1
					});
					_nodes.push(_iNode);
				} else {
					var _itr = _processor.getInlineRangeIterator(_patterns, marker.startMarker, marker.endMarker);
					var _node;
					while (_itr.hasNext()) {
						_node = _itr.next();
						if ($tom.kindOf(_node, '#tx_start_marker,#tx_end_marker')) {
							//ignore
						} else if ($tom.kindOf(_node, 'br')) {
							//ignore
						} else {
							_nodes.push(_node);
						}
					}
				}
			});
		}
		return _nodes;
	},
	/**
	 * \uc120\ud0dd\ud55c \uc601\uc5ed\uc548\uc5d0 \uc788\ub294 \ub178\ub4dc \uc911\uc5d0 \ud328\ud134\uc744 \ub9cc\uc871\ud558\ub294 \ucee8\ud2b8\ub864 \ub178\ub4dc(img,object,hr,table,button)\ub4e4\uc744 \ub9ac\ud134\ud55c\ub2e4.
	 * @param {Array} filter - \uc218\uc9d1\ud560 \ub178\ub4dc \ud328\ud134 \uc870\uac74
	 * @returns {Array} - \uc120\ud0dd\ud55c \uc601\uc5ed\uc548\uc5d0 \uc788\ub294 \ub178\ub4dc \uc911\uc5d0 \ud328\ud134\uc744 \ub9cc\uc871\ud558\ub294 \ub178\ub4dc\ub4e4
	 * @example
	 * 	processor.controls(function() {
			return 'hr,table';
		});
	 */
	controls: function(filter) {
		var _nodes = [];
		if (this.hasControl()) {
			if ($tom.kindOf(this.getControl(), filter())) {
				_nodes.push(this.getControl());
			}
		}
		return _nodes;
	},
	/**
	 * \ub354\ubbf8\uc6a9 nbsp\ub97c \ub123\ub294 \ud568\uc218.
	 * webkit \uc6a9\uc5d0 \uad6c\ud604\ub418\uc5b4\uc788\uc2b5\ub2c8\ub2e4.
	 * Safari \uc5d0\uc11c apply \uc2dc
	 * \ud3f0\ud2b8\uc5d0 \ub300\ud55c \uc18d\uc131\uc744 \uc783\uc5b4\ubc84\ub9ac\uae30 \ub54c\ubb38\uc5d0 \ud544\uc694.
	 */
	addDummyNbsp: function () {},
	/**
	 * \ubc30\uc5f4 \ub0b4\uc758 \ubaa8\ub4e0 \ub178\ub4dc\uc5d0\uac8c \uc9c0\uc815\ud55c \uc18d\uc131\uc744 \uc801\uc6a9\ud55c\ub2e4.
	 * @param {Array} nodes - \uc18d\uc131\uc744 \uc801\uc6a9\ud560 \ub178\ub4dc \ubc30\uc5f4
	 * @param {Object} attributes - \ub178\ub4dc\uc5d0 \uc801\uc6a9\ud560 \uc18d\uc131\ub4e4
	 * @returns {Array} - \uc785\ub825 \ub178\ub4dc\ub4e4
	 * @example
	 * 	processor.apply([p,p,p], { style: { textAlign: 'center'}});
	 */
	apply: function(nodes, attributes) {
		if(!nodes) {
			return _NULL;
		}
		if(!nodes.length) {
			nodes = [].concat(nodes);
		}
		nodes.each(function(node) {
			$tom.applyAttributes(node, attributes);
		});
		return nodes;
	},
	/**
	 * \ubc30\uc5f4 \ub0b4\uc758 \ubaa8\ub4e0 \ub178\ub4dc\ub97c \uc8fc\uc5b4\uc9c4 \ube14\ub7ed\uc73c\ub85c \uac10\uc2fc\ub2e4.
	 * @param {Array} nodes - \ube14\ub7ed\uc73c\ub85c \uac10\uc300 \ub178\ub4dc \ubc30\uc5f4
	 * @param {String} tag - \ube14\ub7ed \ub178\ub4dc \uba85
	 * @param {Object} attributes - \ube14\ub7ed\uc5d0 \uc801\uc6a9\ud560 \uc18d\uc131
	 * @returns {Element} - \uc0dd\uc131\ud55c \ube14\ub7ed\ub178\ub4dc
	 * @example
	 * 	processor.wrap([p,p,p], 'div', { style: { backgroundColor: 'black'}});
	 */
	wrap: function(nodes, tag, attributes) {
		if(!nodes) {
			return _NULL;
		}
		if(!nodes.length) {
			nodes = [].concat(nodes);
		}
		attributes = attributes || {};
		var res = $tom.wrap(this.create(tag, attributes), nodes);
        if($tx.msie && !$tom.nextContent(res)){
            var e = this.doc.createElement('p');
            e.innerHTML = $tom.EMPTY_BOGUS;
            this.doc.body.appendChild(e);
        }
        return res;
	},
	/**
	 * \ube14\ub7ed\uc73c\ub85c \uac10\uc2f8\uc9c4 \ub178\ub4dc\ub4e4\uc744 \ube7c\ub0b4\uace0 \ube14\ub7ed\uc744 \uc0ad\uc81c\ud55c\ub2e4.
	 * @param {Element} node - \ube14\ub7ed \ub178\ub4dc
	 * @returns {Element} - \ube14\ub7ed\uc758 \uccab\ubc88\uc9f8 \ub178\ub4dc \ub610\ub294 \ube14\ub7ed\uc758 \ub2e4\uc74c \ub178\ub4dc
	 * @example
	 * 	processor.unwrap(node);
	 */
	unwrap: function(node) {
		if (!node) {
			return _NULL;
		}
		this.bookmark.saveAroundNode(node);
		return $tom.unwrap(node);
	},
	createGoogRange: function() {
		return goog.dom.Range.createFromWindow(this.win)
	},
	createGoogRangeFromNodes: function(startNode, startOffset, endNode, endOffset) {
		return goog.dom.Range.createFromNodes(startNode, startOffset, endNode, endOffset);
	},
    createGoogFromNodeContents: function (node, opt_isReversed) {
        return goog.dom.Range.createFromNodeContents(node, opt_isReversed);
    },
	executeUsingCaret: function(handler) {
		try {
			var range = this.createGoogRange();
			var savedCaret = range.saveUsingCarets();
			return handler(range, savedCaret);
		} finally {
			if (!savedCaret.isDisposed()) {
				savedCaret.restore();
			}
		}
	},
	getControlByAreaSelection: function(){
		if(this.getAreaSelection)
			return this.getAreaSelection().getTarget();
		return this.getControl();
	},
    moveSelection: function(x,y){
        var doc = this.doc;
        var win = this.win;
        var rng;
        var pos;
		x-=win.pageXOffset||doc.documentElement.scrollLeft;
		y-=win.pageYOffset||doc.documentElement.scrollTop;
        if (doc.caretPositionFromPoint) {
            //ff
            rng = doc.createRange();
            pos = doc.caretPositionFromPoint(x, y);
            rng.setStart(pos.offsetNode, pos.offset);
            rng.setEnd(pos.offsetNode, pos.offset);
        }else if(doc.caretRangeFromPoint){
            //chrome
            rng = doc.caretRangeFromPoint(x, y);
        }else {
            //ie
            try{
                rng = doc.body.createTextRange()||doc.createRange();
                rng.moveToPoint(x,y);
                rng.select();
            }catch(e){
                
            }
            return;
        }
        if(!rng) return;
        var sel = this.getSel();
        sel.removeAllRanges();
        sel.addRange(rng);
    }
};

Trex.module("observe that @when control elements are focused at",
	function(editor, toolbar, sidebar, canvas) {
		if($tx.webkit || $tx.presto) {
			canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEDOWN, function(ev) {
				var _processor = canvas.getProcessor();
				var _node = $tx.element(ev);
				if ($tom.kindOf(_node, "img,hr,iframe,table")) {
					var _button = $tom.find(_node, 'button');
					if(_button) {
						_processor.selectControl(_button);
					} else {
						_processor.selectControl(_node);
					}
				} else if ($tom.kindOf(_node, "button")) {
					_processor.selectControl(_node);
				}
			});
		}
	}
);

Trex.module("bind iframe activate or deactivate event",
    function(editor, toolbar, sidebar, canvas) {
//        if ($tx.msie_nonstd) {
            canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function(panelDoc) {
                var _processor = canvas.getProcessor(Trex.Canvas.__WYSIWYG_MODE);

                $tx.observe(panelDoc, 'beforedeactivate', function(ev) {
                    try {
                        var range = _processor.getRange();
                        _processor.isRangeInsideWysiwyg = true;
                        _processor.lastRange = range;

                    } catch (ignore) {
                        // range\ub97c \uac00\uc838\uc62c \ub54c \uc624\ub958\uac00 \ubc1c\uc0dd\ud558\uae30\ub3c4 \ud55c\ub2e4.
                    }
                });

                $tx.observe(panelDoc, 'deactivate', function (ev) {
                    if (_processor.hasControl()) {
                        return;
                    }
                    _processor.isRangeInsideWysiwyg = false;
                });

                $tx.observe(panelDoc, 'activate', function() {
                    _processor.isRangeInsideWysiwyg = true;
                    _processor.lastRange = _NULL;
                });
            });
//        }
    }
);


Trex.module("save range when keyup or mouseup event ",
    function(editor, toolbar, sidebar, canvas) {
        canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function(panelDoc) {
            var processor = canvas.getProcessor(Trex.Canvas.__WYSIWYG_MODE);
            var debounceSaveRange = $tx.debounce(saveRange, 200);
            function saveRange() {
                var newRange = processor.createGoogRange();
                if (newRange) {
                    processor.savedRange = newRange;
                }
            }
            $tx.observe(panelDoc, 'deactivate', function (ev) {
                saveRange();
            });

            $tx.observe(panelDoc, 'mouseup', function (ev) {
                saveRange();
            });

            $tx.observe(panelDoc, 'keydown', function (ev) {
                debounceSaveRange();
            });
        });
    }
);

Trex.I.Processor.Trident = {
	/**
	 * Paragraph \ub97c \ucc44\uc6b4\ub2e4.
 	 * @private
 	 * @param {Node} node - paragraph \ub178\ub4dc
	 */
	stuffNode: function(node) {
		if($tom.getLength(node) == 0) {
			node.innerHTML = '&nbsp;';
		}
		return node;
	},
	/**
	 * @private
	 * @memberOf Trex.Canvas.ProcessorP
	 * Trident\uc5d0\uc11c newlinepolicy\uac00 p\uc77c \uacbd\uc6b0 Enter Key \uc774\ubca4\ud2b8\uac00 \ubc1c\uc0dd\ud558\uba74 \uc2e4\ud589\ud55c\ub2e4. 
	 */
	controlEnterByParagraph: function() {
		var _bNode = this.findNode('div');
        var _dvNode;
		if (!_bNode) { 
			throw $propagate;
		}
		
		var _pNode = this.findNode('%paragraph');
		if ($tom.kindOf(_pNode, 'p')) { 
			if($tom.first(_bNode, 'p') == _pNode) {
				this.execWithMarker(function(marker) {
					_dvNode = $tom.divideParagraph(marker.endMarker);
				});
				this.stuffNode(_pNode);
				this.stuffNode(_dvNode);
				this.moveCaretTo(_dvNode);
			} else {
				throw $propagate;
			}
		} else if($tom.kindOf(_pNode, 'li,td,th,dd,dt')) {
			throw $propagate;
		} else {
			_dvNode = this.newParagraph('p');
			this.execWithMarker(function(marker) {
				$tom.insertNext(_dvNode, marker.endMarker);
			});
			this.moveCaretTo(_dvNode);
		}
	}
};

Trex.module("delete image element @when backspace key event fires",
	function(editor, toolbar, sidebar, canvas) {
		if ($tx.msie_nonstd) {
			canvas.observeKey({ 
				ctrlKey: _FALSE,
				altKey: _FALSE,
				shiftKey: _FALSE,
				keyCode: Trex.__KEY.BACKSPACE
			}, function() {
				var _processor = canvas.getProcessor();
				if (_processor.hasControl() && _processor.getControl()) {
					try {
						var _node = _processor.getControl();
						$tom.remove(_node);
					} catch (e) { }
					throw $stop;
				}
				throw $propagate;
			});
		}
	}
);

Trex.module("delete table element @when backspace key event fires",
	function(editor, toolbar, sidebar, canvas) {
		if ($tx.msie_nonstd) {
			var _oldRangeLeftOffset;
			canvas.observeKey({ 
				ctrlKey: _FALSE,
				altKey: _FALSE,
				shiftKey: _FALSE,
				keyCode: Trex.__KEY.BACKSPACE
			}, function() {
				var _processor = canvas.getProcessor();
				var _rng = _processor.getRange();
				try{
					if(_oldRangeLeftOffset == _rng.boundingLeft){
						var _el = $tom.previous(_processor.getNode());
						if($tom.kindOf(_el, "table")){
							$tom.remove(_el);	
						}	
					}
				}catch(e){ }
				_oldRangeLeftOffset = _rng.boundingLeft;
				throw $propagate;
			});
		}
	}
);

/*-------------------------------------------------------*/

Object.extend(Trex.I.Processor.Trident, {
	restoreRange: function() { //TODO: rename
		if (!this.isRangeInsideWysiwyg && this.lastRange) {
			try {
				this.lastRange.select();
			} catch (e) {
				var _sel = this.getSel();
				var _type = _sel.type.toLowerCase();
				if (_type === "control") {
					_sel.empty();
					var _rng = _sel.createRange();
					_rng.collapse(_FALSE);
					_rng.select();
				}
			} finally {
				this.lastRange = _NULL;
			}
		}
	}
});
Trex.I.Processor.TridentStandard = {
    /**
     * Paragraph \ub97c \ucc44\uc6b4\ub2e4.
     * @private
     * @param {Node} node - paragraph \ub178\ub4dc
     */
    stuffNode: function(node) {
        return $tom.stuff(node, this.newNode('br'));
    },
    /**
     * @private
     * @memberOf Trex.Canvas.ProcessorP
     * Webkit\uc5d0\uc11c newlinepolicy\uac00 p\uc77c \uacbd\uc6b0 Enter Key \uc774\ubca4\ud2b8\uac00 \ubc1c\uc0dd\ud558\uba74 \uc2e4\ud589\ud55c\ub2e4.
     * @param {Event} ev - Enter Key \uc774\ubca4\ud2b8
     */
    controlEnterByParagraph: function(ev) {
        throw $propagate;
    },
    /**
     * @private
     * @memberOf Trex.Canvas.ProcessorBR
     * Webkit\uc5d0\uc11c newlinepolicy\uac00 br\uc77c \uacbd\uc6b0 Enter Key \uc774\ubca4\ud2b8\uac00 \ubc1c\uc0dd\ud558\uba74 \uc2e4\ud589\ud55c\ub2e4.
     * @param {Event} ev - Enter Key \uc774\ubca4\ud2b8
     */
    controlEnterByLinebreak: function(ev) {
        var _processor = this;
        var _rng = this.getRange(false);
        var _parent = _rng.endContainer.parentNode;

        if (_parent && (_parent.tagName == "P" || _parent.tagName == "DIV" || _parent.tagName == "BODY" || _parent.tagName == "BLOCKQUOTE")) {

            if(_parent.tagName == "BLOCKQUOTE" || $tx.hasClassName(_parent, "txc-textbox") || $tx.hasClassName(_parent, "txc-moreless")){
                $tx.stop(ev);
                var _brNode = _processor.win.br();
                _rng.insertNode(_brNode);
                _rng.selectNode(_brNode);
                _rng.collapse(false);
                _brNode = _processor.win.br();
                _rng.insertNode(_brNode);
                _rng.selectNode(_brNode);
                _rng.collapse(false);

                var _rng = _processor.getRange(false);
                _rng.selectNodeContents(_brNode.nextSibling);

                var _sel = _processor.getSel();
                _sel.removeAllRanges();
                _sel.addRange(_rng);
                _sel.collapseToStart();
            }
        }
    },
    /**
     * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 native queryCommandState \uac12\uc744 \uc5bb\uc5b4\uc628\ub2e4.
     * @param {String} command - \ucee4\ub9e8\ub4dc \uba85
     * @returns {Boolean} - \ud574\ub2f9 \uc601\uc5ed\uc774 \ucee4\ub9e8\ub4dc \uc0c1\ud0dc\uc778\uc9c0 \uc5ec\ubd80
     * @example
     * 	processor.queryCommandState('bold');
     * @description
     * webkit \uacc4\uc5f4\uc758 \ube0c\ub77c\uc6b0\uc800(\ud06c\ub86c,\uc0ac\ud30c\ub9ac)\uc5d0\uc11c img \uc5d0 \ub300\ud55c queryCommandState \uac00 \ubd80\uc815\ud655\ud558\uc5ec \uc218\uc815.
     */
    queryCommandState: function(command) {
        var range = this.getRange();
        if (this.hasControl() && range.collapsed === _FALSE && range.endOffset - range.startOffset === 1) {
            if (command === "bold" || command === "underline" || command === "italic" || command === "strikethrough") {
                var elem = this.getControl();
                if (elem.tagName === "IMG" || elem.tagName === "BUTTON") {
                    return _FALSE;
                }
            }
        }//<-\uc5ec\uae30\uae4c\uc9c0 webkit \uacc4\uc5f4\uc758 \ube0c\ub77c\uc6b0\uc800 queryCommandState \uc5d0\ub7ec \ucc98\ub9ac.
        //\uc704 \ucf54\ub4dc\uc640 \uad00\ub828\ub41c \ud2f0\ucf13: #FTDUEDTR-1107
        try {
            return this.doc.queryCommandState(command);
        } catch(e) { return _FALSE; }
    },
    /**
     * for safari bug. \ube48\ub178\ub4dc\uc5d0 \uae00\uc790\ud06c\uae30, \uae00\uc790\ud3f0\ud2b8 \uae30\uc5b5 \ubabb\uc2dc\ud0b4.
     */
    addDummyNbsp: function (nodes) {
        var _node;
        if (nodes.length === 1) {
            _node = nodes[0];
            if (_node.tagName.toLowerCase() === "span"
                && _node.childNodes.length === 1
                && _node.firstChild.nodeType === 3
                && _node.firstChild.data === "") {
                _node.firstChild.data = "\u00A0";
            }
        }
    }
};


/*-------------------------------------------------------*/

Object.extend(Trex.I.Processor.TridentStandard, {
    restoreRange: function() { //TODO: rename
        if (!this.isRangeInsideWysiwyg && this.lastRange) {
            var _sel = this.getSel();
            _sel.removeAllRanges();
            _sel.addRange(this.lastRange);
        }
    }
});


Trex.I.Processor.Gecko = {
	/**
	 * Paragraph \ub97c \ucc44\uc6b4\ub2e4.
 	 * @private
 	 * @param {Node} node - paragraph \ub178\ub4dc
	 */
	stuffNode: function(node) {
		return $tom.stuff(node, this.newNode('br'));
	},
	/**
	 * @private
	 * @memberOf Trex.Canvas.ProcessorP
	 * Gecko\uc5d0\uc11c newlinepolicy\uac00 p\uc77c \uacbd\uc6b0 Enter Key \uc774\ubca4\ud2b8\uac00 \ubc1c\uc0dd\ud558\uba74 \uc2e4\ud589\ud55c\ub2e4. 
	 * @param {Event} ev - Enter Key \uc774\ubca4\ud2b8
	 */
	controlEnterByParagraph: function() {
		throw $propagate;
	}
};

Trex.I.Processor.Webkit = {
	/**
	 * Paragraph \ub97c \ucc44\uc6b4\ub2e4.
 	 * @private
 	 * @param {Node} node - paragraph \ub178\ub4dc
	 */
	stuffNode: function(node) {
		return $tom.stuff(node, this.newNode('br'));
	},
	/**
	 * @private
	 * @memberOf Trex.Canvas.ProcessorP
	 * Webkit\uc5d0\uc11c newlinepolicy\uac00 p\uc77c \uacbd\uc6b0 Enter Key \uc774\ubca4\ud2b8\uac00 \ubc1c\uc0dd\ud558\uba74 \uc2e4\ud589\ud55c\ub2e4.
	 */
	controlEnterByParagraph: function() {
		throw $propagate;
    },
    findParagraph: function(node) {
        var matched = function(node) {
            return $tom.kindOf(node, "div,p,blockquote");
        };
        var mustStop = function(node) {
            return $tom.kindOf(node, "body,li,%tablegroup");
        };
        return $tom.findAncestor(node, matched, mustStop);
    },
    findAncestorListItem: function(node) {
        var matched = function(node) {
            return $tom.kindOf(node, "li");
        };
        var mustStop = function(node) {
            return $tom.kindOf(node, "body,%tablegroup");
        };
        return $tom.findAncestor(node, matched, mustStop);
    },
    divideListItem: function(li) {
        var newLi, self = this;
        self.execWithMarker(function(marker) {
            newLi = $tom.divideTree(li, marker.endMarker);
        });

        if (!$tom.hasUsefulChildren(li, _TRUE)) {
            li.innerHTML = "";
        }
        if (!$tom.hasUsefulChildren(newLi, _TRUE)) {
            newLi.innerHTML = "";
        }
        self.stuffNode(li);
        self.stuffNode(newLi);
        self.moveCaretTo(newLi);
    },
	/**
	 * \uc120\ud0dd\ub41c \uc601\uc5ed\uc758 native queryCommandState \uac12\uc744 \uc5bb\uc5b4\uc628\ub2e4.
	 * @param {String} command - \ucee4\ub9e8\ub4dc \uba85
	 * @returns {Boolean} - \ud574\ub2f9 \uc601\uc5ed\uc774 \ucee4\ub9e8\ub4dc \uc0c1\ud0dc\uc778\uc9c0 \uc5ec\ubd80 
	 * @example
	 * 	processor.queryCommandState('bold');
	 * @description
	 * webkit \uacc4\uc5f4\uc758 \ube0c\ub77c\uc6b0\uc800(\ud06c\ub86c,\uc0ac\ud30c\ub9ac)\uc5d0\uc11c img \uc5d0 \ub300\ud55c queryCommandState \uac00 \ubd80\uc815\ud655\ud558\uc5ec \uc218\uc815.
	 */
	queryCommandState: function(command) {
		var range = this.getRange();
		if (this.hasControl() && range.collapsed === _FALSE && range.endOffset - range.startOffset === 1) {
			if (command === "bold" || command === "underline" || command === "italic" || command === "strikethrough") {
				var elem = this.getControl();
				if (elem.tagName === "IMG" || elem.tagName === "BUTTON") {
					return _FALSE;
				}
			}
		}//<-\uc5ec\uae30\uae4c\uc9c0 webkit \uacc4\uc5f4\uc758 \ube0c\ub77c\uc6b0\uc800 queryCommandState \uc5d0\ub7ec \ucc98\ub9ac.
		//\uc704 \ucf54\ub4dc\uc640 \uad00\ub828\ub41c \ud2f0\ucf13: #FTDUEDTR-1107
		try {
			return this.doc.queryCommandState(command);
		} catch(e) { return _FALSE; }
	},
	/**
	 * for safari bug. \ube48\ub178\ub4dc\uc5d0 \uae00\uc790\ud06c\uae30, \uae00\uc790\ud3f0\ud2b8 \uae30\uc5b5 \ubabb\uc2dc\ud0b4.
	 */
	addDummyNbsp: function (nodes) {
		var _node;
		if (nodes.length === 1) {
			_node = nodes[0];
			if (_node.tagName.toLowerCase() === "span"
			&& _node.childNodes.length === 1
			&& _node.firstChild.nodeType === 3
			&& _node.firstChild.data === "") {
				_node.firstChild.data = "\u00A0";
			}
		}
	}
};

Trex.I.Processor.Presto = {
	/**
	 * Paragraph \ub97c \ucc44\uc6b4\ub2e4.
 	 * @private
 	 * @param {Node} node - paragraph \ub178\ub4dc
	 */
	stuffNode: function(node) {
		return $tom.stuff(node, this.newNode('br'));
	},
	/**
	 * @private
	 * @memberOf Trex.Canvas.ProcessorP
	 * Presto\uc5d0\uc11c newlinepolicy\uac00 p\uc77c \uacbd\uc6b0 Enter Key \uc774\ubca4\ud2b8\uac00 \ubc1c\uc0dd\ud558\uba74 \uc2e4\ud589\ud55c\ub2e4. 
	 * @param {Event} ev - Enter Key \uc774\ubca4\ud2b8
	 */
	controlEnterByParagraph: function(ev) {
		throw $propagate;
	}
};


Trex.I.Processor.StandardP = {
	putBogusParagraph: function() {
		var _body = this.doc.body;
		var _lastChild = $tom.last(_body);
		if (_lastChild && $tom.kindOf(_lastChild, 'p')) {
			return;
		}
		var _newChild = this.newParagraph('p');
		if($tom.kindOf(_lastChild, "br")) {
			$tom.replace(_lastChild, _newChild);
		} else {
			$tom.append(_body, _newChild);
		}
	}
};


Trex.module("put bogus paragraph @when any key event fires",
	function(editor, toolbar, sidebar, canvas) { //NOTE: #FTDUEDTR-695
		if($tx.msie_nonstd) {
			return;
		}
		if (canvas.config.newlinepolicy == "p") {
			canvas.reserveJob(Trex.Ev.__CANVAS_PANEL_KEYUP, function(){
				if (!canvas.isWYSIWYG()) {
					return;
				}
				var _processor = canvas.getProcessor();
				_processor.putBogusParagraph();
			}, 10);
		}
	}
);

Trex.module("interrupt enter key action @ wysiwyg panel", function(editor, toolbar, sidebar, canvas/*, config*/) {
    var _config = TrexConfig.get('canvas');
    if (_config.newlinepolicy != "p") {
        return;
    }

    canvas.observeKey({
        ctrlKey: _FALSE,
        altKey: _FALSE,
        shiftKey: _FALSE,
        keyCode: Trex.__KEY.ENTER
    }, function(ev) {
        if (!canvas.isWYSIWYG()) {
            return;
        }
        var _processor = canvas.getProcessor();
        try {
            _processor.getTxSel().collapse(_FALSE);
            _processor.controlEnterByParagraph(ev);
        } catch(e) {
            if (e == $propagate) {
                throw e;
            }
        }
    });
});


Trex.I.Processor.TridentP = {
	
};


Trex.I.Processor.TridentStandardP = {

};


Trex.I.Processor.GeckoP = {

};


Trex.I.Processor.WebkitP = {

};

Trex.I.Processor.PrestoP = {
	
};


(function() {
	var BlockRangeIterator = Trex.Class.create({
		initialize: function(processor, patterns, start, end) {
			this.processor = processor;
			this.start = start;
			this.end = end || this.start;
			this.current = this.start;
		
			this.wTranslator = $tom.translate(patterns).extract('%wrapper');
			this.pTranslator = $tom.translate(patterns).extract('%paragraph');
		},
		hasNext: function() {
			return !!this.current;
		},
		next: function() {
			var _current = this.current;
			_current = this.find(_current);

			var _next = _current;

			if ($tom.include(_current, this.end)) {
				_next = _NULL;
			} else {
				while(_next && !$tom.next(_next)) {
					_next = $tom.parent(_next);
					if($tom.isBody(_next)) {
						_next = _NULL;
					}
				}
				if(_next) {
					_next = $tom.next(_next);
				}
			}
			if (_next == this.end) {
				_next = _NULL;
			}
			this.current = _next;
			return _current;
		},
		find: function(node) {
			var _bNode;
			var _node = node;
			
			if(!$tom.hasContent(_node)) {
				return _node;
			}
			
			while(_node) {
				_bNode = _node;
				if($tom.isBody(_node)) {
					break;
				} 
				
				if($tom.kindOf(_node, this.wTranslator.getExpression())) {
					return _node;
				}
				
				if($tom.kindOf(_node, '%wrapper,%outergroup')) { 
					_node = $tom.descendant(_bNode, this.pTranslator.getExpression());
					if(_node) {
						return _node;
					}
					_node = $tom.descendant(_bNode, '%paragraph');
					if(_node) {
						_bNode = _node;
						break;
					}
				}

				if($tom.kindOf(_node, this.pTranslator.getExpression())) {
					return _node;
				}
                if(_node.nextSibling && _node.nodeType == 3) {
                    // BlockIterator \uc774\ub2c8\uae4c TextNode \ub294 \ucc3e\ub294 \ub300\uc0c1\uc774 \uc544\ub2d8.
                    _node = _node.nextSibling;
                } else {
                    _node = _node.parentNode;
                }
			}
			var _innerName = $tom.paragraphOf($tom.getName(_bNode));
			var _wNode = this.processor.newNode(_innerName);
			var _pNodes = $tom.extract(_bNode, node, '%text,%inline,img,object,embed,hr');
			$tom.wrap(_wNode, _pNodes);
			this.processor.stuffNode(_wNode);
			return _wNode;
		}
	});
	
	Object.extend(Trex.I.Processor.Standard, /** @lends Trex.Canvas.Processor.prototype */{
		/**
		 * @private
		 * \uc120\ud0dd\ud55c \uc601\uc5ed\uc548\uc5d0 \uc788\ub294 \ub178\ub4dc \uc911\uc5d0 \ud328\ud134\uc744 \ub9cc\uc871\ud558\ub294 \ube14\ub7ed \ub178\ub4dc\ub4e4\uc744 \ub9ac\ud134\ud55c\ub2e4.
		 * @param {String} pattern - \uc218\uc9d1\ud560 \ub178\ub4dc \ud328\ud134 \uc870\uac74 
		 * @param {Element} start - \uc2dc\uc791\ud558\ub294 \ub178\ub4dc(#tx_start_marker)
		 * @param {Element} end - \ub05d\ub098\ub294 \ub178\ub4dc(#tx_end_marker)
		 * @returns {Array} - \uc120\ud0dd\ud55c \uc601\uc5ed\uc548\uc5d0 \uc788\ub294 \ub178\ub4dc \uc911\uc5d0 \ud328\ud134\uc744 \ub9cc\uc871\ud558\ub294 \ub178\ub4dc\ub4e4
		 * @example
		 * 	processor.getBlockRangeIterator('div,p,li', node, node);
		 */
		getBlockRangeIterator: function(pattern, start, end) {
			return new BlockRangeIterator(this, pattern, start, end);
		}
	});
})();

(function() {
	var InlineRangeIterator = Trex.Class.create({
		initialize: function(processor, patterns, start, end) {
			this.processor = processor;
			this.start = start;
			this.end = end || this.start;
			this.current = this.start;
			
			this.iTranslator = $tom.translate(patterns).extract('%inline');
		},
		hasNext: function() {
			return !!this.current;
		},
		next: function() {
			var _current = this.current;
			_current = this.find(_current);
			
			var _next = _current;
			if (_current == this.end) {
				_next = _NULL;
			} else {
				while(_next && !$tom.next(_next)) {
					_next = $tom.parent(_next);
					if($tom.isBody(_next)) {
						_next = _NULL;
					}
				}
				if(_next) {
					_next = $tom.next(_next);
				}
			}
			if ($tom.include(_next, this.end)) {
				_next = $tom.top(_next, _TRUE);
			} 
			this.current = _next;
			return _current;
		},
		find: function(node) {
			var _node = node;
			if($tom.kindOf(_node, '%paragraph,%outergroup,%block') || $tom.isBody(_node)) {
				var _bNode = _node;
				_node = $tom.top(_bNode, _TRUE);
				if(!_node) {
					var _innerName = $tom.inlineOf();
					var _iNode = this.processor.create(_innerName);
					$tom.append(_bNode, _iNode);
					return _iNode;
				}
			}
			
			if($tom.kindOf(_node, 'br')) {
				return _node;
			} else if(!$tom.hasContent(_node)) {
				return _node;
			}
			
			if($tom.kindOf(_node, this.iTranslator.getExpression())) { 
				return _node;
			}
			
			var _innerName = $tom.inlineOf();
			var _iNode = this.processor.create(_innerName);
			$tom.insertAt(_iNode, _node);
			if(_node) {
				$tom.append(_iNode, _node);
			}
			return _iNode;
		}
	});
	
	Object.extend(Trex.I.Processor.Standard,  /** @lends Trex.Canvas.Processor.prototype */{
		/**
		 * @private
		 * \uc120\ud0dd\ud55c \uc601\uc5ed\uc548\uc5d0 \uc788\ub294 \ub178\ub4dc \uc911\uc5d0 \ud328\ud134\uc744 \ub9cc\uc871\ud558\ub294 \uc778\ub77c\uc778 \ub178\ub4dc\ub4e4\uc744 \ub9ac\ud134\ud55c\ub2e4.
		 * @param {String} pattern - \uc218\uc9d1\ud560 \ub178\ub4dc \ud328\ud134 \uc870\uac74 
		 * @param {Element} start - \uc2dc\uc791\ud558\ub294 \ub178\ub4dc(#tx_start_marker)
		 * @param {Element} end - \ub05d\ub098\ub294 \ub178\ub4dc(#tx_end_marker)
		 * @returns {Array} - \uc120\ud0dd\ud55c \uc601\uc5ed\uc548\uc5d0 \uc788\ub294 \ub178\ub4dc \uc911\uc5d0 \ud328\ud134\uc744 \ub9cc\uc871\ud558\ub294 \ub178\ub4dc\ub4e4
		 * @example
		 * 	processor.getInlineRangeIterator('span,font,a', node, node);
		 */
		getInlineRangeIterator: function(pattern, start, end) {
			return new InlineRangeIterator(this, pattern, start, end);
		}
	});
})();

(function() {
	var __CACHING_DOC = _NULL;
	var __CACHING_NODE = {};
	var __CACHING_PARAGRAPH = {};
	Object.extend(Trex.I.Processor.Standard, /** @lends Trex.Canvas.Processor.prototype */{
		/**
		 * \ub178\ub4dc\ub97c \uc0dd\uc131\ud558\uc5ec \ub9ac\ud134\ud55c\ub2e4. \uce90\uc2f1\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc774\ubbf8 \uc0dd\uc131\ud588\ub358 \ub178\ub4dc\ub294 \ubcf5\uc0ac\ud55c\ub2e4. 
		 * @private
		 * @param {String} name - \ub178\ub4dc\uba85
		 * @example
		 * 	processor.newNode('div');
		 */
		newNode: function(name) {
			if(__CACHING_DOC != this.doc) {
				__CACHING_NODE = {};
				__CACHING_DOC = this.doc;
			}
			if(!__CACHING_NODE[name]) {
				__CACHING_NODE[name] = this.win[name]();
			}
			return $tom.clone(__CACHING_NODE[name], _FALSE);
		},
		/**
		 * \ud14d\uc2a4\ud2b8 \ub178\ub4dc\ub97c \uc0dd\uc131\ud55c\ub2e4.
	 	 * @private
	 	 * @param {String} text - \ud14d\uc2a4\ud2b8\ub0b4\uc6a9
		 */
		newText: function(text) {
			return this.doc.createTextNode(text);
		},
		/**
		 * \ub178\ub4dc\ub97c \uc0dd\uc131\ud558\uc5ec \ub9ac\ud134\ud55c\ub2e4. \uce90\uc2f1\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc774\ubbf8 \uc0dd\uc131\ud588\ub358 \ub178\ub4dc\ub294 \ubcf5\uc0ac\ud55c\ub2e4. 
		 * @private
		 * @param {String} name - \ub178\ub4dc\uba85
		 * @example
		 * 	processor.newParagraph('p');
		 */
		newParagraph: function(name) {
			if(__CACHING_DOC != this.doc) {
				__CACHING_PARAGRAPH = {};
				__CACHING_DOC = this.doc;
			}
			if(!__CACHING_PARAGRAPH[name]) {
				__CACHING_PARAGRAPH[name] = this.stuffNode(this.newNode(name));
			}
			return $tom.clone(__CACHING_PARAGRAPH[name], _TRUE);
		}
	});
})();


(function() {
	var __CACHING_DOC = _NULL;
	var __CACHING_NODE = _NULL;
	var __HAS_DUMMY = _FALSE;
	var __TEXT_GC_LIST = [];

	Object.extend(Trex.I.Processor.Standard, /** @lends Trex.Canvas.Processor.prototype */{
		/**
		 * \ube48 \ud14d\uc2a4\ud2b8 \ub178\ub4dc\ub97c \uc0dd\uc131\ud55c\ub2e4.
	 	 * @private
	 	 * @param {Boolean} keep - \uacc4\uc18d \uc720\uc9c0\ud560 \uac83\uc778\uc9c0 \uc5ec\ubd80 optional
		 */
		newDummy: function(keep) {
			if(__CACHING_DOC != this.doc) {
				__CACHING_NODE = _NULL;
				__TEXT_GC_LIST = [];
				__CACHING_DOC = this.doc;
			}
			if(!__CACHING_NODE) {
				__CACHING_NODE = this.doc.createTextNode(Trex.__WORD_JOINER);
			}
			var _dummy = $tom.clone(__CACHING_NODE);
			if(!keep) {
				__TEXT_GC_LIST.push(_dummy);
				__HAS_DUMMY = _TRUE;
			}
//            try {
//                throw new Error();
//            } catch (e) {
//                 + "\n" + e.stack);
//            }
			return _dummy;
		},
		/**
		 * \uc0dd\uc131\ub41c \ube48 \ud14d\uc2a4\ud2b8 \ub178\ub4dc\ub4e4\uc744 \uc0ad\uc81c\ud55c\ub2e4.
	 	 * @private
		 */
        /* TODO
         * Bug : __TEXT_GC_LIST\uc5d0 \uc800\uc7a5\ub41c dummy\ub97c splitText\ub97c \ud558\uba74, reference\uac00 \uc0ac\ub77c\uc9c0\ub294 \ud6a8\uacfc\uac00 \ubc1c\uc0dd\ud55c\ub2e4.
         * dummy\ub97c \ub123\uae30 \uc704\ud55c splitText \ubd80\ubd84\uc744 \uc218\uc815\ud560 \ud544\uc694\uac00 \uc788\ub2e4.
         * startConatiner\ub97c \uc9c0\uc6b0\uba74 (\ud604\uc7ac\uae4c\uc9c0 \ud655\uc778\ub41c \ubc14\uc5d0 \ub530\ub974\uba74) Chrome\uc5d0\uc11c\ub294 \ucee4\uc11c\uac00 \uc0ac\ub77c\uc9c0\uace0 \ub354 \uc774\uc0c1 range\ub97c \uac00\uc838\uc624\uc9c0 \ubabb\ud558\uac8c \ub41c\ub2e4.
         */
        clearDummy: function() {
            if (!__HAS_DUMMY) { 
                return;
            }
			var range, startNode;
            try {
				range = this.createGoogRange();
	            startNode = range && range.getStartNode();
            } catch (ignore4ie678) {}
			
			var remained = _NULL;
//            
            for (var i = 0, len = __TEXT_GC_LIST.length-1; i < len; i++) {
                try {
                    var _dummy = __TEXT_GC_LIST.shift();
//                    )
                    if (_dummy && _dummy.nodeValue) {
                        if (_dummy.nodeValue == Trex.__WORD_JOINER) {
                            if (startNode != _dummy) {
//                                
                                $tom.remove(_dummy);
                            } else {                                
                                remained = _dummy;
                            }
                        } else {
//                            
                            _dummy.nodeValue = _dummy.nodeValue.replace(Trex.__WORD_JOINER_REGEXP, "");
                        }
                    } else {
//                        
                    }
                } catch(e) {
                }
            }
            remained && __TEXT_GC_LIST.splice(0, 0, remained);
            __HAS_DUMMY = _FALSE;
        }
	});
})();

/**
 * Wysiwyg \uc601\uc5ed\uc758 \ucee8\ud150\uce20\ub97c \uc870\uc791\ud558\uae30 \uc704\ud574 \uc0ac\uc6a9\ub418\uba70,  <br/>
 * browser\uc640 newlinepolicy\uc5d0 \ub530\ub77c \ud544\uc694\ud55c \ud568\uc218\ub4e4\uc744 mixin\ud55c\ub2e4. <br/>
 * \uc774 \uac1d\uccb4\ub97c \ud1b5\ud574\uc11c Bookmark, txSelection, Marker \uac1d\uccb4\uc5d0 \uc811\uadfc\ud55c\ub2e4. <br/>
 * canvas.getProcessor()\ub97c \ud1b5\ud574\uc11c \uc5bb\uac70\ub098 <br/>
 * canvas.execute(), canvas.query()\ub97c \ud1b5\ud574\uc11c processor\ub97c \uc5bb\uc5b4\uc11c \uc0ac\uc6a9\ud55c\ub2e4. <br/>
 *
 * @abstract
 * @class
 * @param {Object} win - Wysiwyg \uc601\uc5ed\uc758 window \uac1d\uccb4
 * @param {Object} doc - Wysiwyg \uc601\uc5ed\uc758 document \uac1d\uccb4
 * 
 * @example
 *	canvas.execute(function(processor) {
 *		processor.pasteContent('<img />', _FALSE);
 *	});
 * 
 *	var value = canvas.query(function(processor) {
 *		return processor.getText();
 *	});
 * 
 *	var _processor = canvas.getProcessor();
 *	_processor.focusOnTop();
 */
Trex.Canvas.Processor = Trex.Class.draft({
	/** @ignore */
	$mixins: [
		Trex.I.Processor.Standard,
		(($tx.msie_nonstd)? Trex.I.Processor.Trident: {}),
        (($tx.msie_std)? Trex.I.Processor.TridentStandard: {}),
		(($tx.gecko)? Trex.I.Processor.Gecko: {}),
		(($tx.webkit)? Trex.I.Processor.Webkit: {}),
		(($tx.presto)? Trex.I.Processor.Presto: {})
	]
});

/**
 * newlinepolicy\uac00 p\uc778 Wysiwyg Processor
 * @class
 * @extends Trex.Canvas.Processor
 * @param {Object} win - Wysiwyg \uc601\uc5ed\uc758 window \uac1d\uccb4
 * @param {Object} doc - Wysiwyg \uc601\uc5ed\uc758 document \uac1d\uccb4
 */
Trex.Canvas.ProcessorP = Trex.Class.create({
	/** ignore */
	$extend: Trex.Canvas.Processor,
	/** @ignore */
	$mixins: [
		Trex.I.Processor.StandardP,
		(($tx.msie_nonstd)? Trex.I.Processor.TridentP: {}),
        (($tx.msie_std)? Trex.I.Processor.TridentStandardP: {}),
		(($tx.gecko)? Trex.I.Processor.GeckoP: {}),
		(($tx.webkit)? Trex.I.Processor.WebkitP: {}),
		(($tx.presto)? Trex.I.Processor.PrestoP: {})
	]
});


Trex.register("filter > mode change", function(editor, toolbar, sidebar, canvas, config) {

    /* -> Text Convert */
    function toText(html) {
        // FTDUEDTR-1360
        var filterList = [
            [Trex.__WORD_JOINER_REGEXP, ""], // word_joiner \uc81c\uac70
            //\ubaa8\ub4e0 \ud0dc\uadf8 \uc18d\uc131\uc81c\uac70
            [new RegExp("<(\\/?[a-z]+)[^>]*>", "gi"), "<$1>"],
            //\ubaa8\ub4e0 \ud0dc\uadf8 \uc904\ubc14\uafc8 \uc81c\uac70
            [new RegExp("\\n\\s*", "g"), ""],
            //head, script, style, \uc8fc\uc11d \uc81c\uac70
            [new RegExp("<head>.*?<\\/head>", "gi"), ""], //<head ~ <\\/head> delete
            [new RegExp("<s" + "cript>.*?<\\/s" + "cript>", "gi"), ""],
            [new RegExp("<style>.*?<\\/style>", "gi"), ""], //<style ~ <\\/style> delete
            [new RegExp("<!--.*?-->", "gi"), ""], //comment delete
            //\ube48 \ud0dc\uadf8\uc0ad\uc81c
            [new RegExp("<span></span>", "gi"), ""], //<br>
            //\uae30\ubcf8\ud0dc\uadf8\uc0ad\uc81c
            [new RegExp("^<p>&nbsp;</p>$", "gi"), ""],
            [new RegExp("^<p><br></p>$", "gi"), ""],
            //\ud14c\uc774\ube14 \ucc98\ub9ac.
            [new RegExp("<td>(.+?)<\\/td>", "gi"), "\t$1"], //<td>
            [new RegExp("<th>(.+?)<\\/th>", "gi"), " \t$1"], //<th>
            [new RegExp("<\\/tr>", "gi"), ""], //</tr>
            [new RegExp("<tr>", "gi"), "\n"], //<tr>
            [new RegExp("<\\?tbody>", "gi"), ""], //<tbody> 14
            //\uac1c\ud589 \ucc98\ub9ac
            [new RegExp("<div>([^<]*)<\\/div>", "gi"), "\n$1"],
            [new RegExp("<p>&nbsp;</p>", "gi"), "\n"],
            [new RegExp("<p><br></p>", "gi"), "\n"],
            [new RegExp("<br>(<\\/p>)", "gi"), "$1"],
            [new RegExp("<h[1-6]>(.+?)<\\/h[1-6]>", "gi"), "\n$1\n\n"], //<h1(h6) ~ <\\/h1(h6]> \uc81c\uac70
            [new RegExp("(<p>(.+?)<\\/p>)", "gi"), "$1\n"], //<td>
            [new RegExp("<br>\\n", "gi"), "\n"], //<br>+\uac1c\ud589
            [new RegExp("<br>", "gi"), "\n"], //<br>
            [new RegExp("(<ul>|<\\/ul>|<ol>|<\\/ol>|<\\/table>)", "gi"), "\n\n"], //<ul>
            //\uacf5\ubc31 \ucc98\ub9ac
            [new RegExp("(<li>(.+?)<\\/li>)", "gi"), "\t$1\n"], //<li>
            //\ub098\uba38\uc9c0 \ubaa8\ub4e0 \ud0dc\uadf8 \uc0ad\uc81c
            [new RegExp("<div><\\/div>\n", "gi"), "~"],
            [new RegExp("<[\\/a-zA-Z!]+>", "g"), ""],
            //\ud2b9\uc218\ubb38\uc790 \uce58\ud658
            [new RegExp("&nbsp;?", "g"), " "], [new RegExp("&quot;?", "g"), "\""], [new RegExp("&gt;?", "g"), '>'], [new RegExp("&lt;?", "g"), '<'], [new RegExp("&amp;?", "g"), '&'], [new RegExp("&copy;?", "g"), '(c)'], [new RegExp("&trade;?", "g"), '(tm)'], [new RegExp("&#8220;?", "g"), "\""], [new RegExp("&#8221;?", "g"), "\""], [new RegExp("&#8211;?", "g"), "_"], [new RegExp("&#8217;?", "g"), "'"], [new RegExp("&#38;?", "g"), "&"], [new RegExp("&#169;?", "g"), "(c)"], [new RegExp("&#8482;?", "g"), "(tm)"], [new RegExp("&#151;?", "g"), "--"], [new RegExp("&#039;?", "g"), "'"], [new RegExp("&#147;?", "g"), "\""], [new RegExp("&#148;?", "g"), "\""], [new RegExp("&#149;?", "g"), "*"], [new RegExp("&reg;?", "g"), "(R]"], [new RegExp("&bull;?", "g"), "*"]];


        var tmp = html;
        for (var i = 0; i < filterList.length; i++) {
            tmp = tmp.replace(filterList[i][0], filterList[i][1]);
        }
        return tmp;
    }

    function brn2n(html) {
        try {
            return html.replace(new RegExp("<br[^>]*>\\n", "gi"), "\n");
        } catch (ignore) {
        }
        return html;
    }

    function fromText(txt) {
        if (txt !== _NULL && txt.length !== 0) {
            txt = txt.replace(/&/g, "&amp;");
            txt = txt.replace(/ /g, "&nbsp;");
            txt = txt.replace(/\"/g, "&quot;");
            txt = txt.replace(/>/g, "&gt;");
            txt = txt.replace(/</g, "&lt;");
            if (txt.lastIndexOf("\n") === txt.length - 1) {
                txt = txt.substr(0, txt.length - 1);
            }
            if (txt.lastIndexOf("\r") === txt.length - 1) {
                txt = txt.substr(0, txt.length - 1);
            }
            txt = txt.replace(/\r\n|\r|\n/g, "<br>\n");
        }
        return txt;
    }
	
	// FTDUEDTR-794 : new line formatting on the source mode.
	function addNewlineToSource(html) {
		return html.replace(/<\/(p)><(p[\s>])/gi, '</$1>\n<$2');
	}
	function removeNewlineFromSource(source) {
		return source.replace(/<\/(p)>\n+<(p[\s>])/gi, '</$1><$2');
	}

    // FTDUEDTR-1387
    function removeEditorOriginDomain(content) {
        if(!($tx.msie && $tx.msie_docmode < 9))
            return content;
        if(!canvas.isWYSIWYG())
            return content;

        var wysiwygLocation = canvas.getCurrentPanel().getWindow().location,
            wysiwygLocationHost = wysiwygLocation.protocol + '//' + wysiwygLocation.host,
            wysiwygLocationHref = wysiwygLocation.href,
            editorHostPath = wysiwygLocationHref.substring(0,wysiwygLocationHref.lastIndexOf('/')+1),
            hrefRegexPattern = new RegExp("(href=[\"'])"
                + "(" + wysiwygLocationHost.getRegExp() + "[^\"']*)"
                + "([\"'])", "gi");

        return content.replace(hrefRegexPattern, function(match, p1_prefix, p2_url, p3_postfix/*, offset, string*/){
            var url = p2_url.replace(wysiwygLocationHref, '').
                    replace(editorHostPath, '').
                    replace(wysiwygLocationHost, '');
            return p1_prefix + url + p3_postfix;
        });
    }

    var _docparser = editor.getDocParser();
	_docparser.registerFilter('filter/converting', {
		'text@load': function(contents) {
			return toText(contents);
		},
		'source@load': function(contents) {
			return contents;
		},
		'html@load': function(contents) {
			return contents;
		},
		'text4save': function(contents) {
			var content;
			if (config.canvas.escapeTextModeContents) {
				content = fromText(contents);
			} else {
				content = contents;
			}
			if (config.canvas.removeTextModeBr) {
				content = brn2n(content);
			}
			return content;
		},
		'source4save': function(contents) {
			return contents;
		},
		'html4save': function(contents) {
			return removeEditorOriginDomain(contents);
		},
		'text2source': function(contents) {
			return fromText(contents);
		},
		'text2html': function(contents) {
			return fromText(contents);
		},
		'source2text': function(contents) {
			return toText(removeNewlineFromSource(contents));
		},
		'source2html': function(contents) {
			return removeNewlineFromSource(contents);
		},
		'html2text': function(contents) {
			return toText(contents);
		},
		'html2source': function(contents) {
			return removeEditorOriginDomain(addNewlineToSource(contents));
		}
	});
});



Trex.register("filter > non-breaking space", function(editor/*, toolbar, sidebar, canvas, config*/) {

    function convertNonBreakingSpaceToNoramlSpace(contents) {
        return contents.replace(/\u00A0/g, ' ');
    }

    var _docparser = editor.getDocParser();
    _docparser.registerFilter('filter/converting/nonbreakingsapce', {
        'text@load': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        },
        'source@load': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        },
        'html@load': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        },
        'text4save': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        },
        'source4save': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        },
        'html4save': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        },
//        'text2source': function(contents) {
//            return contents;
//        },
        'text2html': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        },
//        'source2text': function(contents) {
//            return contents;
//        },
        'source2html': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        },
//        'html2text': function(contents) {
//            return contents;
//        },
        'html2source': function(contents) {
            return convertNonBreakingSpaceToNoramlSpace(contents);
        }
    });
});

Trex.register("filter > clear redundancy",
	function (editor) {
		function clearRedundancy(contents) {
			var clearHandler = function (content, style, loop) {
				var matchCount = 0;
				var matchHandler = function (all, value, text) {
					matchCount++;
					if (text.length == 0 || text.trim().length == 0) {
						return "";
					} else {
						return ['<span style="', style, ':', value, ';">', text, '</span>'].join("");
					}
				};
				var regex = new RegExp("(?:<span[^>;]*style=\"" + style + ":[^\";]*;?\"[^>;]*>){" + loop + "}<span\\s*style=['\"]?" + style + ":\\s*(\\w+)[;'\"]*>([\\S\\s]*?)<\/span>(?:<\/span>){" + loop + "}", "gi"); //#FTDUEDTR-1119
				do {
					matchCount = 0;
					content = content.replace(regex, matchHandler);
				} while (matchCount > 0);

				return content;
			};

			contents = contents.replace(/<(span|font)([^>]*)><\/\1>/gi, function (fullMatched, tagName, subMatched) {
				if (/ (?:id|class)=/i.test(subMatched)) { //NOTE: #FTDUEDTR-1041
					return fullMatched;
				}
				return "";
			});

			var styles = ['font-size', 'font-family'];
			for (var i = 0; i < styles.length; i++) {
				contents = clearHandler(contents, styles[i], 2);
				contents = clearHandler(contents, styles[i], 1);
			}
			return contents;
		}

		function removeSpacerParagraph(contents) {
			// FTDUEDTR-1319
			return $tx.msie ? contents.replace(/<p>\s*<\/p>/gi, '') : contents;
		}

		function makeSpacerParagraph(contents) {
			// FTDUEDTR-1319
			return $tx.msie ? contents.replace(/<p>\s*<\/p>/gi, $tom.EMPTY_PARAGRAPH_HTML) : contents;
		}

		var docparser = editor.getDocParser();
		docparser.registerFilter(
			'filter/redundancy', {
				'text@load': function (contents) {
					return contents;
				},
				'source@load': function (contents) {
					return removeSpacerParagraph(clearRedundancy(contents));
				},
				'html@load': function (contents) {
					return removeSpacerParagraph(clearRedundancy(contents));
				},
				'text4save': function (contents) {
					return contents;
				},
				'source4save': function (contents) {
					return makeSpacerParagraph(contents);
				},
				'html4save': function (contents) {
					return makeSpacerParagraph(contents);
				},
				'text2source': function (contents) {
					return contents;
				},
				'text2html': function (contents) {
					return contents;
				},
				'source2text': function (contents) {
					return contents;
				},
				'source2html': function (contents) { //source2wysiwyg
					return contents;
				},
				'html2text': function (contents) {
					return contents;
				},
				'html2source': function (contents) { //wysiwyg2source
					return clearRedundancy(contents);
				}
			}
		);
	}
);

/**
 * @fileoverview
 * attachments.js
 *
 */
TrexMessage.addMsg({
	'@attacher.only.wysiwyg.alert': "\uc5d0\ub514\ud130 \uc0c1\ud0dc\uc5d0\uc11c\ub9cc \ubcf8\ubb38\uc5d0 \uc0bd\uc785\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\uc5d0\ub514\ud130\ubaa8\ub4dc\uc5d0\uc11c \ucca8\ubd80\ubc15\uc2a4\uc758 \uc378\ub124\uc77c\uc744 \ud074\ub9ad\ud574\uc11c \uc0bd\uc785\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4."
});
/**
 * Trex.Attachment
 * \ucca8\ubd80\ub41c data\ub97c wrapping\ud558\ub294 class
 *
 * @abstract
 * @class
 * @extends Trex.Entry
 *
 * @param {Object} actor
 * @param {Object} data
 */
Trex.Attachment = Trex.Class.draft(/** @lends Trex.Attachment.prototype */{
	/** @ignore */
	$extend: Trex.Entry,
	isChecked: _FALSE,
	focused: _FALSE,
	attrs: {
		align: "left"
	},
	initialize: function(actor, data) {
		this.actor = actor;
		this.canvas = actor.canvas;
		this.entryBox = actor.entryBox;
		
		this.type = this.constructor.__Identity;
		this.setProperties(data);
		
		if (this.oninitialized) {
			this.oninitialized(actor, data);
		}
	},
	/**
	 * focused \uac12\uc744 \uc124\uc815\ud55c\ub2e4.
	 * @function
	 */
	setFocused: function(focused) {
		if (this.focused !== focused) {
			this.focused = focused;
		}
	},
	/**
	 * existStage \uac12\uc744 \uc124\uc815\ud55c\ub2e4.
	 * @function
	 */
	setExistStage: function(existStage) { //just attachments~
		/**
		 * attachment\uac00 content\uc5d0 \uc874\uc7ac\ud558\ub294\uc9c0 \ud655\uc778\ud560 \ub54c \uc0ac\uc6a9\ub418\ub294 \uc18d\uc131
		 */
		this.existStage = existStage;
		if (this.entryBox.changeState) {
			this.entryBox.changeState(this);
		}
	},
	/**
	 * content\uc5d0\uc11c attachment\ub97c \uc9c0\uc6b4\ub2e4.
	 * @function
	 */
	remove: function() {
		var _content = this.canvas.getContent();
		if (this.canvas.isWYSIWYG()) {
			if (_content.search(this.regHtml) > -1) {
				_content = _content.replace(this.regHtml, "");
				this.canvas.setContent(_content);
			}
		} else {
			if (_content.search(this.regText) > -1) {
				_content = _content.replace(this.regText, "");
				this.canvas.setContent(_content);
			}
		}
	},
	/**
	 * attachment HTML\uc744 \uc5d0\ub514\ud130 \ubcf8\ubb38\uc5d0 \ubd99\uc5ec\ub123\ub294\ub2e4.
	 * @function
	 */
	register: function() {
		if (Editor.getSidebar().addOnlyBox) {
			return;
		}
		var _actor = this.actor;
		if (_actor.boxonly) {
			return;
		}
		
		if (this.canvas.isWYSIWYG()) {
			var _pastescope = this.pastescope;
			var _dispHtml = this.dispHtml;
			var objectElemTagName = "img";
			var findRegex = this.matchRegexStartTag;// /<(\w+)/
			var matched = _dispHtml.match(findRegex);
			//for other elements(Exam: button of file attachment).
			if (matched && matched[1]) {
				objectElemTagName = matched[1];
			}
			if (this.objectStyle) {
				var objectElemeReg = new RegExp("<" + objectElemTagName + " ", "i");
				_dispHtml = _dispHtml.replace(objectElemeReg, "<" + objectElemTagName + " style=\"" + Trex.Util.toStyleString(this.objectStyle) + "\" ");
			}
			if (this.objectAttr) {
				_dispHtml = _dispHtml.replace(objectElemeReg, "<" + objectElemTagName + " " + Trex.Util.toAttrString(this.objectAttr) + " ");
			}
			var _style = this.paragraphStyle || {};
			if ($tx.webkit) {
				this.canvas.getPanel('html').el.focus(); // FTDUEDTR-1281
			}
			this.canvas.execute(function(processor) {
				processor.moveCaretWith(_pastescope);
				processor.pasteContent(_dispHtml, _TRUE, {
					'style': _style
				});
			});
		} else {
			if (this.actor.wysiwygonly) {
				alert(TXMSG("@attacher.only.wysiwyg.alert"));
			} else {
				this.canvas.getProcessor().insertTag('', this.dispText);
			}
		}
	},
	/**
	 * \uc778\uc790\ub85c \ubc1b\uc740 old regex\ub85c attachment\ub97c \uc2dd\ubcc4\ud574\uc11c HTML\uc744 \uad50\uccb4\ud55c\ub2e4.
	 * @function
	 */
	replace: function(oldReg) {
		var _canvas = this.canvas;
		var _content = _canvas.getContent();
		var _actor = this.actor;
		if (!_actor.boxonly) {
			if (_canvas.isWYSIWYG()) {
				if (_content.search(oldReg.regHtml) > -1) {
					_content = _content.replace(oldReg.regHtml, this.dispHtml);
					_canvas.setContent(_content);
				} else {
					_canvas.pasteContent(this.dispHtml, _TRUE);
				}
			} else {
				if (_content.search(oldReg.regText) > -1) {
					_content = _content.replace(oldReg.regText, "");
					_canvas.setContent(_content);
				}
				alert(TXMSG("@attacher.only.wysiwyg.alert"));
			}
		}
	},
	/**
	 * attachment \uad00\ub828\ud558\uc5ec \ud544\uc694\ud55c \uc18d\uc131\uc744 this \uac1d\uccb4\uc5d0 \ud560\ub2f9\ud55c\ub2e4.
	 * @function
	 */
	setProperties: function(data) {
		var _data = data;
		this.data = _data;
		this.key = this.actor.getKey(_data) || 'K' + Trex.Util.generateKey();
		this.field = this.getFieldAttr(_data);
		this.boxAttr = this.getBoxAttr(_data);
		
		this.objectAttr = this.getObjectAttr.bind(this)(_data);
		this.objectStyle = this.getObjectStyle.bind(this)(_data);
		this.paragraphStyle = this.getParaStyle.bind(this)(_data);
		
		this.saveHtml = this.getSaveHtml.bind(this)(_data);
		this.dispHtml = this.getDispHtml.bind(this)(_data);
		this.dispText = this.getDispText.bind(this)(_data);
		this.regLoad = this.getRegLoad.bind(this)(_data);
		this.regHtml = this.getRegHtml.bind(this)(_data);
		this.regText = this.getRegText.bind(this)(_data);
	},
	refreshProperties: function() {
		this.setProperties(this.data);
	},
	/**
	 * object\uc758 attribute \uac12\uc744 \uac00\uc838\uc628\ub2e4.
	 * @function
	 */
	getObjectAttr: function() {
		return this.actor.config.objattr;
	},
	getObjectStyle: function() {
		var objstyle = {};
		if (this.actor.config.objstyle) {
			objstyle = Object.extend(objstyle, this.actor.config.objstyle);
		}
		return objstyle;
	},
	getParaStyle: function(data) {
		var parastyle = Object.extend({}, this.actor.config.parastyle || this.actor.config.defaultstyle);
		return parastyle;
	},
    updateEntryElement: function(targetElement) {
        if (!targetElement) {
            return;
        }

        var tempNode = _DOC.createElement('div');
        tempNode.innerHTML = this.dispHtml;
        targetElement.innerHTML = $tom.first(tempNode).innerHTML;
    }
});


TrexConfig.addSidebar('attachbox', {
	show: _FALSE,
	destroy: _FALSE
});

/**
 * Trex.AttachBox
 * Trex.Attachment instance\ub4e4\uc774 \uc800\uc7a5\ub418\ub294 class  
 * @class
 * @extends Trex.EntryBox
 */
Trex.AttachBox = Trex.Class.create({
	/** @ignore */
	$extend: Trex.EntryBox,
	isChecked: _FALSE,
	initialize: function() {

	},
	checkAvailableCapacity: function() { //Before Popup
		return _TRUE;
	},
	getAvailableCapacity: function() { //Within Flash
		return _TRUE;
	},
	checkInsertableSize: function() { //Before Attach
		return _TRUE;
	}
});

Trex.install("editor.getAttachBox & sidebar.getAttachments",
	function(editor, toolbar, sidebar, canvas, config){
		var _attachBox = new Trex.AttachBox(config, editor);
		sidebar.entryboxRegistry['attachbox'] = _attachBox;
		editor.getAttachBox = function() {
			return _attachBox;
		};
		sidebar.getAttachments = _attachBox.getEntries.bind(_attachBox);
	}
);

Trex.register("filter > attachers",
	function(editor) {
		var _attachBox = editor.getAttachBox();
		var _docparser = editor.getDocParser();		
		_docparser.registerFilter(
			'filter/attachments', {
				'text@load': function(contents){
					var entries = _attachBox.datalist;					
					entries.each(function(entry) {
						if (entry.loadDataByContent) {
							entry.loadDataByContent('text@load', contents);
						}
						contents = entry.getChangedContent(contents, entry.regLoad, "");
					});
					return contents;
				},
				'source@load': function(contents){
					var entries = _attachBox.datalist;					
					entries.each(function(entry) {
						if (entry.loadDataByContent) {
							entry.loadDataByContent('source@load', contents);
						}
						contents = entry.getChangedContent(contents, entry.regLoad, entry.dispText);
					});
					return contents;
				},
				'html@load': function(contents){
					var entries = _attachBox.datalist;					
					entries.each(function(entry) {
						if (entry.loadDataByContent) {
							entry.loadDataByContent('html@load', contents);
						}
						contents = entry.getChangedContent(contents, entry.regLoad, entry.dispHtml);
					});
					return contents;
				},
				'text4save': function(contents){
					var entries = _attachBox.datalist;					
					entries.each(function(entry) {
						if (entry.loadDataByContent) {
							entry.loadDataByContent('text4save', contents);
						}
						contents = entry.getChangedContent(contents, entry.regText, "");
					});
					return contents;
				},
				'source4save': function(contents){
					var entries = _attachBox.datalist;					
					entries.each(function(entry) {
						if (entry.loadDataByContent) {
							entry.loadDataByContent('source4save', contents);
						}
						contents = entry.getChangedContent(contents, entry.regText, entry.saveHtml, ["id", "class"]);
					});
					return contents;
				},
				'html4save': function(contents){
					var entries = _attachBox.datalist;
					entries.each(function(entry) {
						if (entry.loadDataByContent) {
							entry.loadDataByContent('html4save', contents);
						}
						contents = entry.getChangedContent(contents, entry.regHtml, entry.saveHtml, ["id", "class"]);
					});
					return contents;
				},
				'text2source': function(contents){
					return contents;
				},
				'text2html': function(contents){
					return contents;
				},
				'source2text': function(contents){
					var entries = _attachBox.datalist;					
					entries.each(function(entry) {
						if (entry.loadDataByContent) {
							entry.loadDataByContent('source2text', contents);
						}
						contents = entry.getChangedContent(contents, entry.regText, "");
					});
					return contents;
				},
				'source2html': function(contents){
					var entries = _attachBox.datalist;					
					entries.each(function(entry) {
						if (entry.loadDataByContent) {
							entry.loadDataByContent('source2html', contents);
						}
						contents = entry.getChangedContent(contents, entry.regText, entry.dispHtml);
					});
					return contents;
				},
				'html2text': function(contents){
					var entries = _attachBox.datalist;					
					entries.each(function(entry) {
						if (entry.loadDataByContent) {
							entry.loadDataByContent('html2text', contents);
						}
						contents = entry.getChangedContent(contents, entry.regHtml, "");
					});
					return contents;
				},
				'html2source': function(contents){
					var entries = _attachBox.datalist;					
					entries.each(function(entry) {
						if (entry.loadDataByContent) {
							entry.loadDataByContent('html2source', contents);
						}
						contents = entry.getChangedContent(contents, entry.regHtml, entry.dispText, ["id", "class"]);
					});
					return contents;
				}
			}
		);
	}
);
		
Trex.module("push history @when entrybox has changes",
	function(editor, toolbar, sidebar, canvas) {
		var _attachBox = editor.getAttachBox();		

		_attachBox.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_REMOVED, function(entry) {
			canvas.history.saveHistory(
                { deleted: _FALSE },
                { deleted: _TRUE },
                function(data) {
                    entry.deletedMark = data.deleted;
                    _attachBox.fireJobs(Trex.Ev.__ENTRYBOX_ENTRY_REFRESH, entry);
                }
			);
		});
        /*
         * IE\uc5d0\uc11c\ub294 canvas.execute \uac00 setTimeout \uc744 \ud1b5\ud558\uc5ec \uc2e4\ud589\uc774 \ub418\uae30 \ub54c\ubb38\uc5d0
         * \uc774\ud558 \uc2e4\ud589\ub418\uc5b4\uc57c \ud558\ub294 \ub85c\uc9c1\uacfc \uc21c\uc11c\uac00 \ub4a4\ubc14\ub00c\ub294 \ubb38\uc81c\uac00 \uc788\ub2e4.
         * saveHistory, injectHistory \uc640 \uac19\uc774 \uc30d\uc73c\ub85c \uc2e4\ud589\uc774 \ub418\uba70,
         * \uc21c\uc11c \ubcf4\uc7a5\uc774 \uc911\uc694\ud55c \uc791\uc5c5\uc758 \uacbd\uc6b0\uc5d0 \uc774\ub97c \ub9de\ucdb0\uc8fc\uae30 \uc704\ud574 \ub4a4\uc5d0 \uc2e4\ud589\ub418\uc5b4\uc57c \ud558\ub294 \ub85c\uc9c1\ub3c4
         * setTimeout \uc744 \uc774\uc6a9\ud55c\ub2e4.
         */
        var runOrRunLaterIfIE = function(fn) {
            if ($tx.msie) {
                setTimeout(function() {
                    fn();
                }, 0);
            } else {
                fn();
            }
        };
		
		_attachBox.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_ADDED, function(entry) {
			runOrRunLaterIfIE(function() {
                canvas.history.injectHistory(
                    { deleted: _TRUE },
                    { deleted: _FALSE },
                    function(data) {
                        entry.deletedMark = data.deleted;
                        _attachBox.fireJobs(Trex.Ev.__ENTRYBOX_ENTRY_REFRESH, entry);
                    }
                );
            });
		});
	}
);

TrexMessage.addMsg({
	'@attacher.ins': "\uc0bd\uc785",
	'@attacher.del': "\uc0ad\uc81c",
	'@attacher.caption': "\uc124\uba85",
	'@attacher.preview.image': "#iconpath/pn_preview.gif",
	'@attacher.imagedelete.confirm': "\uc0ad\uc81c\ud558\uc2dc\uba74 \ubcf8\ubb38\uc5d0\uc11c\ub3c4 \uc0ad\uc81c\ub429\ub2c8\ub2e4. \uacc4\uc18d\ud558\uc2dc\uaca0\uc2b5\ub2c8\uae4c?",
	'@attacher.delete.confirm': "\uc815\ub9d0\ub85c \uc0ad\uc81c\ud558\uc2dc\uaca0\uc2b5\ub2c8\uae4c?",
	'@attacher.delete.all.confirm': "\ubaa8\ub4e0 \ucca8\ubd80 \ud30c\uc77c\uc744 \uc0ad\uc81c\ud558\uc2dc\uaca0\uc2b5\ub2c8\uae4c? \uc0ad\uc81c\ud558\uc2dc\uba74 \ubcf8\ubb38\uc5d0\uc11c\ub3c4 \uc0ad\uc81c\ub429\ub2c8\ub2e4.",
	'@attacher.exist.alert': "\uc774\ubbf8 \ubcf8\ubb38\uc5d0 \uc0bd\uc785\ub418\uc5b4 \uc788\uc2b5\ub2c8\ub2e4."
});

Trex.install("attachbox.onAttachBoxInitialized @if config.sidebar.attachbox.show = true", function(editor, toolbar, sidebar, canvas, config) {
	var attachbox = editor.getAttachBox();
	if (config.sidebar.attachbox.show == _TRUE) {
		Object.extend(attachbox, Trex.I.AttachBox);
		attachbox.onAttachBoxInitialized(config, canvas, editor);
	}
});
Trex.I.AttachBox = {
	useBox: _TRUE,
	isDisplay: _FALSE,
	lastSelectedEntry: _NULL,
	onAttachBoxInitialized: function(config, canvas) {
		var _entryBox = this;
		this.canvas = canvas;
		
		var _initializedId = ((config.initializedId) ? config.initializedId : "");
		this.elBox = $must("tx_attach_div" + _initializedId, "Trex.I.AttachBox");
		
		this.elList = $must("tx_attach_list" + _initializedId, "Trex.I.AttachBox");
		var _elPreview = $must('tx_attach_preview' + _initializedId, "Trex.I.AttachBox");
		this.elPreviewKind = $tom.collect(_elPreview, "p");
		var _elPreviewImg = $tom.collect(_elPreview, "img");
		this.elPreviewImg = _elPreviewImg;
		this.imageResizer = new Trex.ImageResizer(_elPreviewImg, {
			maxWidth: 147,
			maxHeight: 108,
			defImgUrl: TXMSG("@attacher.preview.image"),
			onComplete: function(width, height) { //vertical positioning
				_elPreviewImg.style.marginTop = Math.floor((108 - height) / 2).toPx();
			}
		});
		
		this.elDelete = $tom.collect("#tx_attach_delete" + _initializedId + " a");
		$tx.observe(this.elDelete, 'click', function() {
			if (config.sidebar.attachbox.confirmForDeleteAll) {
				_entryBox.onDeleteAll(false);
			} else {
				_entryBox.onDeleteAll(true);
			}
		});
		
		if (typeof showAttachBox == "function") { //NOTE: \ucca8\ubd80\ubc15\uc2a4\uac00 \ubcf4\uc5ec\uc9c8 \ub54c \uc2e4\ud589\ud560 \uc11c\ube44\uc2a4 \ucf5c\ubc31
			this.observeJob(Trex.Ev.__ATTACHBOX_SHOW, function() {
				showAttachBox();
			});
		}
		if (typeof hideAttachBox == "function") { //NOTE: \ucca8\ubd80\ubc15\uc2a4\uac00 \uac10\ucdb0\uc9c8 \ub54c \uc2e4\ud589\ud560 \uc11c\ube44\uc2a4 \ucf5c\ubc31
			this.observeJob(Trex.Ev.__ATTACHBOX_HIDE, function() {
				hideAttachBox();
			});
		}
		
		var _elProgress = $must('tx_upload_progress' + _initializedId, 'Trex.I.AttachBox');
		this.elProgress = _elProgress;
		this.elProgressPercent = $tom.collect(_elProgress, "div");
		this.elProgressTicker = $tom.collect(_elProgress, "p");
		
		this.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_ADDED, function(entry) {
			_entryBox.registerEntryNode(entry);
			_entryBox.displayBox();
		});
		this.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_MODIFIED, function(entry) {
			_entryBox.modifyEntryNode(entry);
			_entryBox.refreshPreview();
		});
		this.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_REMOVED, function(entry) {
			_entryBox.removeEntryNode(entry);
			_entryBox.displayBox();
			if (_entryBox.lastSelectedEntry && _entryBox.lastSelectedEntry.key == entry.key) {
				_entryBox.refreshPreview();
			}
			
		});
		this.observeJob(Trex.Ev.__ENTRYBOX_ALL_ENTRY_REMOVED, function() {
			_entryBox.datalist.each(function(entry) {
				_entryBox.removeEntryNode(entry, _TRUE);
			});
			_entryBox.displayBox();
			if (_entryBox.lastSelectedEntry) {
				_entryBox.refreshPreview();
			}
		});
		this.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_REFRESH, function(entry) {
			_entryBox.displayBox();
			_entryBox.refreshEntryNode(entry);
		});
		
		var _elUploadedCount = $tx('tx_attach_up_count' + _initializedId),_elUploadedSize = $tx('tx_attach_up_size' + _initializedId), _elMaximumSize = $tx('tx_attach_max_size' + _initializedId), _elGroupUsedSize = $tx('tx_attach_group_used_size' + _initializedId), _elGroupMaximumSize = $tx('tx_attach_group_max_size' + _initializedId);
		
		this.observeJob(Trex.Ev.__ENTRYBOX_CAPACITY_UPDATE, function() {
			var capacity = config.sidebar.capacity;
			if (capacity.show == _FALSE) {
				return;
			}
			if( _elUploadedCount ){
				_elUploadedCount.innerText = capacity.uploadedFileNum + '\uac1c';
			}
            
			if (_elUploadedSize) {
				_elUploadedSize.innerText = capacity.uploaded.toByteUnit();
			}
			if (_elMaximumSize) {
				// maximum\uc744 \uc548\uc4f0\uace0 available\uc744 \uc0ac\uc6a9\ud558\ub294 \uc774\uc720\ub294 group \uac12 \uc774\uc6a9\uc2dc group.used\uc758 \uc0ac\uc6a9\uc5ec\ud558\uc5d0 \ub530\ub77c \ucd5c\ub300\uce58\uac00 \ub2ec\ub77c\uc9c0\uae30 \ub54c\ubb38
				_elMaximumSize.innerText = capacity.available.toByteUnit();
			}
			if (capacity.group) {
				if (_elGroupUsedSize) {
					_elGroupUsedSize.innerText = (capacity.group.used + capacity.uploaded).toByteUnit();
				}
				if (_elGroupMaximumSize) {
					_elGroupMaximumSize.innerText = capacity.group.maximum.toByteUnit();
				}
			}
		});
		
		// canvas\uc5d0\uc11c \uc81c\uac70\ub41c \ucca8\ubd80\ud30c\uc77c\uc740 \ucca8\ubd80\ubc15\uc2a4\uc5d0\ub294 1\ucc28\ub85c\ub294 \ub0a8\uc544\uc788\uae30 \ub54c\ubb38\uc5d0 \uc544\ub798\uc640 \uac19\uc740 \uc0ad\uc81c \uacfc\uc815\uc774 \ud544\uc694\ud558\uc9c0 \uc54a\ub2e4
		//        canvas.observeJob(Trex.Ev.__CANVAS_PANEL_DELETE_SOMETHING, function(ev){
		//            // \ub370\uc774\ud130\uc911\uc5d0 \uc874\uc7ac\ud558\uc9c0 stage\uc5d0 \uc874\uc7ac\ud558\uc9c0 \uc54a\ub294 entry\ub294 \ubc15\uc2a4\uc5d0\uc11c \ubc14\ub85c \uc81c\uac70
		//            _entryBox.datalist.each(function (entry) {
		//                if (entry.type =='image' && entry.actor.name == 'image' && entry.existStage == false) {
		//                    entry.execRemove();
		//                }
		//            });
		//            _entryBox.refreshPreview();
		//        });
	},
	onDeleteAll: function(force) {
		if (this.datalist.length === 0) {
			return;
		}
		if (!force && !confirm(TXMSG("@attacher.delete.all.confirm"))) {
			return;
		}
		this.datalist.each(function(entry) {
			if (entry.deletedMark == _FALSE) {
				entry.execRemove();
			}
		});
		//		this.imageResizer.execResize(TXMSG("@attacher.preview.image"));
		this.initPreviewImage();
	},
	checkDisplay: function() {
		return this.isDisplay;
	},
	setDisplay: function(isDisplay) {
		this.isDisplay = isDisplay;
	},
	displayBox: function() {
		var isDisplay = _FALSE;
		for (var i = 0; i < this.datalist.length; i++) {
			if (this.datalist[i].deletedMark == _FALSE) {
				isDisplay = _TRUE;
			}
		}
		//var isDisplay = (this.datalist.length > 0);
		if (this.isDisplay == isDisplay) {
			return;
		}
		if (isDisplay) {
			$tx.show(this.elBox);
			this.fireJobs(Trex.Ev.__ATTACHBOX_SHOW, _TRUE);
		} else {
			$tx.hide(this.elBox);
			this.fireJobs(Trex.Ev.__ATTACHBOX_HIDE, _FALSE);
		}
		this.isDisplay = isDisplay;
	},
	registerEntryNode: function(entry) {
		var _elData = tx.li({
			className: "type-" + entry.type
		});
		if (entry.actor.boxonly) {
			$tx.addClassName(_elData, "tx-boxonly");
		}
		this.elList.appendChild(_elData);
		entry.elData = _elData;
		
		entry.makeSelection = function(isPreviewed) {
			if (isPreviewed) {
				this.showEntryThumb(entry);
			} else {
				this.hideEntryThumb(entry);
			}
		}
.bind(this);
		
		//NOTE: only blog cuz iframe area
		$tx.observe(_elData, 'mouseover', this.onEntryMouseOver.bind(this, entry));
		$tx.observe(_elData, 'mouseout', this.onEntryMouseOut.bind(this, entry));
		
		var _elRow = tx.dl();
		_elData.appendChild(_elRow);
		
		var _elName = tx.dt({
			className: "tx-name",
			unselectable: "on"
		}, entry.boxAttr.name); //\ud30c\uc77c\uba85
		entry.elName = _elName;
		_elRow.appendChild(_elName);
		$tx.observe(_elData, 'click', function(e) {
			var _el = $tx.element(e);
			if (_el.className == "tx-delete" || _el.className == "tx-insert") {
				return;
			}
			if (e.ctrlKey) {
				this.clickEntryWithCtrl(entry);
			} else if (e.shiftKey) {
				this.clickEntryWithShift(entry);
			} else {
				this.clickEntry(entry);
			}
			if (entry.actor.name == 'image') { //NOTE: get image scale
				if (!entry.data.width || !entry.data.height) {
					new Trex.ImageScale(entry.data);
				}
			}
		}
.bind(this), _FALSE);
		
		var _elButton = tx.dd({
			className: "tx-button"
		}); //\ubc84\ud2bc
		_elRow.appendChild(_elButton);

		var _elCaption = tx.a({ className: "tx-caption" }, TXMSG("@attacher.caption")); //\uc124\uba85
		_elButton.appendChild(_elCaption);
		$tx.observe(_elCaption, 'click', function() {
			//entry.execRemove();
			$('#tx_attach_caption label').attr('for','caption_'+entry.data.uid);
			$('#tx_attach_caption input').attr('id','caption_'+entry.data.uid);
			$('#tx_attach_caption input').val(entry.data.caption);
			$('#tx_attach_caption button').attr('value',entry.data.uid+'^'+entry.data.tmpcode);
			$('#tx_attach_caption').show();
		}, _FALSE);
        
		var _elDelete = tx.a({
			className: "tx-delete"
		}, TXMSG("@attacher.del")); //\uc0ad\uc81c
		_elButton.appendChild(_elDelete);
		$tx.observe(_elDelete, 'click', function() {
			if(entry.type === 'file') {
				if(!confirm(TXMSG("@attacher.delete.confirm"))) { return; }
			} else {
				if(!confirm(TXMSG("@attacher.imagedelete.confirm"))) { return; }
			}
			entry.execRemove();
		}, _FALSE);
		
		
		var _elInsert = tx.a({
			className: "tx-insert"
		}, TXMSG("@attacher.ins")); //\uc0bd\uc785
		entry.elInsert = _elInsert;
		_elButton.appendChild(_elInsert);
		$tx.observe(_elInsert, 'click', function() {
			if (entry.existStage && !entry.actor.config.multipleuse) {
				alert(TXMSG("@attacher.exist.alert"));
			} else {
				entry.execAppend();
			}
		}, _FALSE);
		
		
	},
	changeState: function(entry) {
		var _existStage = entry.existStage;
		if (_existStage && !entry.actor.config.multipleuse) {
			$tx.addClassName(entry.elData, "tx-existed");
		} else {
			$tx.removeClassName(entry.elData, "tx-existed");
		}
	},
	modifyEntryNode: function(entry) {
		entry.elName.innerText = entry.boxAttr.name;
	},
	removeEntryNode: function(entry, force) {
		if (force) {
			entry.elData.parentNode.removeChild(entry.elData);
		} else if (entry.deletedMark) {
			$tx.hide(entry.elData);
		}
	},
	refreshEntryNode: function(entry) {
		if (entry.deletedMark) {
			$tx.hide(entry.elData);
		} else {
			$tx.show(entry.elData);
		}
	},
	refreshPreview: function() {
		// reload last selected entry
		for (var i = 0, l = this.datalist.length - 1; i < l; ++i) {
			var entry = this.datalist[i];
			if (this.lastSelectedEntry && this.lastSelectedEntry.key == entry.key && entry.deleteMark == false) {
				this.setPreivewImage(entry);
				return _TRUE;
			}
		}
		
		// reselect
		for (var i = 0, l = this.datalist.length - 1; i < l; ++i) {
			var entry = this.datalist[i];
			if (entry.deletedMark == false && $tx.hasClassName(entry.elData, "tx-clicked")) {
				this.setPreivewImage(entry);
				return _TRUE;
			}
		}
		
		// init
		this.initPreviewImage();
		return _FALSE;
	},
	setPreivewImage: function(entry) {
		this.imageResizer.execResize(entry.boxAttr.image);
		this.lastSelectedEntry = entry;
	},
	initPreviewImage: function() {
		this.imageResizer.execResize(TXMSG("@attacher.preview.image"));
		this.lastSelectedEntry = _NULL;
	},
	showEntryThumb: function(entry) {
		$tx.addClassName(entry.elData, "tx-clicked");
		$tx.removeClassName(entry.elData, "tx-hovered");
	},
	hideEntryThumb: function(entry) {
		$tx.removeClassName(entry.elData, "tx-clicked");
	},
	onEntryMouseOver: function(entry) {
		$tx.addClassName(entry.elData, "tx-hovered");
	},
	onEntryMouseOut: function(entry) {
		$tx.removeClassName(entry.elData, "tx-hovered");
	},
	startUpload: function() {
		this.elProgressPercent.style.width = "0".toPx();
		$tx.setStyle(this.elList, {
			opacity: 0.3
		});
		$tx.show(this.elProgress);
	},
	doUpload: function(percent) {
		var progressWidth = 300;
		this.elProgressPercent.style.width = Math.floor(progressWidth * (isNaN(percent) ? 0 : parseFloat(percent) * 0.01)).toPx();
		this.elProgressTicker.innerText = Math.floor((isNaN(percent) ? 0 : parseFloat(percent))) + "%";
	},
	endUpload: function() {
		$tx.hide(this.elProgress);
		$tx.setStyle(this.elList, {
			opacity: 1
		});
	},
	clickEntry: function(entry) {
		if (this.lastSelectedEntry) {
			if (this.lastSelectedEntry.key == entry.key) {
				return;
			}
			this.datalist.each(function(entry) {
				entry.makeSelection(_FALSE);
			});
		}
		this.elPreviewKind.className = ((entry.boxAttr.className) ? entry.boxAttr.className : "");
		entry.makeSelection(_TRUE);
		this.setPreivewImage(entry);
	},
	clickEntryWithCtrl: function(entry) {
		if ($tx.hasClassName(entry.elData, 'tx-clicked')) {
			entry.makeSelection(_FALSE);
			this.refreshPreview();
		} else {
			this.elPreviewKind.className = ((entry.boxAttr.className) ? entry.boxAttr.className : "");
			entry.makeSelection(_TRUE);
			this.setPreivewImage(entry);
		}
	},
	clickEntryWithShift: function(entry) {
		if ($tx.hasClassName(entry.elData, 'tx-clicked')) {
			entry.makeSelection(_FALSE);
			this.lastSelectedEntry = _NULL;
		} else {
			var idx = this.getIndexOf(entry);
			var targetIdx;
			if (this.lastSelectedEntry) {
				targetIdx = this.getIndexOf(this.lastSelectedEntry);
			}
			
			var from = targetIdx, to = idx;
			if (idx == targetIdx) {
				from = to = idx;
			} else if (idx < targetIdx) {
				from = idx;
				to = targetIdx;
			}
			
			this.elPreviewKind.className = ((entry.boxAttr.className) ? entry.boxAttr.className : "");
			for (var i = from; i < to + 1; i++) {
				this.datalist[i].makeSelection(_TRUE);
			}
			this.setPreivewImage(entry);
		}
	},
	getIndexOf: function(entry) {
		var i, matched;
		for (i = 0; i < this.datalist.length; i++) {
			if (this.datalist[i] === entry) {
				matched = _TRUE;
				break;
			}
		}
		return matched ? i : -1;
	},
	getSelectedList: function(attachType) {
		var _list = [];
		var _source;
		if (attachType) {
			_source = this.getAttachments(attachType);
		} else {
			_source = this.datalist;
		}
		_source.each(function(entry) {
			if ($tx.hasClassName(entry.elData, "tx-clicked")) {
				_list.push(entry);
			}
		});
		return _list;
	},
	removeSelection: function(datalist) {
		datalist.each(function(data) {
			$tx.removeClassName(data.elData, "tx-clicked");
		})
	}
};

Trex.install("attachbox.onFileCapacityInitialized @if sidebar.capacity.show = true",
	function(editor, toolbar, sidebar, canvas, config){
		var attachbox = editor.getAttachBox();
		if (config.sidebar.capacity.show === _TRUE) {
			Object.extend(attachbox, Trex.I.FileCapacity);
			attachbox.onFileCapacityInitialized(config, canvas);
		}
	}
);
Trex.module("attachbox.updateCapacity on Trex.Ev.__ATTACHBOX_SHOW",
    function(editor/*, toolbar, sidebar, canvas, config*/) {
        var attachbox = editor.getAttachBox();
        attachbox.observeJob(Trex.Ev.__ATTACHBOX_SHOW, function() {
            attachbox.updateCapacity();
        });
    }
);

TrexConfig.addSidebar('capacity',
	{
		show: _TRUE,
		maximum: 10 * 1024 * 1024 * 1024 * 1024, //10240M <= 1024
		filemaximum: _NULL,
		filter: {
			use: '', //sound,movie
			sound: {
				title: 'sound file',
				maximum: 10 * 1024 * 1024 * 1024 * 1024,
				extensions: ",mp3,wav,ogg,wma,m4a,ape,wmv,asf,ra,ram,"
			},
			movie: {
				title: 'movie file',
				maximum: 10 * 1024 * 1024 * 1024 * 1024,
				extensions: ",wmv,mpg,avi,mkv,mp4,mpeg,swf,"
			}
		}
	}
);
Trex.I.FileCapacity = {
	onFileCapacityInitialized: function(config, canvas) {
		var _initializedId = (config.initializedId) ? config.initializedId : "";
		var _fileConfig = config.sidebar.capacity;

		//#FTDUEDTR-1260
		//\uc544\ub798 \ubd80\ubd84\uc774 \uc18c\uc2a4\uc0c1 \uc804\ud600 \uc0ac\uc6a9\ub418\ub294 \ubd80\ubd84\uc774 \uc5c6\uc5b4\uc11c \uc77c\ub2e8 \uc8fc\uc11d\ucc98\ub9ac\ud558\uc600\uc2b5\ub2c8\ub2e4.
		//this.elList = $must("tx_attach_list" + _initializedId, "Trex.I.FileCapacity");

		_fileConfig.uploaded = 0; //Initialize capacity
		_fileConfig.available = _fileConfig.maximum; //Remaining capacity
		_fileConfig.uploadedFileNum = 0;  //Uploaded file number.

		var _setCapacity = function(name, size) {
			size = parseInt(size, 10);
	 		if ( isNaN(size) || _fileConfig[name] == _UNDEFINED ){
	 			return _FALSE;            // invalid setting
	 		}

            if( _fileConfig.group && name == 'available' ){
                _fileConfig[name] = Math.min(size, _fileConfig.maximum, _fileConfig.group.maximum - _fileConfig.group.used); //\uc0ac\uc6a9\uac00\ub2a5\ud55c \uc6a9\ub7c9 - \uadf8\ub8f9\uc6a9\ub7c9 \ud3ec\ud568
            } else {
                _fileConfig[name] = size;
            }

	 		return _fileConfig[name];
	 	};

		this.checkAvailableCapacity = function() { //Before Popup override
			return (_fileConfig.uploaded < _fileConfig.available);
		};
		this.checkInsertableSize = function(attachSize) { //Before Attach override
			return (parseInt(_fileConfig.uploaded, 10) + parseInt(attachSize, 10) <= parseInt(_fileConfig.available, 10));
		};

		/**
		 * Gets capacity by attachment type
		 * @memberOf Trex.AttachBox.prototype
		 * @alias getCapacity
		 * @param {Object} name
		 */
		this.getCapacity = function(name) {
			return (_fileConfig[name] || 0);
		};

		/**
		 * Change available capacity
		 * @memberOf Trex.AttachBox.prototype
		 * @alias changeAvailableCapacity
		 * @param {Number} size
		 */
		this.changeAvailableCapacity = function(size){
			if ( _setCapacity("available", size ) ){
                capacityUpdateEvent();
				return size;
			}

			return _FALSE;
		};

        /**
         * Change maximum capacity
         * @memberOf Trex.AttachBox.prototype
         * @alias changeMaximumCapacity
         * @param {Number} size
         */
        this.changeMaximumCapacity = function(size){
            if ( _setCapacity("maximum", size ) ){
                return size;
            }
            return _FALSE;
        };

        /**
         * Change one file maximum capacity
         * @memberOf Trex.AttachBox.prototype
         * @alias changeFileMaximumCapacity
         * @param {Number} size
         */
        this.changeFileMaximumCapacity = function(size){
            if ( _setCapacity("filemaximum", size ) ){
                return size;
            }
            return _FALSE;
        };

        this.updateCapacity = function() {
            capacityUpdateEvent();
        }

		/**
		 *  Resets uploaded file count & size
		 *
		 *  @memberOf Trex.AttachBox.prototype
		 *  @alias empty
		 */
		var _setAttachSize = function(fileSize) {
			var uploaded = _fileConfig.uploaded + fileSize.toNumber();
            if( uploaded < 0 ){
                uploaded = 0;
            }
            _fileConfig.uploaded = uploaded;
		};
        var decreaseCapacity = function(fileSize) {
            _setAttachSize(-1 * fileSize);
            _fileConfig.uploadedFileNum -= 1;
        };
        var increaseCapacity = function(fileSize){
            _setAttachSize(fileSize);
            _fileConfig.uploadedFileNum += 1;
        };

		var _filters = {};
		if(_fileConfig.filter.use.length > 0) {
			_fileConfig.filter.use.split(",").each(function(filterName) {
				if(_fileConfig.filter[filterName]) {
					_filters[filterName] = Object.extend({}, _fileConfig.filter[filterName]);
				}
			});
		}
		this.getFiltersNameByExt = function(ext) {
			var _filterNames = [];
			for(var _filterName in _filters) {
				if(_filters[_filterName].extensions.indexOf("," + ext.toLowerCase() + ",") > -1) {
					_filterNames.push(_filterName);
				}
			}
			return _filterNames;
		};
		this.getFilterExtensions = function(filterName) {
			if (_filters[filterName]) {
				return _filters[filterName].extensions;
			}else {
				return _NULL;
			}
		};
		this.getFilterMaximum = function(filterName) {
			if (_filters[filterName]) {
				return _filters[filterName].maximum;
			}else {
				return _NULL;
			}
		};
		this.getUploadedSizeByFilter = function(filterName) {
			var _uploadedSize = 0;
			var _extensions = _filters[filterName].extensions;
			this.datalist.each(function(entry) {
				if (entry.data && entry.data.filename) {
					var _ext = entry.data.filename.split(".").pop().toLowerCase();
					if (_extensions.indexOf("," + _ext + ",") > -1) {
						_uploadedSize += entry.data.filesize;
					}
				}
			});
			return _uploadedSize;
		};

        //\uadf8\ub8f9\uc6a9\ub7c9\uc0ac\uc6a9
		if(_fileConfig.group) {
            //\uc0ac\uc6a9\uac00\ub2a5\ud55c \uc6a9\ub7c9 - \uadf8\ub8f9\uc6a9\ub7c9 \ud3ec\ud568
            _setCapacity("available", Math.min(_fileConfig.maximum, _fileConfig.group.maximum - _fileConfig.group.used) );
		}
		this.getGroupCapacity = function(name){
			return ((_fileConfig.group)? (_fileConfig.group[name] || 0): 0);
		};

		this.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_ADDED, function(entry){
			if(entry.actor.isCheckSize) {
				increaseCapacity(entry.data.filesize || 0);
                capacityUpdateEvent();
			}
		});
		this.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_REMOVED, function(entry){
			if(entry.actor.isCheckSize) {
				decreaseCapacity(entry.data.filesize || 0);
                capacityUpdateEvent();
			}
		});
		this.observeJob(Trex.Ev.__ENTRYBOX_ALL_ENTRY_REMOVED, function() {
			_fileConfig.uploaded = 0;
			_fileConfig.uploadedFileNum = 0;
            capacityUpdateEvent();
		});
        this.observeJob(Trex.Ev.__ENTRYBOX_ENTRY_REFRESH, function(entry) {
            if (!entry.actor.isCheckSize) {
                return;
            }
            var size = entry.data.filesize || 0;
            if (entry.deletedMark) {
                decreaseCapacity(size);
            } else {
                increaseCapacity(size);
            }
            capacityUpdateEvent();
        });

        var self = this;
        var capacityUpdateEvent = function(){
            // \ud544\uc694\ud55c \uc815\ubcf4\ub9cc \ub118\uaca8 \uc918\uc57c\ud560\uae4c? _fileConfig\ub97c \uadf8\ub0e5 \ub118\uaca8\ub3c4 \ub420\uae4c??
            var senddata = {
                uploaded: _fileConfig.uploaded,
                available: _fileConfig.available,
                maximum: _fileConfig.maximum,
                uploadedFileNum: _fileConfig.uploadedFileNum,
                group: _fileConfig.group
            };
            self.fireJobs(Trex.Ev.__ENTRYBOX_CAPACITY_UPDATE, senddata);
        };
	}
};

/**
 * @filewoverview 
 * attacher.js - \ucca8\ubd80 \uad00\ub828 source\ub85c \uc774 \uc18c\uc2a4\uc5d0\uc11c \uc874\uc7ac\ud558\ub294 Attacher\ub4e4\uc744 \uc9c1\uc811 \uc0dd\uc131\ud55c\ub2e4. 
 * Editor\uac00 \uc0dd\uc131\ub420\ub54c initialize\ub41c\ub2e4.
 */

TrexMessage.addMsg({
	'@attacher.can.modify.alert': "\uae30\uc874\uc5d0 \ub4f1\ub85d\ub41c #{title}\uc744(\ub97c) \uc218\uc815\ud560 \uc218 \uc788\ub294 \ud654\uba74\uc73c\ub85c \uc774\ub3d9\ud569\ub2c8\ub2e4.",
	'@attacher.can.modify.confirm': "#{title}\uc740(\ub294) \ud558\ub098\ub9cc \ub4f1\ub85d\uc774 \uac00\ub2a5\ud569\ub2c8\ub2e4.\n\ub2e4\uc2dc \uc62c\ub9ac\uc2dc\uba74 \uae30\uc874\uc758 #{title}\uc774(\uac00) \uc0ad\uc81c\ub429\ub2c8\ub2e4. \uacc4\uc18d\ud558\uc2dc\uaca0\uc2b5\ub2c8\uae4c?",
	'@attacher.insert.alert': "\uc5d0\ub514\ud130 \uc0c1\ud0dc\uc5d0\uc11c\ub9cc \uc0bd\uc785\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.",
	'@attacher.capacity.alert': "\uc6a9\ub7c9\uc744 \ucd08\uacfc\ud558\uc600\uc2b5\ub2c8\ub2e4.",
	'@attacher.size.alert': "\uc6a9\ub7c9\uc744 \ucd08\uacfc\ud558\uc5ec \ub354\uc774\uc0c1 \ub4f1\ub85d\ud560 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4."
});	

Trex.install("sidebar.getAttacher & sidebar.getUploadAdaptor",
	function(editor, toolbar, sidebar) {
		var _attachers = sidebar.attachers = {};
		
		/**
		 * memberOf Trex.Sidebar.prototype
		 * @param {Object} name
		 */
		sidebar.getAttacher = function(name) {
			if(_attachers[name] != _NULL) {
				return _attachers[name];
			} else if(arguments.length == 0){
				return _attachers;
			}else{
				return _NULL;
			}
		};
		
	}
);

Trex.register("new attachers",
	function(editor, toolbar, sidebar, canvas, config) {
		var _attachBox = editor.getAttachBox();
		var _attachers = sidebar.attachers;
		
		for(var i in Trex.Attacher) {
			var _name = Trex.Attacher[i]['__Identity'];
			if(_name){
				_attachers[_name] = new Trex.Attacher[i](editor, _attachBox, config); 
			}
		}
		
		if (_attachers["file"]) {
			sidebar.getUploadAdaptor = function(){
				return _attachers["file"].getAdaptor();
			};
		}
	}
);

/**
 * Class Trex.Attacher 
 * 
 * @abstract
 * @class
 * @extends Trex.Actor
 * @param {Object} editor
 * @param {Object} entryBox
 * @param {Object} config 
 */
Trex.Attacher = Trex.Class.draft(/** @lends Trex.Attacher.prototype */{
	/** @ignore */
	$extend: Trex.Actor,
	canModified: _FALSE,
	canResized: _FALSE,
	initialize: function(editor, entryBox, config) {
		this.editor = editor;
		this.canvas = editor.getCanvas();
		this.entryBox = entryBox;

		var _config = this.config = TrexConfig.getAttacher(this.constructor.__Identity, config);
		if(config.pvpage && !!_config.usepvpage) {
			this.pvUrl =  TrexConfig.getUrl(config.pvpage, { "pvname": this.name });
		}
		this.boxonly = ((_config.boxonly != _NULL)? _config.boxonly: _FALSE);
		this.isMultiple = ((_config.multiple != _NULL)? _config.multiple: _FALSE);
		this.isCheckSize = ((_config.checksize != _NULL)? _config.checksize: _FALSE);
		this.wysiwygonly = ((_config.wysiwygonly != _NULL)? _config.wysiwygonly: _TRUE);
		this.pastescope = _config.pastescope;
		
		if (this.oninitialized) {
			this.oninitialized(config);
		}
		this.attachHandler = this.attachHandler.bind(this);
	},
	/**
	 * Attacher\ub97c \uc2e4\ud589, \ucca8\ubd80\ub97c \ud558\uae30 \uc704\ud55c popup window\ub97c \ub744\uc6cc\uc8fc\uac70\ub098 \ud544\uc694\ud55c action\uc744 \uc218\ud589\ud55c\ub2e4.
	 * @param {String} param - \ud31d\uc5c5\uc744 \ub744\uc6b8\ub54c \ucd94\uac00\ud560 \ud30c\ub77c\ubbf8\ud130 \ubb38\uc790\uc5f4 
	 * @function
	 */
	execute: function(param) {
		if(this.wysiwygonly && !this.canvas.isWYSIWYG()) {
			alert(TXMSG("@attacher.insert.alert"));
			return;
		}

		if(this.isCheckSize && !this.entryBox.checkAvailableCapacity()) {
			alert(TXMSG("@attacher.capacity.alert"));
			return;
		}

		if(!this.checkInsertable()) {
			if(this.canModified) {
				var _jstObj = new Template( TXMSG("@attacher.can.modify.alert") );
				alert( _jstObj.evaluate( {title : this.title}));
			} else {
				var _jstObj = new Template( TXMSG("@attacher.can.modify.confirm") );
				if(!confirm(_jstObj.evaluate({ title : this.title }))) {
					return;
				}
			}
		}
		if(this.config.LayerBox) {
			var gap	= 12;
			var exConfirm = function(){
				var obj = document.getElementById("fallr-iframe");
				var objDoc = obj.contentWindow || obj .contentDocument;
				objDoc.exConfirm();
				if($('#fallr-overlay')) $.fallr('hide');
				return;
			};

			var exCancel = function(){
				$('#fallr-iframe').get(0).contentWindow.exCancel();
				if($('#fallr-overlay')) $.fallr('hide');
				return;
			};

			$.fallr('show', {
				content : ' ',
				width	: parseInt(this.config.width) + gap * 2,
				height	: parseInt(this.config.height) + gap * 4 + gap/2,
				iframe	: {url:this.config.popPageUrl,scrolling:'no',width:this.config.width,height:this.config.height},
				position: this.config.position,
				closeHide: function() { $('#fallr-iframe').get(0).contentWindow.exCancel();},
				buttons	: {
					button1 : {text: 'Confirm', icon: '3', onclick:exConfirm},
					button2 : {text: 'Cancel', icon: '*', danger: true, onclick:exCancel}
				},
				afterHide	: function() { } // \uc774\uacf3\uc5d0 \uc138\uc158,\uce90\uc2dc \ubc0f \ubbf8\ub4f1\ub85d\ub41c \ud30c\uc77c \uc0ad\uc81c \ub8e8\ud2f4
			});
			return false;
		} else {
			if(this.clickHandler) {
				this.clickHandler();
			} else {
				try {
					var _url = this.config.popPageUrl;
					if(param) {
						_url = _url + ((_url.indexOf("?") > -1) ? "&" : "?") + param;
					}
    					var isDocumentDomainDeclaredExplicitly = (document.location.hostname != document.domain);
					if (isDocumentDomainDeclaredExplicitly) {
						_url = _url + ((_url.indexOf("?") > -1) ? "&" : "?") + "xssDomain=" + document.domain;
					}

					_url = (this.pvUrl? this.pvUrl + ((this.pvUrl.indexOf("?") > -1) ? "&" : "?") + "u="+escape(_url): _url);
					var win = _WIN.open(_url, "at" + this.name, this.config.features);
					win.focus();
				} catch (e) {}
			}
		}
	},
	/**
	 * Argument\uc758 data\ub97c \uc774\uc6a9\ud574\uc11c editor\uc5d0 \ucca8\ubd80\ud558\uba70, Attacher type\uc5d0 \ub54c\ub77c data\uc758 format\uc740 \ub2e4\ub974\ub2e4.  
	 * @function
	 * @param {Object} data
	 * @param {Object} attachmentType - optional
	 */
	attachHandler: function(data, attachmentType) {
		if(this.checkInsertable()) {
			if(this.isCheckSize && !this.entryBox.checkInsertableSize(data.filesize)) {
				alert(TXMSG("@attacher.size.alert"));
				return;
			}
			this.execAttach(data,  attachmentType);
		} else {
			this.execReattach(data,  attachmentType);
		}
	},
	createEntry: function(data, type) {
		return this.createAttachment(data, type);
 	},
	createAttachment: function(data, type) {
		var _attachmentType = this.constructor.__Identity;
		if(type){
			_attachmentType = type;
		}
		return new Trex.Attachment[_attachmentType.capitalize()](this, data);
	},
	checkInsertable: function() {
        if (this.isMultiple) {
            return _TRUE;
        }

        var list = this.getDatalist().findAll(function(entry) {
            return entry.deletedMark != _TRUE;
        });
        return list.length === 0;
	}
});

TrexMessage.addMsg({
	'@embeder.alert': "\uc5d0\ub514\ud130 \uc0c1\ud0dc\uc5d0\uc11c\ub9cc \uc0bd\uc785\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4."
});

/**
 * Trex.EmbedBox
 * \ubcf8\ubb38\uc5d0 \uc0bd\uc785\ud55c embed\ub4e4\uc774 \uc800\uc7a5\ub418\ub294 class 
 * 
 * @class
 * @extends Trex.EntryBox
 * @param {Object} config
 * @param {Object} canvas
 * @param {Object} editor
 */
Trex.EmbedBox = Trex.Class.create({
	/** @ignore */
	$extend: Trex.EntryBox,
	initialize: function() {
	}
});

Trex.install("editor.getEmbedBox & sidebar.getEmbeder & sidebar.getEmbeddedData",
	function(editor, toolbar, sidebar, canvas, config){
		var _embedBox = new Trex.EmbedBox(config, canvas, editor);
		
		sidebar.entryboxRegistry['embedbox'] = _embedBox;
		editor.getEmbedBox = function() {
			return _embedBox;
		};
		sidebar.getEmbeddedData = _embedBox.getEntries.bind(_embedBox);
		
		var _embeders = sidebar.embeders = {};
		sidebar.getEmbeder = function(name) {
			if(_embeders[name] != _NULL) {
				return _embeders[name];
			} else if(arguments.length == 0){
				return _embeders;
			}else{
				return _NULL;
			}
		};
	}
);

Trex.register("new embeders",
	function(editor, toolbar, sidebar, canvas, config){
		var _embedBox = editor.getEmbedBox();
		var _embeders = sidebar.embeders;
		
		for(var i in Trex.Embeder) {
			var _name = Trex.Embeder[i]['__Identity'];
			if (_name) {
				if(!toolbar.tools[_name]){
//					);
				}
				_embeders[_name] = new Trex.Embeder[i](editor, _embedBox, config);
			}
		}
	}
);

Trex.Embeder = Trex.Class.draft({
	$extend: Trex.Actor,
	canResized: _FALSE,
	initialize: function(editor, entryBox, config) {
		this.editor = editor;
		this.canvas = editor.getCanvas();
		this.entryBox = entryBox;
		
		var _config = this.config = TrexConfig.getEmbeder(this.constructor.__Identity, config);
		if(config.pvpage && !!_config.usepvpage) {
			this.pvUrl =  TrexConfig.getUrl(config.pvpage, { "pvname": this.name });
		}
		this.wysiwygonly = ((_config.wysiwygonly != _NULL)? _config.wysiwygonly: _TRUE);
		this.pastescope = _config.pastescope;
		
		this.embedHandler = this.embedHandler.bind(this);
		
		//NOTE: Cuz Specific Case 
		if (this.oninitialized) {
			this.oninitialized.bind(this)(config);
		}
	},
	execute: function() {
		if(this.wysiwygonly && !this.canvas.isWYSIWYG()) {
			alert(TXMSG("@embeder.alert"));
			return;
		}
		
		if(this.config.LayerBox) {
			var gap	= 12;
			var exConfirm = function(){
				var obj = document.getElementById("fallr-iframe");
				var objDoc = obj.contentWindow || obj .contentDocument;
				objDoc.exConfirm();
				$.fallr('hide');
				return;
			};

			var exCancel = function(){
				$('#fallr-iframe').get(0).contentWindow.exCancel();
				$.fallr('hide');
				return;
			};

			$.fallr('show', {
				content : ' ',
				width	: parseInt(this.config.width) + gap * 2,
				height	: parseInt(this.config.height) + gap * 4 + gap/2,
				iframe	: {url:this.config.popPageUrl,scrolling:'no',width:this.config.width,height:this.config.height},
				position: this.config.position,
				closeHide: function() { $('#fallr-iframe').get(0).contentWindow.exCancel();},
				buttons	: {
					button1 : {text: 'Confirm', icon: '3', onclick:exConfirm},
					button2 : {text: 'Cancel', icon: '*', danger: true, onclick:exCancel}
				},
				afterHide	: function() { /* \uc774\uacf3\uc5d0 \uc138\uc158,\uce90\uc2dc \ubc0f \ubbf8\ub4f1\ub85d\ub41c \ud30c\uc77c \uc0ad\uc81c \ub8e8\ud2f4*/ }
			});
			return false;
		} else {
			if(this.clickHandler) {
				this.clickHandler();
			} else {
				try {
					var _url = this.config.popPageUrl;
	                var isDocumentDomainDeclaredExplicitly = (document.location.hostname != document.domain);
                if (isDocumentDomainDeclaredExplicitly) {
                    _url = _url + ((_url.indexOf("?") > -1) ? "&" : "?") + "xssDomain=" + document.domain;
                }

				_url = (this.pvUrl? this.pvUrl + ((this.pvUrl.indexOf("?") > -1) ? "&" : "?") + "u="+escape(_url): _url);
					var win = _WIN.open(_url, "at" + this.name, this.config.features);
					win.focus();
				} catch (e) {}
			}
		}
	},
	embedHandler: function(data) {
		this.execAttach(data);
	},
	createEntry: function(data, type) {
		var _embeddedItemType = this.constructor.__Identity;
		if(type){
			_embeddedItemType = type;
		}
		return new Trex.EmbedEntry[_embeddedItemType.capitalize()](this, data);
	},
	execAttach: function(data) {
		var _pastescope = this.pastescope;
		var _html = this.getCreatedHtml(data);
		var _style = this.config.parastyle || this.config.defaultstyle || {};
		this.canvas.execute(function(processor) {
			processor.moveCaretWith(_pastescope);
			processor.pasteContent(_html, _TRUE, _style);
		});
	},
	execReattach: function(/*data, type*/) {
	},
	execReload: function(/*data, type*/) {
	},
	getReloadContent: function(data, content) {
		if(!data.dispElId) {
			return content;
		}
		var _html = this.getCreatedHtml(data);
		var _reg = new RegExp("<(?:img|IMG)[^>]*id=\"?" + data.dispElId + "\"?[^>]*\/?>", "gm");
		if(content.search(_reg) > -1) {
			return content.replace(_reg, _html);
		}
		return content;
	}
});


Trex.register("filter > embeder",
    function(editor) {
        var _embedBox = editor.getEmbedBox();
        var _docparser = editor.getDocParser();
        _docparser.registerFilter(
            'filter/embeder', {
                'text@load': function(contents){
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('text@load', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regLoad, "");
                    });
                    return contents;
                },
                'source@load': function(contents){
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('source@load', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regLoad, entry.dispText);
                    });
                    return contents;
                },
                'html@load': function(contents){
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('html@load', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regLoad, entry.dispHtml);
                    });
                    return contents;
                },
                'text4save': function(contents){
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('text4save', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regText, "");
                    });
                    return contents;
                },
                'source4save': function(contents){
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('source4save', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regText, entry.saveHtml, ["id", "class"]);
                    });
                    return contents;
                },
                'html4save': function(contents){
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('html4save', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regHtml, entry.saveHtml, ["id", "class"]);
                    });
                    return contents;
                },
                'text2source': function(contents){
                    return contents;
                },
                'text2html': function(contents){
                    return contents;
                },
                'source2text': function(contents){
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('source2text', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regText, "");
                    });
                    return contents;
                },
                'source2html': function(contents){
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('source2html', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regText, entry.dispHtml);
                    });
                    return contents;
                },
                'html2text': function(contents){
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('html2text', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regHtml, "");
                    });
                    return contents;
                },
                'html2source': function(contents){
                    var entries = _embedBox.datalist;
                    entries.each(function(entry) {
                        if (entry.loadDataByContent) {
                            entry.loadDataByContent('html2source', contents);
                        }
                        contents = entry.getChangedContent(contents, entry.regHtml, entry.dispText, ["id", "class"]);
                    });
                    return contents;
                }
            }
        );
    }
);
Trex.module("embad entry data", function (editor, toolbar, sidebar, canvas, config) {
    var _embedBox = editor.getEmbedBox();
    var _embeders = sidebar.embeders;
    editor.observeJob(Trex.Ev.__EDITOR_LOAD_DATA_BEGIN, function(jsonData) {
        _embedBox.empty();
        var content = jsonData.content;
        function setEmbedEntrys(embedEntrys, contents) { //NOTE: data format = JSON
            embedEntrys = embedEntrys || [];
            contents = contents || "";
            embedEntrys.each(function(embedEntry){
                try {
                    var _actor = _embeders[embedEntry.embeder];
                    if(_actor) {
                        _actor.execReload(embedEntry.data, contents, embedEntry.type);
                    }
                } catch(ignore) {
                    // \ucca8\ubd80\ub370\uc774\ud130 \uc77c\ubd80\ub97c \uc815\uc0c1\uc801\uc73c\ub85c \ubd88\ub7ec\uc624\uc9c0 \ubabb\ud588\uc2b5\ub2c8\ub2e4.
                    
                }
            });
        }
        for(var name in _embeders){
            if(_embeders[name]["onloadData"]){
                setEmbedEntrys(_embeders[name]["onloadData"](content),content)
            }
        }
    });
});
/**
 * Trex.EmbedEntry
 * \uc0bd\uc785\ub41c embed\ub4e4\uc744 wrapping\ud558\ub294 class 
 * @class
 * @extends Trex.Entry
 * 
 * @param {Object} actor
 * @param {Object} data 
 * 
 * 1.5 \ub418\uba74\uc11c IE\uc5d0\uc11c\ub294 \ubcc0\ud658\ud558\uc9c0 \uc54a\uc74c
*/
Trex.EmbedEntry = Trex.Class.create({
	$extend: Trex.Entry,
	attrs: {
		align: "left"
	},
	initialize: function(actor, data) {
		this.actor = actor;
        this.canvas = actor.canvas;
		this.entryBox = actor.entryBox;

		this.setProperties(data);
	},
	register:  function() { 
		if(this.canvas.isWYSIWYG()) {
			var _style = this.actor.config.defaultstyle;
			if(_style){
				this.canvas.pasteContent(this.dispHtml, _TRUE, {
						'style': _style 
					});
			}else{
				this.canvas.pasteContent(this.dispHtml, _TRUE);	
			}
		} else {
			this.canvas.getProcessor().insertTag('', this.dispText);						
		}	
	},
	setProperties: function(data) {
		this.type = this.constructor.__Identity;
		
		var _data = this.data = data;
		this.key = _data.key;

		this.dispHtml = this.getDispHtml(_data);
		this.saveHtml = this.dispText = this.getDispText(_data); //NOTE: embeder\ub4e4\uc740 dispText\uc640 saveHtml\uac00 \uac19\ub2e4.
		this.regHtml = this.getRegHtml(_data);
		this.regLoad = this.regText = this.getRegText(_data); //NOTE: embeder\ub4e4\uc740 dispText\uc640 saveHtml\uac00 \uac19\ub2e4.
	},
	refreshProperties: function() {
		this.setProperties(this.data);
	}
});


Trex.I.ButtonFontTool = Trex.Mixin.create({
    oninitialized: function(config) {
        var self = this;
        self.button = new Trex.Button(self.buttonCfg);
        self.weave(self.button, _NULL, self.handler);
        if (config.sync) {
            self.startSyncButtonWithStyle();
        }
        self.bindKeyboard(config.hotKey, self.handler.bind(self));
    },
    rangeExecutor: function(processor, newStyle, range) {
        var el = null;
        if($tx.msie && this.wrapDummy && processor.isCollapsed()){
            el = this.wrapDummy(processor, range);
            processor.execCommand(this.getQueryCommandName());
            var rng = processor.createGoogRangeFromNodes(el, 1, el, 1);
            rng.select();
        }else {
            processor.execCommand(this.getQueryCommandName());
        }
    },
    onAfterHandler: function(data) {
        // TODO \ud604\uc7ac \ud234\uc758 state\ub9cc \ubcc0\uacbd\ud558\uba74 \ub418\ub294\ub370, \ubd88\ud544\uc694\ud558\uac8c Trex.Ev.__CANVAS_PANEL_QUERY_STATUS\ub97c fire\ud55c\ub2e4.
        var canvas = this.canvas;
        if (canvas.triggerQueryStatus) {
            canvas.triggerQueryStatus();
        }
    },
    startSyncButtonWithStyle: function() {
        var self = this;
        self.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, function(goog_range) {
            self.syncButton(self.queryCurrentStyle(goog_range));
        });
    },
    queryCurrentStyle: function(goog_range) {
        var self = this;
        var state = self.canvas.query(function(processor) {
            var command = self.getQueryCommandName();
            var minGeckoVersion = 20;
            var geckoQueryCommandStateNotWorkingVersion = ($tx.gecko && $tx.gecko_ver < minGeckoVersion);
            if (command && !$tx.opera && !geckoQueryCommandStateNotWorkingVersion) {
                // gecko? : FTDUEDTR-1181
                // opera?: <span style="font-weight: bold">...</span> \uc778 \uacbd\uc6b0\uc5d0 bold \uc0c1\ud0dc\uac00 false\ub85c \ub098\uc628\ub2e4. <b>...</b>\uc778 \uacbd\uc6b0\ub294 \uc81c\ub300\ub85c \ub098\uc634.
                return processor.queryCommandState(command);
            } else {
                var targetNode = self.findQueryingNode(goog_range);
                return !!targetNode && self.isStyleApplied(targetNode);
            }
        });
        return state;
    },

    computeNewStyle: function() {
        return _NULL;
    },

    cachedProperty: _FALSE,
    syncButton: function(state) {
        if (this.cachedProperty != state) {
            this.button.setState(state);
            this.cachedProperty = state;
        }
    }
});

Trex.I.MenuFontTool = Trex.Mixin.create({
	oninitialized: function(config) {
        var self = this;
        self.beforeOnInitialized(config);
        var menuInitHandler = self.menuInitHandler && self.menuInitHandler.bind(self);
        self.weave(self.createButton(), self.createMenu(), self.handler, menuInitHandler);
        if (config.sync) {
            self.startSyncButtonWithStyle();
        }        
	},
    rangeExecutor: function(processor, newStyle, range) {
        this.wrapTextAsStyledSpan(processor, newStyle, range);
    },
    startSyncButtonWithStyle: function() {
        var self = this;
        self.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, function(goog_range) {
            self.syncButton(self.queryCurrentStyle(goog_range));
        });
    },
    queryCurrentStyle: function(goog_range) {   // only for fontfamily, fontsize
        var self = this;
        var queriedValue = self.queryCommandValue();

        // try to get using queryCommand
        if (self.reliableQueriedValue(queriedValue) && queriedValue && self.getTextByValue(queriedValue)) {
        	return self.getTextByValue(queriedValue);
        }

        // try to get from style
    	var currentStyle = self.canvas.query(function(processor) {
            var targetNode;
            if ($tx.msie && goog_range.isCollapsed()) { // FTDUEDTR-1233
                targetNode = processor.getNode();
            } else {
                targetNode = self.findQueryingNode(goog_range);
            }
            return self.queryElementCurrentStyle(targetNode);
        });
    	if (currentStyle && self.getTextByValue(currentStyle)) {
    		return self.getTextByValue(currentStyle);
    	}

    	// fallback
    	return queriedValue || currentStyle || self.getTextByValue(self.getDefaultProperty());
    },
    queryCommandValue: function() {
        var self = this;
        return self.canvas.query(function(processor) {
            return processor.queryCommandValue(self.getQueryCommandName());
        });
    },
    reliableQueriedValue: function(value) {
    	return _TRUE;
    },
    queryElementCurrentStyle: function(element) {
        var cssPropertyName = this.getCssPropertyName();

        var queryingNode = element;
        var MAX_VISIT_PARENT = 10;
        for (var i = 0; i < MAX_VISIT_PARENT && $tom.kindOf(queryingNode, "%inline"); i++) {
            var currentStyleValue = queryingNode.style[cssPropertyName];
            if (currentStyleValue) {
                return currentStyleValue;
            }
            if ($tom.kindOf(queryingNode, 'font') && $tom.getAttribute(this.getFontTagAttribute())) {
                return $tom.getAttribute(this.getFontTagAttribute());
            }
            queryingNode = queryingNode.parentNode;
        }

        var processor = this.canvas.getProcessor();
        if (element) {
            return processor.queryStyle(element, cssPropertyName);
        } else {
            return _NULL;
        }
    },
    computeNewStyle: function(newStyle) {
        var style = {};
        style[this.getCssPropertyName()] = newStyle;
        return style;
    },

    cachedProperty: _FALSE,
    syncButton: function(text) {
        var self = this;
        self.button.setText(text);
        if (self.cachedProperty != text) {
            self.button.setText(text);
            self.cachedProperty = text;
        }
    }
});

Trex.I.FontTool = Trex.Mixin.create({
    initialize: function(editor, toolbar, config) {
        this.$super.initialize(editor, toolbar, config);
    },
    handler: function(data) {
        this.onBeforeHandler(data);
        this.doHandle(data);
        this.onAfterHandler(data);
    },
    onBeforeHandler: function() {
    },
    doHandle: function(data) {
        var self = this,
            range, newStyle = self.computeNewStyle(data);
        self.canvas.execute(function(processor) {
            var selectedCells = (processor.table) ? processor.table.getTdArr() : [];
            if (selectedCells.length > 0) {
                range = goog.dom.Range.createFromNodeContents(selectedCells[0]);
                processor.executeUsingCaret(function() {
                    self.tableCellsExecutor(processor, newStyle, selectedCells);
                });
            } else {
                range = processor.createGoogRange();
                if (range) {
                    self.rangeExecutor(processor, newStyle, range);
                }
            }
        });
    },
    onAfterHandler: function() {
    },
    tableCellsExecutor: function(processor, newStyle, cells) {
        var self = this;
        cells.each(function(cell) {
            var range = goog.dom.Range.createFromNodeContents(cell);
            range.select();
            self.rangeExecutor(processor, newStyle, range);
        });
    },
    findQueryingNode: function(goog_range) {
        if (goog_range) {
			var textNode;
			try {
	            textNode = this.findFirst(goog_range.__iterator__(), function(node) {
	                return node.nodeType == 3 && node.nodeValue.trim();
	            });
			} catch (ignore4ie678) {}
            if (textNode) {
                return textNode.parentNode;
            } else {    // fallback condition
                var startNode = goog_range.getStartNode();
                if (startNode && startNode.nodeType == 3) {
                    return startNode.parentNode;
                }
                return startNode;
            }
        }
    },
    findFirst: function(iterator, condition) {
        try {
            return goog.iter.filter(iterator, condition).next();
        } catch(e) {
            return null;
        }
    }
});

Trex.I.WrappingSpanFontTool = Trex.Mixin.create({
    wrapTextAsStyledSpan: function(processor, newStyle, range) {
        var affectedNodes;
        if (processor.isCollapsed()) {
            var startNode = range.getStartNode();
            if (startNode.nodeType == 3) {
                startNode = startNode.parentNode;
            }
            var targetNode = this.findOrCreateDummySpan(startNode, processor, range);
            var wordJoiner = targetNode.firstChild;
            processor.createGoogRangeFromNodes(wordJoiner, wordJoiner.length, wordJoiner, wordJoiner.length).select();
            affectedNodes = [ targetNode ];
        } else {
            processor.executeUsingCaret(function(range, savedCaret) {
                var iterator = createTextRangeIterator(savedCaret);
                var textNodes = collectTextNodes(iterator);
                affectedNodes = collectTextOnlySpans(textNodes);
            });
        }
        processor.apply(affectedNodes, {
            style: newStyle
        });

        function createTextRangeIterator(savedCaret) {
            var startCaret = savedCaret.getCaret(_TRUE),
                endCaret = savedCaret.getCaret(_FALSE);
            return new goog.dom.TextRangeIterator(startCaret, 0, endCaret, 0);
        }

        // Known Issue : <p>&nbsp;</p>\uc5d0 \ub300\ud574 p\uc758 childNodes.length === 0 \uc774\ub77c  \uc801\uc6a9\uc774 \uc548\ub41c\ub2e4.
        function collectTextNodes(iterator) {
            var result = [];
            goog.iter.forEach(iterator, function(node) {
                // \uc798\ubabb\ub41c \uc704\uce58\uc758 TextNode\ub294 \uc81c\uc678
                if (node.nodeType == 3 && !$tom.kindOf(node.parentNode, "table,thead,tbody,tr,ul,ol")) {
                    result.push(node);
                }
            });
            return result;
        }

        function collectTextOnlySpans(textNodes) {
            var result = [];
            textNodes.each(function(node) {
                var parentNode = node.parentNode;
                if (parentNode.nodeName == "SPAN" && hasOnlyOneChild(parentNode)) {
                    result.push(parentNode);
                } else {
                    var newSpan = processor.create("span");
                    $tom.wrap(newSpan, node);
                    result.push(newSpan);
                }
            });
            return result;
        }

        function hasOnlyOneChild(node) {
            var childNodes = node.childNodes;
            var childCount = childNodes.length;
            if (childCount > 3) {   // early return
                return _FALSE;
            }
            for (var i = 0, len = childCount; i < len; i++) {
                if ($tom.isGoogRangeCaret(childNodes[i])) {
                    childCount = childCount - 1;
                }
            }
            return childCount == 1;
        }
    },
    /**
     * collapsed \uc77c \ub54c\uc5d0 style\uc744 \uc801\uc6a9\ud560 \uc218 \uc788\ub294 span\uc744 \ucc3e\uac70\ub098, \uc0c8\ub85c span\uc744 \ub9cc\ub4e0\ub2e4.
     */
    findOrCreateDummySpan: function(node, processor, goog_range) {
        var reuseExistNode = (node.tagName == "SPAN" && node.childNodes.length == 1 && node.firstChild.nodeType == 3 && node.firstChild.nodeValue == Trex.__WORD_JOINER);
        if (reuseExistNode) {
            return node;
        } else {
            return this.createDummySpan(node, processor, goog_range);
        }
    },
    createDummySpan: function (parentNode, processor, goog_range) {
        var newNode = null;
        if (parentNode.tagName == "SPAN") {
            newNode = $tom.clone(parentNode);
        } else {
            newNode = processor.create('span');
        }
        newNode.appendChild(processor.newDummy());
        newNode = goog_range.insertNode(newNode);    // NOTE: IE\uc5d0\uc11c\ub294 return\ub41c value\ub97c \uc0ac\uc6a9\ud574\uc57c \ud55c\ub2e4.

        // insertNode\ub85c \uc778\ud574 \ube48 TextNode\uac00 \uc0dd\uae34 \uacbd\uc6b0, \ubc14\ub85c \uc0ad\uc81c\ud574\uc900\ub2e4.
        $tom.removeEmptyTextNode(newNode.previousSibling);
        $tom.removeEmptyTextNode(newNode.nextSibling);
        return newNode;
    }
});

Trex.I.WrappingDummyFontTool = Trex.Mixin.create({
    wrapDummy: function(processor, range) {
        var targetNode = this.createDummySpan(processor, range);
        var wordJoiner = targetNode.firstChild;
        $tom.unwrap(targetNode);
        processor.createGoogRangeFromNodes(wordJoiner, 0, wordJoiner, wordJoiner.length).select();
        return wordJoiner;
    },
    createDummySpan: function (processor, goog_range) {
        var newNode = null;
        newNode = processor.create('span');
        newNode.appendChild(processor.newDummy());
        newNode = goog_range.insertNode(newNode);    // NOTE: IE\uc5d0\uc11c\ub294 return\ub41c value\ub97c \uc0ac\uc6a9\ud574\uc57c \ud55c\ub2e4.
        // insertNode\ub85c \uc778\ud574 \ube48 TextNode\uac00 \uc0dd\uae34 \uacbd\uc6b0, \ubc14\ub85c \uc0ad\uc81c\ud574\uc900\ub2e4.
        $tom.removeEmptyTextNode(newNode.previousSibling);
        $tom.removeEmptyTextNode(newNode.nextSibling);
        return newNode;
    }
});
/**
 * @fileoverview 
 *  wysiwyg, source, text \uc138\ubaa8\ub4dc\ub85c\uc758 \ubcc0\uacbd\uc744 \uac00\ub2a5\ud558\uac8c\ud558\ub294 dropdown \ud615\uc2dd\uc758 tool 'Switcher' Source,
 * Class Trex.Tool.Switcher \uc640 configuration\uc744 \ud3ec\ud568    
 *     
 */

TrexMessage.addMsg({
	'@switcher.wysiwyg': '\uc5d0\ub514\ud130',
	'@switcher.source': 'HTML',
	'@switcher.text': '\ud14d\uc2a4\ud2b8'
});

TrexConfig.addTool(
	"switcher",
	{
		wysiwygonly: _FALSE,
		status: _TRUE,
		options: [
			{ label: TXMSG('@switcher.wysiwyg'), title: TXMSG('@switcher.wysiwyg'), data: 'html' },
			{ label: TXMSG('@switcher.source'), title: TXMSG('@switcher.source'), data: 'source' },
			{ label: TXMSG('@switcher.text'), title: TXMSG('@switcher.text'), data: 'text' }
		]
	}
);

Trex.Tool.Switcher = Trex.Class.create({
	$const: {
		__Identity: 'switcher'
	},
	$extend: Trex.Tool,
	oninitialized: function(config) {
			var _canvas = this.canvas;
			
			var _map = {};
			config.options.each(function(option) {
				_map[option.data] = {
					title: option.title
				};
			});
			
			var _cachedProperty = "";
			var _defaultProperty = config.options[0];
			
			var _isChangeToTextMode = function (mode) {
				if (mode === "text") {
					if (_canvas.mode !== "text") {
						return _TRUE;
					}
				}
				return _FALSE;
			};
			var _hasContent = function () {
				var content, curText, baseText;
				content = _canvas.getContent();
				curText = content.toLowerCase().trim();
				baseText = $tom.EMPTY_PARAGRAPH_HTML.toLowerCase().trim();
				if (curText && curText !== baseText && curText !== "&nbsp;") {
					return _TRUE;
				}
				return _FALSE;
			};
			var _toolHandler = function (data) {
				if (config.changeModeConfirmMsg) {
					if (_isChangeToTextMode(data)) {
						if (_hasContent()) {
							if (_FALSE === confirm(config.changeModeConfirmMsg)) {
								return $stop;
							}
						}
					}
				}
				_canvas.changeMode(data);
			};
			
			var _changeMode = function(from, to) {
				if(from == to) return;
				if(_cachedProperty == to) {
					return;
				}
				if(!_map[to]) {
					return;
				}
				this.button.setValue(to);
				this.button.setText(_map[to].title);
				_cachedProperty = to; //NOTE: Editor.modify()\ub97c \ud1b5\ud55c \ub85c\ub529\uc77c \uacbd\uc6b0 switcher \ub3d9\uae30\ud654\ub97c \uc704\ud574.
			}.bind(this);
			
			_canvas.observeJob(Trex.Ev.__CANVAS_MODE_CHANGE, _changeMode);
			_canvas.observeJob(Trex.Ev.__CANVAS_MODE_INITIALIZE, _changeMode);

			/* button & menu weave */
			this.weave.bind(this)(
				/* button */
				new Trex.Button.Select(TrexConfig.merge(this.buttonCfg, {
					selectedValue: _defaultProperty.data,
					selectedText: _defaultProperty.label 
				})),
				/* menu */
				new Trex.Menu.Select(this.menuCfg),
				/* handler */
				_toolHandler
			);
		}
	
});

/**
 * @fileoverview 
 *  wysiwyg, source \ub450 \ubaa8\ub4dc\uc758 \ubcc0\uacbd\uc744 \uac00\ub2a5\ud558\uac8c\ud558\ub294 checkbox\ud615\uc2dd\uc758 tool 'SwitcherToggle' Source,
 * Class Trex.Tool.SwitcherToggle \uc640 configuration\uc744 \ud3ec\ud568    
 *     
 */

TrexConfig.addTool(
	"switchertoggle", 
	{
		wysiwygonly: _FALSE,
		sync: _TRUE,
		status: _TRUE,
		options: [
			{ label: '\uc5d0\ub514\ud130', title: "\uc5d0\ub514\ud130", data: 'html' }, 
			{ label: 'HTML', title: "HTML", data: 'source' }
		]
	}
);

Trex.Tool.SwitcherToggle = Trex.Class.create({
	$const: {
		__Identity: 'switchertoggle'
	},
	$extend: Trex.Tool,
	oninitialized: function() {
		var _canvas = this.canvas;
		
		var _toolHandler = function() {
			switch(_canvas.mode){
				case 'html':   
					_canvas.changeMode('source');
					break;
				case 'source':
					_canvas.changeMode('html');
					break;					
			}
			return _FALSE;
		};
		
		/* button & menu weave */
		this.weave.bind(this)(
			/* button */
			new Trex.Button.Toggle(TrexConfig.merge(this.buttonCfg, {
				borderClass: 'tx-switchtoggle'
			})),
			/* menu */
			_NULL,
			/* handler */
			_toolHandler
		);
			
		var _toggleCheckbox = function(from, to) {
			this.button.setValue(to == 'source');
		}.bind(this);
		_canvas.observeJob(Trex.Ev.__CANVAS_MODE_CHANGE, _toggleCheckbox);
		_canvas.observeJob(Trex.Ev.__CANVAS_MODE_INITIALIZE, _toggleCheckbox);
	}
	
});


/**
 * @fileoverview 
 * \uc124\uc815\uc5d0\uc11c \uc9c0\uc815\ub41c \uc5ec\ub7ec \uae00\uaf34\ub4e4\uc744 \uc120\ud0dd\ud560 \uc218 \uc788\ub294 \uba54\ub274\ub97c \ud3ec\ud568\ud558\ub294 tool\uc778 '\uae00\uaf34' Icon\uc744 \uc704\ud55c source\ub85c, 
 * \ud544\uc694\ud55c configuration\uacfc Class Trex.Tool.FontFamily\uc744/\ub97c \ud3ec\ud568	
 * 
 *   
 */

TrexMessage.addMsg({
	'@fontfamily.gulim': '\uad74\ub9bc',
	'@fontfamily.batang': '\ubc14\ud0d5',
	'@fontfamily.dotum': '\ub3cb\uc6c0',
	'@fontfamily.gungsuh': '\uad81\uc11c'
});

TrexConfig.addTool(
	"fontfamily", 
	{
		sync: _TRUE,
		status: _TRUE,
		useFavorite: _TRUE,
		options: [
			{ label: TXMSG('@fontfamily.gulim')+' (<span class="tx-txt">\uac00\ub098\ub2e4\ub77c</span>)', title: TXMSG('@fontfamily.gulim'), data: 'Gulim,\uad74\ub9bc,AppleGothic,sans-serif', klass: 'tx-gulim' },
			{ label: TXMSG('@fontfamily.batang')+' (<span class="tx-txt">\uac00\ub098\ub2e4\ub77c</span>)', title: TXMSG('@fontfamily.batang'), data: 'Batang,\ubc14\ud0d5,serif', klass: 'tx-batang' },
			{ label: TXMSG('@fontfamily.dotum')+' (<span class="tx-txt">\uac00\ub098\ub2e4\ub77c</span>)', title: TXMSG('@fontfamily.dotum'), data: 'Dotum,\ub3cb\uc6c0,sans-serif', klass: 'tx-dotum' },
			{ label: TXMSG('@fontfamily.gungsuh')+' (<span class="tx-txt">\uac00\ub098\ub2e4\ub77c</span>)', title: TXMSG('@fontfamily.gungsuh'), data: 'Gungsuh,\uad81\uc11c,serif', klass: 'tx-gungseo' },
			{ label: 'Arial (<span class="tx-txt">abcde</span>)', title: 'Arial', data: 'Arial,sans-serif', klass: 'tx-arial' },
			{ label: 'Verdana (<span class="tx-txt">abcde</span>)', title: 'Verdana', data: 'Verdana,sans-serif', klass: 'tx-verdana' },
            { label: 'Courier New (<span class="tx-txt">abcde</span>)', title: 'Courier New', data: 'Courier New,monspace', klass: 'tx-courier-new' }
		]
	}
);
/* legacy fontfamily * 
{ label: ' \uad74\ub9bc (<span class="tx-txt">\uac00\ub098\ub2e4\ub77c</span>)', title: '\uad74\ub9bc', data: 'Gulim,\uad74\ub9bc,AppleGothic,sans-serif', klass: 'tx-gulim' },
{ label: ' \ubc14\ud0d5 (<span class="tx-txt">\uac00\ub098\ub2e4\ub77c</span>)', title: '\ubc14\ud0d5', data: 'Batang,\ubc14\ud0d5', klass: 'tx-batang' },
{ label: ' \ub3cb\uc6c0 (<span class="tx-txt">\uac00\ub098\ub2e4\ub77c</span>)', title: '\ub3cb\uc6c0', data: 'Dotum,\ub3cb\uc6c0', klass: 'tx-dotum' },
{ label: ' \uad81\uc11c (<span class="tx-txt">\uac00\ub098\ub2e4\ub77c</span>)', title: '\uad81\uc11c', data: 'Gungsuh,\uad81\uc11c', klass: 'tx-gungseo' },
{ label: ' Arial (<span class="tx-txt">abcde</span>)', title: 'Arial', data: 'Arial', klass: 'tx-arial' },
{ label: ' Verdana (<span class="tx-txt">abcde</span>)', title: 'Verdana', data: 'Verdana', klass: 'tx-verdana' },
{ label: ' Arial Black (<span class="tx-txt">abcde</span>)', title: 'Arial Black', data: 'Arial Black', klass: 'tx-arial-black' },
{ label: ' Book Antiqua (<span class="tx-txt">abcde</span>)', title: 'Book Antiqua', data: 'Book Antiqua', klass: 'tx-book-antiqua' },
{ label: ' Comic Sans MS (<span class="tx-txt">abcde</span>)', title: 'Comic Sans MS', data: 'Comic Sans MS', klass: 'tx-comic-sans-ms' },
{ label: ' Courier New (<span class="tx-txt">abcde</span>)', title: 'Courier New', data: 'Courier New', klass: 'tx-courier-new' }, 	
{ label: ' Georgia (<span class="tx-txt">abcde</span>)', title: 'Georgia', data: 'Georgia', klass: 'tx-georgia' },
{ label: ' Helvetica (<span class="tx-txt">abcde</span>)', title: 'Helvetica', data: 'Helvetica', klass: 'tx-helvetica' },
{ label: ' Impact (<span class="tx-txt">abcde</span>)', title: 'Impact', data: 'Impact', klass: 'tx-impact' },
{ label: ' Symbol (<span class="tx-txt">abcde</span>)', title: 'Symbol', data: 'Symbol', klass: 'tx-symbol' },
{ label: ' Tahoma (<span class="tx-txt">abcde</span>)', title: 'Tahoma', data: 'Tahoma', klass: 'tx-tahoma' },
{ label: ' Terminal (<span class="tx-txt">abcde</span>)', title: 'Terminal', data: 'Terminal', klass: 'tx-terminal' },
{ label: ' Times New Roman (<span class="tx-txt">abcde</span>)', title: 'Times New R..', data: 'Times New Roman', klass: 'tx-times-new-roman' },
{ label: ' Trebuchet MS (<span class="tx-txt">abcde</span>)', title: 'Trebuchet MS', data: 'Trebuchet MS', klass: 'tx-trebuchet-ms' },
{ label: ' Webdings (<span class="tx-txt">abcde</span>)', title: 'Webdings', data: 'Webdings', klass: 'tx-webdings' },
{ label: ' Wingdings (<span class="tx-txt">abcde</span>)', title: 'Wingdings', data: 'Wingdings', klass: 'tx-wingdings' }
 */
Trex.Tool.FontFamily = Trex.Class.create({
	$const: {
		__Identity: 'fontfamily'
	},
	$extend: Trex.Tool,
	$mixins: [Trex.I.CookieBaker, Trex.I.FontTool, Trex.I.MenuFontTool, Trex.I.WrappingSpanFontTool],
	beforeOnInitialized: function(config) {
		function findAvailableFonts(config) {
			self.usedWebFonts = (($tx.msie && config.webfont && config.webfont.use) ? config.webfont.options : []);
			self.usedFonts = config.options.concat(self.usedWebFonts);
		}

		function setUseFavoriteFont(config) {
			if (config.useFavorite && self.usedWebFonts.length > 0) {
				self.useFavorite = _TRUE;
				self.initCookie('txFontFamilyFavorite');
			} else {
				self.useFavorite = _FALSE;
			}
		}

		var self = this;
		self.focusLoosed = _FALSE;

		findAvailableFonts(config);
		setUseFavoriteFont(config);

		self.createFontFamilyMap(self.usedFonts);
	},
	createFontFamilyMap: function(usedFonts) {
		var self = this, fontFamilyMap = {};
		this.fontFamilyMap = fontFamilyMap;
		usedFonts.each(function (option) {
			var fontNames, title, i, key;
			fontNames = option.data.split(",");
			title = option.title;
			for (i = 0; i < fontNames.length; i += 1) {
				key = self.preprocessFontFamily(fontNames[i]);
				fontFamilyMap[key] = title;
			}
			if (!fontFamilyMap[title.toLowerCase()]) {
				fontFamilyMap[title.toLowerCase()] = title;
			}
		});
	},
	createButton: function() {
		var button = new Trex.Button.Select(this.buttonCfg);
		this.button = button;
		button.setValue(this.getDefaultProperty());
		button.setText(this.getTextByValue(this.getDefaultProperty()));
		return button;
	},
	createMenu: function() {
		var self = this;
		var menu = new Trex.Menu.Select(TrexConfig.merge(self.menuCfg, {
			options: self.usedFonts
		}));
		this.menu = menu;
		//overwrite generateListItem
		menu.generateListItem = function (option) {
			var result = [], i, item, labalBackup;
			for(i = 0; i < option.length; i += 1) {
				item = option[i];
				labalBackup = item.label;
				item.label = item.label.replace(/<span class="tx\-txt">/, '<span class="tx-txt" style="font-family:' + item.data + ';">');
				result.push(Trex.MarkupTemplate.get("menu.select.item").evaluate(item));
				item.label = labalBackup;	
			}
			return result.join("");
		};
		if (self.usedWebFonts.length > 0) {
			$tx.addClassName(menu.elMenu, "tx-fontfamily-webfont-menu");
			var elDummyForFocus = tx.input({'type': 'text', 'className': 'tx-dummyfocus'});
			$tom.append(menu.elMenu, elDummyForFocus);
			$tx.observe(menu.elMenu, 'mousedown', function(ev) {
				if (ev.offsetX < self.menu.elMenu.clientWidth) { //not scrollbar
					return;
				}
				elDummyForFocus.style.top = ev.offsetY.toPx();
				if (!self.focusLoosed) {
					elDummyForFocus.focus();
					elDummyForFocus.blur();
					self.menu.elMenu.focus();
					self.focusLoosed = _TRUE;
				}
			});
		}
		return menu;
	},
	menuInitHandler: function() {
		var self = this;
		var menu = self.menu;
		self.focusLoosed = _FALSE;
		if(!self.useFavorite) {
			return [];
		}
		menu.elMenu.scrollTop = 0;
		var elGroup = $tom.collect(menu.elMenu, "ul.tx-menu-favlist");
		if(elGroup) {
			$tom.remove(elGroup);
		}
		var favorite = self.extractOptions(self.usedFonts, self.readCookie());
		elGroup = menu.generateList(favorite);
		$tom.insertFirst(menu.elMenu, elGroup);
		$tx.addClassName(elGroup, 'tx-menu-favlist');
		return favorite;
	},
	onBeforeHandler: function(data) {
		this.canvas.includeWebfontCss("font-family: " + data);
	},
	onAfterHandler: function(data) {
		var self = this;
		if (self.useFavorite) {
			self.writeCookie(self.mergeValues(self.readCookie(), data));
		}
	},
	getDefaultProperty: function() {
		return this.canvas.getStyleConfig().fontFamily;
	},
	getRelatedCssPropertyNames: function() {
		return ["font", this.getCssPropertyName()];
	},
	getCssPropertyName: function() {
		return "fontFamily";
	},
	getQueryCommandName: function() {
		return "fontname";
	},
	getFontTagAttribute: function() {
		return "face";
	},
	preprocessFontFamily: function (name) {
		//\ube0c\ub77c\uc6b0\uc800\uc5d0 \ub530\ub77c qoute \ub4f1\uc73c\ub85c \uac10\uc2f8\uc8fc\ub294 \uacbd\uc6b0\uac00 \uc788\uc74c.
		//\ud3f0\ud2b8 \uc774\ub984\uc911\uc5d0 _9 \ub098 9 \ub85c \ub05d\ub098\ub294\uac8c \uc788\uc5b4 \ubb38\uc81c\uac00 \uc788\uc5c8\ub2e4\uace0 \uc8fc\uc11d\uc774 \uc788\uc5c8\uc74c.
		return name.toLowerCase().replace(/'|"/g, "").replace(/_?9$/, "");
	},
	getTextByValue: function(value) {
		if (value.include(",")) {
			value = value.split(",")[0];
		}
		value = this.preprocessFontFamily(value);
		return this.fontFamilyMap[value];
	}
});

/**
 * @fileoverview 
 * \uc124\uc815\uc5d0\uc11c \uc9c0\uc815\ub41c \uc5ec\ub7ec fontsize\ub4e4\uc744 \uc120\ud0dd\ud560 \uc218 \uc788\ub294 \uba54\ub274\ub97c \ud3ec\ud568\ud558\ub294 tool\uc778 '\uae00\uc790\ud06c\uae30' Icon\uc744 \uc704\ud55c source\ub85c,
 * Class Trex.Tool.FontSize, configuration \uc744 \ud3ec\ud568    
 * 
 *   
 */
TrexConfig.addTool(
	"fontsize", 
	{
		sync: _TRUE,
		status: _TRUE,
		options: [
			{ label: '\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac (8pt)', title: '8pt', data: '8pt', klass: 'tx-8pt' },
			{ label: '\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac (9pt)', title: '9pt', data: '9pt', klass: 'tx-9pt' },
			{ label: '\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac (10pt)', title: '10pt', data: '10pt', klass: 'tx-10pt' },
			{ label: '\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac (11pt)', title: '11pt', data: '11pt', klass: 'tx-11pt' },
			{ label: '\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac (12pt)', title: '12pt', data: '12pt', klass: 'tx-12pt' },
			{ label: '\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac (14pt)', title: '14pt', data: '14pt', klass: 'tx-14pt' },
			{ label: '\uac00\ub098\ub2e4\ub77c\ub9c8\ubc14\uc0ac (18pt)', title: '18pt', data: '18pt', klass: 'tx-18pt' },
			{ label: '\uac00\ub098\ub2e4\ub77c\ub9c8 (24pt)', title: '24pt', data: '24pt', klass: 'tx-24pt' },
			{ label: '\uac00\ub098\ub2e4 (36pt)', title: '36pt', data: '36pt', klass: 'tx-36pt' }
		]
	}
);

Trex.Tool.FontSize = Trex.Class.create({
	$const: {
		__Identity: 'fontsize'
	},
	$extend: Trex.Tool,
    $mixins: [Trex.I.FontTool, Trex.I.MenuFontTool, Trex.I.WrappingSpanFontTool],
    beforeOnInitialized: function(config) {
        this.createFontSizeMap(config);
    },
    createButton: function() {
        var defaultProperty = this.getDefaultProperty();
        var button = this.button = new Trex.Button.Select(this.buttonCfg);
        button.setValue(defaultProperty);
        button.setText(this.getTextByValue(defaultProperty));
        return button;
    },
    createMenu: function() {
        return new Trex.Menu.Select(this.menuCfg);
    },
    createFontSizeMap: function(config) {
        var fontSizeMap = this.fontSizeMap = {};
        config.options.each(function(option) {
            fontSizeMap[option.data] = option.title;
        });
        [
            //NOTE: font tag\uc758 \uc18d\uc131\uc73c\ub85c \uae00\uc790 \ud06c\uae30\ub97c \uc9c0\uc815\ud588\uc744 \uacbd\uc6b0
            { title: '8pt', data: '1' },
            { title: '10pt', data: '2' },
            { title: '12pt', data: '3' },
            { title: '14pt', data: '4' },
            { title: '18pt', data: '5' },
            { title: '24pt', data: '6' },
            { title: '36pt', data: '7' },
            { title: '7.5pt', data: '10px'},
            { title: '8pt', data: '11px' },
            { title: '9pt', data: '12px' },
            { title: '10pt', data: '13px' },
            { title: '11pt', data: '15px' },
            { title: '12pt', data: '16px' },
            { title: '14pt', data: '19px' },
            { title: '18pt', data: '24px' },
            { title: '24pt', data: '32px' },
            { title: '36pt', data: '48px' },
            { title: '8pt', data: 'x-small' },
            { title: '10pt', data: 'small' },
            { title: '12pt', data: 'medium' },
            { title: '14pt', data: 'large' },
            { title: '18pt', data: 'x-large' },
            { title: '24pt', data: 'xx-large' },
            { title: '36pt', data: '-webkit-xxx-large' } //NOTE: webkit \uacc4\uc5f4\uc5d0\uc11c \uc0ac\uc6a9\ud558\ub294 \uae00\uc790 \ud06c\uae30
        ].each(function(option) {
            fontSizeMap[option.data] = option.title;
        });
    },
    reliableQueriedValue: function(value) {
    	return $tx.webkit === false;
    },
    getTextByValue: function(value) {
        var matchedText = this.fontSizeMap[value];
        if (!matchedText) {
            var round = Math.round(parseFloat(value)).toPx();
            matchedText = this.fontSizeMap[round];
        }
        return matchedText;
    },
    getRelatedCssPropertyNames: function() {
        return ["font", this.getCssPropertyName()];
    },
    getCssPropertyName: function() {
        return "fontSize";
    },
    getQueryCommandName: function() {
        return "fontsize";
    },
    getDefaultProperty: function() {
        return this.canvas.getStyleConfig().fontSize;
    },
    getFontTagAttribute: function() {
        return "size";
    }
});

/**
 * @fileoverview 
 * Toolbar\uc758 Bold Icon\uc744 \uc704\ud574 \ud544\uc694\ud55c configuration\uacfc Class Trex.Tool.Bold\uc744/\ub97c \ud3ec\ud568    
 *  
 */
TrexConfig.addTool(
	"bold", 
	{
		wysiwygonly: _TRUE,
		sync: _TRUE,
		status: _TRUE,
        hotKey: { // ctrl + b
            ctrlKey: _TRUE,
			keyCode: 66
        }
	}
);

Trex.Tool.Bold = Trex.Class.create({
	$const: {
		__Identity: 'bold'
	},
	$extend: Trex.Tool,
    $mixins: [Trex.I.FontTool, Trex.I.ButtonFontTool, Trex.I.WrappingDummyFontTool],
    getRelatedCssPropertyNames: function() {
        return ["font", this.getCssPropertyName()];
    },
    getCssPropertyName: function() {
        return "fontWeight";
    },
    getQueryCommandName: function() {
        return "bold";
    },
    isStyleApplied: function(node) {
        return ["bold", "700"].contains($tx.getStyle(node, "fontWeight"));
    }
});

/**
 * @fileoverview 
 *  Tool 'Underline' Source,
 *  Class Trex.Tool.Underline  configuration \uc744 \ud3ec\ud568 \ud558\uace0\uc788\ub2e4.    
 * 
 */
TrexConfig.addTool(
	"underline",
	{
		wysiwygonly: _TRUE,
		sync: _TRUE,
		status: _TRUE,
        hotKey: {
            // ctrl + u
			ctrlKey: _TRUE,
			keyCode: 85
		}
	}
);

Trex.Tool.Underline = Trex.Class.create({
	$const: {
		__Identity: 'underline'
	},
	$extend: Trex.Tool,
    $mixins: [
        Trex.I.FontTool,
        Trex.I.ButtonFontTool,
        Trex.I.WrappingDummyFontTool,
        ($tx.gecko ? Trex.I.Tool.QueryStyle.Gecko : Trex.I.Tool.QueryStyle.Standard)
    ],
    getRelatedCssPropertyNames: function() {
        return [this.getCssPropertyName()];
    },
    getCssPropertyName: function() {
        return "textDecoration";
    },
    getQueryCommandName: function() {
        return "underline";
    },
    isStyleApplied: function(node) {
        var matchTagName = 'u';
        return this.queryNodeStyle(node, this.getCssPropertyName(), this.getQueryCommandName(), matchTagName);
    }
});
/**
 * @fileoverview 
 * 'Italic' Icon Source,
 * Class Trex.Tool.Italic\uacfc configuration\uc744 \ud3ec\ud568    
 *     
 */
TrexConfig.addTool(
	"italic",
	{
		wysiwygonly: _TRUE,
		sync: _TRUE,
		status: _TRUE,
        hotKey: {
            // ctrl + i - \uae30\uc6b8\uc784
			ctrlKey: _TRUE,
			keyCode: 73
		}
	}
);

Trex.Tool.Italic = Trex.Class.create({
	$const: {
		__Identity: 'italic'
	},
	$extend: Trex.Tool,
    $mixins: [Trex.I.FontTool, Trex.I.ButtonFontTool, Trex.I.WrappingDummyFontTool],
    getRelatedCssPropertyNames: function() {
        return ["font", this.getCssPropertyName()];
    },
    getCssPropertyName: function() {
        return "fontStyle";
    },
    getQueryCommandName: function() {
        return "italic";
    },
    isStyleApplied: function(node) {
        return $tx.getStyle(node, "fontStyle") == "italic";
    }
});
/**
 * @fileoverview 
 *  Tool '\ucde8\uc18c\uc120' Source,
 * Class Trex.Tool.Strike \uc640 configuration\uc744 \ud3ec\ud568    
 *     
 */
TrexConfig.addTool(
	"strike",
	{
		wysiwygonly: _TRUE,
		sync: _TRUE,
		status: _TRUE,
        hotKey: {
            // ctrl + d
			ctrlKey: _TRUE,
			keyCode: 68
		}
	}
);

Trex.Tool.Strike = Trex.Class.create({
	$const: {
		__Identity: 'strike'
	},
	$extend: Trex.Tool,
    $mixins: [
        Trex.I.FontTool,
        Trex.I.ButtonFontTool,
        Trex.I.WrappingDummyFontTool,
        ($tx.gecko ? Trex.I.Tool.QueryStyle.Gecko : Trex.I.Tool.QueryStyle.Standard)
    ],
    getRelatedCssPropertyNames: function() {
        return [this.getCssPropertyName()];
    },
    getCssPropertyName: function() {
        return "textDecoration";
    },
    getQueryCommandName: function() {
        return "strikethrough";
    },
    isStyleApplied: function(node) {
        var matchTagName = 'strike';
        return this.queryNodeStyle(node, this.getCssPropertyName(), this.getQueryCommandName(), matchTagName);
    }
});
/**
 * @fileoverview 
 * \uae00\uc790\uc0c9\uc744 \ubcc0\uacbd\ud558\uae30 \uc704\ud574 \uc4f0\uc774\ub294 '\uae00\uc790\uc0c9' Icon\uc744 \uc704\ud574 \ud544\uc694\ud55c source, 
 * Class Trex.Tool.ForeColor \uc640 configuration\uc744 \ud3ec\ud568    
 *  
 */
TrexConfig.addTool(
	"forecolor",
	{ 
		defaultcolor: "#7c84ef",
		wysiwygonly: _TRUE,
		sync: _FALSE,
		status: _TRUE,
		useFavorite: _TRUE,
		thumbs: Trex.__CONFIG_COMMON.thumbs,
		needRevert: _TRUE
	}
);

Trex.Tool.ForeColor = Trex.Class.create({
	$const: {
		__Identity: 'forecolor'
	},
	$extend: Trex.Tool,
	$mixins: [Trex.I.CookieBaker, Trex.I.FontTool, Trex.I.MenuFontTool, Trex.I.WrappingSpanFontTool],
    beforeOnInitialized: function(config) {
		this.useFavorite = !!config.useFavorite;
		if (this.useFavorite) {
			this.initCookie('txForeColorFavorite');
		}
    },
    createButton: function() {
        var initialColor = this.readCookie() || this.getDefaultProperty();

        var button = this.button = new Trex.Button.Splits(this.buttonCfg);
        button.setValue(initialColor);
        this.syncButton(initialColor);
        return button;
    },
    createMenu: function() {
        return new Trex.Menu.ColorPallete(this.menuCfg);
    },
    onAfterHandler: function(data) {
        this.syncButton(data);
        if (this.useFavorite) {
            this.writeCookie(data);
        }
    },
    getDefaultProperty: function() {
        return this.canvas.getStyleConfig().color;
    },
    getRelatedCssPropertyNames: function() {
        return [this.getCssPropertyName()];
    },
    getCssPropertyName: function() {
        return "color";
    },
    getQueryCommandName: function() {
        return "forecolor";
    },
    computeNewStyle: function(data) {
        var style = {};
        style[this.getCssPropertyName()] = data || this.getDefaultProperty();
        return style;
    },
    syncButton: function(color) {
        try {
            if (color) {
                $tx.setStyle(this.button.elButton, {'backgroundColor': color});
            }
        } catch(e) {
            
        }
    }
});



/**
 * @fileoverview 
 *  \uae00\uc790 \ubc30\uacbd\uc0c9\uc744 \uc801\uc6a9 \ud558\uae30 \uc704\ud574 \uc4f0\uc774\ub294, Toolbar\uc758 \uae00\uc790\ubc30\uacbd\uc0c9 Icon\uc744 \uc704\ud574 \ud544\uc694\ud55c 
 *  configuration\uacfc Class Trex.Tool.BackColor\uc744/\ub97c \ud3ec\ud568
 * 
 */
TrexConfig.addTool(
	"backcolor",
	{
		defaultcolor: "#9aa5ea",
		wysiwygonly: _TRUE, 
		sync: _FALSE,
		status: _TRUE,
		useFavorite: _TRUE,
		texts: {
			options: [
				{ color: '#ff0000', text: '#ffffff', label: '\uac00\ub098\ub2e4' },
				{ color: '#e545d0', text: '#ffffff', label: '\uac00\ub098\ub2e4' },
				{ color: '#000000', text: '#ffffff', label: '\uac00\ub098\ub2e4' },
				{ color: '#ff5e00', text: '#ffffff', label: '\uac00\ub098\ub2e4' },
				{ color: '#7c43b1', text: '#ffffff', label: '\uac00\ub098\ub2e4' },
				{ color: '#848484', text: '#ffffff', label: '\uac00\ub098\ub2e4' },
				{ color: '#ffbb00', text: '#ffffff', label: '\uac00\ub098\ub2e4' },
				{ color: '#4673ff', text: '#ffffff', label: '\uac00\ub098\ub2e4' },
				{ color: '#66e8ff', text: '#000000', label: '\uac00\ub098\ub2e4' },
				{ color: '#ffe400', text: '#ffffff', label: '\uac00\ub098\ub2e4' }, 
				{ color: '#1fafda', text: '#ffffff', label: '\uac00\ub098\ub2e4' },
				{ color: '#8cfccb', text: '#000000', label: '\uac00\ub098\ub2e4' },
				{ color: '#a8c40d', text: '#ffffff', label: '\uac00\ub098\ub2e4' },
				{ color: '#009999', text: '#ffffff', label: '\uac00\ub098\ub2e4' },
				{ color: '#ffffff', text: '#000000', label: '\uac00\ub098\ub2e4' }
			]
		},
		thumbs: Trex.__CONFIG_COMMON.thumbs,
		needRevert: _TRUE,
		needTrans: _FALSE
	}
);

Trex.Tool.BackColor = Trex.Class.create({
	$const: {
		__Identity: 'backcolor'
	},
	$extend: Trex.Tool,
	$mixins: [Trex.I.CookieBaker, Trex.I.FontTool, Trex.I.MenuFontTool, Trex.I.WrappingSpanFontTool],
    beforeOnInitialized: function(config) {
        this.useFavorite = !!config.useFavorite;
        if (this.useFavorite) {
            this.initCookie('txBackColorFavorite');
        }
    },
    createButton: function() {
        var initialColor =  this.readCookie() || this.getDefaultProperty();

        var button = this.button = new Trex.Button.Splits(this.buttonCfg);
        button.setValue(initialColor);
        this.syncButton(initialColor);
        return button;
    },
    createMenu: function() {
        return new Trex.Menu.ColorPallete(this.menuCfg);
    },
    onAfterHandler: function(data) {
        this.syncButton(data);
        if (this.useFavorite) {
            this.writeCookie(data);
        }
    },
    getDefaultProperty: function() {
        return this.config.defaultcolor;
    },
    syncButton: function(data) {
        try {
            var color = data ? data.split("|")[0] : _NULL;
            if (color) {
                $tx.setStyle(this.button.elButton, {
                    backgroundColor: color
                });
            }
		} catch(e){
            
        }
    },
    getRelatedCssPropertyNames: function() {
        return ["color", this.getCssPropertyName()];
    },
    getCssPropertyName: function() {
        return "backgroundColor";
    },
    getQueryCommandName: function() {
        return ($tx.gecko || $tx.opera) ? "hilitecolor" : "backcolor";
    },
    computeNewStyle: function(data) {
        if (this.shouldRevert(data) || this.includeTextColor(data)) {
            var split = data ? data.split("|") : [];
            return {backgroundColor: split[0], color: split[1]};
        }
        return {backgroundColor: data};
    },
    shouldRevert: function(data) {
        return data == _NULL;
    },
    includeTextColor: function(data) {
        return data && (data.indexOf("|") > -1);
    }
});

/**
 * @fileoverview
 * '\ub4e4\uc5ec\uc4f0\uae30' Icon Source,
 * Class Trex.Tool.Indent configuration\uc744 \ud3ec\ud568
 *
 */
TrexConfig.addTool(
    "indent",
    {
        sync: _FALSE,
        status: _FALSE,
        hotKey: {
            // tab - \ub4e4\uc5ec\uc4f0\uae30
            keyCode: 9
        }
    }
);

Trex.Tool.Indent = Trex.Class.create({
    $const: {
        __Identity: 'indent'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        this.weave(new Trex.Button(this.buttonCfg), _NULL, this.handler);
        this.bindKeyboard(config.hotKey, this.tabKeyHandler.bind(this));
        this.createHandlers();
    },
    handler: function() {
        var self = this, canvas = self.canvas;
        canvas.execute(function(processor) {
            self.onIndentClicked.handle(processor);
        });
    },
    tabKeyHandler: function() {
        var self = this;
        this.canvas.execute(function(processor) {
            self.onTabPressed.handle(processor);
        });
    },
    createHandlers: function() {
        var IndentTool = Trex.Tool.Indent;
        var Judge = IndentTool.Judge;
        var Operation = IndentTool.Operation;
        var Handler = IndentTool.Handler;
        var ChainHandler = Trex.ChainHandler;
        
        var onDefaultIndent = ChainHandler.connect([
            new ChainHandler(Judge.ListItem, Operation.IndentListItem),
            new ChainHandler(Judge.BlockNode, Operation.IndentBlockNode)
        ]);
        var onCollapsedTabPressed = ChainHandler.connect([
            new ChainHandler(Judge.And(Judge.HeadOfParagraph, Judge.ListItem), Operation.IndentListItem),
            new ChainHandler(Judge.ChildOfLastTableCell, Operation.GoToBelowTable),
            new ChainHandler(Judge.ChildOfTableCell, Operation.GoToNextCell),
            new ChainHandler(Judge.AlwaysTrue, Operation.IndentBlockNode)
//            new ChainHandler(Judge.And(Judge.HeadOfParagraph, Judge.BlockNode), Operation.IndentBlockNode),
//            new ChainHandler(Judge.AlwaysTrue, Operation.AddFourSpaces)
        ]);

        this.onTabPressed = new Handler(onCollapsedTabPressed, onDefaultIndent, onDefaultIndent);
        this.onIndentClicked = new Handler(onDefaultIndent, onDefaultIndent, onDefaultIndent);
    }
});

Trex.Tool.Indent.Handler = Trex.Class.create({
    initialize: function (collasped, selection, tableCell) {
        var IndentTool = Trex.Tool.Indent;
        var RangeIndenter = IndentTool.RangeIndenter;
        var TableCellIndenter = IndentTool.TableCellIndenter;
        this.collapsedRange = new RangeIndenter(collasped);
        this.selectedRange = new RangeIndenter(selection);
        this.tableCellSelected = new TableCellIndenter(tableCell);
    },
    handle: function(processor) {
        var tableCells = (processor.table) ? processor.table.getTdArr() : [];
        if (tableCells.length > 0) {
            this.tableCellSelected.indent(processor);
        } else if (processor.isCollapsed()) {
            this.collapsedRange.indent(processor);
        } else {
            this.selectedRange.indent(processor);
        }
    }
});

Trex.ChainHandler = Trex.Class.create({
    $const: {
        connect: function(handlers) {
            var firstHandler = handlers[0];
            for (var i = 1; i < handlers.length; i++) {
                handlers[i - 1].setNext(handlers[i]);
            }
            return firstHandler;
        }
    },
    initialize: function(judge, executor) {
        this.judge = judge;
        this.executor = executor;
        return this;
    },
    setNext: function(successor) {
        this.successor = successor;
        return this.successor;
    },
    handle: function() {
    	var args = arguments;
        if (this.judge.apply(this, args)) {
            this.executor.apply(this, args);
        } else if (this.successor) {
            this.successor.handle.apply(this.successor, args);
        }
    }
});

(function() {
    Trex.Tool.Indent.Helper = {
        findBlocksToIndentFromRange: function(range, processor, savedCaret) {
            var startCaret = savedCaret.getCaret(_TRUE);
            var endCaret = savedCaret.getCaret(_FALSE);
            if (processor.isCollapsed()) {
                // getStartNode, getStartOffset \ud638\ucd9c\ud558\uc9c0 \uc54a\uc73c\uba74 \uc624\ub958\uac00 \ubc1c\uc0dd\ud55c\ub2e4.
                range.getStartNode();
                range.getStartOffset();
                var node = this.findBlockToIndent(startCaret, processor);
                var isEmptyParagraph = (node && node.tagName == "P" && node.firstChild == startCaret && node.lastChild == endCaret);
                if (isEmptyParagraph) {
                    processor.stuffNode(node);
                }
                // TODO : block\uc744 create\ud55c \uacbd\uc6b0\ub9cc restoreInternal\uc744 \ud574\uc57c\ud55c\ub2e4. tab press[P\ub85c \uac10\uc2f8\uc5ec \uc788\uc9c0 \uc54a\uc740 \ud14d\uc2a4\ud2b8\uc5d0\uc11c tab \ub204\ub974\uae30] \ud14c\uc2a4\ud2b8\ucf00\uc774\uc2a4\uc640 \uad00\ub828\uc788\uc74c
                savedCaret.restoreInternal();
                return [ node ];
            } else {
                var iterator = new goog.dom.TextRangeIterator(startCaret, 0, endCaret, 0);
                return this.findBlocksToIndentFromIterator(processor, iterator);
            }
        },
        findBlocksToIndentFromIterator: function(processor, iterator) {
            var self = this;
            var allNodes = self.collectAllNodes(iterator);
            var leafNodes = self.selectLeafNodes(allNodes);
            var validLeafNodes = self.filterUnableToIndent(leafNodes);

            var blocksToIndent = validLeafNodes.map(function(node) {
                return self.findBlockToIndent(node, processor);
            });
            blocksToIndent = blocksToIndent.compact().uniq();
            return blocksToIndent;
        },
        collectAllNodes: function (iterator) {
            var allNodes = [];
            goog.iter.forEach(iterator, function(node) {
                if (!allNodes.contains(node)) {
                    allNodes.push(node);
                }
            });
            return allNodes;
        },
        selectLeafNodes: function (nodes) {
            var leafNodes = [];
            nodes.each(function(node) {
                if (node.childNodes.length == 0) {
                    leafNodes.push(node);
                }
            });
            return leafNodes;
        },
        filterUnableToIndent: function (nodes) {
            var result = [];
            nodes.each(function(node) {
                // indent\ub97c \ud558\uc9c0 \ubabb\ud558\ub294 TextNode\ub97c \uac78\ub7ec\ub0b8\ub2e4.
                if ($tom.kindOf(node, "ul,ol,dl")) {
                    $tom.removeListIfEmpty(node);
                } else if ($tom.kindOf(node.parentNode, "table") && $tom.isText(node)) {

                } else if ($tom.kindOf(node.parentNode, "thead,tbody,tfooter") && !$tom.kindOf(node, "tr")) {

                } else if ($tom.kindOf(node.parentNode, "tr") && !$tom.kindOf(node, "th,td")) {

                } else if ($tom.kindOf(node.parentNode, "ul,ol,dl") && !$tom.kindOf(node, "li,dd,dt")) {

                } else {
                    result.push(node);
                }
            });
            return result;
        },
        findBlockToIndent: function(node) {
            var block = this.findOrCreateBlockForNode(node);
            return this.findIndentableHigherBlock(block);
        },
        findOrCreateBlockForNode: function(node) {
            if ($tom.isText(node) || $tom.kindOf(node, "%inline,img")) {
                var blockAncestor = $tom.ancestor(node, "p,li,dd,dt,h1,h2,h3,h4,h5,h6,div");
                if (blockAncestor && $tom.children(blockAncestor, "%block").length == 0) {
                    return blockAncestor;
                } else {
                    blockAncestor = $tom.ancestor(node, "%paragraph,pre,noscript,form,hr,address,fieldset,blockquote");
                    return $tom.wrapInlinesWithP(node, blockAncestor);
                }
            } else {
                return node;
            }
        },
        findIndentableHigherBlock: function(block) {
            var foundNode = _NULL;
            var visitNode = block;
            while (visitNode && visitNode.tagName != "BODY") {
                if (!foundNode && $tom.kindOf(visitNode, "p,div,h1,h2,h3,h4,h5,h6")) {
                    foundNode = visitNode;
                } else if ($tom.kindOf(visitNode, "li,dd,dt")) {
                    return visitNode;
                } else if (foundNode && $tom.kindOf(visitNode, "td,th")) {
                    return foundNode;
                }
                visitNode = visitNode.parentNode;
            }
            return foundNode;
        },
        findAncestorTableCell: function(node) {
            return $tom.ancestor(node, "td,th");
        },
        findNextCell: function(node) {
            var currentCell = this.findCurrentCell(node);
            var nextCell = $tom.next(currentCell, "td,th");
            if (!nextCell) {
                var nextRow = $tom.next($tom.parent(currentCell), "tr");
                if (nextRow) {
                    nextCell = $tom.first(nextRow, "td,th");
                }
            }
            return nextCell;
        },
        findPreviousCell: function(node) {
            var currentCell = this.findCurrentCell(node);
            var prevCell = $tom.previous(currentCell, "td,th");
            if (!prevCell) {
                var prevRow = $tom.previous($tom.parent(currentCell), "tr");
                if (prevRow) {
                    prevCell = $tom.last(prevRow, "td,th");
                }
            }
            return prevCell;
        },
        findCurrentCell: function(node) {
            return $tom.kindOf(node, "td,th") ? node : this.findAncestorTableCell(node);
        },
        isCaretOnStartOf: function(node, range) {
            var startNode = range.getStartNode();
            var startOffset = range.getStartOffset();
            while ($tom.isElement(startNode) && startNode.childNodes.length > 0) {
                startNode = startNode.childNodes[startOffset];
                startOffset = 0;
            }
            if (!startNode) {
                return _TRUE;
            }
            var iterator = new goog.dom.TextRangeIterator(node, 0, startNode, startOffset);
            var hasContent = _FALSE;
            goog.iter.forEach(iterator, function(visiting) {
                if (visiting.nodeType == 3 && !$tom.kindOf(visiting.parentNode, "script,style")) {
                    var text = (visiting === startNode) ? visiting.nodeValue.substring(0, startOffset) : visiting.nodeValue;
                    text = text.replace(Trex.__WORD_JOINER_REGEXP, "");
                    hasContent = $tom.removeMeaninglessSpace(text).length > 0;
                } else if ($tom.isElement(visiting)) {
                    if ($tom.kindOf(visiting, "img,embed,iframe")) {
                        hasContent = _TRUE;
                    }
                }
                if (hasContent) {
                    throw goog.iter.StopIteration;
                }
            });
            return !hasContent;
        }
    };
    var indentHelper = Trex.Tool.Indent.Helper;

    var $caret_moved = {};
    // range \uc0ac\uc6a9\ud574\uc11c indent\ud560 block\uc744 \ucc3e\uc544\uc11c chain handler \uc791\uc5c5 \uc9c0\uc2dc\ud55c\ub2e4.
    Trex.Tool.Indent.RangeIndenter = Trex.Class.create({
        initialize: function(handler) {
            this.handler = handler;
        },
        indent: function(processor) {
            var self = this;
            processor.executeUsingCaret(function(range, savedCaret) {
                var blockNodes = indentHelper.findBlocksToIndentFromRange(range, processor, savedCaret);
                blockNodes.each(function(node) {
                    try {
                        self.handler.handle(node, processor, range);
                    } catch (e) {
                        if (e == $caret_moved) {
                            savedCaret.dispose();
                        } else {
                            throw e;
                        }
                    }
                });
            });
        }
    });

    Trex.Tool.Indent.TableCellIndenter = Trex.Class.create({
        initialize: function(handler) {
            this.handler = handler;
        },
        indent: function(processor) {
            var self = this;
            var tableCells = (processor.table) ? processor.table.getTdArr() : [];
            tableCells.each(function(cell) {
                var iterator = new goog.dom.TagIterator(cell);
                var blockNodes = indentHelper.findBlocksToIndentFromIterator(processor, iterator);
                blockNodes.each(function(node) {
                    self.handler.handle(node, processor, _NULL);
                });
            });
        }
    });



    Trex.Tool.Indent.Judge = {
        ChildOfFirstTableCell: function(node) {
            var tableCell = indentHelper.findAncestorTableCell(node);
            return tableCell && !indentHelper.findPreviousCell(tableCell);
        },
        ChildOfLastTableCell: function(node) {
            var tableCell = indentHelper.findAncestorTableCell(node);
            return tableCell && !indentHelper.findNextCell(tableCell);
        },
        ChildOfTableCell: function(node) {
            return indentHelper.findAncestorTableCell(node);
        },
        ListItem: function(node) {
            return $tom.kindOf(node, "li") && $tom.kindOf(node.parentNode, "ol,ul");
        },
        OneDepthList: function(node) {
            if ($tom.kindOf(node, "li")) {
                // TODO: depth\uacc4\uc0b0\uc744 \ud560 \uac83\uc774\ub0d0 \ubd80\ubaa8/\uc870\uc0c1\ub9cc \ud655\uc778\ud558\uc5ec return \ud560 \uac83\uc774\ub0d0 \uace0\ubbfc..
                var listBuilder = new Trex.Tool.StyledList.ListBuilder();
                if (listBuilder.countDepthOfList(node) == 1) {
                    return _TRUE;
                }
            }
            return _FALSE;
        },
        IndentedBlockNode: function(node) {
            return $tom.kindOf(node, "%block") && node.style && node.style.marginLeft != "";
        },
        BlockNode: function(node) {
            // TODO %block vs %paragraph
            return $tom.kindOf(node, "%block");
        },
        HeadOfParagraph: function(node, processor, range) {
            return indentHelper.isCaretOnStartOf(node, range);
        },
        And: function(judge1, judge2){
            return function() {
                return judge1.apply(this, arguments) && judge2.apply(this, arguments);
            }
        },
        AlwaysTrue: function() {
            return _TRUE;
        }
    };

    Trex.Tool.Indent.Operation = {
        /* indent */
        GoToBelowTable: function(node, processor) {
            var table = $tom.ancestor(node, 'table');
            processor.bookmarkToNext(table);
            throw $caret_moved;
        },
        GoToNextCell: function(node, processor) {
            var nextCell = indentHelper.findNextCell(node);
            if (nextCell) {
                processor.selectFirstText(nextCell);
                throw $caret_moved;
            }
        },
        IndentListItem: function(node) {
            var groupNode = $tom.ancestor(node, 'ul,ol,dl');
            if (groupNode) {
                var prevSibling = $tom.previous(node);
                var nextSibling = $tom.next(node);
                if ($tom.kindOf(prevSibling, "ul,ol,dl")) {
                    // move to previous Group
                    $tom.append(prevSibling, node);
                } else {
                    var newGroupNode = $tom.clone(groupNode);
                    $tom.applyStyles(newGroupNode, { marginLeft: _NULL, paddingLeft: _NULL });
                    $tom.wrap(newGroupNode, node);
                }
                // move next Siblings to same parent
                if ($tom.kindOf(nextSibling, "ul,ol,dl")) {
                    $tom.moveChild(nextSibling, node.parentNode);
                    $tom.remove(nextSibling);
                }
            }
        },
        getChildrenAsElement: function(node) {
            var blocks = [];
            var childNodes = node.childNodes;
            for (var i = 0, len = childNodes.length; i < len; i++) {
                var child = childNodes[i];
                if ($tom.isText(child)) {
                    var wrappedChild = $tom.wrapInlinesWithP(child, node);
                    blocks.push(wrappedChild);
                } else if ($tom.isElement(child)) {
                    blocks.push(child);
                }
            }
            return blocks;
        },
        IndentBlockNode: function(node) {
            $tom.applyStyles(node, {marginLeft: "+2em"});
        },
//        AddFourSpaces: function(node, processor) {
//            processor.pasteContent("&nbsp;&nbsp;&nbsp;&nbsp;", _FALSE);
//        },
        /* outdent */
        GoToAboveTable: function(node, processor) {
            var table = $tom.ancestor(node, 'table');
            processor.bookmarkToPrevious(table);
            throw $caret_moved;
        },
        GoToPreviousCell: function(node, processor) {
            var previousCell = indentHelper.findPreviousCell(node);
            if (previousCell) {
                processor.moveCaretTo(previousCell, _TRUE);
                throw $caret_moved;
            }
        },
        OutdentListItem: function(node, processor) {
            var list = $tom.ancestor(node, 'ul,ol,dl');
            if (!list) {
                return;
            }
            var parentNode = list.parentNode;
            if ($tom.kindOf(parentNode, "li")) {
                $tom.unwrap(parentNode);
                parentNode = list.parentNode;
            }
            var grandParentList = $tom.kindOf(parentNode, 'ul,ol,dl') ? parentNode : _NULL;
            var newList;
            if (grandParentList) {
                newList = $tom.divideNode(list, $tom.indexOf(node));
                $tom.insertAt(node, newList);
            } else {
                newList = $tom.divideNode(list, $tom.indexOf(node));
                var cssText = $tom.getStyleText(node);
                // list\uc758 \uc2a4\ud0c0\uc77c\uc744 p\uc5d0\ub3c4 \uc801\uc6a9\ud55c\ub2e4.
                var p = processor.newNode('p');
                $tom.setStyleText(p, cssText);
                $tom.replace(node, p);
                $tom.insertAt(p, newList);
            }
            $tom.removeListIfEmpty(list);
            $tom.removeListIfEmpty(newList);
        },
        OutdentBlockNode: function(node) {
            $tom.applyStyles(node, {marginLeft: "-2em"});
        },
        Propagate: function() {
            throw $propagate;
        }
    };
})();
/**
 * @fileoverview 
 * Tool '\ub0b4\uc5b4\uc4f0\uae30' Source,
 * Class Trex.Tool.Outdent \uc640 configuration\uc744 \ud3ec\ud568    
 *     
 */
TrexConfig.addTool(
	"outdent",
	{
		sync: _FALSE,
		status: _FALSE,
        hotKey: { // shift + tab - \ub0b4\uc5b4\uc4f0\uae30
			shiftKey: _TRUE,
			keyCode: 9
		}
	}
);

Trex.Tool.Outdent = Trex.Class.create({
	$const: {
		__Identity: 'outdent'
	},
	$extend: Trex.Tool,
	oninitialized: function(config) {
        this.weave(new Trex.Button(this.buttonCfg), _NULL, this.handler);
        this.createHandlers();
		if (!$tx.opera&&!($tx.chrome&&$tx.os_mac)) {
            this.observeBackspace();
		}
        this.bindKeyboard(config.hotKey, this.shiftTabKeyHandler.bind(this));
	},
    handler: function() {
        var self = this;
        this.canvas.execute(function(processor) {
            self.onOutdentClicked.handle(processor);
        });
    },
    shiftTabKeyHandler: function() {
        var self = this;
        this.canvas.execute(function(processor) {
            self.onShiftTabPressed.handle(processor);
        });
    },
    observeBackspace: function() {
        var canvas = this.canvas;
        var self = this;
        canvas.observeKey({ keyCode: Trex.__KEY.BACKSPACE }, function() {
            canvas.query(function(processor) {
                self.onBackspace.handle(processor);
            });
        });
    },
    createHandlers: function() {
        var IndentTool = Trex.Tool.Indent;
        var Judge = IndentTool.Judge;
        var Operation = IndentTool.Operation;
        var Handler = IndentTool.Handler;
        var Chain = Trex.ChainHandler;

        var onDefaultOutdent = Chain.connect([
            new Chain(Judge.ListItem, Operation.OutdentListItem),
            new Chain(Judge.BlockNode, Operation.OutdentBlockNode)
        ]);
        var propagate = Chain.connect([
            new Chain(Judge.AlwaysTrue, Operation.Propagate)
        ]);
        var onCollapsedShiftTabPressed = Chain.connect([
            new Chain(Judge.ListItem, Operation.OutdentListItem),
            new Chain(Judge.ChildOfFirstTableCell, Operation.GoToAboveTable),
            new Chain(Judge.ChildOfTableCell, Operation.GoToPreviousCell),
            new Chain(Judge.BlockNode, Operation.OutdentBlockNode)
        ]);
        var onCollapsedBackspace = Chain.connect([
            new Chain(Judge.And(Judge.HeadOfParagraph, Judge.OneDepthList), Operation.Propagate),
            new Chain(Judge.And(Judge.HeadOfParagraph, Judge.ListItem), Operation.OutdentListItem),
            new Chain(Judge.And(Judge.HeadOfParagraph, Judge.IndentedBlockNode), Operation.OutdentBlockNode),
            new Chain(Judge.AlwaysTrue, Operation.Propagate)
        ]);

        this.onShiftTabPressed = new Handler(onCollapsedShiftTabPressed, onDefaultOutdent, onDefaultOutdent);
        this.onOutdentClicked = new Handler(onDefaultOutdent, onDefaultOutdent, onDefaultOutdent);
        this.onBackspace = new Handler(onCollapsedBackspace, propagate, propagate);
    }
});
Trex.I.AlignExecution = Trex.Mixin.create(/** @lends Trex.I.AlignExecution */{
	executeAlignImageMode: function(processor) {
		var _imageAlignProps = this.constructor.__ImageModeProps['image'];
		var _node = processor.getControlByAreaSelection();
		if(!_node) {
			return;
		}
		processor.apply(_node, _imageAlignProps);
		var _textAlignProps = this.constructor.__ImageModeProps['paragraph'];
		if (_textAlignProps) {
			var _wNode = $tom.find(_node, "%paragraph");
			processor.apply(_wNode, _textAlignProps);
		}
	},
    executeAlignTableMode: function(processor) {
        var selEl = processor.getControlByAreaSelection();
        if(!selEl) return;
        processor.apply(selEl, this.constructor.__TableModeProps);
    },
	executeAlignTextMode: function(processor) {
		var _textAlignProps = this.constructor.__TextModeProps['paragraph'];
		var _node = processor.getControl();
		if(_node && $tom.kindOf(_node, 'button') ) {
			var _wNode = $tom.find(_node, '%paragraph');
			if (_wNode) {
				processor.apply(_wNode, _textAlignProps);
			}
			var _tNode = $tom.collect(_node, 'blockquote'); //NOTE: # FTDUEDTR-1027
			if(_tNode) {
				_tNode.style.margin = this.constructor.__TextModeProps['button']['style']['margin'];
			}
		} else {
			var _nodes = processor.blocks(function(){
				return '%paragraph';
			});
			processor.apply(_nodes, _textAlignProps);

			var _controlNodes = [];
			_nodes.each(function (node) {
				var tables;
				tables = $tom.collectAll(node, 'table,hr');
				tables.each(function (table) {
					_controlNodes.push(table);
				});
			});
			processor.apply(_controlNodes, {
				'align': _textAlignProps['style']['textAlign']
			});
		}
	},
	queryImageFloat: function(processor) {
		var _node = processor.getControlByAreaSelection();
		if (_node) {
			return processor.queryStyle(_node, 'float');
		} else {
			return _NULL;
		}
	},
	queryParaFloat: function(processor) {
		var _value, _node = processor.findNode('%paragraph');
		if (_node) {
			_value = processor.queryStyle(_node, 'float');
		}
		return _value || _NULL;
	},
	queryTextAlign: function(processor) {
		var _node = processor.findNode('%paragraph');
		var _value = processor.queryStyle(_node, 'textAlign');
		if(!_value) {
			_value = processor.queryAttr(_node, 'align');
		}
		if(!_value || _value == "start" || _value == "auto" || _value == "-webkit-auto") {
			_value = 'left';
		}
		return _value;
	},
	queryControlAlign: function(processor) {
		var node = processor.getControlByAreaSelection();
        return processor.queryAttr(node, 'align');
	},
    executeAlign: function(processor) {
        var tool = this;
        var alignMode = tool.getAlignMode(processor);
        if (alignMode == "tableCell") {
            tool.executeTableCellMode(processor);
        } else if (alignMode == "image") {
            tool.executeAlignImageMode(processor);
        } else if (alignMode == "table") {
            tool.executeAlignTableMode(processor);
        } else {
            tool.executeAlignTextMode(processor);
        }
        if(!processor.getAreaSelection) return;
        var sel = processor.getAreaSelection();
        sel.update();
    },
    getAlignMode: function(processor) {
		var selectedTdArr = (processor.table) ? processor.table.getTdArr() : [];
        var node = processor.getControlByAreaSelection();
        if (selectedTdArr.length > 0) {
            return "tableCell";
        } else if($tom.kindOf(node, 'table')){
            return 'table'
        } else if (this.imageAlignMode) {
            return "image";
        } else {
            return "text";
        }
    },
    executeTableCellMode: function(processor) {
        if (!this.indenter) {
            var Judge = Trex.Tool.Indent.Judge;
            var ChainHandler = Trex.ChainHandler;
            var self = this;
            function alignBlockNode(node) {
                $tom.applyAttributes(node, self.constructor.__TextModeProps.paragraph);
            }

            var defaultAlign = ChainHandler.connect([
                new ChainHandler(Judge.ListItem, alignBlockNode),
                new ChainHandler(Judge.BlockNode, alignBlockNode)
            ]);

            this.indenter = new Trex.Tool.Indent.TableCellIndenter(defaultAlign);
        }
        this.indenter.indent(processor);
    },
    syncButtonState: function() {
        var self = this;
        var state = self.canvas.query(function(processor) {
            return self.queryCurrentStyle(processor);
        });
        self.button.setState(state);
    },
    queryCurrentStyle: function(processor) {
        var mode = this.getAlignMode(processor);
        if(mode == 'table'){
            return this.queryTableMode(processor)
        }else if(mode == 'image'){
            return this.queryImageMode(processor)
        }else {
            return this.queryTextMode(processor)
        }
    },
    queryTableMode: function(processor){
        var _node = processor.getControlByAreaSelection();
        return $tom.getAttribute(_node, 'align') == this.constructor.__TableModeProps.align
    },
    queryImageMode: function(processor) {
		var imageModeProps = this.constructor.__ImageModeProps;
		var currentImageFloat = this.queryImageFloat(processor);
		if (currentImageFloat && currentImageFloat != 'none') {
			if (imageModeProps.image && imageModeProps.image.style['float']) {
				return (currentImageFloat == imageModeProps.image.style['float']);
			}
		}
		var currentParaFloat = this.queryParaFloat(processor);
		if (currentParaFloat && currentParaFloat != 'none') {
			if (imageModeProps.paragraph && imageModeProps.paragraph.style['float']) {
				return (currentParaFloat == imageModeProps.paragraph.style['float']);
			}
		}
		var currentTextAlign = this.queryTextAlign(processor);
		if (imageModeProps.paragraph && imageModeProps.paragraph.style.textAlign) {
			return (currentTextAlign == imageModeProps.paragraph.style.textAlign);
		}
        return _FALSE;
    },
    queryTextMode: function(processor) {
		var textModeProps = this.constructor.__TextModeProps;
		var textAlign = textModeProps.paragraph.style.textAlign;
        var controlAlign = this.queryControlAlign(processor);
        if (controlAlign == _NULL) {
            var align = this.queryTextAlign(processor) || 'left';
            return (align == textAlign);
        } else {
            return (controlAlign == textAlign);
        }
    }
});
(function() {
    /**
     * @fileoverview
     * Toolbar\uc758 AlignLeft Icon\uc744 \uc704\ud574 \ud544\uc694\ud55c configuration\uacfc Class Trex.Tool.AlignLeft\ub97c \ud3ec\ud568
     *
     */
    TrexConfig.addTool(
        "alignleft",
        {
            sync: _TRUE,
            status: _TRUE,
            hotKey: { // ctrl + ,
                ctrlKey: _TRUE,
                keyCode: 188
            }
        }
    );

    /*
     * Text : align left
     * Image : float none + align left
     */
    var __TextAlignProperty = "left";
    var __ImageFloatProperty = 'none';
    var __ImageClearProperty = 'none';
    var paragraphProp = {
        'align': _NULL,
        'style': {
            'textAlign': __TextAlignProperty
        }
    };

    Trex.Tool.AlignLeft = Trex.Class.create({
        $const: {
            __Identity: 'alignleft',
            __ImageModeProps: {
                'paragraph': paragraphProp,
                'image': {
                    'style': {
                        'clear': __ImageClearProperty,
                        'float': __ImageFloatProperty,
                        'marginLeft': "",
                        'marginRight': ""
                    }
                }
            },
            __TextModeProps: {
                'paragraph': paragraphProp,
                'button': {
                    'style': {
                        'margin': '0'
                    }
                }
            },
            __TableModeProps: {
                align: _NULL
            }
        },
        $extend: Trex.Tool,
        $mixins: [Trex.I.AlignExecution],
        oninitialized: function(config) {
            var self = this;
            self.imageAlignMode = _FALSE;

            self.weave(new Trex.Button(self.buttonCfg), _NULL, self.handler);
            self.bindKeyboard(config.hotKey, self.handler.bind(self));
            self.startSyncButtonWithStyle();
        },
        handler: function() {
            var self = this;
            var canvas = self.canvas;
            var toolbar = self.toolbar;
            canvas.execute(function(processor) {
                self.executeAlign(processor);
                var alignMode = self.getAlignMode(processor);
                if (alignMode == "image") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_IMG_LEFT);
                } else if (alignMode == "text") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_LEFT);
                } else if (alignMode == "table") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_TABLE_LEFT);
                }
            });
            canvas.triggerQueryStatus();
        },
	        startSyncButtonWithStyle: function() {
            var self = this;
            self.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, function(){
                 self.syncButtonState();
            });
        }
    });
})();
(function() {
    /**
     * @fileoverview
     * Toolbar\uc758 AlignCenter Icon\uc744 \uc704\ud574 \ud544\uc694\ud55c configuration\uacfc Class Trex.Tool.AlignCentrer\ub97c \ud3ec\ud568
     *
     */
    TrexConfig.addTool(
            "aligncenter",
    {
        sync: _TRUE,
        status: _TRUE,
        hotKey: {
            ctrlKey: _TRUE, // ctrl + .
            keyCode: 190
        }
    }
            );

    /*
     * Text : align center
     * Image : float none + align center
     */
    var __TextAlignProperty = "center";
    var __ImageFloatProperty = 'none';
    var __ImageClearProperty = 'none';
    var paragraphProp = {
        'align': _NULL,
        'style': {
            'textAlign': __TextAlignProperty
        }
    };

    Trex.Tool.AlignCenter = Trex.Class.create({
        $const: {
            __Identity: 'aligncenter',
            __ImageModeProps: {
                'paragraph': paragraphProp,
                'image': {
                    'style': {
                        'clear': __ImageClearProperty,
                        'float': __ImageFloatProperty,
                        'marginLeft': "",
                        'marginRight': ""
                    }
                }
            },
            __TextModeProps: {
                'paragraph': paragraphProp,
                'button': {
                    'style': {
                        'margin': '0 auto'
                    }
                }
            },
            __TableModeProps: {
                align: __TextAlignProperty
            }
        },
        $extend: Trex.Tool,
        $mixins: [Trex.I.AlignExecution],
        oninitialized: function(config) {
            var self = this;
            self.imageAlignMode = _FALSE;

            self.weave(new Trex.Button(self.buttonCfg), _NULL, self.handler);
            self.bindKeyboard(config.hotKey, self.handler.bind(self));
            self.startSyncButtonWithStyle();
        },
        handler: function() {
            var self = this;
            var canvas = self.canvas;
            var toolbar = self.toolbar;
            canvas.execute(function(processor) {
                self.executeAlign(processor);
                var alignMode = self.getAlignMode(processor);
                if (alignMode == "image") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_IMG_CENTER);
                } else if (alignMode == "text") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_CENTER);
                } else if (alignMode == "table") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_TABLE_CENTER);
                }
            });
            canvas.triggerQueryStatus();
        },
        startSyncButtonWithStyle: function() {
            var self = this;
            self.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, function() {
                self.syncButtonState();
            });
        }
    });
})();
(function() {
    /**
     * @fileoverview
     * Toolbar\uc758 AlignRight Icon\uc744 \uc704\ud574 \ud544\uc694\ud55c configuration\uacfc Class Trex.Tool.AlignRight\uc744/\ub97c \ud3ec\ud568
     *
     */
    TrexConfig.addTool(
        "alignright",
        {
            sync: _TRUE,
            status: _TRUE,
            hotKey: { // ctrl + /
                ctrlKey: _TRUE,
                keyCode: 191
            }
        }
    );

    /*
     * Text : align right
     * Image : float left
     */
    var __TextAlignProperty = "right";
    var __ImageFloatProperty = 'left';
    var __ImageClearProperty = 'both';
    var __ImageMarginProperty = "8px";
    var __ImageNoMarginProperty = "";

    Trex.Tool.AlignRight = Trex.Class.create({
        $const: {
            __Identity: 'alignright',
            __ImageModeProps: {
                'image': {
                    'style': {
                        'clear': __ImageClearProperty,
                        'float': __ImageFloatProperty,
                        'marginLeft': __ImageNoMarginProperty,
                        'marginRight': __ImageMarginProperty
                    }
                }
            },
            __TextModeProps: {
                'paragraph': {
                    'align': _NULL,
                    'style': {
                        'textAlign': __TextAlignProperty
                    }
                },
                'button': {
                    'style': {
                        'margin': '0 0 0 auto'
                    }
                }
            },
            __TableModeProps: {
                align: __ImageFloatProperty
            }
        },
        $extend: Trex.Tool,
        $mixins: [Trex.I.AlignExecution],
        oninitialized: function(config) {
            var self = this;
            self.imageAlignMode = _FALSE;

            self.weave(new Trex.Button(self.buttonCfg), _NULL, self.handler);
            self.bindKeyboard(config.hotKey, self.handler.bind(self));
            self.startSyncButtonWithStyle();
        },
        handler: function() {
            var self = this;
            var canvas = self.canvas;
            var toolbar = self.toolbar;
            canvas.execute(function(processor) {
                self.executeAlign(processor);
                var alignMode = self.getAlignMode(processor);
                if (alignMode == "image") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_IMG_FLOAT_LEFT);
                } else if (alignMode == "text") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_RIGHT);
                } else if (alignMode == "table") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_TABLE_FLOAT_LEFT);
                }

            });
            canvas.triggerQueryStatus();
        },
        startSyncButtonWithStyle: function() {
            var self = this;
            self.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, function(){
                 self.syncButtonState();
            });
        }
    });
})();
(function() {
    /**
     * @fileoverview
     * Toolbar\uc758 AlignFull Icon\uc744 \uc704\ud574 \ud544\uc694\ud55c configuration\uacfc Class Trex.Tool.AlignFull\uc744 \ud3ec\ud568
     *
     */
    TrexConfig.addTool(
        "alignfull",
        {
            sync: _TRUE,
            status: _TRUE
        }
    );

    /*
    * Text : align full
    * Image : float right
    */
    var __TextAlignProperty = "justify";
    var __ImageFloatProperty = 'right';
    var __ImageClearProperty = 'both';
    var __ImageMarginProperty = "8px";
    var __ImageNoMarginProperty = "";

    Trex.Tool.AlignFull = Trex.Class.create({
        $const: {
            __Identity: 'alignfull',
            __ImageModeProps: {
                'image': {
                    'style': {
                        'clear': __ImageClearProperty,
                        'float': __ImageFloatProperty,
                        'marginLeft': __ImageMarginProperty,
                        'marginRight': __ImageNoMarginProperty
                    }
                }
            },
            __TextModeProps: {
                'paragraph': {
                    'align': _NULL,
                    'style': {
                        'textAlign': __TextAlignProperty
                    }
                },
                'button': {
                    'style': {
                        'margin': '0'
                    }
                }
            },
            __TableModeProps: {
                align: __ImageFloatProperty
            }
        },
        $extend: Trex.Tool,
        $mixins: [Trex.I.AlignExecution],
        oninitialized: function() {
            var self = this;
            self.imageAlignMode = _FALSE;

            self.weave(new Trex.Button(self.buttonCfg), _NULL, self.handler);
            self.startSyncButtonWithStyle();
        },
        handler: function() {
            var self = this;
            var canvas = self.canvas;
            var toolbar = self.toolbar;
            canvas.execute(function(processor) {
                self.executeAlign(processor);
                var alignMode = self.getAlignMode(processor);
                if (alignMode == "image") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_IMG_FLOAT_RIGHT);
                } else if (alignMode == "text") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_FULL);
                } else if (alignMode == "table") {
                    toolbar.fireJobs(Trex.Ev.__CMD_ALIGN_TABLE_FLOAT_RIGHT);
                }
            });
            canvas.triggerQueryStatus();
        },
        startSyncButtonWithStyle: function() {
            var self = this;
            self.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, function(){
                 self.syncButtonState();
            });
        }
    });
})();
/**
 * @fileoverview 
 * '\ud589,\uc5f4 \uc0bd\uc785' Icon Source,
 * Class Trex.Tool.Insert configuration\uc744 \ud3ec\ud568    
 *     
 */
TrexConfig.addTool(
	"insertcells",
	{
		sync: _FALSE,
		status: _TRUE,
		options: [
			{ label: '\uc704\ub85c \uc0bd\uc785', title: '\uc704\ub85c \uc0bd\uc785', data: 'addRowUpper' , klass: 'tx-insertcells-1'},
			{ label: '\uc544\ub798 \uc0bd\uc785', title: '\uc544\ub798 \uc0bd\uc785', data: 'addRowBelow', klass: 'tx-insertcells-2' },
			{ label: '\uc67c\ucabd \uc0bd\uc785', title: '\uc67c\ucabd \uc0bd\uc785', data: 'addColLeft' , klass: 'tx-insertcells-3'},
			{ label: '\uc624\ub978\ucabd \uc0bd\uc785', title: '\uc624\ub978\ucabd \uc0bd\uc785', data: 'addColRight', klass: 'tx-insertcells-4' }
		]
	}
);

Trex.Tool.Insertcells = Trex.Class.create({
	$const: {
		__Identity: 'insertcells'
	},
	$extend: Trex.Tool,
	oninitialized: function(config) {
		var _canvas = this.canvas;

		var _defaultProperty = _canvas.getStyleConfig().insert;
		var _optionz = (config.options || []);
		var _map = {};
		_optionz.each(function(option) {
			_map[option.data] = option.title;
		});

		/*
		 * "addRowUpper", "addRowBelow", "addColLeft", "addColRight"
		 */
		var _toolHandler = function(command) {
			_canvas.execute(function(processor){
				if (processor.table) {
					switch(command){
						case "addRowUpper":
							processor.table.insertRowAbove();
							break;
						case "addRowBelow":
							processor.table.insertRowBelow();
							break;
						case "addColLeft":
							processor.table.insertColLeft();
							break;
						case "addColRight":
							processor.table.insertColRight();
							break;
					}
				}
			});
		};
		
		/* button & menu weave */
		this.weave.bind(this)(
			/* button */
			new Trex.Button.Select(TrexConfig.merge(this.buttonCfg, {
				selectedValue: _defaultProperty
			})),
			/* menu */
			new Trex.Menu.Select(this.menuCfg),
			/* handler */
			_toolHandler);
	}
});


/**
 * @fileoverview 
 * '\ud589,\uc5f4 \uc0bd\uc785' Icon Source,
 * Class Trex.Tool.deletecells configuration\uc744 \ud3ec\ud568    
 *     
 */
TrexConfig.addTool(
	"deletecells",
	{
		sync: _FALSE,
		status: _TRUE,
		options: [
			{ label: '\ud589 \uc0ad\uc81c', title: '\ud589 \uc0ad\uc81c', data: 'deleteRow' , klass: 'tx-deletecells-1'},
			{ label: '\uc5f4 \uc0ad\uc81c', title: '\uc5f4 \uc0ad\uc81c', data: 'deleteCol' , klass: 'tx-deletecells-2'}
		]
	}
);

Trex.Tool.deletecells = Trex.Class.create({
	$const: {
		__Identity: 'deletecells'
	},
	$extend: Trex.Tool,
	oninitialized: function(config) {
		var _canvas = this.canvas;

		var _defaultProperty = _canvas.getStyleConfig().insert;
		/*
		 * "deleteRow", "deleteCol"
		 */
		var _toolHandler = function(command) {
			_canvas.execute(function(processor){
				if (processor.table) {
					switch(command) {
						case "deleteRow":
							processor.table.deleteRow();
							break;
						case "deleteCol":
							processor.table.deleteCol();
							break;
					}
				}
			});
		};
		
		/* button & menu weave */
		this.weave.bind(this)(
			/* button */
			new Trex.Button.Select(TrexConfig.merge(this.buttonCfg, {
				selectedValue: _defaultProperty
			})),
			/* menu */
			new Trex.Menu.Select(this.menuCfg),
			/* handler */
			_toolHandler);
	}
});


/**
 * @fileoverview 
 * '\ud589,\uc5f4 \uc0bd\uc785' Icon Source,
 * Class Trex.Tool.Mergecells configuration\uc744 \ud3ec\ud568    
 *     
 */
TrexConfig.addTool(
	"mergecells",
	{
		sync: _FALSE,
		status: _TRUE,
		options: [
			{ label: '\ubcd1\ud569', title: '\ubcd1\ud569', data: 'merge' , klass: 'tx-mergecells-1'},
			{ label: '\ubd84\ud560', title: '\ubd84\ud560', data: 'cancelmerge', klass: 'tx-mergecells-2' }
		]
	}
	
	
);

Trex.Tool.Mergecells = Trex.Class.create({
	$const: {
		__Identity: 'mergecells'
	},
	$extend: Trex.Tool,
	oninitialized: function() {
		var _canvas = this.canvas;
		var _defaultProperty = _canvas.getStyleConfig().insert;
		
		var _toolHandler = function(command) {
			_canvas.execute(function(processor){
				if (processor.table) {
					switch(command){
						case "merge":
							processor.table.merge();
							break;
						case "cancelmerge":
							processor.table.resetMerge();
							break;
					}
				}
			});
		};

		/* button & menu weave */
		this.weave.bind(this)(
			/* button */
			new Trex.Button.Select(TrexConfig.merge(this.buttonCfg, {
				selectedValue: _defaultProperty
			})),
			/* menu */
			new Trex.Menu.Select(this.menuCfg),
			/* handler */
			_toolHandler);
	}
});



TrexMessage.addMsg({
	'@cellslineheight.subtitle1': '1pt',
	'@cellslineheight.subtitle2': '2pt',
	'@cellslineheight.subtitle3': '3pt',
	'@cellslineheight.subtitle4': '4pt',
	'@cellslineheight.subtitle5': '5pt'
});

TrexConfig.addTool(
	"cellslineheight",
	{
		sync: _FALSE,
		status: _TRUE,
		options: [
			{ label: TXMSG('@cellslineheight.subtitle1'), title: '1pt', data: 1, klass: 'tx-cellslineheight-1' },
			{ label: TXMSG('@cellslineheight.subtitle2'), title: '2pt', data: 2, klass: 'tx-cellslineheight-2' },
			{ label: TXMSG('@cellslineheight.subtitle3'), title: '3pt', data: 3, klass: 'tx-cellslineheight-3' },
			{ label: TXMSG('@cellslineheight.subtitle4'), title: '4pt', data: 4, klass: 'tx-cellslineheight-4' },
			{ label: TXMSG('@cellslineheight.subtitle5'), title: '5pt', data: 5, klass: 'tx-cellslineheight-5' }
		]
	}
);

Trex.Tool.Cellslineheight = Trex.Class.create({
	$const: {
		__Identity: 'cellslineheight'
	},
	$extend: Trex.Tool,
    oninitialized: function(config) {
        var self = this;
		
		self.createListStyleMap(config);
        self.weave(
			new Trex.Button.CellslineheightList(self.buttonCfg),
			new Trex.Menu.Select(self.menuCfg),
			self.handler
		);

	},
    createListStyleMap: function(config) {
        var listStyleMap = this.listStyleMap = {};
		config.options.each(function(option) {
			listStyleMap[option.data] = {
				type: option.type,
				klass: option.klass
			};
		});
    },
    handler: function(data) {
        var self = this;
        if (!self.listStyleMap[data]) {
            return;
        }
		// \uc2e4\uc81c \ub85c\uc9c1\uc740 \uc5ec\uae30\ubd80\ubd84 \uc785\ub2c8\ub2e4.
		self.canvas.query(function(processor){
			if (processor.table) {
				processor.table.setBorderHeight(data);
			}
		});
    },
	getButtonClassByValue: function(value) {
        var listStyleMap = this.listStyleMap;
		if(listStyleMap[value]) {
            return listStyleMap[value].klass;
        } else {
            return listStyleMap[this.getDefaultProperty()].klass;
        }
    }
});

Trex.Button.CellslineheightList = Trex.Class.create({
	$extend: Trex.Button.Select
});


/**
 * @fileoverview 
 * \uae00\uc790\uc0c9\uc744 \ubcc0\uacbd\ud558\uae30 \uc704\ud574 \uc4f0\uc774\ub294 '\uae00\uc790\uc0c9' Icon\uc744 \uc704\ud574 \ud544\uc694\ud55c source, 
 * Class Trex.Tool.Cellslinecolor \uc640 configuration\uc744 \ud3ec\ud568	
 *  
 */
TrexConfig.addTool(
	"cellslinecolor",
	{ 
		defaultcolor: "#7c84ef",
		wysiwygonly: _TRUE,
		sync: _FALSE,
		status: _TRUE,
		useFavorite: _TRUE,
		thumbs: Trex.__CONFIG_COMMON.thumbs,
		needRevert: _TRUE
	}
);

Trex.Tool.Cellslinecolor = Trex.Class.create({
	$const: {
		__Identity: 'cellslinecolor'
	},
	$extend: Trex.Tool,
	oninitialized: function() {
		var canvas = this.canvas;
		var self = this;
		
		this.button = new Trex.Button(this.buttonCfg);
	  	
		var _toolHandler = function(color) {
			syncButton(color);
			canvas.query(function(processor){
				if (processor.table) {
					processor.table.setBorderColor(color);
				}
			});
		};
		
		var syncButton = function(color) {
			if (color) {
				try {
					$tx.setStyle(self.button.elButton, {
						'backgroundColor': color
					});
				} catch(e) {
					
				}
			}
		};
		syncButton(this.config.defaultcolor);
		
		/* button & menu weave */
		this.weave.bind(this)(
			/* button */
			self.button,
			/* menu */
			new Trex.Menu.ColorPallete(this.menuCfg),
			/* handler */
			_toolHandler
		);
	}
});




TrexMessage.addMsg({
	'@cellslinestyle.subtitle1': '\ud14c\ub450\ub9ac \uc5c6\uc74c',
	'@cellslinestyle.subtitle2': '\uc2e4\uc120',
	'@cellslinestyle.subtitle3': '\uc810\uc120',
	'@cellslinestyle.subtitle4': '\uc791\uc740 \uc810\uc120'
});

TrexConfig.addTool(
	"cellslinestyle",
	{
		sync: _FALSE,
		status: _TRUE,
		options: [
			{ label: TXMSG('@cellslinestyle.subtitle1'), title: '\ud14c\ub450\ub9ac \uc5c6\uc74c', data: 'none', klass: 'tx-cellslinestyle-1' },
			{ label: TXMSG('@cellslinestyle.subtitle2'), title: '\uc2e4\uc120', data: 'solid', klass: 'tx-cellslinestyle-2' },
			{ label: TXMSG('@cellslinestyle.subtitle3'), title: '\uc810\uc120', data: 'dotted', klass: 'tx-cellslinestyle-3' },
			{ label: TXMSG('@cellslinestyle.subtitle4'), title: '\uc791\uc740 \uc810\uc120', data: 'dashed', klass: 'tx-cellslinestyle-4' }
		]
	}
);

Trex.Tool.Cellslinestyle = Trex.Class.create({
	$const: {
		__Identity: 'cellslinestyle'
	},
	$extend: Trex.Tool,
    oninitialized: function(config) {
        var self = this;
		self.createListStyleMap(config);
        self.weave(
			new Trex.Button.CellsLineStyledList(self.buttonCfg),
			new Trex.Menu.Select(self.menuCfg),
			self.handler
		);

	},
    createListStyleMap: function(config) {
        var listStyleMap = this.listStyleMap = {};
		config.options.each(function(option) {
			listStyleMap[option.data] = {
				type: option.type,
				klass: option.klass
			};
		});
    },
    handler: function(data) {
        var self = this;
        if (!self.listStyleMap[data]) {
            return;
        }
        // \uc2e4\uc81c \ub85c\uc9c1\uc740 \uc5ec\uae30\ubd80\ubd84 \uc785\ub2c8\ub2e4.
		self.canvas.query(function(processor){
			if (processor.table) {
				processor.table.setBorderType(data);
			}
		});
    },
    getDefaultProperty: function() {
        return 1;
    }
});

Trex.Button.CellsLineStyledList = Trex.Class.create({
	$extend: Trex.Button.Select
});

/**
 * @fileoverview 
 * '\ud589,\uc5f4 \uc0bd\uc785' Icon Source,
 * Class Trex.Tool.celloutline configuration\uc744 \ud3ec\ud568    
 *     
 */


TrexConfig.addTool(
	"cellsoutline",
	{
		sync: _FALSE,
		status: _TRUE,
		options: [
			{ label: '\ubaa8\ub4e0 \ud14c\ub450\ub9ac', title: '\ubaa8\ub4e0 \ud14c\ub450\ub9ac', data: 'all', klass: 'tx-cellsoutline-1' },
			{ label: '\ubc14\uae65 \ud14c\ub450\ub9ac', title: '\ubc14\uae65 \ud14c\ub450\ub9ac', data: 'out', klass: 'tx-cellsoutline-2' },
			{ label: '\uc548\ucabd \ud14c\ub450\ub9ac', title: '\uc548\ucabd \ud14c\ub450\ub9ac', data: 'in', klass: 'tx-cellsoutline-3' },
			{ label: '\uc704\ucabd \ud14c\ub450\ub9ac', title: '\uc704\ucabd \ud14c\ub450\ub9ac', data: 'top' , klass: 'tx-cellsoutline-4' },
			{ label: '\uc544\ub798\ucabd \ud14c\ub450\ub9ac', title: '\uc544\ub798\ucabd \ud14c\ub450\ub9ac', data: 'bottom', klass: 'tx-cellsoutline-5' },
			{ label: '\uc67c\ucabd \ud14c\ub450\ub9ac', title: '\uc67c\ucabd \ud14c\ub450\ub9ac', data: 'left' , klass: 'tx-cellsoutline-6' },
			{ label: '\uc624\ub978\ucabd \ud14c\ub450\ub9ac', title: '\uc624\ub978\ucabd \ud14c\ub450\ub9ac', data: 'right' , klass: 'tx-cellsoutline-7' },
			{ label: '\ud14c\ub450\ub9ac \uc5c6\uc74c', title: '\ud14c\ub450\ub9ac \uc5c6\uc74c', data: 'none' , klass: 'tx-cellsoutline-8' }
		]
	}
);

Trex.Tool.Cellsoutline = Trex.Class.create({
	$const: {
		__Identity: 'cellsoutline'
	},
	$extend: Trex.Tool,
    oninitialized: function(config) {
        var self = this;
		
		this.twinkleCount = 0;
		this.twinkleTimer = _NULL;
		
		self.createListStyleMap(config);
        self.weave(
			new Trex.Button.CellsoutlineList(self.buttonCfg),
			new Trex.Menu.Select(self.menuCfg),
			self.handler
		);
		
		this.toolbar.observeJob(Trex.Ev.__TOOL_CELL_LINE_CHANGE, function(data){
			if (data.fromInit != _TRUE) {
				self.twinkleButton();
			}
		});
	},
    createListStyleMap: function(config) {
        var listStyleMap = this.listStyleMap = {};
		config.options.each(function(option) {
			listStyleMap[option.data] = {
				type: option.type,
				klass: option.klass
			};
		});
    },
    handler: function(data) {
		var self = this;
        if (!self.listStyleMap[data]) {
            return;
        }
		// \uc2e4\uc81c \ub85c\uc9c1\uc740 \uc5ec\uae30\ubd80\ubd84 \uc785\ub2c8\ub2e4.
		self.canvas.query(function(processor){
			if (processor.table) {
				processor.table.setBorderRange(data);
			}
		});
		self.canvas.execute(function(processor) {
			if (processor.table) {
				if (data == 'none') {
					processor.table.setNoBorder();
				} else {
					processor.table.applyBorder();
				}
			}
        });
    },
    twinkleButton: function(){
		var self;
		self = this;
		
		if (this.twinkleTimer) {
			clearInterval(this.twinkleTimer);
			this.twinkleTimer = _NULL;
		}
		this.twinkleCount = 4;
		this.twinkleTimer = setInterval(function(){
			if (0 < self.twinkleCount) {
				self.twinkleCount -= 1;
				if (self.button.currentState() == "hovered") {
					self.button.normalState();
				} else {
					self.button.hoveredState()
				}
			} else {
				self.button.normalState();
				clearInterval(self.twinkleTimer);
				self.twinkleTimer = _NULL;
			}
		}, 500);
	}
});

Trex.Button.CellsoutlineList = Trex.Class.create({
	$extend: Trex.Button.Select
});








Trex.MarkupTemplate.add(
'cellsline.preview', [
	'<table width="#{width}" cellPadding="0" style="line-height:0"><tbody><tr>',
	'<td valign="center" height="#{height}">',
	'<div style="border-bottom:#{value};width:#{width}px;height:2px;overflow:hidden;"></div>',
	'</td>',
	'</tr></tbody></table>'
].join('')
);

TrexConfig.addTool(
"cellslinepreview", {
	sync: _FALSE,
	status: _TRUE,
	options: [{
		label: Trex.MarkupTemplate.get('cellsline.preview').evaluate({
			value: '1pt solid #ccc',
			width: 70,
			height: 14
		}), 
		title: '1pt solid #ccc', 
		data: '#ccc 1 solid'
	}, {
		label: Trex.MarkupTemplate.get('cellsline.preview').evaluate({
			value: '2pt solid #c54', 
			width: 70,
			height: 14
		}),
		title: '2pt solid #c54', 
		data: '#c54 2 solid'
	}, {
		label: Trex.MarkupTemplate.get('cellsline.preview').evaluate({
			value: '2pt solid #67f', 
			width: 70,
			height: 14
		}),
		title: '2pt solid #67f', 
		data: '#67f 2 solid'
	}, {
		label: Trex.MarkupTemplate.get('cellsline.preview').evaluate({
			value: '3pt solid #000', 
			width: 70,
			height: 14
		}),
		title: '3pt solid #000', 
		data: '#000 3 solid'
	}, {
		label: Trex.MarkupTemplate.get('cellsline.preview').evaluate({
			value: '1pt dashed #d4c', 
			width: 70,
			height: 14
		}),
		title: '1pt dashed #d4c', 
		data: '#d4c 1 dashed'
	}]
}
);

Trex.Tool.Cellslinepreview = Trex.Class.create({
	$const: {
		__Identity: 'cellslinepreview'
	},
	$extend: Trex.Tool,
    oninitialized: function(config) {
        var self = this;
		
		this.data = {
			color: '',
			height: 0,
			type: ''
		};
		
        this.weave(
		new Trex.Button.CellslinepreviewList(this.buttonCfg),
		new Trex.Menu.Select(this.menuCfg), 
		this.handler);
		
		this.toolbar.observeJob(Trex.Ev.__TOOL_CELL_LINE_CHANGE, function(data){
			self.setData(data);
			self.refreshPreview();
		});
	},
	setData: function(data){
		if ("color" in data) {
			this.data.color = data.color;
		}
		if ("height" in data) {
			this.data.height = data.height;
		}
		if ("type" in data) {
			this.data.type = data.type;
		}
	},
	refreshPreview: function(){
		var data;
		data = this.data;
		text = data.height + "pt " + data.type + " " + data.color;
		this.setPreview(text);
	},
	setPreview: function(value){
		this.button.elText.innerHTML = Trex.MarkupTemplate.get('cellsline.preview').evaluate({
			value: value,
			width: 43,
			height: 14
		});
	},
	addBorderHistory: function(data){
		this.setData(data);
		this.refreshPreview();
	},
	handler: function(data, title){
		var self = this, canvas = self.canvas;
        canvas.execute(function(processor) {
			var datas;
			if (processor.table) {
				datas = data.split(" ");
				processor.table.setBorderButtons(datas[0], datas[1], datas[2]);
			}
        });
	}
});

Trex.Button.CellslinepreviewList = Trex.Class.create({
	$extend: Trex.Button.Select,
	setText: function(text) {
		this.tool.setPreview(text);
	}
});
/**
 * @fileoverview 
 * \ud14c\uc774\ube14 \uc140\uc758 \uc0c9\uc744 \ubcc0\uacbd\ud558\uae30 \uc704\ud574 \uc4f0\uc784
 *  
 */
TrexConfig.addTool(
	"tablebackcolor",
	{ 
		defaultcolor: "#9aa5ea",
		wysiwygonly: _TRUE,
		sync: _FALSE,
		status: _TRUE,
		useFavorite: _TRUE,
		thumbs: Trex.__CONFIG_COMMON.thumbs,
		needRevert: _TRUE
	}
);

Trex.Tool.Tablebackcolor = Trex.Class.create({
	$const: {
		__Identity: 'tablebackcolor'
	},
	$extend: Trex.Tool,
	
    oninitialized: function() {
        var _canvas = this.canvas;
		var self = this;
		
		self.button = new Trex.Button(this.buttonCfg);
		
        var _toolHandler = function(color) {
			_canvas.query(function(processor){
				if (processor.table) {
					processor.table.tableBackground(color);
				}
			});
			syncButton(color);
		};

       var syncButton = function(color) {
	        try {
	            if (color) {
	                $tx.setStyle(self.button.elButton, {'backgroundColor': color});
	            }
	        } catch(e) {
	            
	        }
	    }

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            self.button,
            /* menu */
            new Trex.Menu.ColorPallete(this.menuCfg),
            /* handler */
            _toolHandler
        );
    }
});



/**
 * @fileoverview 
 *  toolbar\uc758 \uc811\ud78c \ubd80\ubd84\uc744 \uc5f4\uace0\ub2eb\ub294 '\ub354\ubcf4\uae30' Icon\uc744 \uc704\ud574 \ud544\uc694\ud55c configuration\uacfc Class Trex.Tool.Advanced \ub97c \ud3ec\ud568    
 * 
 */
TrexConfig.addTool(
	"tableedittool",
	{
		sync: _FALSE,
		status: _TRUE,
		opened: _FALSE
	}
);

/**
 * Trex.Tool.Advanced
 * 
 * @class
 * @extends  Trex.Tool
 */
Trex.Tool.TableEditTool = Trex.Class.create({
	$const: {
		__Identity: 'tableedittool'
	},
	$extend: Trex.Tool,
	/**
	 * instance\uac00 \uc0dd\uc131\ub420 \ub54c \uc2e4\ud589\ub418\uba70 \ud544\uc694\ud55c UI Component \ubc0f Event handler\ub97c \uc0dd\uc131\ud55c\ub2e4.  
	 * 
	 * @memberOf Trex.Tool.Advanced.prototype 
	 * @param {Object} config
	 */
	oninitialized: function(config) {
		var _toolbar = this.toolbar;

		var _elBasic = _toolbar.el;
		var _elAdvanced = $tom.collect(_elBasic.parentNode, 'div.tx-toolbar-advanced');
		if(!_elAdvanced) {
			return;
		}

		_toolbar.observeJob("toolbar.advanced.fold", function() {
			
			$tx.hide(_elAdvanced);
			$tx.removeClassName(_elBasic, 'tx-toolbar-basic-open');
		});

		_toolbar.observeJob("toolbar.advanced.spread", function() {
			
			$tx.show(_elAdvanced);
			$tx.addClassName(_elBasic, 'tx-toolbar-basic-open');
		});

		var _isOpened = _FALSE;
		var _toolHandler = function() {
			if(_isOpened) {
				_toolbar.fireJobs("toolbar.advanced.fold");
			} else {
				_toolbar.fireJobs("toolbar.advanced.spread");
			}
			_isOpened = !_isOpened;
		};

		/* button & menu weave */
		this.weave.bind(this)(
			/* button */
			new Trex.Button(this.buttonCfg),
			/* menu */
			_NULL,
			/* handler */
			_toolHandler
		);

		if(config.opened == _TRUE) { 
			_elAdvanced.show();
			$tx.addClassName(_elBasic, 'tx-toolbar-basic-open');
			_isOpened = _TRUE;
		}
	}
});

/**
 * @fileoverview 
 * Tool '\uc11c\uc2dd' Source,
 *     
 */
TrexConfig.addTool(
	"tabletemplate",
	{
		sync: _FALSE,
		status: _TRUE,
		rows: 5,
		cols: 9,
		options: [
			{ label: 'image', data: 1 , klass: 'tx-tabletemplate-1' },
			{ label: 'image', data: 2 , klass: 'tx-tabletemplate-2' },
			{ label: 'image', data: 3 , klass: 'tx-tabletemplate-3' },
			{ label: 'image', data: 4 , klass: 'tx-tabletemplate-4' },
			{ label: 'image', data: 5 , klass: 'tx-tabletemplate-5' },
			{ label: 'image', data: 6 , klass: 'tx-tabletemplate-6' },
			{ label: 'image', data: 7 , klass: 'tx-tabletemplate-7' },
			{ label: 'image', data: 8 , klass: 'tx-tabletemplate-8' },
			{ label: 'image', data: 9 , klass: 'tx-tabletemplate-9' },
			
			{ label: 'image', data: 10 , klass: 'tx-tabletemplate-10' },
			{ label: 'image', data: 11 , klass: 'tx-tabletemplate-11' },
			{ label: 'image', data: 12 , klass: 'tx-tabletemplate-12' },
			{ label: 'image', data: 13 , klass: 'tx-tabletemplate-13' },
			{ label: 'image', data: 14 , klass: 'tx-tabletemplate-14' },
			{ label: 'image', data: 15 , klass: 'tx-tabletemplate-15' },
			{ label: 'image', data: 16 , klass: 'tx-tabletemplate-16' },
			{ label: 'image', data: 17 , klass: 'tx-tabletemplate-17' },
			{ label: 'image', data: 18 , klass: 'tx-tabletemplate-18' },
			
			{ label: 'image', data: 19 , klass: 'tx-tabletemplate-19' },
			{ label: 'image', data: 20 , klass: 'tx-tabletemplate-20' },
			{ label: 'image', data: 21 , klass: 'tx-tabletemplate-21' },
			{ label: 'image', data: 22 , klass: 'tx-tabletemplate-22' },
			{ label: 'image', data: 23 , klass: 'tx-tabletemplate-23' },
			{ label: 'image', data: 24 , klass: 'tx-tabletemplate-24' },
			{ label: 'image', data: 25 , klass: 'tx-tabletemplate-25' },
			{ label: 'image', data: 26 , klass: 'tx-tabletemplate-26' },
			{ label: 'image', data: 27 , klass: 'tx-tabletemplate-27' },
			
			{ label: 'image', data: 28 , klass: 'tx-tabletemplate-28' },
			{ label: 'image', data: 29 , klass: 'tx-tabletemplate-29' },
			{ label: 'image', data: 30 , klass: 'tx-tabletemplate-30' },
			{ label: 'image', data: 31 , klass: 'tx-tabletemplate-31' },
			{ label: 'image', data: 32 , klass: 'tx-tabletemplate-32' },
			{ label: 'image', data: 33 , klass: 'tx-tabletemplate-33' },
			{ label: 'image', data: 34 , klass: 'tx-tabletemplate-34' },
			{ label: 'image', data: 35 , klass: 'tx-tabletemplate-35' },
			{ label: 'image', data: 36 , klass: 'tx-tabletemplate-36' },
			
			{ label: 'image', data: 37 , klass: 'tx-tabletemplate-37' },
			{ label: 'image', data: 38 , klass: 'tx-tabletemplate-38' },
			{ label: 'image', data: 39 , klass: 'tx-tabletemplate-39' },
			{ label: 'image', data: 40 , klass: 'tx-tabletemplate-40' },
			{ label: 'image', data: 41 , klass: 'tx-tabletemplate-41' },
			{ label: 'image', data: 42 , klass: 'tx-tabletemplate-42' },
			{ label: 'image', data: 43 , klass: 'tx-tabletemplate-43' },
			{ label: 'image', data: 44 , klass: 'tx-tabletemplate-44' },
			{ label: 'image', data: 45 , klass: 'tx-tabletemplate-45' }
			
		]
	}

);

Trex.Tool.Tabletemplate = Trex.Class.create({
	$const: {
		__Identity: 'tabletemplate'
	},
	$extend: Trex.Tool,
	oninitialized: function(config) {
		var _tool = this; 
		var _canvas = this.canvas;
		var _map = {};
		config.options.each(function(option) {
			_map[option.data] = {
				type: option.type
			};
		});

		var _toolHandler = function(data) {
			if(!_map[data]) {
				return;
			}
			
			var _table = _NULL;
			_canvas.execute(function(processor) {
				if (processor.table) {
					_table = processor.findNode('table');
					processor.table.setTemplateStyle(_table, data);
				}
			});
			
			
		};

		/* button & menu weave */
		this.weave.bind(this)(
			/* button */
			new Trex.Button(this.buttonCfg),
			/* menu */
			new Trex.Menu.List(this.menuCfg),
			/* handler */
			_toolHandler
		);
		
	}
	
});


/**
 * @fileoverview
 * table, cell resize
 *
 */


TrexMessage.addMsg({
    '@tableresize.cancel.image': "#iconpath/btn_cancel.gif",
    '@tableresize.confirm.image': "#iconpath/btn_confirm.gif",
    '@tableresize.invalid': "\uc798\ubabb\ub41c \uc785\ub825 \uac12 \uc785\ub2c8\ub2e4.",
    '@tableresize.title': "\uc120\ud0dd\ub41c \ud45c cell \ud06c\uae30\ub97c \uc785\ub825\ud574 \uc8fc\uc138\uc694.",
    '@tableresize.width': "\ub108\ube44",
    '@tableresize.height': "\ub192\uc774"
});

TrexConfig.addTool(
    "tableresize",
    {
        wysiwygonly: _TRUE,
        sync: _FALSE,
        status: _TRUE
    }
);

Trex.Tool.TableResize = Trex.Class.create({
    $const: {
        __Identity: 'tableresize'
    },
    $extend: Trex.Tool,
    oninitialized: function() {
        var canvas = this.canvas;
        var self = this;

        this.button = new Trex.Button(this.buttonCfg);

        var _toolHandler = function(data) {
            canvas.execute(function(processor){
                processor.table.resize(data);
            });
        };



        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            self.button,
            /* menu */
            new Trex.Menu.TableResize(this.menuCfg),
            /* handler */
            _toolHandler
        );
    }
});

Trex.MarkupTemplate.add(
    'menu.tableresize', [
    '<div class="tx-menu-inner">',
    '<p class="desc_cellsize">\uc120\ud0dd\ub41c \ud45ccell \ud06c\uae30\ub97c \uc785\ub825\ud574\uc8fc\uc138\uc694.</p>',
    '<div>',
    '<label for="cellWidth">@tableresize.width</label>',
    '<input type="text" name="cellWidth" id="cellWidth" class="inp_cellw" /> px',
    '</div>',
    '<div>',
    '<label for="cellHeight">@tableresize.height</label>',
    '<input type="text" name="cellHeight" id="cellHeight" class="inp_cellh" /> px',
    '</div>',
    '<div class="wrap_btn">',
    '<img src="@tableresize.confirm.image" class="tx-menu-btn" alt="\ud655\uc778" />',
    '<img src="@tableresize.cancel.image" class="tx-menu-btn" alt="\ucde8\uc18c" />',
    '</div>',
    '</div><!-- //tx-menu-inner -->'
    ].join("\n")
);
Trex.Menu.TableResize = Trex.Class.create({
    $extend: Trex.Menu,
    ongenerated: function() {
        var _elMenu = this.elMenu;
        Trex.MarkupTemplate.get('menu.tableresize').evaluateToDom({}, _elMenu);
        var self = this;
        var _elInput = $tom.collectAll(_elMenu, 'input');
        var _elImgs = $tom.collectAll(_elMenu, 'img');
        $tx.observe(_elImgs[0], "click", function(ev) {
            var _val = self._isValidation(_elInput[0].value)&&self._isValidation(_elInput[1].value);
            if (!_val) {
                alert( TXMSG("@tableresize.invalid") );
                $tx.stop(ev);
                return;
            }
            this.onSelect(ev, {
                width: parseInt(_elInput[0].value),
                height: parseInt(_elInput[1].value)
            });
            $tx.stop(ev);
        }.bind(this));

        $tx.observe(_elImgs[1], "click", function() {
            this.onCancel();
        }.bindAsEventListener(this));

    },
    _isValidation: function(n){
        return  n > 0;
    },
    onregenerated: function() {
        var _elMenu = this.elMenu;
        var p = Editor.getCanvas().getProcessor();
        var td = p.table.getTdArr()[0];
        var _elInput =$tom.collectAll(_elMenu, 'input');
        if(!td){
            _elInput[0].value = '';
            _elInput[1].value = '';
        }else {
            var offset = Trex.TableUtil.getCellOffset(td);
            _elInput[0].value = offset.width;
            _elInput[1].value = offset.height;
        }
    }
});



/**
 * @fileoverview
 * table, cell valign
 *
 */
TrexConfig.addTool(
    "tablevalign",
    {
        wysiwygonly: _TRUE,
        sync: _FALSE,
        status: _TRUE,
        options: [
            { label: '\uc0c1\ub2e8\ub9de\ucda4', data: 'TOP' , klass: 'cell_ico cell_top' },
            { label: '\uc911\uac04\ub9de\ucda4', data: 'MIDDLE' , klass: 'cell_ico cell_mid' },
            { label: '\ud558\ub2e8\ub9de\ucda4', data: 'BOTTOM' , klass: 'cell_ico cell_bot' }
        ]
    }
);

Trex.Tool.TableValign = Trex.Class.create({
    $const: {
        __Identity: 'tablevalign'
    },
    $extend: Trex.Tool,
    oninitialized: function() {
        var canvas = this.canvas;
        var self = this;

        this.button = new Trex.Button(this.buttonCfg);

        var _toolHandler = function(a) {
            canvas.getProcessor().table.execute(function(){
                var tds = canvas.getProcessor().table.getTdArr();
                tds.each(function(el){
                    el.style.verticalAlign = a.toLowerCase();
                });
            });
        };

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            self.button,
            /* menu */
            new Trex.Menu.Tablevalign(this.menuCfg),
            /* handler */
            _toolHandler
        );
    }
});
Trex.MarkupTemplate.add(
    'menu.tablevalign',
    '<ul class="tx-menu-list list_valign" unselectable="on">#{items}</ul>'
);

Trex.Menu.Tablevalign = Trex.Class.create(/** @lends Trex.Menu.Select.prototype */{
    /** @ignore */
    $extend: Trex.Menu,
    /**
     * menu\ub97c \uc0dd\uc131\ud55c\ub2e4.
     * @function
     */
    generate: function() {
        /*
         [{
         label: "string",
         title: "string",
         data: "string",
         klass: "string"
         }]
         */
        var _config = this.config;
        var _optionz = this.getValidOptions(_config);

        var _elList = this.generateList(_optionz);
        $tom.insertFirst(this.elMenu, _elList);

        if (this.generateHandler) {
            this.generateHandler(_config);
        }
        if (this.ongeneratedList) {
            this.generateList = this.ongeneratedList.bind(this);
        }
        if (this.ongeneratedListItem) {
            this.generateListItem = this.ongeneratedListItem.bind(this);
        }
    },

    /**
     * menu \uc758 list markup \uc744 \ub9cc\ub4e4\uace0 event handler \ub97c \uc5f0\uacb0\ud55c\ub2e4.
     * @function
     */
    generateList: function(optionz) {
        var _elGroup = Trex.MarkupTemplate.get("menu.tablevalign").evaluateAsDom({
            'items': this.generateListItem(optionz)
        });

        var _elItemList = $tom.collectAll(_elGroup, "li a");
        for (var i=0; i < optionz.length; i++) {
            var _option = optionz[i];
            var _elItem = _elItemList[i];
            $tx.observe(_elItem, "click", this.onSelect.bindAsEventListener(this, _option.data, _option.title));
        }
        return _elGroup;
    },
    /**
     * menu \uc758 list item markup \uc0dd\uc131\ud55c\ub2e4.
     * @function
     * @return {String} HTML markup
     */
    generateListItem: function(option) {
        var result = [];
        for(var i=0; i < option.length; i++) {
            result.push(Trex.MarkupTemplate.get("menu.select.item").evaluate(option[i]));
        }
        return result.join("");
    },
    /**
     * menu \uc758 list item \uc774 \uc120\ud0dd\ub418\uc5c8\uc744 \ub54c command \ub97c \uc2e4\ud589\ud55c\ub2e4.
     * @function
     */
    onSelect: function() {
        var _args = $A(arguments);
        var _ev = _args.shift();
        this._command.apply(this, _args);
        this.hide();
        $tx.stop(_ev);
    }
});



/**
 * @fileoverview 
 * '\uc904\uac04\uaca9' Icon Source,
 * Class Trex.Tool.LineHeight configuration\uc744 \ud3ec\ud568    
 *     
 */
TrexConfig.addTool(
	"lineheight",
	{
		sync: _FALSE,
		status: _TRUE,
		options: [
			{ label: '50%', title: '50%', data: '0.5' },
			{ label: '80%', title: '80%', data: '0.8' },
			{ label: '100%', title: '100%', data: '1.0' },
			{ label: '120%', title: '120%', data: '1.2' },
			{ label: '150%', title: '150%', data: '1.5' },
			{ label: '180%', title: '180%', data: '1.8' },
			{ label: '200%', title: '200%', data: '2.0' }
		]
	}
);

Trex.Tool.LineHeight = Trex.Class.create({
	$const: {
		__Identity: 'lineheight'
	},
	$extend: Trex.Tool,
	oninitialized: function(config) {
		var _canvas = this.canvas;

		var _defaultProperty = _canvas.getStyleConfig().lineHeight;
		var _optionz = (config.options || []);
		var _map = {};
		_optionz.each(function(option) {
			_map[option.data] = option.title;
		});

		var _toolHandler = function(command) {
			_canvas.execute(function(processor) {
				var _nodes = processor.blocks(function() {
					return '%paragraph';
				});
				processor.apply(_nodes, { 
					'style': {
						'lineHeight': command
					}
				});	
			});
		};
		
		/* button & menu weave */
		this.weave.bind(this)(
			/* button */
			new Trex.Button.Select(TrexConfig.merge(this.buttonCfg, {
				selectedValue: _defaultProperty
			})),
			/* menu */
			new Trex.Menu.Select(this.menuCfg),
			/* handler */
			_toolHandler);
	}
});


/**
 * @fileoverview
 *  \uc5ec\ub7ec Style\uc758 \ub9ac\uc2a4\ud2b8\ub97c \uc0bd\uc785 \ud560 \uc218 \uc788\ub294 Tool 'styledlist' Source,
 * Class Trex.Tool.StyledList \uc640 configuration\uc744 \ud3ec\ud568
 *
 */

TrexMessage.addMsg({
	'@styledlist.subtitle1': '\ucde8\uc18c',
	'@styledlist.subtitle2': '\ub3d9\uadf8\ub77c\ubbf8',
	'@styledlist.subtitle3': '\ub124\ubaa8',
	'@styledlist.subtitle4': '\uc22b\uc790',
	'@styledlist.subtitle5': '\ub85c\ub9c8\uc22b\uc790',
	'@styledlist.subtitle6': '\uc54c\ud30c\ubcb3'
});

TrexConfig.addTool(
	"styledlist",
	{
		status: _TRUE,
		options: [
			{ label: TXMSG('@styledlist.subtitle1'), title: 'cancel', type: 'cancel', data: 'cancel', klass: 'tx-styledlist-0' },
			{ label: TXMSG('@styledlist.subtitle2'), title: 'disc', type: 'ul', data: 'disc', klass: 'tx-styledlist-1' },
			{ label: TXMSG('@styledlist.subtitle3'), title: 'square', type: 'ul', data: 'square', klass: 'tx-styledlist-2' },
			{ label: TXMSG('@styledlist.subtitle4'), title: 'decimal', type: 'ol', data: 'decimal', klass: 'tx-styledlist-3' },
			{ label: TXMSG('@styledlist.subtitle5'), title: 'upper-roman', type: 'ol', data: 'upper-roman', klass: 'tx-styledlist-4' },
			{ label: TXMSG('@styledlist.subtitle6'), title: 'upper-alpha', type: 'ol', data: 'upper-alpha', klass: 'tx-styledlist-5' }
		],
        hotKey: {
            ul: { // ctrl + alt + u
                ctrlKey: _TRUE,
                altKey: _TRUE,
                keyCode: 85
            },
            ol: { // ctrl + alt + o
                ctrlKey: _TRUE,
                altKey: _TRUE,
                keyCode: 79
            }
        }
	}
);

Trex.Tool.StyledList = Trex.Class.create({
	$const: {
		__Identity: 'styledlist'
	},
	$extend: Trex.Tool,
    oninitialized: function(config) {
        var self = this;
        self.createListStyleMap(config);
        self.weave(
			new Trex.Button.StyledList(self.buttonCfg),
			new Trex.Menu.Select(self.menuCfg),
			self.handler,
			self.menuInitHandler.bind(self)
		);
        self.indentHelper = Trex.Tool.Indent.Helper;
        self.bindKeyboard(config.hotKey.ul, self.handler.bind(self, "disc"));
        self.bindKeyboard(config.hotKey.ol, self.handler.bind(self, "decimal"));
        self.startSyncButtonWithStyle();
	},
    createListStyleMap: function(config) {
        var listStyleMap = this.listStyleMap = {};
		config.options.each(function(option) {
			listStyleMap[option.data] = {
				type: option.type,
				klass: option.klass
			};
		});
    },
    handler: function(data) {
        var self = this;
        if (!self.listStyleMap[data]) {
            return;
        }
        var listTag = self.listStyleMap[data].type;
        var listHeadStyle = {listStyleType: data};

        self.canvas.execute(function(processor) {
            if (listTag == 'cancel') {
                self.outdentListItem(processor);
            } else {
                self.createListFromSelection(processor, listTag, listHeadStyle);
            }
        });
    },
    outdentListItem: function(processor) {
        processor.executeUsingCaret(function(range, savedCaret) {
            var blockNodes = Trex.Tool.Indent.Helper.findBlocksToIndentFromRange(range, processor, savedCaret);
            blockNodes.each(function(node) {
                Trex.Tool.Indent.Operation.OutdentListItem(node, processor);

            });
        });
    },
    createListFromSelection: function(processor, listTag, listHeadStyle) {
        var self = this;
        processor.executeUsingCaret(function(range, savedCaret) {
            var blockNodes = self.indentHelper.findBlocksToIndentFromRange(range, processor, savedCaret);
            var listGroups = self.groupEachList(blockNodes);
            listGroups.each(function(nodes) {
                var builder = new Trex.Tool.StyledList.ListBuilder(processor, listTag, listHeadStyle);
                builder.createListForNodes(nodes);
            });
        });
        this._removeBrInListItemForIE(processor);
    },
    _removeBrInListItemForIE: function(processor) {
        // FTDUEDTR-1391
        if ($tx.msie_docmode >= 11) {
            var range = processor.createGoogRange();
            var startNode = range.getStartNode();
            if (range.isCollapsed()
                && $tom.isElement(startNode)
                && $tom.isElement(startNode.firstChild)
                && $tom.isTagName(startNode.firstChild, 'br')) {
                $tom.remove(startNode.firstChild);
                startNode.appendChild(processor.newText(''));
            }
        }
    },
    groupEachList: function(blockNodes) {
        var indentHelper = this.indentHelper;
        var groupsForList = [];
        var currentGroup = [];
        var previousCell = _NULL;
        blockNodes.each(function(node) {
            var currentCell = indentHelper.findCurrentCell(node);
            // new list group detected
            if (currentCell != previousCell) {
                if (currentGroup.length > 0) {
                    groupsForList.push(currentGroup);
                    currentGroup = [];
                }
                previousCell = currentCell;
            }

            currentGroup.push(node);
        });
        // remained group
        if (currentGroup.length > 0) {
            groupsForList.push(currentGroup);
        }
        return groupsForList;
    },
    menuInitHandler: function() {
        var insideList = this.canvas.query(function(processor) {
            return !! processor.findNode('%listhead');
        });
        var elCancel = $tom.collect(this.menu.elMenu, 'li');
        if (insideList) {
            $tx.show(elCancel);
        } else {
            $tx.hide(elCancel);
        }
    },
    startSyncButtonWithStyle: function() {
        var self = this;
        var canvas = self.canvas;
        var cachedProperty = self.getDefaultProperty();

        canvas.observeJob(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, function() {
			var listHeadStyle = canvas.query(function(processor) {
				var node = processor.findNode('%listhead');
				return processor.queryStyle(node, 'listStyleType');
			});
			listHeadStyle = listHeadStyle || self.getDefaultProperty();
			if(cachedProperty == listHeadStyle) {
				return;
			}

			var text = self.getButtonClassByValue(listHeadStyle);
			self.button.setText(text);
			cachedProperty = listHeadStyle;
		});
	},
    getDefaultProperty: function() {
        return "decimal";
    },
    getButtonClassByValue: function(value) {
        var listStyleMap = this.listStyleMap;
        if(listStyleMap[value]) {
            return listStyleMap[value].klass;
        } else {
            return listStyleMap[this.getDefaultProperty()].klass;
        }
    }
});

Trex.Button.StyledList = Trex.Class.create({
	$extend: Trex.Button.Select,
	setText: function(text) {
		this.elIcon.className = "tx-icon " + text;
	}
});

Trex.Tool.StyledList.ListBuilder = Trex.Class.create({
    currentDepth: _NULL,
    prepared: _FALSE,
    listElement: _NULL,
    uselessListCandidate: [],
    processor: _NULL,
    initialize: function(processor, listTag, listHeadStyle) {
        this.processor = processor;
        this.listTag = listTag;
        this.listStyle = listHeadStyle;
    },
    createListForNodes: function(nodes) {
        var self = this;
        var depthList = self.getNodeDepthList(nodes);
        depthList.each(function(object) {
            var node = object.node;
            var depth = object.depth;
            if (!self.prepared) {
                self.prepareRootList(node, depth);
            }
            self.adjustDepth(node, depth);
            self.appendAsListItem(node);
        });
        self.cleanupEmptyList();
    },
    getNodeDepthList: function(list) {
        var self = this;
        return list.map(function(node) {
            return {node: node, depth: self.countDepthOfList(node)};
        });
    },
    countDepthOfList: function (node) {
        var count = 0;
        var parent = $tom.parent(node);
        while (parent && !$tom.isBody(parent)) {
            if ($tom.kindOf(parent, "ol,ul")) {
                count++;
            } else if ($tom.kindOf(parent, "th,td")) {
                break;
            }
            parent = $tom.parent(parent);
        }
        return (count || 1);
    },
    prepareRootList: function(node, depth) {
        var self = this;
        self.listElement = self.createNewList();
        var insertionPoint;
        if (node.tagName == "LI") {
            self.uselessListCandidate.push(node.parentNode);
            insertionPoint = $tom.divideNode(node.parentNode, $tom.indexOf(node));
        } else {
            insertionPoint = node;
        }
        $tom.insertAt(self.listElement, insertionPoint);
        self.currentDepth = depth;
        self.listDepth = depth;
        self.prepared = _TRUE;
    },
    adjustDepth: function(node, depth) {
        var self = this;
        while (depth != self.currentDepth) {
            if (depth > self.currentDepth) {
                self.increaseDepth();
            } else {
                self.decreaseDepth();
            }
        }
    },
    increaseDepth: function() {
        var self = this;
        var listElement = self.listElement;
        
        self.currentDepth++;
        var subList = self.createNewList();
        listElement.appendChild(subList);
        self.listElement = subList;
    },
    decreaseDepth: function() {
        var self = this;
        var listElement = self.listElement;
        
        self.currentDepth--;
        if (self.listDepth > self.currentDepth) {  // \uc0c8\ub85c \ub9cc\ub4e0 listgroup\uc758 depth\uac00 \ubd80\uc871\ud558\uae30 \ub54c\ubb38\uc5d0 \ucd5c\uc0c1\uc704\uc5d0 listgroup\uc744 \ucd94\uac00\ud574\uc11c \ud2b8\ub9ac\ub97c \ud0a4\uc6b4\ub2e4.
            self.uselessListCandidate.push(listElement.parentNode);
            var insertPosition = $tom.divideNode(listElement.parentNode, $tom.indexOf(listElement));
            var newList = self.createNewList();
            $tom.insertAt(newList, insertPosition);
            newList.appendChild(listElement);
        }
        self.listElement = listElement.parentNode;
    },
    createNewList: function() {
        var self = this;
        var newList = self.processor.newNode(self.listTag);
        $tx.setStyle(newList, self.listStyle);
        return newList;
    },
    cleanupEmptyList: function() {
        this.uselessListCandidate.each(function(node) {
            $tom.removeListIfEmpty(node);
        });
    },
    wrapWithListItem: function(node) {
        if (node.tagName == "LI") {
            return node;
        } else if (node.tagName == "P" || ($tx.webkit && node.tagName == "DIV")) {
            // p\uc5d0 \uc2a4\ud0c0\uc77c\uc774 \uc788\uc73c\uba74 marginLeft\ub294 \uc9c0\uc6b0\uace0 li\ub85c \uac10\uc2f8\uae30
            var newListItem = this.createListItem();
            $tom.applyStyles(node, {marginLeft: _NULL});
            if ($tom.getStyleText(node)) {
            	$tom.wrap(newListItem, node);
                return newListItem;
            } else {
                return $tom.replace(node, newListItem);
            }
        } else {
            var li = this.createListItem();
            li.appendChild(node);
            return li;
        }
    },
    createListItem: function() {
        return this.processor.newNode("li");
    },
    appendAsListItem: function(node) {
        var listItem = this.wrapWithListItem(node);
        if ($tom.kindOf(node.parentNode, "%listhead")) {
            this.uselessListCandidate.push(node.parentNode);
        }
        this.listElement.appendChild(listItem);
    }
});
/**
 * @fileoverview 
 * '\ub9c1\ud06c\uc0bd\uc785' Icon Source,
 * Class Trex.Tool.Link\uacfc configuration\uc744 \ud3ec\ud568    
 *     
 */
TrexConfig.addTool(
	"link",
	{
		wysiwygonly: _TRUE,
		sync: _FALSE,
		status: _TRUE
	}
);

TrexMessage.addMsg({
	'@insertlink.cancel.image': "#iconpath/btn_cancel.gif",
	'@insertlink.confirm.image': "#iconpath/btn_confirm.gif",
	'@insertlink.invalid.url': "URL\uc744 \uc785\ub825\ud574\uc8fc\uc138\uc694.",
	'@insertlink.link.alt': "[#{title}]\ub85c \uc774\ub3d9\ud569\ub2c8\ub2e4.",
	'@insertlink.remove.image': "#iconpath/btn_remove.gif",
	'@insertlink.title': "\uc120\ud0dd\ub41c \ubd80\ubd84\uc5d0 \uac78\ub9b4 URL\uc8fc\uc18c\ub97c \ub123\uc5b4\uc8fc\uc138\uc694.",
	'@insertlink.onclick.target': "\ud074\ub9ad \uc2dc",
	'@insertlink.target.blank': "\uc0c8 \ucc3d",
	'@insertlink.target.self': "\ud604\uc7ac\ucc3d",
	'@insertlink.class.name': "tx-link"
});

Trex.Tool.Link = Trex.Class.create({
	$const: {
		__Identity: 'link'
	},
	$extend: Trex.Tool,
	oninitialized: function() {
			var _tool = this; 
			var _canvas = this.canvas;

			var _toolHandler = function(data) {
				if (_canvas.isWYSIWYG()) {
					if (data) {
						_canvas.execute(function(processor) {
							var _attributes = {
								'href': data.link,
								'target': data.target ? data.target : '_blank',
								'className': data.className
							};
                            var _aNode, _nodes;
							if(processor.findNode('a')) {
								_aNode = processor.findNode('a');
								$tom.applyAttributes(_aNode, _attributes);
							} else if (processor.hasControl()) {
								_nodes = processor.controls(function() {
									return 'img';
								});
								$tom.wrap(processor.create('a', _attributes), _nodes);
							} else if(processor.isCollapsed()) {
								_aNode = processor.create('a', _attributes);
								var text = processor.doc.createTextNode(data.link);
								_aNode.appendChild(text);
								processor.pasteNode(_aNode, _FALSE);
							} else {
								_nodes = processor.inlines(function() {
									return '%text,img,a,%inline';
								});
								_nodes.each(function(node) {
									if ($tom.hasUsefulChildren(node, _TRUE)) {
										if ($tom.kindOf(node, 'a')) {
											$tom.applyAttributes(node, _attributes);
										} else if ($tom.kindOf(node, 'img')) {
											$tom.wrap(processor.create('a', _attributes), [node]);
										} else {
											var _styleValue = $tom.getStyleText(node);
											var _oldNodes = $tom.collectAll(node, 'a');
											_oldNodes.each(function(oldNode){
												$tom.moveChildToParent(oldNode);
												$tom.remove(oldNode);
											});
											var _aNode = processor.create('a', _attributes);
											$tom.setStyleText(_aNode, _styleValue);
											$tom.replace(node, _aNode);
										}	
									} else {
										$tom.remove(node);
									}
								});
							}
						});
					} else {
						_canvas.execute(function(processor) {
							var _node = processor.findNode('a');
							if (_node) {
								processor.unwrap(_node);
							}
						});
					}
				}else{
					_canvas.execute(function(processor) {
						processor.insertTag('<a href="' + data.link + '" target="' +data.target+ '" >','</a>');
					});	
				}	
			};
			
			var __DefaultValue = "";
			var _initHandler = function() {
				if (_canvas.isWYSIWYG()) {
					return _canvas.query(function(processor){
						var node, value, target, text;
						node = processor.findNode('a');
						if (node) {
							value = $tom.getAttribute(node, "href");
							if (value) {
								target = $tom.getAttribute(node, "target");
								return {
									exist: _TRUE,
									value: value,
									target: target
								};
							}
						} else {
							text = processor.getText();
							if (/^\w+\:\/\/\S+/.test(text)) { // only for url with protocol. 
								return {
									exist: _FALSE,
									value: text
								}
							}
						}
						return {
							exist: _FALSE,
							value: __DefaultValue
						};
					});
				}else{
					return {
						exist: _FALSE,
						value: __DefaultValue
					};
				}
			};

			/* button & menu weave */
			this.weave.bind(this)(
				/* button */
				new Trex.Button(this.buttonCfg),
				/* menu */
				new Trex.Menu.Link(this.menuCfg),
				/* handler */
				_toolHandler,
				/* handler for menu initial value */
				_initHandler
			);

			var _popdownHandler = function(ev) {
				_tool.button.onMouseDown(ev);
			};
			this.bindKeyboard({ // ctrl + k - \ub9c1\ud06c
				ctrlKey: _TRUE,
				keyCode: 75
			}, _popdownHandler);
		}
	
});

/* Trex.Menu.Link ************************************************************************************/
Trex.MarkupTemplate.add(
	'menu.insertlink', [
		'<div class="tx-menu-inner">',
		'    <dl>',
		'        <dt>',
		'            @insertlink.title',
		'        </dt>',
		'        <dd>',
		'            <input type="text" class="tx-text-input"/>',
		'        </dd>',
		'        <dd class="tx-rp">',
		'            <span class="tx-text tx-first">@insertlink.onclick.target</span>',
		'            <span><input type="radio" name="tx-insertlink-win" value="_blank"/><span class="tx-text">@insertlink.target.blank</span></span>',
		'            <span><input type="radio" name="tx-insertlink-win" value="_top"/><span class="tx-text">@insertlink.target.self</span></span>',
		'        </dd>',
		'        <dd class="tx-hr">',
		'            <hr/>',
		'        </dd>',
		'        <dd>',
		'            <img width="32" height="21" src="@insertlink.confirm.image"/>',
		'            <img width="32" height="21" src="@insertlink.cancel.image"/>',
		'            <img width="51" height="21" src="@insertlink.remove.image" style="display: none;"/>',
		'        </dd>',
		'    </dl>',
		'</div>'
	].join("")
);
Trex.Menu.Link = Trex.Class.create({
	$extend: Trex.Menu,
	ongenerated: function() {
		var _elMenu = this.elMenu;
		Trex.MarkupTemplate.get('menu.insertlink').evaluateToDom({}, _elMenu);

		var _elTargets = $tom.collectAll(_elMenu, ".tx-rp input");
		var _newInput = this.newInput = _elTargets[0];
		$tx.observe(_newInput, "click", function(){
				_newInput.checked = "checked";
				_currInput.checked = "";
		});
		var _currInput = this.currInput = _elTargets[1];
		$tx.observe(_currInput, "click", function(){
				_currInput.checked = "checked";
				_newInput.checked = "";
		});

		var _checkValidation = this.urlValidator;
		var _elInput = this.elInput = $tom.collect(_elMenu, 'input.tx-text-input');
		$tx.observe(_elInput, "keydown", function(ev) {
			if(ev.keyCode == 13) { //Enter
				var _val = _checkValidation(_elInput.value);
				if (!_val) {
					alert( TXMSG("@insertlink.invalid.url") );
					$tx.stop(ev);
					return;
				}
				var _target = _newInput.checked ? _newInput.value : _currInput.value;
				this.onSelect(ev, {
					link: _val,
					target: _target,
					className: TXMSG("@insertlink.class.name")
				});
				$tx.stop(ev);
			}
		}.bindAsEventListener(this));

		var _elImgs = $tom.collectAll(_elMenu, 'img');
		$tx.observe(_elImgs[0], "click", function(ev) {
			var _val = _checkValidation(_elInput.value);
			if (!_val) {
				alert( TXMSG("@insertlink.invalid.url") );
				$tx.stop(ev);
				return;
			}
			var _target = _newInput.checked ? _newInput.value : _currInput.value;
			this.onSelect(ev, {
					link: _val,
					target: _target,
					className: TXMSG("@insertlink.class.name")
				});
			$tx.stop(ev);
		}.bind(this));

		$tx.observe(_elImgs[1], "click", function() {
			this.onCancel();
		}.bindAsEventListener(this));

		var _elRemoveBtn = $tx(_elImgs[2]);
		$tx.observe(_elRemoveBtn, "click", function(ev) {
			this.onSelect(ev, _NULL);
		}.bindAsEventListener(this));
		this.toggleRemoveBtn = function(exist) {
			_elRemoveBtn.style.display = ((exist)? '': 'none');
		};
	},
	onregenerated: function() {
		var _elInput = this.elInput;
		var _initData = this.initHandler();
		_elInput.value = _initData.value;
		if(_initData.target == "_self" || _initData.target == "_top"){
			this.currInput.checked = "checked";
			this.newInput.checked = "";
		}else{
			this.newInput.checked = "checked";
			this.currInput.checked = "";
		}

		this.toggleRemoveBtn(_initData.exist);
		_elInput.focus();

		// Set focus to end of input box. ( For IE );
		if ($tx.msie_nonstd) {
			setTimeout(function() {
				try {
					_elInput.focus();
					var _sel = _DOC.selection.createRange();
					_sel.move("character", _elInput.value.length);
					_sel.select();
				}
				catch (ignore) {}
			}, 100);
		}
	},
    urlValidator: function(value) {
        if (!value) {
            return _FALSE;
        }
        value = value.trim();
        if (value.length == 0) {
            return _FALSE;
        }
        var pattern = /^[a-z0-9+.-]+:|^\/\//i;// FTDUEDTR-1330 && MAILCS-24754
        if ( pattern.test(value) ) {
            return value;
        } else {
            return "http://" + value;
        }
    }
});


/**
 * @fileoverview 
 * \uc9c1\uc811 \ud3b8\uc9d1\uc774 \uac00\ub2a5\ud55c \uae30\ub2a5\uc744 \ud3ec\ud568\ud55c Tool '\uae00\uc0c1\uc790' Source,
 * Class Trex.Tool.RichTextBox \uc640 configuration\uc744 \ud3ec\ud568    
 *     
 */
TrexConfig.addTool(
	"richtextbox",
	{
		sync: _FALSE,
		status: _TRUE,
		rows: 4,
		cols: 6,
		borderwidth: 1,
		bordercolor: '#cbcbcb',
		bgcolor: '#ffffff',
		padding: "10px",
		styles: [ 
			{	klass: "", image: "#iconpath/textbox/thum_line01.gif", data: "solid" },
			{	klass: "", image: "#iconpath/textbox/thum_line02.gif", data: "double" },
			{	klass: "", image: "#iconpath/textbox/thum_line03.gif", data: "dashed" },
			{	klass: "", image: "#iconpath/textbox/thum_line04.gif", data: "none" }
		],
		options: Trex.__CONFIG_COMMON.textbox.options,
		thumbs: Trex.__CONFIG_COMMON.thumbs
	}
);

TrexMessage.addMsg({
	'@richtextbox.add': "\ub354\ud558\uae30",
	'@richtextbox.sub': "\ube7c\uae30",
	'@richtextbox.alert': "1 \uc774\uc0c1 20 \uc774\ud558\uc758 \uc22b\uc790\ub9cc \uc785\ub825 \uac00\ub2a5\ud569\ub2c8\ub2e4.",
	'@richtextbox.bg.color': "\ubc30\uacbd\uc0c9",
	'@richtextbox.border.color': "\uc120 \uc0c9",
	'@richtextbox.border.style': "\uc120 \uc2a4\ud0c0\uc77c",
	'@richtextbox.border.width': "\uc120 \uad75\uae30"
});

Trex.Tool.RichTextBox = Trex.Class.create({
	$const: {
		__Identity: 'richtextbox'
	},
	$extend: Trex.Tool,
	oninitialized: function() {
		var _canvas = this.canvas;
		var _toolbar = this.toolbar;
		var _tool = this;
		
		var _toolHandler = this.handler = function() {
			var _this = _tool.menu; 
			var _style = {
				"borderStyle": _this.elPreview.style.borderStyle,
				"borderWidth": _this.elPreview.style.borderWidth,
				"borderColor": _this.elPreview.style.borderColor,
				"backgroundColor": _this.elPreview.style.backgroundColor,
				"padding": _this.padding
			};
			var _tag = "div";
			var _attributes = { "className": 'txc-textbox', style: _style };
			_canvas.execute(function(processor) {
				var _nodes = processor.blocks(function() {
				return '%wrapper,%paragraph';
			});
			var _bNode;
			_nodes = _nodes.findAll(function(node) {
			if($tom.kindOf(node, "%innergroup")) {
				_bNode = processor.wrap($tom.children(node), _tag, _attributes);
				_toolbar.fireJobs('cmd.textbox.added', _bNode);
				return _FALSE;
			} else {
				return _TRUE;
			}
                });
                _bNode = processor.wrap(_nodes, _tag, _attributes);
                _toolbar.fireJobs('cmd.textbox.added', _bNode);
            });
		};
		
		/* button & menu weave */
		this.weave.bind(this)(
			/* button */
			new Trex.Button(this.buttonCfg),
			/* menu */
			new Trex.Menu.RichTextbox(this.menuCfg),
			/* handler */
			_toolHandler
		);
	}
});
Trex.MarkupTemplate.add(
		'richtextbox.colorpallete',
		['<dd class="#{wrapClass}">',
		'	<div class="tx-color-box">',
		'		<a href="javascript:;" class="tx-color-bg-thumb" style="background-color:#{color}"></a>', //==> _elThumb
		'	</div>',
		'	<a href="javascript:;" class="tx-color-arrow-down"></a>',
		'	<div class="tx-colorpallete" unselectable="on" style="display:none;z-index:15000;"></div>',
		'</dd>'].join("")
	);
Trex.Menu.RichTextbox = Trex.Class.create({
	$extend: Trex.Menu,
	ongenerated: function(config) {
		var _this = this;
		var _styleHashMap = {};
		config.options.each(function(option) {
			_styleHashMap[option.data] = option.style;
		});
		
		this.borderWidth = config.borderWidth || 1;
		this.borderColor = config.borderColor || '#cbcbcb';
		this.bgColor = config.bgColor || '#ffffff';
		this.padding = config.padding;
		
		var _generateBorderStyle = this.generateBorderStyle.bind(this);
		var _generateBorderWidth = this.generateBorderWidth.bind(this);
		var _generateBorderColor = this.generateBorderColor.bind(this);
		var _generateBgColor = this.generateBgColor.bind(this);
		
		var _elMenu = this.elMenu;
		var _elHeader = $tom.collect(_elMenu, 'div.tx-menu-header');
		var _elPreviewArea = $tom.collect(_elHeader, 'div.tx-menu-preview-area');
        this.elPreview = $tom.collect(_elPreviewArea, 'div.tx-menu-preview');
        var _elSwitch = this.elSwitch = $tom.collect(_elHeader, 'div.tx-menu-switch');
		var _elSimple = $tom.collect(_elSwitch, 'div.tx-menu-simple');
		var _elAdvanced = $tom.collect(_elSwitch, 'div.tx-menu-advanced');
		var _elInner = $tom.collect(_elMenu, 'div.tx-menu-inner');
		var _elFooter = $tom.collect(_elMenu, 'div.tx-menu-footer');
		var _elConfirm = $tom.collect(_elFooter, 'img.tx-menu-confirm');
		var _elCancel = $tom.collect(_elFooter, 'img.tx-menu-cancel');
		
		(function create_thumbs_for_simplemode(){
			var _el = _this.simplePalette= tx.div({ className: 'tx-menu-list'});
			_elInner.appendChild(_el);
			var _rows = config.rows;
			var _cols = config.cols;
			_el.innerHTML = Trex.HtmlCreator.createTableMarkup(_rows, _cols, config.options);
			
			$tx.observe(_el, 'click', function(ev){
				var _el = $tx.element(ev);
				TrexEvent.fire(_el, {
					'span': function(){
						var _class;
						if(_el.firstChild && _el.firstChild.nodeType == 1 && _el.firstChild.tagName.toLowerCase() == 'img') {
							_class = _el.firstChild.title;
						} else {
							_class = _el.innerText;	
						}
						var _style = _styleHashMap[_class];
						applyPreviewStyle(_style);
					}
				});	
				$tx.stop(ev);
			});
		})();
		
		(function createElementsInInnerContainerForAdvancedMode(){
			var _el = _this.advancedPalette = tx.div({ className: "tx-advanced-list" });
			_elInner.appendChild(_el);
			_el.appendChild(
				tx.dl({
					style: {
						"height": "24px"
					}
				}, 
				tx.dt(TXMSG("@richtextbox.border.style")), _generateBorderStyle()));
			_el.appendChild(tx.dl(tx.dt(TXMSG("@richtextbox.border.width")), _generateBorderWidth()));
			_el.appendChild(tx.dl(tx.dt(TXMSG("@richtextbox.border.color")), _generateBorderColor()));
			_el.appendChild(tx.dl(tx.dt(TXMSG("@richtextbox.bg.color")), _generateBgColor()));
		})();
		
		var copyStyles = function(){
			_this.borderWidthInput.value = parseInt(_this.elPreview.style.borderWidth);
			_this.borderColorInput.style.backgroundColor = _this.elPreview.style.borderTopColor;
			_this.bgColorInput.style.backgroundColor = _this.elPreview.style.backgroundColor;
		};
		
		var applyPreviewStyle = function (style){
			_this.elPreview.style.border = style['border'];
			_this.elPreview.style.backgroundColor = style['backgroundColor']
		};
		
		var selectMode = function(mode){
			if(mode =="simple"){
				$tx.addClassName(_elSimple, "tx-selected");
				$tx.show(_this.simplePalette);
				$tx.removeClassName(_elAdvanced, "tx-selected");
				$tx.hide(_this.advancedPalette);
			}else if(mode =="advanced"){
				$tx.removeClassName(_elSimple, "tx-selected");
				$tx.hide(_this.simplePalette);
				$tx.addClassName(_elAdvanced, "tx-selected");
				$tx.show(_this.advancedPalette);
				copyStyles();
			}
			_this.fireJobs(Trex.Ev.__MENU_LAYER_CHANGE_SIZE, {
				detail: {
					menu: _this
				}
			});
		};
		
		(function bindingEvents(){
			$tx.observe(_elSimple, 'click', selectMode.bind(_this, "simple") );
			$tx.observe(_elAdvanced, 'click', selectMode.bind(_this, "advanced") );
			$tx.observe(_elConfirm, 'click', _this.onSelect.bind(_this));
			$tx.observe(_elCancel, 'click', function(){
				_this.onCancel();
			});
		})();
		
		selectMode("simple");
		applyPreviewStyle(_styleHashMap['txc-textbox13']);
	},
	generateBorderStyle: function(){
		var _this = this;
		var _elWrap = tx.dd({ className: 'tx-border-area' });
		$tx.observe(_elWrap, 'click', function(ev) {
			var _el = $tx.element(ev);
			TrexEvent.fire(_el, {
				'img': function(element){
					var _data = element.getAttribute("data");
					_this.elPreview.style.borderStyle = _data;
					if(_data == 'double' && _this.borderWidthInput.value.toNumber() < 3){
						_this.elPreview.style.borderWidth = "3px";
						_this.borderWidthInput.value = "3";
					} 
				}
			});
			$tx.stop(ev);
		});
		_elWrap.innerHTML = Trex.HtmlCreator.createTableMarkup(1, 4, this.config.styles);
		return _elWrap;
	},
	generateBorderWidth: function() {
		var _this = this;
		var _elWrap = tx.dd({ className: 'tx-border-area' });
		var _elInput = this.borderWidthInput = tx.input({ type: 'text', value: this.borderWidth });
		_elWrap.appendChild(_elInput);

		var _drawDeco = function(width) {
			if(width > 20 ) {
				alert(TXMSG("@richtextbox.alert"));
				_elInput.value = 20;
			}else if(width < 1){
				alert(TXMSG("@richtextbox.alert"));
				_elInput.value = 1;
			}else{
				_this.elPreview.style.borderWidth = width + "px";
				_elInput.value = width;	
			}
		};

		$tx.observe(_elInput, 'blur', function(ev) {
			_drawDeco(_elInput.value.toNumber(), ev);
		});
		$tx.observe( _elInput, "keydown", function(ev){
			if( ev.keyCode == $tx.KEY_RETURN )
				$tx.stop(ev);
		});
		var _elAddBtn = tx.a({ href:'javascript:;', className: 'btn_add' }, TXMSG("@richtextbox.add"));
		_elWrap.appendChild(_elAddBtn);
		$tx.observe(_elAddBtn, 'click', function(ev) {
			_drawDeco(_elInput.value.toNumber() + 1);
			$tx.stop(ev);
		});

		var _elSubBtn = tx.a({ href:'javascript:;', className: 'btn_sub' }, TXMSG("@richtextbox.sub"));
		_elWrap.appendChild(_elSubBtn);
		$tx.observe(_elSubBtn, 'click', function(ev) {
			_drawDeco(_elInput.value.toNumber() - 1);
			$tx.stop(ev);
		});
		
		return _elWrap;
	},
	generateBorderColor: function() {
		var _this = this;
		var _elWrap = Trex.MarkupTemplate.get("richtextbox.colorpallete").evaluateAsDom({"color": this.borderColor, "wrapClass": "tx-color-wrap"});
		var _elPallete = $tom.collect(_elWrap, "div.tx-colorpallete");
		
		var _changeBorderColor = function(color) {
			_this.elPreview.style.borderColor = _elThumb.style.backgroundColor = _this.borderColor = color;
		};
		
		var _colorPallete = _NULL;
		var _toggleColorPallete = function() {
			if (_colorPallete == _NULL) {
				_colorPallete = _this.createColorPallete(_elPallete, _changeBorderColor);
				_colorPallete.show();
			} else {
				if (!$tx.visible(_elPallete)) _colorPallete.show();
				else _colorPallete.hide();
			}
		};
		
		this.externalBorderColorToggler = function(){
			if ($tx.visible(_elPallete)) {
				_colorPallete.hide();
			}
		};
		
		var _elThumb = this.borderColorInput = $tom.collect(_elWrap, ".tx-color-box a");
		$tx.observe(_elThumb, 'click', function(ev) {
			_this.externalBgColorToggler();
			_toggleColorPallete();
			$tx.stop(ev);
		});

		var _elArrow = $tom.collect(_elWrap, "a.tx-color-arrow-down");
		$tx.observe(_elArrow, 'click', function(ev) {
			_this.externalBgColorToggler();
			_toggleColorPallete();
			$tx.stop(ev);
		});

		return _elWrap;
	},
	createColorPallete: function(element, cmd) {
        var self = this;
		var pallete = new Trex.Menu.ColorPallete({el: element, thumbs: this.config.thumbs});
		pallete.setCommand(cmd);
        pallete.observeJob(Trex.Ev.__MENU_LAYER_SHOW, function(ev){
            self.fireJobs(Trex.Ev.__MENU_LAYER_SHOW, ev);
        });
        pallete.observeJob(Trex.Ev.__MENU_LAYER_HIDE, function(ev){
            self.fireJobs(Trex.Ev.__MENU_LAYER_HIDE, ev);
        });
        pallete.observeJob(Trex.Ev.__MENU_LAYER_CHANGE_SIZE, function(ev){
            self.fireJobs(Trex.Ev.__MENU_LAYER_CHANGE_SIZE, ev);
        });
		return pallete;
	},
	generateBgColor: function() {
		var _this = this;
		var _elWrap = Trex.MarkupTemplate.get("richtextbox.colorpallete").evaluateAsDom({"color":this.bgColor});
		var _elPallete = $tom.collect(_elWrap, "div.tx-colorpallete");
		
		var _changeBgColor = function(color) {
			_this.elPreview.style.backgroundColor = _elThumb.style.backgroundColor = _this.bgColor = color;
		};
		
		var _colorPallete = _NULL;
		var _toggleColorPallete = function() {
			if (_colorPallete == _NULL) {
				_colorPallete = _this.createColorPallete(_elPallete, _changeBgColor);
				_colorPallete.show();
			} else {
				if (!$tx.visible(_elPallete)) _colorPallete.show();
				else _colorPallete.hide();
			}
		};
		
		this.externalBgColorToggler = function(){
			if ($tx.visible(_elPallete)) {
				_colorPallete.hide();
			}
		};
		
		var _elThumb = this.bgColorInput = $tom.collect(_elWrap, ".tx-color-box a");			
		$tx.observe(_elThumb, 'click', function(ev) {
			_this.externalBorderColorToggler();
			_toggleColorPallete();
			$tx.stop(ev);
		});
		
		var _elArrow = $tom.collect(_elWrap, "a.tx-color-arrow-down");
		$tx.observe(_elArrow, 'click', function(ev) {
			_this.externalBorderColorToggler();
			_toggleColorPallete();
			$tx.stop(ev);
		});

		return _elWrap;
	}
});
/**
 * @fileoverview 
 * Tool '\uc778\uc6a9\uad6c' Source,
 * Class Trex.Tool.Quote \uc640 configuration\uc744 \ud3ec\ud568    
 *     
 */
TrexConfig.addTool(
	"quote",
	{
		sync: _FALSE,
		status: _TRUE,
		rows: 2,
		cols: 3,
		options: [
			{ type: 'image', data: 'tx-quote1', image: '#iconpath/quote/citation01.gif' },
			{ type: 'image', data: 'tx-quote2', image: '#iconpath/quote/citation02.gif' },
			{ type: 'image', data: 'tx-quote3', image: '#iconpath/quote/citation03.gif' },
			{ type: 'image', data: 'tx-quote4', image: '#iconpath/quote/citation04.gif' },
			{ type: 'image', data: 'tx-quote5', image: '#iconpath/quote/citation05.gif' },
			{ type: 'cancel', data: 'tx-quote6', image: '#iconpath/quote/citation06.gif' }
		]
	},
	function(root){
		var _config = TrexConfig.getTool("quote", root);
		_config.options.each(function(option) {
			option.image = TrexConfig.getIconPath(option.image, 'quote'); 
		});
	}
);

Trex.Tool.Quote = Trex.Class.create({
	$const: {
		__Identity: 'quote'
	},
	$extend: Trex.Tool,
	oninitialized: function(config) {
			var _tool = this; 
			var _canvas = this.canvas;

			var _map = {};
			config.options.each(function(option) {
				_map[option.data] = {
					type: option.type
				};
			});

			var _toolHandler = function(data) {
				if(!_map[data]) {
					return;
				}
				var _type = _map[data].type;
				var _tag = "blockquote";
				var _attributes = { "className": data };

				if(_canvas.isWYSIWYG()) {
					_canvas.execute(function(processor) {
						var _bNode = processor.findNode(_tag);
						if (_bNode) {
							if(_type == "cancel") {
								processor.unwrap(_bNode);
							} else {
								processor.apply(_bNode, _attributes);
							}
						} else {
							if(_type != "cancel") {
								var _nodes = processor.blocks(function() {
									return '%wrapper,%paragraph';
								});
								_nodes = _nodes.findAll(function(node) {
									if($tom.kindOf(node, "%innergroup")) {
										processor.wrap($tom.children(node), _tag, _attributes);	
										return _FALSE;
									} else {
										return _TRUE;
									}
								});
								processor.wrap(_nodes, _tag, _attributes);	
							}
						}	
					});
				} else {
					_canvas.execute(function(processor) {
						processor.insertTag('<blockquote>','</blockquote>');
					});
				}
			};

			/* button & menu weave */
			this.weave.bind(this)(
				/* button */
				new Trex.Button(this.buttonCfg),
				/* menu */
				new Trex.Menu.List(this.menuCfg),
				/* handler */
				_toolHandler
			);

			var _popdownHandler = function(ev) {
				_tool.button.onMouseDown(ev);
			};
			this.bindKeyboard({ // ctrl + q
				ctrlKey: _TRUE,
				keyCode: 81
			}, _popdownHandler);
		}
	
});


/**
 * @fileoverview
 *  Table\uc744 \uc0bd\uc785\ud558\ub294 \uae30\ub2a5\uc744 \uac00\uc9c4 Tool 'table' Source,
 *  Class Trex.Tool.Table,Trex.Menu.Table,Trex.Menu.Table.TableEdit\uc640 configuration \uc744 \ud3ec\ud568 \ud558\uace0\uc788\ub2e4.
 */

TrexConfig.addTool(
	"table",
	{
		borderStyle: "1px solid #ccc",
		sync: _FALSE,
		status: _TRUE,
        cellSelect:{
            hotKeyUse:_TRUE,
            hotKey:{
                shiftKey: _TRUE,
                altKey: _TRUE,
                keyCode:39
            }
        }
	},
	function(root){
		var bgc = TrexConfig.get("canvas",root).styles.backgroundColor;
		if (bgc != "transparent") {
			TrexConfig.getTool("table",root).bgcolor = bgc;
		}
	}
);

TrexMessage.addMsg({
	'@table.alert': "1 \uc774\uc0c1 99 \uc774\ud558\uc758 \uc22b\uc790\ub9cc \uc785\ub825 \uac00\ub2a5\ud569\ub2c8\ub2e4."
});

Trex.Tool.Table = Trex.Class.create({
	$const: {
		__Identity: 'table',
		__DEFAULT_TABLE_PROPERTY:{
			"cellSpacing": 0,
			"cellPadding": 1,
			"border": 0,
			"style": {
				border: "none",
				borderCollapse:"collapse"
			}
		},
		__DEFAULT_TABLE_PROPERTY_STR: "cellspacing=\"0\" cellpadding=\"0\" border=\"0\"",
		__DEFAULT_TABLE_STYLE: "border:none;border-collapse:collapse;",
		__DEFAULT_TABLE_CLASS: "txc-table",
		__DEFAULT_TABLE_CELL_HEIGHT: 24
	},
	$extend: Trex.Tool,
	oninitialized: function(config) {
		var _self = this;
		this.tableSize = { row: 0, col:0 };

		var _canvas = this.canvas;

		var _toolHandler = this.handler = function(data) {
			_canvas.execute(function(processor) {
                // get table width
                var tableWidth = '100%';
                processor.executeUsingCaret(function(range, savedCaret){
                    var endCaret = savedCaret.getCaret(_FALSE);
                    if (!$tom.ancestor(endCaret, 'table')) {
                        tableWidth = _self.getDefaultTableWidth();
                    }
                });

                // insert empty table
                var table = _self.makeEmptyTable(data.row, data.col, tableWidth);
                var _tNode = processor.pasteContent(table, _TRUE);
                processor.bookmarkInto(_tNode);

                // open advanced toolbar
				if (_self.toolbar.tools.advanced) {
					_self.toolbar.tools.advanced.forceOpen();
				}
			});
		};

		/* button & menu weave */
		this.weave.bind(this)(
			/* button */
			new Trex.Button(this.buttonCfg),
			/* menu */
			new Trex.Menu.Table(this.menuCfg),
			/* handler */
			_toolHandler
		);
	},
	makeEmptyTable: function(row, col, tableWidth){
		var tableStringArr = [];

        tableStringArr.push("<table class=\""+Trex.Tool.Table.__DEFAULT_TABLE_CLASS+"\"");
        tableWidth && tableStringArr.push(' width="' + tableWidth + '"');
		tableStringArr.push(Trex.Tool.Table.__DEFAULT_TABLE_PROPERTY_STR);
		tableStringArr.push(" style=\"");
		tableStringArr.push(Trex.Tool.Table.__DEFAULT_TABLE_STYLE);
		tableStringArr.push(";font-family:");
		tableStringArr.push( this.editor.canvas.getStyle("fontFamily") );
		tableStringArr.push(";font-size:");
		tableStringArr.push( this.editor.canvas.getStyle("fontSize") );
		tableStringArr.push("\"><tbody>");

		var borderStyleText = this.config.borderStyle;
		var tdWidth = this.getDefaultCellWidth(col, tableWidth),
		tdHeight = this.getDefaultCellHeight(row);
		var basicBorder = ["border-bottom:",borderStyleText,";border-right:",borderStyleText,";"].join("");

		for( var i = 0; i < row; i++ ){
			tableStringArr.push("<tr>");
			for( var j = 0; j < col; j++ ){
				var border = [basicBorder];
				tableStringArr.push("<td style=\"width:");
				tableStringArr.push(tdWidth);
				tableStringArr.push(";");
				tableStringArr.push("height:",tdHeight,";");
				tableStringArr.push(basicBorder);
				if ( i == 0 ){
					tableStringArr.push("border-top:",borderStyleText,";");
				}
				if ( j == 0 ){
					tableStringArr.push("border-left:",borderStyleText,";");
				}
				tableStringArr.push(";\"><p>" + $tom.EMPTY_BOGUS + "</p></td>");
			}
			tableStringArr.push("</tr>")
		}
		tableStringArr.push("</tbody></table>");
		return tableStringArr.join("");
	},
    getDefaultCellWidth: function(columnCount, tableWidth) {
        var width;
        tableWidth = tableWidth || '100%';
        if (tableWidth.toString().indexOf('%') !== -1) {
            width = (100 / columnCount) + '%';
        } else {
            width = parseInt(parseInt(tableWidth,10)/columnCount, 10);
            if (isNaN(width)) {
                width = 0;
            }
            width = width.toPx();
        }
        return width;
    },
    getDefaultCellHeight: function(rowCount) {
        return Trex.Tool.Table.__DEFAULT_TABLE_CELL_HEIGHT.toPx();
    },
	getDefaultTableWidth: function(){ //NOTE: #FTDUEDTR-905
		var tableWidth = this.config.tableWidth;
		if (!tableWidth) {
            tableWidth = this.getCanvasInnerWidth();
		}
		return tableWidth;
	},
    getCanvasInnerWidth: function() {
        var padding = this.canvas.getSizeConfig().contentPadding || 8;
        return (this.canvas.getSizeConfig().contentWidth || 600) - padding * 2 - 20;
    }
});


Trex.Tool.Table.TemplateWizard = Trex.Class.create({
	initialize: function(){
		this.templateList = (typeof getTableTemplateList == "function")? getTableTemplateList() : [{
			klass: "ex1",
			common: {
			backgroundColor:"transparent",
			borderTop:"none",
			borderLeft:"none",
			borderRight: "1px solid #d9d9d9",
			borderBottom: "1px solid #d9d9d9"
		},
		firstRow: {
			borderTop: "1px solid #000"
		},
		firstCol: {
			borderLeft: "1px solid #000"
		},
		lastCol: {
			borderRight: "1px solid #000"
		},
		lastRow: {
			borderBottom: "1px solid #000"
		},
		evenRow: {},
		oddRow: {}
		}];
		this.currentTemplate = _NULL;
	},
	applyStyle: function(table, templateIndex){
		if ( isNaN( templateIndex ) ){
			return ;
		}

		var tableMatrixer = new Trex.Tool.Table.TableCellMatrixer(table);
		var tdMatrix = tableMatrixer.getTdMatrix();

		this.currentTemplate = this.templateList[templateIndex];
		for( var i = 0; i < tdMatrix.length; i++){
			for( var j = 0; j < tdMatrix[i].length; j++){
				this.setCellStyle(tdMatrix[i][j], {
					isEvenRow: (i % 2) == 1,
					isFirstRow: i == 0,
					isLastRow: i == tdMatrix.length - 1,
					isFirstCol: j == 0,
					isLastCol: (j == tdMatrix[i].length - 1)
				});
			}
		}
	},
	setCellStyle: function(elTd, truthMap){
		var t = this.currentTemplate;
		var style = Object.extend({}, t['common']);
		Object.extend(style, (truthMap.isEvenRow)?t['evenRow'] : t['oddRow']);
		Object.extend(style, (truthMap.isFirstRow)?t['firstRow'] : (truthMap.isLastRow)?t['lastRow'] : {});
		Object.extend(style, (truthMap.isLastCol)?t['lastCol'] : {});
		Object.extend(style, (truthMap.isFirstCol)?t['firstCol'] : {});
		txlib.setStyle(elTd, style);
	},
	getTemplateList: function(){
		return this.templateList;
	}
});
Trex.Tool.Table.TableCellMatrixer = Trex.Class.create({
	initialize: function(table){
		this.rowSize = this.initRowSize(table);
		this.colSize = this.initColSize(table);
		var context = $tom.first(table,"tbody") || table;
		this.tdMatrix = this.createTdMatrix(context);
		//this.table = table;

		for (var i = 0; i < this.tdMatrix.length; i++) {
			for (var j = 0; j < this.tdMatrix[i].length; j++) {
				var td = this.tdMatrix[i][j];
				if (td.cols > 1) {
					td.cols--;
					this.tdMatrix[i].splice(j+1, 0, td);
				}
			}
		}
		for( var i = 0; i< this.tdMatrix.length; i++ ){
			for( var j = 0; j < this.tdMatrix[i].length; j++ ){
				var td = this.tdMatrix[i][j];
				if ( td.rows > 1 ){
					td.rows--;
					this.tdMatrix[i + 1].splice(j, 0, td);
				}
			}
		}
	},

	createTdMatrix: function(tbody){
		var tdMatrix = [];

		var trArr = $tom.children(tbody, "tr");
		for( var i = 0, len = trArr.length; i < len; i++ ){
			tdMatrix.push(this.createTdArray(trArr[i]));
		}

		return tdMatrix;
	},
	createTdArray: function(tr){
		var tdArr = [];

		var tds = $tom.children(tr, "td");
		for( var i = 0, len = tds.length; i < len; i++ ){
			tdArr.push( this.decorateSingleTd( tds[i] ) );
		}
		return tdArr;
	},
	decorateSingleTd: function(td){
		var cols = parseInt( td.getAttribute("colSpan") || 1);
		var rows = parseInt( td.getAttribute("rowSpan") || 1);
		td.cols = cols;
		td.rows = (rows-1) * cols + 1;

		return td;
	},
	initRowSize: function(table){
		return table.rows.length;
	},
	initColSize: function(table){
		var colSize = 0;
		var tdArr = $tom.children( $tom.collect(table, "tr"), "td");
		tdArr.each(function(td){
            colSize += parseInt(td.getAttribute("colSpan") || 1);
		});

		return colSize;
	},
	getRowSize: function(){
		return this.rowSize;
	},
	getColSize: function(){
		return this.colSize;
	},
	getTdMatrix: function(){
		return this.tdMatrix;
	}
});

TrexMessage.addMsg({
	'@table.title.insert': '\ud45c\uc0bd\uc785 &nbsp;',
	'@table.title.setDirectly': '\ud45c \uc9c1\uc811\uc124\uc815',
	'@table.title.row': '\uc5f4 \uac1c\uc218',
	'@table.title.col': '\ud589 \uac1c\uc218'
});
Trex.MarkupTemplate.add(
	'menu.table.direct', [
		'<div>@table.title.setDirectly</div>',
		'<div class="tx-table-input-area">',
		'<div class="tx-field tx-col-field">@table.title.row<input type="text" value="1"><a class="tx-btn tx-btn-add" href="javascript:void 0;">@table.title.row+</a><a class="tx-btn tx-btn-sub" href="javascript:void 0;">@table.title.row-</a></div>',
		'<div class="tx-field tx-row-field">@table.title.col<input type="text" value="1"><a class="tx-btn tx-btn-add" href="javascript:void 0;">@table.title.col+</a><a class="tx-btn tx-btn-sub" href="javascript:void 0;">@table.title.col-</a></div>',
		'</div>'
	].join("")
);
/* Trex.Menu.Table ************************************************************************************/
Trex.Menu.Table = Trex.Class.create({
	$const:{
		MAX_ROW:99,
		MAX_COL:99
	},
	$extend: Trex.Menu,
	ongenerated: function() {
		this.rowSize = 1;
		this.colSize = 1;

		this.elInnerPreview = $tom.collect(this.elMenu, 'div.tx-menu-inner .tx-menu-preview');
		this.dynamicSizer = this.generateDynamicSizer(this.elInnerPreview);

		this.elInnerRowCol = $tom.collect(this.elMenu, 'div.tx-menu-inner .tx-menu-rowcol');
		this.generateTextSizer(this.elInnerRowCol);

		this.elButtonArea = $tom.collect(this.elMenu, 'div.tx-menu-inner .tx-menu-enter');
		this.generateButtonArea(this.elButtonArea);
	},
	onregenerated: function() {
		this.showDynamicSizer();
	},
	showDynamicSizer: function(){
		this.dynamicSizer.clear();
		$tx.show( this.elInnerPreview );
		$tx.hide( this.elInnerRowCol );
		$tx.hide( this.elButtonArea );
	},
	showTextSizer: function(){
		$tx.hide(this.elInnerPreview);
		$tx.show(this.elInnerRowCol);
		$tx.show(this.elButtonArea);
	},
	generateDynamicSizer: function(elPreivewContext){
		var _self = this;
		var elRowCol= tx.span();
		var elDisplay = tx.div({className:"tx-dynamic-sizer-display"}, TXMSG('@table.title.insert'), elRowCol);
		elPreivewContext.appendChild( elDisplay );

		var dynamicSizer = new Trex.DynamicSizer({
			el: elPreivewContext,
			clickHandler: this.onSelect.bind(this),
			moveHandler: function(row, col){
				elRowCol.innerHTML = row + 'x' +col;
			}
		});

		var _elA = tx.a({href:"javascript:;"}, TXMSG('@table.title.setDirectly'));
		$tx.observe( _elA, "click", function(ev){
			_self.showTextSizer();
			$tx.stop(ev);
            _self.fireJobs(Trex.Ev.__MENU_LAYER_CHANGE_SIZE, {
                detail: {
                    menu: _self
                }
            });
		});

		var _elButton = tx.div({className:"tx-more-button"});
		_elButton.appendChild(_elA);
		elPreivewContext.appendChild( _elButton );

		return dynamicSizer;
	},
	generateTextSizer: function(elContext) {
		var _self = this;

		Trex.MarkupTemplate.get('menu.table.direct').evaluateToDom({}, elContext);

		var calculator = {
			calculate: function(value, max, operand){
				value = parseInt(value);
				if ( value + operand > max || value + operand< 1){
					alert( TXMSG("@table.alert") );
					return value;
				}else{
					return value + operand;
				}
			},
			getValidValue:function(value, previousValue, max){
				if ( value <= 0 || value > max  ){
					alert( TXMSG("@table.alert") );
					return previousValue;
				}else{
					return value;
				}

			}
		};

		var colInput = $tom.collect(elContext, "div.tx-col-field input");
		$tx.observe(colInput, "blur", function(){
			colInput.value = _self.colSize = calculator.getValidValue(colInput.value, _self.colSize, Trex.Menu.Table.MAX_COL);
		});
		$tx.observe( $tom.collect(elContext, "div.tx-col-field a.tx-btn-add"), "click", function(e){
			colInput.value = _self.colSize = calculator.calculate(_self.colSize, Trex.Menu.Table.MAX_COL, 1);
			$tx.stop(e);
			return _FALSE;
		});
		$tx.observe($tom.collect(elContext, "div.tx-col-field a.tx-btn-sub"), "click", function(e){
			colInput.value = _self.colSize = calculator.calculate(_self.colSize, Trex.Menu.Table.MAX_COL, -1);
			$tx.stop(e);
            return _FALSE;
		});

		var rowInput = $tom.collect(elContext, "div.tx-row-field input");
		$tx.observe(rowInput, "blur", function(){
			rowInput.value = _self.rowSize = calculator.getValidValue(rowInput.value, _self.rowSize, Trex.Menu.Table.MAX_ROW);
		});
		$tx.observe($tom.collect(elContext, "div.tx-row-field a.tx-btn-add"), "click", function(e){
			rowInput.value = _self.rowSize = calculator.calculate(_self.rowSize, Trex.Menu.Table.MAX_ROW, 1);
			$tx.stop(e);
			return _FALSE;
		});
		$tx.observe($tom.collect(elContext, "div.tx-row-field a.tx-btn-sub"), "click", function(e){
			rowInput.value = _self.rowSize = calculator.calculate(_self.rowSize, Trex.Menu.Table.MAX_ROW, -1);
			$tx.stop(e);
			return _FALSE;
		});
	},
	generateButtonArea: function(elContext){
		var _self = this;
		var elDiv = tx.div();
		var elAConfirm = tx.a({href:"javascript:;", className:"tx-btn-confirm"}, "\ud655\uc778");
		var elACancel = tx.a({href:"javascript:;", className:"tx-btn-cancel"}, "\ucde8\uc18c");

		$tx.observe( elAConfirm, "click", function(ev){
			_self.onSelect(ev, {
				row: _self.rowSize,
				col: _self.colSize
			});
		});

		$tx.observe(elACancel, "click", function(e) {
			$tx.stop(e);
			this.onCancel();
			return _FALSE;
		}.bindAsEventListener(this));

		elDiv.appendChild(elAConfirm);
		elDiv.appendChild(elACancel);
		elContext.appendChild(elDiv);
	}
});
/**
 * @fileoverview 
 * \uc678\ubd80 \uc774\ubaa8\ud2f0\ucf58
 *     
 */
(function() {
	TrexConfig.addTool(
		"emoticon",
		{
			sync: _FALSE,
			status: _FALSE
		}
	);

	Trex.Tool.Emoticon = Trex.Class.create({
		$const: {
			__Identity: 'emoticon'
		},
		$extend: Trex.Tool,
        oninitialized: function() {
            /* button & menu weave */
            this.weave(
                new Trex.Button(this.buttonCfg),
                _NULL,
                this.handler
            );
        },
        handler: function() {
			Trex.Tool.Embed('icon',1,400,200,'\uc544\uc774\ucf58 \uc0bd\uc785\ud558\uae30');
		}
	});
})();
/**
 * @fileoverview 
 * Tool 'Redo' Source,
 * Class Trex.Tool.ReDo \uc640 configuration\uc744 \ud3ec\ud568    
 *     
 */
TrexConfig.addTool(
	"redo",
	{
		sync: _FALSE,
		status: _FALSE
	}
);

Trex.Tool.ReDo = Trex.Class.create({
	$const: {
		__Identity: 'redo'
	},
	$extend: Trex.Tool,
	oninitialized: function() {
			var _canvas = this.canvas;

			var _toolHandler = function() {
				_canvas.getProcessor().blur();
				_canvas.focus();	
					
				setTimeout( function(){
					_canvas.fireJobs('canvas.panel.redo');	
				}, 0);	
			};

			/* button & menu weave */
			this.weave.bind(this)(
				/* button */
				new Trex.Button(this.buttonCfg),
				/* menu */
				_NULL,
				/* handler */
				_toolHandler
			);

			this.bindKeyboard({ // ctrl + y - \ub2e4\uc2dc\uc2e4\ud589
				ctrlKey: _TRUE,
				keyCode: 89
			}, function() {
				_canvas.fireJobs('canvas.panel.redo');
				_canvas.triggerQueryStatus();
			});
		}
	
});

/**
 * @fileoverview 
 *  Tool 'UnDo' Source,
 *  Class Trex.Tool.UnDo \uc640  configuration \uc744 \ud3ec\ud568 \ud558\uace0\uc788\ub2e4.    
 * 
 */
TrexConfig.addTool(
	"undo",
	{
		sync: _FALSE,
		status: _FALSE
	}
);

Trex.Tool.UnDo = Trex.Class.create({
	$const: {
		__Identity: 'undo'
	},
	$extend: Trex.Tool,
	oninitialized: function() {
			var _canvas = this.canvas;

			var _toolHandler = function() {
				_canvas.getProcessor().blur();
				_canvas.focus();	
					
				setTimeout( function(){
					_canvas.fireJobs('canvas.panel.undo');	
				}, 20);
			};

			/* button & menu weave */
			this.weave.bind(this)(
				/* button */
				new Trex.Button(this.buttonCfg),
				/* menu */
				_NULL,
				/* handler */
				_toolHandler
			);

			this.bindKeyboard({ // ctrl + z - \uc2e4\ud589\ucde8\uc18c
				ctrlKey: _TRUE,
				keyCode: 90
			}, function() {
				_canvas.fireJobs('canvas.panel.undo');
				_canvas.triggerQueryStatus();
			});
		}
	
});

/**
 * @fileoverview 
 *  
 */
TrexConfig.addTool(
	"removeformat", 
	{
		wysiwygonly: _TRUE,
		sync: _TRUE,
		status: _FALSE,
        hotKey: { // ctrl + shift + x
            ctrlKey: _TRUE,
            shiftKey: _TRUE,
			keyCode: 88
        }
	}
);

Trex.I.FontToolForRemoveformat = Trex.Mixin.create({
    oninitialized: function(config) {
        this.bindKeyboard(config.hotKey, this.handler.bind(this));
    },
    computeNewStyle: function() {
        return _NULL;
    },
    rangeExecutor: function(processor) {
        processor.execCommand(this.getQueryCommandName());
    }
});

Trex.Tool.Removeformat = Trex.Class.create({
	$const: {
		__Identity: 'removeformat'
	},
	$extend: Trex.Tool,
    $mixins: [Trex.I.FontTool, Trex.I.FontToolForRemoveformat],
    getQueryCommandName: function() {
        return "removeformat";
    },
    isStyleApplied: function(node) {
        return false;
    }
});

Trex.module('initialize removeformat without toolbar button', function(editor, toolbar, sidebar, canvas/*, config*/) {
    if (!$tx('tx_removeformat')) {
        var cfg = TrexConfig.getTool('removeformat');
        var el = _DOC.createElement('div');
        el.id = 'tx_removeformat';
        _DOC.body.appendChild(el);
        new Trex.Tool.Removeformat(editor, toolbar, cfg);
    }
});
/**
 * @fileoverview 
 * \uc5ec\ub7ec \uc2a4\ud0c0\uc77c\uc758 \uad6c\ubd84\uc120\uc744 \uc0bd\uc785\ud560 \ub54c \uc4f0\uc774\ub294 menu\ub97c \ud3ec\ud568\ud558\ub294 Tool\uc778 '\uad6c\ubd84\uc120' Icon Source,
 * Class Trex.Tool.HorizontalRule\uacfc configuration\uc744 \ud3ec\ud568    
 *     
 */
TrexConfig.addTool(
	"horizontalrule",
	{
		wysiwygonly: _TRUE,
		sync: _FALSE,
		status: _TRUE,
		top: _NULL,
		left: _NULL,
		options: [{	data: 'tx-hr-border-1', 
			image: '#iconpath/horizontalrule/line01.gif',
			html: '<hr style="display:block; border: black 0 none; border-top: black 1px solid; height: 1px"/>'
		},
		{	data: 'tx-hr-border-2',
			image: '#iconpath/horizontalrule/line02.gif',
			html: '<hr style="display:block; border: black 0 none; border-top: black 1px solid; border-bottom: black 3px solid; height: 7px"/>'
		},
		{	data: 'tx-hr-border-3',
			image: '#iconpath/horizontalrule/line04.gif',
			html: '<hr style="display:block; border: black 0 none; border-top: black 1px dotted; height: 1px"/>'
		},
		{	data: 'tx-hr-image-1',
			image: '#iconpath/horizontalrule/line03.gif',
			html: '<div style="background: url(#decopath/horizontalrule/line03.gif) repeat-x scroll left;  width: 99%; height: 15px"><hr style="border: black 0 none; left: -9999px; position: relative; top: -9999px"></div>'
		},
		{	data: 'tx-hr-image-2',
			image: '#iconpath/horizontalrule/line05.gif',
			html: '<div style="background: url(#decopath/horizontalrule/line05.gif) repeat-x scroll left;  width: 99%; height: 15px"><hr style="border: black 0 none; left: -9999px; position: relative; top: -9999px"></div>'
		},
		{	data: 'tx-hr-image-3',
			image: '#iconpath/horizontalrule/line06.gif',
			html: '<div style="background: url(#decopath/horizontalrule/line06.gif) repeat-x scroll left;  width: 99%; height: 15px"><hr style="border: black 0 none; left: -9999px; position: relative; top: -9999px"></div>'
		},
		{	data: 'tx-hr-image-4',
			image: '#iconpath/horizontalrule/line07.gif',
			html: '<div style="background: url(#decopath/horizontalrule/line08.gif) repeat-x scroll left;  width: 99%; height: 15px"><hr style="border: black 0 none; left: -9999px; position: relative; top: -9999px"></div>'
		}]
	},
	function(root){
		var _config = TrexConfig.getTool("horizontalrule", root);
		_config.options.each(function(option) {
			option.image = TrexConfig.getIconPath(option.image);
			if(option.html) {
				option.html = TrexConfig.getDecoPath(option.html);
			}
		});
	}
);

Trex.Tool.HorizontalRule = Trex.Class.create({
	$const: {
		__Identity: 'horizontalrule'
	},
	$extend: Trex.Tool,
	oninitialized: function(config) {
			var _canvas = this.canvas;

			var map = {};
			config.options.each(function(option) {
				map[option.data] = {
					html: option.html
				};
			});

			var _toolHandler = function(data) {
				if(!map[data]) {
					return;
				}
				var _item = map[data];
				if (_canvas.isWYSIWYG()) {
					_canvas.execute(function(processor){
                        // hr \ud0dc\uadf8\ub294 p \ud0dc\uadf8 \ud558\uc704\uc5d0 \ud3ec\ud568 \ub420 \uc218 \uc5c6\uc73c\ubbc0\ub85c newline\uc73c\ub85c \ub0b4\uc6a9\uc744 \ucd94\uac00 \ud55c \ub4a4\uc5d0 \ub798\ud551\ub41c p\ud0dc\uadf8\ub97c \uc81c\uac70\ud55c\ub2e4.
                        var pastedNode = processor.pasteContent(_item.html, _TRUE);
                        if ($tom.isTagName(pastedNode.parentNode, 'p')) {
                            $tom.unwrap(pastedNode.parentNode);
                        }
					});
				} else {
					_canvas.execute(function(processor) {
						processor.insertTag('',_item.html);
					});
				}	
			};

			/* button & menu weave */
			this.weave.bind(this)(
				/* button */
				new Trex.Button(this.buttonCfg),
				/* menu */
				new Trex.Menu.List(this.menuCfg),
				/* handler */
				_toolHandler
			);
		}
	
});

/**
 * @fileoverview 
 *  Tool '\ud2b9\uc218\ubb38\uc790' Source,
 * Class Trex.Tool.SpecialChar \uc640 configuration\uc744 \ud3ec\ud568    
 *     
 */
(function(){
	TrexMessage.addMsg({
		'@specialchar.subtitle1': '\uc77c\ubc18\uae30\ud638',
		'@specialchar.subtitle2': '\uc218\ud559\ubd80\ud638, \ud1b5\ud654\ub2e8\uc704',
		'@specialchar.subtitle3': '\uc6d0 \uae30\ud638, \uad04\ud638',
		'@specialchar.subtitle4': '\uc77c\ubcf8\uc5b4',
		'@specialchar.subtitle5': '\ub85c\ub9c8\uc790, \uadf8\ub9ac\uc2a4'
	});
	
	TrexConfig.addTool(
		"specialchar", 
		{
			sync: _FALSE,
			status: _TRUE,
			rows: 9,
			cols: 20,
			top: _NULL,
			left: _NULL,
			matrices: [{
				title: TXMSG('@specialchar.subtitle1'),
				options: ['\uff03', '\uff06', '\uff0a', '\uff20', '\xa7', '\u203b', '\u2606', '\u2605', '\u25cb', '\u25cf', '\u25ce', '\u25c7', '\u25c6', '\u25a1', '\u25a0', '\u25b3', '\u25b2', '\u25bd', '\u25bc', '\u2192', '\u2190', '\u2191', '\u2193', '\u2194', '\u3013', '\u25c1', '\u25c0', '\u25b7', '\u25b6', '\u2664', '\u2660', '\u2661', '\u2665', '\u2667', '\u2663', '\u2299', '\u25c8', '\u25a3', '\u25d0', '\u25d1', '\u2592', '\u25a4', '\u25a5', '\u25a8', '\u25a7', '\u25a6', '\u25a9', '\u2668', '\u260f', '\u260e', '\u261c', '\u261e', '\xb6', '\u2020', '\u2021', '\u2195', '\u2197', '\u2199', '\u2196', '\u2198', '\u266d', '\u2669', '\u266a', '\u266c', '\u327f', '\u321c', '\u2116', '\u33c7', '\u2122', '\u33c2', '\u33d8', '\u2121', '\xae', '\xaa', '\xba', '\uff02', '\uff08', '\uff09', '\uff3b', '\uff3d', '\uff5b', '\uff5d', '\u2018', '\u2019', '\u201c', '\u201d', '\u3014', '\u3015', '\u3008', '\u3009', '\u300a', '\u300b', '\u300c', '\u300d', '\u300e', '\u300f', '\u3010', '\u3011', '\uff01', '\uff07', '\uff0c', '\uff0e', '\uff0f', '\uff1a', '\uff1b', '\uff1f', '\uff3e', '\uff3f', '\uff40', '\uff5c', '\uffe3', '\u3001', '\u3002', '\xb7', '\u2025', '\u2026', '\xa8', '\u3003', '\u2015', '\u2225', '\uff3c', '\u223c', '\xb4', '\uff5e', '\u02c7', '\u02d8', '\u02dd', '\u02da', '\u02d9', '\xb8', '\u02db', '\xa1', '\xbf', '\u02d0']
			},{
				title: TXMSG('@specialchar.subtitle2'),
				options: ['\uff0b', '\uff0d', '\uff1c', '\uff1d', '\uff1e', '\xb1', '\xd7', '\xf7', '\u2260', '\u2264', '\u2265', '\u221e', '\u2234', '\u2642', '\u2640', '\u2220', '\u22a5', '\u2312', '\u2202', '\u2207', '\u2261', '\u2252', '\u226a', '\u226b', '\u221a', '\u223d', '\u221d', '\u2235', '\u222b', '\u222c', '\u2208', '\u220b', '\u2286', '\u2287', '\u2282', '\u2283', '\u222a', '\u2229', '\u2227', '\u2228', '\uffe2', '\u21d2', '\u21d4', '\u2200', '\u2203', '\u222e', '\u2211', '\u220f','\uff04', '\uff05', '\uffe6', '\uff26', '\u2032', '\u2033', '\u2103', '\u212b', '\uffe0', '\uffe1', '\uffe5', '\xa4', '\u2109', '\u2030', '?', '\u3395', '\u3396', '\u3397', '\u2113', '\u3398', '\u33c4', '\u33a3', '\u33a4', '\u33a5', '\u33a5', '\u33a6', '\u3399', '\u339a', '\u339b', '\u339c', '\u339d', '\u339e', '\u339f', '\u33a0', '\u33a1', '\u33a2', '\u33ca', '\u338d', '\u338e', '\u338f', '\u33cf', '\u3388', '\u3389', '\u33c8', '\u33a7', '\u33a8', '\u33b0', '\u33b1', '\u33b2', '\u33b3', '\u33b4', '\u33b5', '\u33b6', '\u33b7', '\u33b8', '\u33b9', '\u3380', '\u3381', '\u3382', '\u3383', '\u3384', '\u33ba', '\u33bb', '\u33bc', '\u33bd', '\u33be', '\u33bf', '\u3390', '\u3391', '\u3392', '\u3393', '\u3394', '\u2126', '\u33c0', '\u33c1', '\u338a', '\u338b', '\u338c', '\u33d6', '\u33c5', '\u33ad', '\u33ae', '\u33af', '\u33db', '\u33a9', '\u33aa', '\u33ab', '\u33ac', '\u33dd', '\u33d0', '\u33d3', '\u33c3', '\u33c9', '\u33dc', '\u33c6']
			},{
				title: TXMSG('@specialchar.subtitle3'),
				options: [
					'\u3260', '\u3261', '\u3262', '\u3263', '\u3264', '\u3265', '\u3266', '\u3267', '\u3268', '\u3269',
					'\u326a', '\u326b', '\u326c', '\u326d', '\u326e', '\u326f', '\u3270', '\u3271', '\u3272', '\u3273',
					'\u3274', '\u3275', '\u3276', '\u3277', '\u3278', '\u3279', '\u327a', '\u327b', '\u3200', '\u3201',
					'\u3202', '\u3203', '\u3204', '\u3205', '\u3206', '\u3207', '\u3208', '\u3209', '\u320a', '\u320b', 
					'\u320c', '\u320d', '\u320e', '\u320f', '\u3210', '\u3211', '\u3212', '\u3213', '\u3214', '\u3215', 
					'\u3216', '\u3217', '\u3218', '\u3219', '\u321a', '\u321b', '\u24d0', '\u24d1', '\u24d2', '\u24d3', 
					'\u24d4', '\u24d5', '\u24d6', '\u24d7', '\u24d8', '\u24d9', '\u24da', '\u24db', '\u24dc', '\u24dd', 
					'\u24de', '\u24df', '\u24e0', '\u24e1', '\u24e2', '\u24e3', '\u24e4', '\u24e5', '\u24e6', '\u24e7', '\u24e8', '\u24e9', '\u2460', '\u2461', '\u2462', '\u2463', '\u2464', '\u2465', '\u2466', '\u2467', '\u2468', '\u2469', '\u246a', '\u246b', '\u246c', '\u246d', '\u246e', '\u249c', '\u249d', '\u249e', '\u249f', '\u24a0', '\u24a1', '\u24a2', '\u24a3', '\u24a4', '\u24a5', '\u24a6', '\u24a7', '\u24a8', '\u24a9', '\u24aa', '\u24ab', '\u24ac', '\u24ad', '\u24ae', '\u24af', '\u24b0', '\u24b1', '\u24b2', '\u24b3', '\u24b4', '\u24b5', '\u2474', '\u2475', '\u2476', '\u2477', '\u2478', '\u2479', '\u247a', '\u247b', '\u247c', '\u247d', '\u247e', '\u247f', '\u2480', '\u2481', '\u2482']
			},{
				title: TXMSG('@specialchar.subtitle4'),
				options: ['\u3041', '\u3042', '\u3043', '\u3044', '\u3045', '\u3046', '\u3047', '\u3048', '\u3049', '\u304a', '\u304b', '\u304c', '\u304d', '\u304e', '\u304f', '\u3050', '\u3051', '\u3049', '\u3053', '\u3054', '\u3055', '\u3056', '\u3057', '\u3058', '\u3059', '\u305a', '\u305b', '\u305c', '\u305d', '\u305e', '\u305f', '\u3060', '\u3061', '\u3062', '\u3063', '\u3064', '\u3065', '\u3066', '\u3067', '\u3068', '\u3069', '\u306a', '\u306b', '\u306c', '\u306d', '\u306e', '\u306f', '\u3070', '\u3071', '\u3072', '\u3073', '\u3074', '\u3075', '\u3076', '\u3077', '\u3078', '\u3079', '\u307a', '\u307b', '\u307c', '\u307d', '\u307e', '\u307f', '\u3080', '\u3081', '\u3082', '\u3083', '\u3084', '\u3085', '\u3086', '\u3087', '\u3088', '\u3089', '\u308a', '\u308b', '\u308c', '\u308d', '\u308e', '\u308f', '\u3090', '\u3091', '\u3092', '\u3093', '\u30a1', '\u30a2', '\u30a3', '\u30a4', '\u30a5', '\u30a6', '\u30a7', '\u30a8', '\u30a9', '\u30aa', '\u30ab', '\u30ac', '\u30ad', '\u30ae', '\u30af', '\u30b0', '\u30b1', '\u30b2', '\u30b3', '\u30b4', '\u30b5', '\u30b6', '\u30b7', '\u30b8', '\u30b9', '\u30ba', '\u30bb', '\u30bc', '\u30bd', '\u30be', '\u30bf', '\u30c0', '\u30c1', '\u30c2', '\u30c3', '\u30c4', '\u30c5', '\u30c6', '\u30c7', '\u30c8', '\u30c9', '\u30ca', '\u30cb', '\u30cc', '\u30cd', '\u30ce', '\u30cf', '\u30d0', '\u30d1', '\u30d2', '\u30d3', '\u30d4', '\u30d5', '\u30d6', '\u30d7', '\u30d8', '\u30d9', '\u30da', '\u30db', '\u30dc', '\u30dd', '\u30de', '\u30df', '\u30e0', '\u30e1', '\u30e2', '\u30e3', '\u30e4', '\u30e5', '\u30e6', '\u30e7', '\u30e8', '\u30e9', '\u30ea', '\u30eb', '\u30ec', '\u30ed', '\u30ee', '\u30ef', '\u30f0', '\u30f1', '\u30f2', '\u30f3', '\u30f4', '\u30f5', '\u30f6']
			},{
				title: TXMSG('@specialchar.subtitle5'),
				options: ['\uff10', '\uff11', '\uff12', '\uff13', '\uff14', '\uff15', '\uff16', '\uff17', '\uff18', '\uff19', '\u2170', '\u2171', '\u2172', '\u2173', '\u2174', '\u2175', '\u2176', '\u2177', '\u2178', '\u2179', '\u2160', '\u2161', '\u2162', '\u2163', '\u2164', '\u2165', '\u2166', '\u2167', '\u2168', '\u2169', '\u0391', '\u0392', '\u0393', '\u0394', '\u0395', '\u0396', '\u0397', '\u0398', '\u0399', '\u039a', '\u039b', '\u039c', '\u039d', '\u039e', '\u039f', '\u03a0', '\u03a1', '\u03a3', '\u03a4', '\u03a5', '\u03a6', '\u03a7', '\u03a8', '\u03a9', '\u03b1', '\u03b2', '\u03b3', '\u03b4', '\u03b5', '\u03b6', '\u03b7', '\u03b8', '\u03b9\u03ba', '\u03bb', '\u03bc', '\u03bd', '\u03be', '\u03bf', '\u03c0', '\u03c1', '\u03c3', '\u03c4', '\u03c5', '\u03c6', '\u03c7', '\u03c8', '\u03c9']
			}],
			asyncUrl: "trex/tool/async/specialchar.js"
		}
	);
	
	Trex.Tool.SpecialChar = Trex.Class.create({
		$const: {
			__Identity: 'specialchar'
		},
		$extend: Trex.AsyncTool,
		oninitialized: function(config) {
			this.config = config;
			this.weave.bind(this)(
				new Trex.Button(this.buttonCfg), 
				_NULL,
				this.onLoadModule // define in Trex.AsyncTool
			);
		}
	});
})();

/**
 * @fileoverview 
 * \uc601\uc5b4 \uc0ac\uc804 \ud31d\uc5c5\uc744 \ub744\uc6cc \uc8fc\ub294 '\uc0ac\uc804' Icon\uc744 \uc704\ud574 \ud544\uc694\ud55c source, configuration\uacfc Class Trex.Tool.Dictionary\uc744/\ub97c \ud3ec\ud568    
 *   
 */
TrexConfig.addTool(
	"dictionary",
	{
		url: 'http://engdic.daum.net/dicen/small_view_top.do',
		sync: _FALSE,
		status: _FALSE
	}
);

Trex.Tool.Dictionary = Trex.Class.create({
	$const: {
		__Identity: 'dictionary'
	},
	$extend: Trex.Tool,
	oninitialized: function(config) {
			var _canvas = this.canvas;

			var _toolHandler = function() {
				var _word = _canvas.query(function(processor) {
					return encodeURI(processor.getText());
				});
				var _popupUrl = (_word.length > 0) ?  "http://engdic.daum.net/dicen/small_search.do" : config.url;
				var _dicWin = _WIN.open(_popupUrl + '?q=' + _word, 'dicWin', 'width=410,height=550,scrollbars=yes'); 
				_dicWin.focus();
			};

			/* button & menu weave */
			this.weave.bind(this)(
				/* button */
				new Trex.Button(this.buttonCfg),
				/* menu */
				_NULL,
				/* handler */
				_toolHandler
			);
		}
});

(function() {
    TrexConfig.addTool(
        "background",
        {
            wysiwygonly: _TRUE,
            sync: _FALSE,
            status: _TRUE,
			needRevert: true,
            thumbs: Trex.__CONFIG_COMMON.thumbs
        }
    );

    var articleBackgroundColor;

    Trex.Tool.Background = Trex.Class.create({
        $const: {
            __Identity: 'background'
        },
        $extend: Trex.Tool,
        oninitialized: function() {
            /* button & menu weave */
            this.weave(
                new Trex.Button(this.buttonCfg),
                new Trex.Menu.ColorPallete(this.menuCfg),
                this.handler
            );
        },
        handler: function(color) {
            var self = this;
            var canvas = self.canvas;

            canvas.fireJobs("canvas.apply.backgroundcolor", color);
            canvas.history.saveHistory(
                {
                    backgroundColor: articleBackgroundColor,
                    backgroundImage: canvas.getStyle('backgroundImage')
                },
                {
                    backgroundColor: color,
                    backgroundImage: canvas.getStyle('backgroundImage')
                },
                function(data){
                    self._restoreColor(data);
                }
            );
			if (color === null) {
				canvas.addStyle({
	                backgroundColor: canvas.getConfig().styles ? canvas.getConfig().styles.backgroundColor || "" : "",
	                backgroundImage: canvas.getConfig().styles ? canvas.getConfig().styles.backgroundImage || "" : ""
	            });
				articleBackgroundColor = "";
				canvas.getConfig().hasUserBgcolor = _FALSE;
			} else {
	            canvas.addStyle({
	                backgroundColor: color,
	                backgroundImage: ""
	            });
	            articleBackgroundColor = color;
	            canvas.getConfig().hasUserBgcolor = _TRUE;
			}
        },
        _restoreColor: function(data) {
            var canvas = this.canvas;
            canvas.addStyle({ backgroundColor: data.backgroundColor });
            if (data.backgroundImage) {
                canvas.addStyle({ backgroundImage: data.backgroundImage });
            }
            articleBackgroundColor = data.backgroundColor;
        }
    });

    Trex.install('canvas.getBgColor & canvas.setBgColor & editor.getContentWithBg',
        function(editor, toolbar, sidebar, canvas, config) {
            articleBackgroundColor = config.canvas.styles.backgroundColor;

            // \uc800\uc7a5, \ub85c\ub4dc\ud560\ub54c content \uc218\uc815
            canvas.getBgColor = function() {
                var color = articleBackgroundColor || canvas.getPanel("html").getStyle("backgroundColor");
                if ( color ) {
                    return Trex.Color.getHexColor(color);
                } else {
                    return "";
                }
            };

            canvas.setBgColor = function(color) {
                canvas.getPanel("html").addStyle({
                    "backgroundColor": color || 'transparent'
                });
            };

            editor.getContentWithBg = function() {
                var _selColor = canvas.getBgColor().toLowerCase();
                if(_selColor == 'transparent') {
                    return editor.getContent();
                } else {
                    return [
                        '<table class="txc-wrapper" border="0" cellspacing="0" cellpadding="0"><tr>',
                        '<td bgcolor="',_selColor,'">',
                        editor.getContent(),
                        '</td>',
                        '</tr></table>'
                    ].join("");
                }
            };

            var _originInitContent = canvas.initContent.bind(canvas);
            canvas.initContent = function(content) {
                if(content.search(/<table[^>]*txc-wrapper[^>]*>/i) > -1) {
                    var _selColor;
                    content = content.replace(/<table[^>]*txc-wrapper[^>]*><tr><td([^>]*)>([\s\S]*?)<\/td><\/tr><\/table>/i, function(full, color, html){
                        _selColor = color.replace(/\sbgcolor="([#\w]*)"/, "$1");
                        return html;
                    });
                    canvas.setBgColor(_selColor);
                }
                _originInitContent(content);
            };

            canvas.history.initHistory({
                'backgroundColor': config.canvas.styles.backgroundColor,
                'backgroundImage': config.canvas.styles.backgroundImage || "none"
            });

            canvas.reserveJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function() {
                var color = canvas.config.articleBackgroundColor;
                if ( color && color != "transparent" ){
                    canvas.addStyle({
                        backgroundColor: color,
                        backgroundImage: ""
                    });
                }
            });

            canvas.observeJob('canvas.apply.letterpaper', function(data){
                if ( data.id ){
                    canvas.getPanel("html").addStyle({
                        "backgroundColor": 'transparent'
                    });
                }
            });
        }
    );
})();
/**
 * @fileoverview 
 *  toolbar\uc758 \uc811\ud78c \ubd80\ubd84\uc744 \uc5f4\uace0\ub2eb\ub294 '\ub354\ubcf4\uae30' Icon\uc744 \uc704\ud574 \ud544\uc694\ud55c configuration\uacfc Class Trex.Tool.Advanced \ub97c \ud3ec\ud568    
 * 
 */
TrexConfig.addTool(
	"advanced",
	{
		sync: _FALSE,
		status: _TRUE,
		opened: _FALSE
	}
);

/**
 * Trex.Tool.Advanced
 * 
 * @class
 * @extends  Trex.Tool
 */
Trex.Tool.Advanced = Trex.Class.create({
	$const: {
		__Identity: 'advanced'
	},
	$extend: Trex.Tool,
	/**
	 * instance\uac00 \uc0dd\uc131\ub420 \ub54c \uc2e4\ud589\ub418\uba70 \ud544\uc694\ud55c UI Component \ubc0f Event handler\ub97c \uc0dd\uc131\ud55c\ub2e4.  
	 * 
	 * @memberOf Trex.Tool.Advanced.prototype 
	 * @param {Object} config
	 */
	oninitialized: function(config) {
		var self = this;
		var _toolbar = this.toolbar;

		var _elBasic = _toolbar.el;
		self.opened = _FALSE;
		var _elAdvanced = $tom.collect(_elBasic.parentNode, 'div.tx-toolbar-advanced');
		if(!_elAdvanced) {
			return;
		}

		_toolbar.observeJob(Trex.Ev.__CMD_ADVANCED_FOLD, function() {
			
			$tx.hide(_elAdvanced);
			$tx.removeClassName(_elBasic, 'tx-toolbar-basic-open');
		});

		_toolbar.observeJob(Trex.Ev.__CMD_ADVANCED_SPREAD, function() {
			
			$tx.show(_elAdvanced);
			$tx.addClassName(_elBasic, 'tx-toolbar-basic-open');
		});

		var _toolHandler = function() {
			if(self.opened) {
				_toolbar.fireJobs(Trex.Ev.__CMD_ADVANCED_FOLD);
			} else {
				_toolbar.fireJobs(Trex.Ev.__CMD_ADVANCED_SPREAD);
			}
			self.opened = !self.opened;
		};

		/* button & menu weave */
		this.weave.bind(this)(
			/* button */
			new Trex.Button(this.buttonCfg),
			/* menu */
			_NULL,
			/* handler */
			_toolHandler
		);

		if(config.opened == _TRUE) {
			this.forceOpen();
		}
	},
	forceOpen: function(){
		this.button.pushedState();
		this.toolbar.fireJobs(Trex.Ev.__CMD_ADVANCED_SPREAD);
		this.opened = _TRUE;
	}
});

Trex.module("add drop-down menu button if extra buttons exist.", 
	function (editor, toolbar, sidebar, canvas) {
		canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function() {
			var _elButtonList = $tom.collectAll(editor.getWrapper(), 'li.tx-list-extra div.tx-extra');
			if (_elButtonList.length == 0) {
				return;
			}
			_elButtonList.each(function(elButton) {
				var elMenu = $tom.next(elButton, '.tx-extra-menu');
				if (!elMenu) {
					return;
				}
				
				toolbar.makeWidget(
					new Trex.Button({
						el: elButton,
						sync: _FALSE,
						status: _TRUE
					}), 
					new Trex.Menu({
						el: elMenu
					}), 
					function() { /*dummy handler*/ }
				);
			});
		});
	}
);


(function(){
	TrexConfig.addTool(
		"fullscreen", {
			wysiwygonly: _FALSE,
			status: _FALSE,
			switched: _FALSE,
			minHeight: 200,
			minWidth: 720,
			asyncUrl: "trex/tool/async/fullscreen.js"
		}
	);
	
	Trex.Tool.FullScreen = Trex.Class.create({
		$const: {
			__Identity: 'fullscreen'
		},
		$extend: Trex.AsyncTool,
		oninitialized: function(config) {
			this.weave.bind(this)(
				new Trex.Button(this.buttonCfg), 
				_NULL,
				this.onLoadModule // define in Trex.AsyncTool
			);
			
			var self = this;
			// #FTDUEDTR-150
			this.bindKeyboard({ // ctrl + m - \ub113\uac8c\uc4f0\uae30
				ctrlKey: _TRUE,
				keyCode: 77
			}, function () {
				if (!self.loaded) {
					self.onLoadModule();
				}
			});
		}
	});
})();
/**
 * Created by sungwon on 14. 4. 30.
 */
TrexConfig.addTool(
    "codehighlight",
    {
        disabledonmobile: _TRUE,
        sync: _FALSE,
        status: _FALSE,
        wysiwygonly: _TRUE,
        features: { left:250, top:65, width:700, height:437 },
        popPageUrl: "#host#path/pages/trex/code_highlight.html",
        highlight: function (){
            alert(TXMSG("@codehighlight.insert.alert"));
        }

    },
    function(root){
        var _config = TrexConfig.getTool("codehighlight", root);
        _config.popPageUrl = TrexConfig.getUrl(_config.popPageUrl);
        _config.features = TrexConfig.getPopFeatures(_config.features);
    }
);

TrexMessage.addMsg({
    '@codehighlight.insert.alert': "\uc5d0\ub514\ud130 \uc0c1\ud0dc\uc5d0\uc11c\ub9cc \uc0bd\uc785\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.",
    '@codehighlight.init.error': '\ucf54\ub4dc \uac15\uc870 \ud45c\ud604 \ud568\uc218\uac00 \uc815\uc758\ub418\uc5b4 \uc788\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.'
});

Trex.Tool.Codehighlight = Trex.Class.create({
    $const: {
        __Identity: 'codehighlight'
    },
    $extend: Trex.Tool,
    isModify: false,
    target: null,
    oninitialized: function(config) {
        var self = this;
        this.highlight = config.highlight;
        this.canvas.observeElement({ tag: "button", klass: "txc-code-wrap" }, function(el){
            var  pre = $tom.first(el, 'pre');
            self.isModify = true;
            self.target = pre;
            self.toolbar.fireJobs(Trex.Ev.__TOOL_CLICK, self.identity, _TRUE);
        });

        this.toolbar.observeJob(Trex.Ev.__TOOL_CLICK, function(e, isModify){
            if(e != 'codehighlight')
                return;
            if(self.wysiwygonly && !self.canvas.isWYSIWYG()) {
                alert(TXMSG("@codehighlight.insert.alert"));
                return;
            }

            if(!isModify){
                self.isModify =  false;
                self.target =  null;
            }

            if(self.clickHandler) {
                self.clickHandler();
            } else {
                try {
                    var _url = self.config.popPageUrl;
                    var isDocumentDomainDeclaredExplicitly = (document.location.hostname != document.domain);
                    if (isDocumentDomainDeclaredExplicitly) {
                        _url = _url + ((_url.indexOf("?") > -1) ? "&" : "?") + "xssDomain=" + document.domain;
                    }

                    _url = (self.pvUrl? self.pvUrl + ((self.pvUrl.indexOf("?") > -1) ? "&" : "?") + "u="+escape(_url): _url);
                    var win = _WIN.open(_url, "at" + self.name, self.config.features);
                    win.data = self.target? (function(){
                        var buf = [];
                        goog.dom.getTextContent_(self.target, buf, _FALSE);
                        return buf.join('');})():'';
                    win.focus();
                } catch (e) {}
            }
        });
        this.weave.bind(this)(
            new Trex.Button(this.buttonCfg),
            _NULL,function(){}
        );
    },
    attachHandler: function(data){
        if(this.checkInsertable()) {
            this.execAttach(data);
        }else {
            this.execReattach(data);
        }
    },
    execAttach: function(data){
        var _doc = Editor.getCanvas().getProcessor().doc;
        var button = _doc.createElement('button');
        button.className = 'txc-code-wrap'
        button.innerHTML = '<pre class="txc-code"><code>' + this.highlight(data.code) + '</code></pre>';
        this.canvas.pasteNode(button, _TRUE);
    },
    execReattach: function(data) {
        var code = $tom.descendant(this.target, 'code');
        code.innerHTML =  this.highlight(data.code);
    },
    checkInsertable: function() {
        return !this.isModify;
    }
});
Trex.register("add highlight css",
    function(editor, toolbar, sidebar, canvas, config) {
        canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function(_doc){
            function addStyleSheet(url){
                var link = _doc.createElement('link');
                link.setAttribute('rel', 'stylesheet');
                link.setAttribute('type', 'text/css');
                link.href = url;
                (_doc.head||_doc.getElementsByTagName('head')[0]).appendChild(link);
            }
            var url = config.toolbar.codehighlight.styleSheetUrl;
            if(!url)
                return;
            if($tx.isString(url)){
                addStyleSheet(url);
            }else if($tx.isArray(url)){
                url.each(addStyleSheet)
            }else if($tx.isFunction(url)){
                url();
            }
        });
    }
);
Trex.register("filter > codehighlight",
    function(editor, toolbar, sidebar, canvas, config) {
        var highlight = config.toolbar.codehighlight.highlight;
        var _docparser = editor.getDocParser();
        function encode(contents){
            contents = contents.replace(/(<pre[^>]*class=['"]?txc-code['"]?[^>]*>\s*<code[^>]*>)([\s\S]*?)(<\/code>\s*<\/pre>)/ig,function(a, p1, p2, p3){
                return '<button class="txc-code-wrap">'+ p1 + highlight(p2) + p3 +'</button>';
            });
            return contents;
        }
        function decode(contents){
            contents = contents.replace(/<button[^>]*>\s*(<pre[^>]*class=['"]?txc-code['"]?[^>]*>\s*<code[^>]*>)([\s\S]*?)(<\/code>\s*<\/pre>)\s*<\/button>/ig,function(a, p1, p2, p3){
                return p1 + p2.stripTags() + p3;
            });
            return contents;
        }
        _docparser.registerFilter(
            'filter/codehighlight', {
                'text@load': function (contents) {
                    return contents;
                },
                'source@load': function (contents) {
                    return contents;
                },
                'html@load': function (contents) {
                    return encode(contents);
                },
                'text4save': function (contents) {
                    return contents;
                },
                'source4save': function (contents) {
                    return contents;
                },
                'html4save': function (contents) {
                    return decode(contents);
                },
                'text2source': function (contents) {
                    return contents;
                },
                'text2html': function (contents) {
                    return encode(contents);
                },
                'source2text': function (contents) {
                    return contents;
                },
                'source2html': function (contents) { //source2wysiwyg
                    return encode(contents);
                },
                'html2text': function (contents) {
                    return decode(contents);
                },
                'html2source': function (contents) { //wysiwyg2source
                    return decode(contents);
                }
            }
        );
    }
);
/**
 * @fileoverview
 * '\ubd99\uc5ec\ub123\uae30' Icon Source,
 * Class Trex.Tool.Paste configuration\uc744 \ud3ec\ud568
 *
 */
TrexConfig.addTool(
    "paste",
    {
        defaultMode: Trex.Paste.MODE_OFF,
        wysiwygonly: _TRUE,
        sync: _FALSE,
        status: _TRUE,
        options: [
            { label: '\ub044\uae30', title: '\ubd99\uc5ec\ub123\uae30\ub294 \ube0c\ub77c\uc6b0\uc800 \uae30\ubcf8 \uae30\ub2a5\uc744 \uc0ac\uc6a9\ud569\ub2c8\ub2e4', data: Trex.Paste.MODE_OFF, klass: 'cell_ico clip_off' },
            { label: '\ucf1c\uae30', title: '\ub0b4\uc6a9\uc744 \uc815\uc81c\ud574\uc11c HTML\ub85c \ubd99\uc5ec \ub123\uc2b5\ub2c8\ub2e4', data: Trex.Paste.MODE_HTML,klass: 'cell_ico clip_on' },
            { label: '\ubb38\uc790\ub9cc', title: '\ub0b4\uc6a9\uc744 Text\ub9cc \ubd99\uc5ec \ub123\uc2b5\ub2c8\ub2e4', data: Trex.Paste.MODE_TEXT,klass: 'cell_ico clip_text' }
        ]
    }
);

Trex.Tool.Paste = Trex.Class.create({
    $const: {
        __Identity: 'paste'
    },
    $extend: Trex.Tool,
    oninitialized: function(config) {
        var _canvas = this.canvas;
        var _editor = this.editor;
        var _defaultMode = config.defaultMode;

        var _toolHandler = function(command) {
            // reset className
            var elButton = this.button.elButton;
            var resetClassName = elButton.className.replace(/tx\-paste\-[a-z]+/gi, '');
            elButton.className = resetClassName + ' tx-paste-' + command;

            // change paste mode
            var paster = _editor.getPaster();
            paster.switchMode(command);
        };

        /* button & menu weave */
        this.weave.bind(this)(
            /* button */
            new Trex.Button.Select(TrexConfig.merge(this.buttonCfg, {
                selectedValue: _defaultMode
            })),
            /* menu */
            new Trex.Menu.Select(this.menuCfg),
            /* handler */
            _toolHandler);

        // init execute
        this.execute(_defaultMode);
    }
});

Trex.install('force init paste mode', function(editor, toolbar, sidebar, canvas, config) {
    // Toolbar\uac00 \ud65c\uc131\ud654 \ub418\uc9c0 \uc54a\ub354\ub77c\ub3c4 defaultMode\ub85c paster\ub97c \uc14b\ud305\ud558\uae30 \uc704\ud568.
    var paster = editor.getPaster();
    paster.switchMode(config.toolbar.paste.defaultMode);
});
/**
 * @imageoverview 
 * Image \uc5c5\ub85c\ub4dc \uad00\ub828 Source
 * Trex.Tool.Image - UI,
 * Trex.Attacher.Image,
 * Trex.Attachment.Image,
 * default configuration\ub97c \ud3ec\ud568\ud558\uace0 \uc788\ub2e4.
 */
TrexConfig.addTool(
	"image",
	{
		disabledonmobile: _TRUE,
		wysiwygonly: _TRUE,
		sync: _FALSE,
		status: _FALSE
	}
);

TrexMessage.addMsg({
	'@image.title': "\uc0ac\uc9c4"
});

Trex.Tool.Image = Trex.Class.create({
	$const: {
		__Identity: 'image'
	},
	$extend: Trex.Tool,
	oninitialized: function() {
		var _editor = this.editor;
		this.weave.bind(this)(
			new Trex.Button(this.buttonCfg), 
			_NULL,
			function() {
				_editor.getSidebar().getAttacher("image").execute();
			}
		);
	}
});

TrexConfig.addAttacher(
	"image",
	{
		LayerBox: _TRUE,
		multiple: _TRUE,
		multipleuse: _FALSE,
		checksize: _TRUE,
		boxonly: _FALSE,
		wysiwygonly: _TRUE,
		objattr: {},
		features: { left:250, top:65, width:797, height:644 },
		title: '\uc774\ubbf8\uc9c0 \uc5c5\ub85c\ub4dc',
		width: 720,
		height: 370,
		popPageUrl: "#Upload&mode=photo"
	},
	function(root){
		var _config = TrexConfig.getAttacher("image", root);
		_config.popPageUrl = TrexConfig.getUrl(_config.popPageUrl);
		_config.features = TrexConfig.getPopFeatures(_config.features);
	}
);

/**
 * Trex.Attacher.Image
 * @class
 * @extends Trex.Attacher
 */
Trex.Attacher.Image = Trex.Class.create({
	$const: {
		__Identity: 'image'
	},
	$extend: Trex.Attacher,
	name: 'image',
	title: TXMSG("@image.title"),
	canModified: _FALSE,
	canResized: _TRUE,
	matchRegexStartTag: /<(\w+)/,// \ucca8\ubd80\uc2dc\uc5d0 dispHtml\uc744 \uae30\uc900\uc73c\ub85c \uc18d\uc131 \ubc0f \uc2a4\ud0c0\uc77c\uc744 \uc801\uc6a9 \ud560 \ud0dc\uadf8\ub97c \ucc3e\uc744 \ub54c \uc0ac\uc6a9
	oninitialized: function() {
		
	},
	getKey: function(data) {
		return data.imageurl;
	},
	getDataForEntry: function(data) {
		data.imageurl = this.encodeSpaceInUrl(data.imageurl);
		data.originalurl = this.encodeSpaceInUrl(data.originalurl);
		data.attachurl = this.encodeSpaceInUrl(data.attachurl);
		data.thumburl = data.thumburl || data.imageurl.replace(/\/image\//gm, '/P150x100/');
		  
		if(!data.dispElId) {
			data.dispElId = Trex.Util.getDispElId();
		}
		var _seq = ((data.tmpSeq)? this.entryBox.syncSeq(data.tmpSeq): this.entryBox.newSeq());
		var _data = Object.extend({ 
			dataSeq: _seq
		}, data); //NOTE: Cuz IE
		return _data;
	},
	createEntry: function(data, type) {
		return this.createAttachment(data, type);
 	},
	encodeSpaceInUrl: function(url){
		if ( !url ) {
			return ;
		}
		
		return url.replace(/ /g, "%20");	
	},
	execAttach: function(data, type) {
		var _entry = this.createEntry(this.getDataForEntry(data), type);
		_entry.execRegister();
	},
	execReload: function(data, content, type) {
		var _entry = this.createEntry(this.getDataForEntry(data, content), type);
		_entry.execReload();
	}
});

/**
 * Trex.Attachment.Image 
 * 
 *  @example
 *  	data = {
 *			thumburl: "string",
 *			imageurl: "string",
 *			filename: "string",
 *			filesize: number
 *		}
 * @class
 * @extends Trex.Attachment
 */
Trex.Attachment.Image = Trex.Class.create({
	$const: {
		__Identity: 'image'
	},
	$extend: Trex.Attachment,
	getFieldAttr: function(data) {
		return {
			name: 'tx_attach_image', 
			value: [data.thumburl, data.imageurl, data.originalurl, data.exifurl, data.filename, data.filesize].join('|')
		};
	},
	getBoxAttr: function(data) {
		var _nameMaxLength = 50;
		var _filename = data.filename;
		var _rectangle = data.width ? data.width + "x" + data.height + " / " : ""; 

		if(_filename.getRealLength() > _nameMaxLength) {
			var _nameArr = _filename.split(".");
			if(_nameArr.length>1) {
				var _ext = _nameArr.pop().substr(0,4);
				var _name = _nameArr.join(".").cutRealLength(_nameMaxLength - 2);
				_filename = _name + "." + _ext;
			} else {
				_filename = _nameArr.join(".").cutRealLength(_nameMaxLength - 2);
			}
		}
		return {
			name: _filename + " (" + _rectangle + data.filesize.toByteUnit() + ")",
			image: data.thumburl
		};
	},
	getObjectAttr: function(data) {
		var _objattr = Object.extend({}, this.actor.config.objattr);
		if(data.width) {
			if(!_objattr.width || _objattr.width > data.width) {
				_objattr.width = data.width;
			}
		} else {
			_objattr.width = _NULL;
		}
		if(data.height) {
			if(!_objattr.height || _objattr.height > data.height) {
				_objattr.height = data.height;
			}
		} else {
			_objattr.height = _NULL;
		}
		_objattr.alt = data.alt || data.caption || data.filename;            
		return _objattr;
	},
	/**
	 * object\uc758 style \uac12\uc744 \uac00\uc838\uc628\ub2e4.
	 * @function
	 */
	getObjectStyle: function(data) {
		var _objstyle = {};
		if(this.actor.config.objstyle) {
			_objstyle = Object.extend(_objstyle, this.actor.config.objstyle);
		}
		if(data.imagealign) {
			var _objectStyle = {
				"L": Trex.Tool.AlignLeft,
				"C": Trex.Tool.AlignCenter,
				"FL": Trex.Tool.AlignRight,
				"FR": Trex.Tool.AlignFull
			}[data.imagealign];
			if (_objectStyle && _objectStyle.__ImageModeProps && _objectStyle.__ImageModeProps['image']) {
				_objstyle = Object.extend(_objstyle, _objectStyle.__ImageModeProps['image']['style']);
			}
		}
		return _objstyle;
	},
	/**
	 * object\ub97c \uac10\uc2f8\uace0 \uc788\ub294 paragraph tag \uc758 style \uac12\uc744 \uac00\uc838\uc628\ub2e4.
	 * @function
	 */
	getParaStyle: function(data) {
		var _parastyle = Object.extend({}, this.actor.config.parastyle || this.actor.config.defaultstyle);
		if(data.imagealign) {
			var _objectStyle = {
				"L": Trex.Tool.AlignLeft,
				"C": Trex.Tool.AlignCenter,
				"FL": Trex.Tool.AlignRight,
				"FR": Trex.Tool.AlignFull
			}[data.imagealign];
			if (_objectStyle && _objectStyle.__ImageModeProps && _objectStyle.__ImageModeProps['paragraph']) {
				_parastyle = Object.extend(_parastyle, _objectStyle.__ImageModeProps['paragraph']['style']);
			}
		}
		return _parastyle;
	},
	getSaveHtml: function(data) {
		return "<img src=\"" + data.imageurl + "\" class=\"txc-image\"/>";
	},
	getDispHtml: function(data) {
		return "<img id=\"" + data.dispElId + "\" src=\"" + data.imageurl + "\" class=\"txc-image\"/>";
	},
	getDispText: function(data) {
		return "<img src=\"" + data.imageurl + "\" class=\"txc-image\"/>";
	},
	getRegLoad: function(data) {
		return new RegExp("<(?:img|IMG)[^>]*src=\"?" + data.imageurl.getRegExp() + "\"?[^>]*\/?>", "gim");
	},
	getRegHtml: function(data) {
		return new RegExp("<(?:img|IMG)[^>]*src=\"?" + data.imageurl.getRegExp() + "\"?[^>]*\/?>", "gim");
	}, 
	getRegText: function(data) {
		return new RegExp("<(?:img|IMG)[^>]*src=\"?" + data.imageurl.getRegExp() + "\"?[^>]*\/?>", "gim");
	}
});

/**
 * @fileoverview 
 * File \uc5c5\ub85c\ub4dc \uad00\ub828 Source
 * Trex.Tool.File - UI,
 * Trex.Attacher.File,
 * Trex.Attachment.File,
 * default configuration\ub97c \ud3ec\ud568\ud558\uace0 \uc788\ub2e4.
 */
TrexConfig.addTool(
	"file",
	{
		disabledonmobile: _TRUE,
		wysiwygonly: _TRUE,
		sync: _FALSE,
		status: _FALSE
	}
);

TrexMessage.addMsg({
	'@file.title': "\ud30c\uc77c"
});

/**
 * Trex.Tool.File
 * @class
 * @extends Trex.Tool
 */
Trex.Tool.File = Trex.Class.create({
	/** ignore */
	$const: {
		__Identity: 'file'
	},
	/** ignore */
	$extend: Trex.Tool,
	oninitialized: function() {
		var _editor = this.editor;
		this.weave.bind(this)(
			new Trex.Button(this.buttonCfg), 
			_NULL,
			function() {
				_editor.getSidebar().getAttacher("file").execute();
			}
		);
	}
});

TrexConfig.addAttacher(
	"file",
	{
		LayerBox: _TRUE,
		multiple: _TRUE,
		multipleuse: _FALSE,
		checksize: _TRUE,
		boxonly: _TRUE,
		wysiwygonly: _FALSE,
		features: { left:250, top:65, width:450, height:404 },
		title: '\ud30c\uc77c \uc5c5\ub85c\ub4dc',
		width: 430,
		height: 260,
		position: 'top',
		popPageUrl: "#Upload&mode=file"
	},
	function(root){
		var _config = TrexConfig.getAttacher("file", root);
		_config.popPageUrl = TrexConfig.getUrl(_config.popPageUrl);
		_config.features = TrexConfig.getPopFeatures(_config.features);
	}
);

/**
 * Trex.Attacher.File
 * @class
 * @extends Trex.Attacher
 */
Trex.Attacher.File = Trex.Class.create({
	/** @ignore */
	$const: {
		__Identity: 'file'
	},
	/** @ignore */
	$extend: Trex.Attacher,
	name: 'file',
	title: TXMSG("@file.title"),
	canModified: _TRUE,
	canResized: _FALSE,
	oninitialized: function() {
	},
	getKey: function(data) {
		return data.key || data.attachurl;
	},
	/**
	 * data\ub97c editor\uc5d0 \ub9de\uac8c parsing\ud560\ub54c \ubd88\ub9ac\ub294 methond
	 * @memberOf Trex.Attacher.File.prototype
	 * @param {Object} data
	 */
	getDataForEntry: function(data) {
		if(!data.dispElId) {
			data.dispElId = Trex.Util.getDispElId();
		}
		var _seq = ((data.tmpSeq)? this.entryBox.syncSeq(data.tmpSeq): this.entryBox.newSeq());
		var _ext = data.filename.split(".").pop().toLowerCase();
		var _thumburl;
		switch(_ext){
			case "jpg":
			case "gif":
			case "png":
			case "bmp":
				_thumburl = data.attachurl.replace("/attach/", "/thumbnail/");
				break;
			default :
				_thumburl = Trex.Util.thumburl(_ext);
		}
		var _data = Object.extend({
			dataSeq: _seq,
			thumburl: _thumburl,
			prevurl: Trex.Util.prevurl(data.filename.split(".").pop().toLowerCase())
		}, data); //NOTE: Cuz IE
		return _data;
	}
});

/**
 * Trex.Attachment.File 
 * 
 *  @example
 *  	data = {
 *			attachurl: "string",
 *			filename: "string",
 *			filesize: number,
 *			filemime: "string"
 *		}
 * @class
 * @extends Trex.Attachment
 */
Trex.Attachment.File = Trex.Class.create({
	/** @ignore */
	$const: {
		__Identity: 'file'
	},
	/** @ignore */
	$extend: Trex.Attachment,
	getFieldAttr: function(data) {
		return {
			name: 'tx_attach_file',
			value: [data.attachurl, data.filesize, data.filename].join('|')
		};
	},
	getBoxAttr: function(data) {
		var _nameMaxLength = 64;
		var _filename = data.filename;
		if(_filename.getRealLength() > _nameMaxLength) {
			var _nameArr = _filename.split(".");
			if(_nameArr.length>1) {
				var _ext = _nameArr.pop().substr(0,4);
				var _name = _nameArr.join(".").cutRealLength(_nameMaxLength - 2);
				_filename = _name + "." + _ext;
			} else {
				_filename = _nameArr.join(".").cutRealLength(_nameMaxLength - 2);
			}
		}
		return {
			name: _filename + " (" + data.filesize.toByteUnit() + ")",
			image: data.thumburl
		};
	},
	/**
	 * object\uc758 style \uac12\uc744 \uac00\uc838\uc628\ub2e4.
	 * @function
	 */
	getObjectStyle: function(data) {
		var _objstyle = {};
		if(this.actor.config.objstyle) {
			_objstyle = Object.extend(_objstyle, this.actor.config.objstyle);
		}
		if(data.imagealign) {
			var _objectStyle = {
				"L": Trex.Tool.AlignLeft,
				"C": Trex.Tool.AlignCenter,
				"FL": Trex.Tool.AlignRight,
				"FR": Trex.Tool.AlignFull
			}[data.imagealign];
			if (_objectStyle && _objectStyle.__TextModeProps && _objectStyle.__TextModeProps['image']) {
				_objstyle = Object.extend(_objstyle, _objectStyle.__TextModeProps['button']['style']);
			}
		}
		return _objstyle;
	},
	/**
	 * object\ub97c \uac10\uc2f8\uace0 \uc788\ub294 paragraph tag \uc758 style \uac12\uc744 \uac00\uc838\uc628\ub2e4.
	 * @function
	 */
	getParaStyle: function(data) {
		var _parastyle = Object.extend({}, this.actor.config.parastyle || this.actor.config.defaultstyle);
		if(data.imagealign) {
			var _objectStyle = {
				"L": Trex.Tool.AlignLeft,
				"C": Trex.Tool.AlignCenter,
				"FL": Trex.Tool.AlignFull,
				"FR": Trex.Tool.AlignRight
			}[data.imagealign];
			if (_objectStyle && _objectStyle.__TextModeProps && _objectStyle.__TextModeProps['paragraph']) {
				_parastyle = Object.extend(_parastyle, _objectStyle.__TextModeProps['paragraph']['style']);
			}
		}
		return _parastyle;
	},
	getSaveHtml: function(data) {
		return "<a href=\"" + data.attachurl + "\"><img src=\"" + data.prevurl + "\"/> " + data.filename + "</a>";
	},
	getDispHtml: function(data) {
		return "<button id=\"" + data.dispElId + "\" class=\"txc-file\"><img class=\"tx-unresizable\" src=\"" + data.prevurl + "\" ld=\"" + data.attachurl + "\"/> " + data.filename + "</button>";
	},
	getDispText: function(data) {
		return "[" + TXMSG("@file.title") + ":" + data.dataSeq + "]";
	},
	getRegLoad: function(data) {
		return new RegExp("<(?:a|A)\\s*href=\"?" + data.attachurl.getRegExp() + "[^\"]*\"?[^>]*><(?:img|IMG)[^>]*\/?>[\\S\\s]*?<\/(?:a|A)>", "gm");
	},
	getRegHtml: function(data) {
		return new RegExp("<(?:button|BUTTON)[^>]*id=\"?" + data.dispElId + "\"?[^>]*>[\\S\\s]*?" + data.attachurl.getRegExp() + "[\\S\\s]*?<\/(?:button|BUTTON)>", "gm");
	},
	getRegText: function(data) {
		return new RegExp("\\[" + TXMSG("@file.title") + ":" + data.dataSeq + "\\]", "gm");
	}
});
/**
 * Tool 'External' Source,
 *     
 */
TrexConfig.addTool(
	"photoedit",
	{
		disabledonmobile: _TRUE,
		wysiwygonly: _TRUE,
		sync: _FALSE,
		status: _FALSE
	}
);

Trex.Tool.photoedit = Trex.Class.create({
	$const: {
		__Identity: 'photoedit'
	},
	$extend: Trex.Tool,
	oninitialized: function() {
		var _canvas = this.canvas;

		var _toolHandler = function() {
			_canvas.getProcessor().blur();
			_canvas.focus();						
		};

		this.weave.bind(this)(
			new Trex.Button(this.buttonCfg),
			_NULL,
			this.handler
		);
	},
	handler: function() {
		Trex.Tool.External('photoedit');
	}
});

TrexMessage.addMsg({
	'@youtube.title': "Youtube"
});

TrexConfig.addTool(
	"youtube",
	{
		disabledonmobile: _TRUE,
		wysiwygonly: _TRUE,
		sync: _FALSE,
		status: _FALSE
	}
);

Trex.Tool.YouTube = Trex.Class.create({
	$const: {
		__Identity: 'youtube'
	},
	$extend: Trex.Tool,
	oninitialized: function() {
		var _editor = this.editor;
		this.weave.bind(this)(
			new Trex.Button(this.buttonCfg), 
			_NULL,
			function() {
				_editor.getSidebar().getEmbeder("youtube").execute();
			}
		);
	}
});

TrexConfig.addEmbeder(
	"youtube",
	{
		LayerBox: _TRUE,
		wysiwygonly: _FALSE,
		features: { left:250, top:65, width:651, height:510 },
		title: 'You Tube',
		width: 768,
		height: 464,
		position: 'top',
		btn: 'top',
		popPageUrl: "/in/common_youtube"
	},
	function(root){
		var _config = TrexConfig.getEmbeder("youtube", root);
		_config.popPageUrl = TrexConfig.getUrl(_config.popPageUrl);
		_config.features = TrexConfig.getPopFeatures(_config.features);
	}
);

(function() {
	Trex.Embeder.YouTube = Trex.Class.create({
		$const: {
			__Identity: 'youtube'
		},
		$extend: Trex.Embeder,
		name: 'youtube',
		title: TXMSG("@youtube.title"),
		canResized: _TRUE
	});
	
	Trex.register("filter > youtube ", function(editor, toolbar, sidebar){
		var _config = sidebar.embeders.gmaps.config;
	});
})();

TrexMessage.addMsg({
	'@gmaps.title': "Google Maps"
});

TrexConfig.addTool(
	"gmaps",
	{
		disabledonmobile: _TRUE,
		wysiwygonly: _TRUE,
		sync: _FALSE,
		status: _FALSE
	}
);

Trex.Tool.GMaps = Trex.Class.create({
	$const: {
		__Identity: 'gmaps'
	},
	$extend: Trex.Tool,
	oninitialized: function() {
		var _editor = this.editor;
		this.weave.bind(this)(
			new Trex.Button(this.buttonCfg), 
			_NULL,
			function() {
				_editor.getSidebar().getEmbeder("gmaps").execute();
			}
		);
	}
});

TrexConfig.addEmbeder(
	"gmaps",
	{
		LayerBox: _TRUE,
		wysiwygonly: _FALSE,
		features: { left:250, top:65, width:797, height:644 },
		title: 'Google Maps',
		width: parseInt($(window).width()*0.8),
		height: parseInt($(window).height()*0.8),
		position: 'top',
		popPageUrl: "/in/common_gmap.child"
	},
	function(root){
		var _config = TrexConfig.getEmbeder("gmaps", root);
		_config.popPageUrl = TrexConfig.getUrl(_config.popPageUrl);
		_config.features = TrexConfig.getPopFeatures(_config.features);
	}
);

(function() {
	Trex.Embeder.GMaps = Trex.Class.create({
		$const: {
			__Identity: 'gmaps'
		},
		$extend: Trex.Embeder,
		name: 'gmaps',
		title: TXMSG("@gmaps.title"),
		canResized: _TRUE
	});
	
	Trex.register("filter > gmaps ", function(editor, toolbar, sidebar){
		var _config = sidebar.embeders.gmaps.config;
	});
})();

TrexConfig.addTool(
	"media",
	{
		wysiwygonly: _TRUE,
		sync: _FALSE,
		status: _FALSE
	}
);

TrexMessage.addMsg({
	'@media.title': "\uba40\ud2f0\ubbf8\ub514\uc5b4",
	'@media.prev.url': "#iconpath/spacer2.gif",
	'@media.prev.url.tvpot': "#iconpath/img_multi_tvpot.gif",
	'@media.prev.url.wmp': "#iconpath/spacer2.gif"
});
	
Trex.Tool.Media = Trex.Class.create({
	$const: {
		__Identity: 'media'
	},
	$extend: Trex.Tool,
	oninitialized: function() {
		var _editor = this.editor;
		this.weave.bind(this)(
			new Trex.Button(this.buttonCfg), 
			_NULL,
			function() {
				_editor.getSidebar().getEmbeder("media").execute();
			}
		);
	}
});

TrexConfig.addEmbeder(
	"media",
	{
		wysiwygonly: _TRUE,
		useCC: _FALSE,
		features: {
			left:250, 
			top:65, 
			width:458, 
			height:568,
			resizable:"yes"
		},
		popPageUrl: "/in/common_embed",
		allowNetworkingFilter: _FALSE,
		allowNetworkingSites: []
	},
	function(root) {
		var _config = root.sidebar.embeder.media; 
		_config.popPageUrl = TrexConfig.getUrl(_config.popPageUrl);
		_config.features = TrexConfig.getPopFeatures(_config.features);
	}
);

(function() {
	Trex.Embeder.Media = Trex.Class.create({
		$const: {
			__Identity: 'media'
		},
		$extend: Trex.Embeder,
		name: 'media',
		title: TXMSG("@media.title"),
		canResized: _TRUE,
		getCreatedHtml: function(data){
			var _source = data.code || this.makeSourceByUrl(data.url);
			return convertToHtml(_source);
		},
		getDataForEntry: function(){
			//This function is not needed anymore but absence may generate initializing error. So remained...
		},
        makeSourceByUrl: function(url) {
            var ext = this.getUrlExt(url);
            var size = getDefaultSizeByUrl(url);

            switch (ext) {
                case "swf":
                    return this.generateHTMLForFlash(url, size);
                case "mp3":
                case "wma":
                case "asf":
                case "asx":
                case "mpg":
                case "mpeg":
                case "wmv":
                case "avi":
                case "mp4":
                case "mkv":		
                    return this.generateHTMLForMoviePlayer(url, size);
                case "mov":
                    return this.generateHTMLForQuicktime(url, size);
                case 'jpg':
                case 'bmp':
                case 'gif':
                case 'png':
                    return this.generateHTMLForImage(url, size);
                default:
                    var iframeHtml = this.generateHTMLIfIframeSource(url, size);
                    if (iframeHtml) {
                        return iframeHtml;
                    }

                    return this.generateHTMLForDefaultEmbed(url, size);
            }
        },
        getUrlExt: function(url) {
            return url.split(".").pop().split("?")[0].toLowerCase();
        },
        getAllowScriptAccess: function(url) {
            var allowScriptAccessAttr = " allowScriptAccess='never'";
            if (this.config.allowNetworkingFilter && isAllowNetworkingSite(url, this.config) == _FALSE) {
                allowScriptAccessAttr += " allowNetworking='internal'";
            }
            return allowScriptAccessAttr;
        },
        generateHTMLForDefaultEmbed: function (url, size) {
            return "<embed src=\"" + url + "\" width='" + size.width + "' height='" + size.height + "' " + this.getAllowScriptAccess(url) + " ></embed>";
        },
        generateHTMLForImage: function (url, size) {
            return "<img src=\"" + url + "\" border=\"0\"/>";
        },
        generateHTMLForFlash: function (url, size) {
            return "<embed src=\"" + url + "\" quality='high' " + this.getAllowScriptAccess(url) + " type='application/x-shockwave-flash' allowfullscreen='true' pluginspage='http://www.macromedia.com/go/getflashplayer' wmode='transparent' width='" + size.width + "' height='" + size.height + "'></embed>";
        },
        generateHTMLForMoviePlayer: function (url, size) {
            return "<embed src=\"" + url + "\" type=\"application/x-mplayer2\" pluginspage=\"http://www.microsoft.com/Windows/MediaPlayer/\" width='" + size.width + "' height='" + size.height + "'></embed>";
        },
        generateHTMLForQuicktime: function (url, size) {
            return "<embed src=\"" + url + "\" type=\"video/quicktime\" pluginspage=\"http://www.apple.com/quicktime/download/indext.html\" width='" + size.width + "' height='" + size.height + "'></embed>";
        },
        generateHTMLIfIframeSource: function(url, size) {
            var tvpotKey = getTvPotKey(url);
            if (tvpotKey) {
                return "<iframe src=\"http://videofarm.daum.net/controller/video/viewer/Video.html?play_loc=undefined&vid=" + tvpotKey + "\" width='"+size.width+"' height='"+size.height+"' frameborder=\"0\" allowfullscreen></iframe>";
            }

            var youtubeMovieKey = getYouTubeMovieKey(url);
            if (youtubeMovieKey) {
                return "<iframe src=\"http://www.youtube.com/embed/" + youtubeMovieKey + "\" width='"+size.width+"' height='"+size.height+"' frameborder=\"0\" allowfullscreen></iframe>";
            }

            return _NULL;
        }
	});
	
	Trex.register("filter > media ", function(editor, toolbar, sidebar){
		var _config = sidebar.embeders.media.config;
		editor.getDocParser().registerFilter('filter/embeder/media', {
			'text@load': function(contents){
				return contents;
			},
			'source@load': function(contents){
				return convertToHtml(contents);
			},
			'html@load': function(contents){
				return convertToHtml(contents);
			},
			'text4save': function(contents){
				return contents;
			},
			'source4save': function(contents){
				contents = convertFromHtml(contents);
				contents = addFlashOptAllowNetworking(contents, _config);
				return contents;
			},
			'html4save': function(contents){
				contents = convertFromHtml(contents);
				contents = addFlashOptAllowNetworking(contents, _config);
				return contents;
			},
			'text2source': function(contents){
				return contents;
			},
			'text2html': function(contents){
				return contents;
			},
			'source2text': function(contents){
				return contents;
			},
			'source2html': function(contents){
				return convertToHtml(contents);
			},
			'html2text': function(contents){
				return convertFromHtml(contents);
			},
			'html2source': function(contents){
				return convertFromHtml(contents);
			}
		});
	});

	function isAllowNetworkingSite (url, config) {
		var _matchs, host, i, len;
		host = "";
		_matchs = /[\/]*\/\/([^\/]+)\//i.exec(url);
		if (_matchs && _matchs[1]) {
			host = _matchs[1];
		}
		len = config.allowNetworkingSites.length;
		for (i = 0; i < len; i += 1) {
			if (host == config.allowNetworkingSites[i].host) {
                return _TRUE;
            }
		}
		return _FALSE;
	}
	
	function addFlashOptAllowNetworking (content, config) {
		var filteredContent;
		if (config.allowNetworkingFilter == _FALSE) {
			return content;
		}
		filteredContent = content.replace(/(<object[^>]*>)((?:\n|.)*?)(<\/object>)/gi, function(match, start, param, end) {
			var _matchs, _matchsForUrl;
            var isBlockContent = _FALSE;
            _matchs = /data[\s]*=[\s"']*(http:\/\/[^\/]+\/)[^("'\s)]+/i.exec(start);
            if(_matchs && _matchs.length == 2) {
                _matchsForUrl = _matchs[1];
                if (isAllowNetworkingSite(_matchsForUrl, config) === _FALSE){
                    isBlockContent = _TRUE;
                }
            }
            _matchs = /<param[^>]*=[^\w]*movie[^\w]+[^>]*>/i.exec(param);
            if (_matchs && _matchs[0]) {
                _matchsForUrl = /\s+value=["']?([^\s"']*)["']?/i.exec(_matchs[0]);
                if (_matchsForUrl && _matchsForUrl[1]) {
                    if (isAllowNetworkingSite(_matchsForUrl[1], config) === _FALSE) {
                        isBlockContent = _TRUE;
                    }
                }
            }
            _matchs = /<param[^>]*=[^\w]*src[^\w]+[^>]*>/i.exec(param);
            if (_matchs && _matchs[0]) {
                _matchsForUrl = /\s+value=["']?([^\s"']*)["']?/i.exec(_matchs[0]);
                if (_matchsForUrl && _matchsForUrl[1]) {
                    if (isAllowNetworkingSite(_matchsForUrl[1], config) === _FALSE) {
                        isBlockContent = _TRUE;
                    }
				}
			}
            if (isBlockContent === _TRUE) {
                param = param.replace(/<param[^>]*=[^\w]*allowNetworking[^\w]+[^>]*>/i, "");
                param = '<param name="allowNetworking" value="internal" />'.concat(param);
            }
			return start + param + end;
		});
		filteredContent = filteredContent.replace(/(<embed)([^>]*)(><\/embed>|\/>)/gi, function(match, start, attr, end) { //NOTE: #FTDUEDTR-1071 -> #FTDUEDTR-1105
			var _matchs = /\s+src=["']?([^\s"']*)["']?/i.exec(attr);
			if (_matchs && _matchs[1]) {
				if (isAllowNetworkingSite(_matchs[1], config)) {
					return start + attr + end;
				}
			}
			attr = attr.replace(/\s+allowNetworking=["']?[\w]*["']?/i, "").concat(' allowNetworking="internal"');
			return start + attr + end;
		});
		return filteredContent;
	}
	
	function convertFromHtml(content){
		var _matchs;
		var _regLoad = new RegExp("<(?:img|IMG)[^>]*txc-media[^>]*\/?>", "gim");
		var tempContent = content;
		
		while ((_matchs = _regLoad.exec(tempContent)) != _NULL) {
			var _html = _matchs[0];
			var _source = getSourceByExt(_html);
			if (!$tx.msie && _source.indexOf("$") > -1) {
				_source = _source.replace(/\$/g, "$$$$");
			}
			content = content.replace(_html, _source);
		}
		
		return content;
	}
		
	function convertToHtml(content) {
		if ($tx.msie) { //NOTE: #FTDUEDTR-366 + #FTDUEDTR-372 -> #FTDUEDTR-403
            if ($tx.msie_ver < 10) {
                content = content.replace(/<iframe[^>]*src=("|'|)https?:\/\/www\.youtube\.com\/embed\/(\w+)\1[^>]*><\/iframe>/i, function (html, quote, vid) {
                    var matched, width, height;
                    matched = html.match(/\swidth=['"]?(\d+)/);
                    width = (matched && matched[1]) || "560";
                    matched = html.match(/\sheight=['"]?(\d+)/);
                    height = (matched && matched[1]) || "315";
                    return '<object width="' + width + '" height="' + height + '"><param name="movie" ' + 'value="https://www.youtube.com/v/' + vid + '?version=3&amp;hl=ko_KR" /><param name="allowFullScreen" value="true" /><param name="allowscriptaccess" value="always" /><param name="wmode" value="transparent" /><embed src="https://www.youtube.com/v/' + vid + '?version=3&amp;hl=ko_KR" type="application/x-shockwave-flash" width="' + width + '" height="' + height + '" allowscriptaccess="always" allowfullscreen="true" wmode="transparent"></embed></object>';
                });
            }
            if(/<object/.test(content) && /<embed[^>]*type=['"]application\/x-shockwave-flash['"][^>]*>/i.test(content) &&!/<object[^>]*type=['"]application\/x-shockwave-flash['"][^>]*>/i.test(content)) {
                var index = content.indexOf('>');
                content = content.substring(0,index)+ ' type="application\/x-shockwave-flash"' + content.substring(index);
            }
//			content = content.replace(/(<object[^>]*>)((?:\n|.)*?)(<\/object>)/gi, function(match, start, param, end) {
//				param = param.replace(/<param[^>]*=[^\w]*wmode[^\w]+[^>]*>/i, "");
//				param = param.replace(/<param[^>]*=[^\w]*play[^\w]+[^>]*>/i, "");
//				param = '<param name="wmode" value="transparent" />'.concat(param);
//				return start + param + end;
//			});
//			content = content.replace(/(<embed)([^>]*)(>)/gi, function (match, start, attr, end) {
//				attr = attr.replace(/\s+wmode=("|'|)\w*\1/i, '');
//				attr += ' wmode=transparent';
//				return start + attr + end;
//			});

			return content;
		} else {
			var _matchs, _source, _html, _embed;
			var tempContent = content;

			/* Substitute <embed tag within script to <xxembed */
			var _regScript = new RegExp("<(?:script)[^>]*>[\\S\\s]*?(<(?:embed|EMBED)[^>]*src=[^>]*>)[\\S\\s]*?<\/(?:script)>", "gim");
			while ((_matchs = _regScript.exec(tempContent)) != _NULL) {
				_source = _matchs[0];
				_html = _source.replace(/<embed/i, "<xxembed");
				content = content.replace(_source, _html);
			}
			var _regLoad = new RegExp("<(?:object|OBJECT)[^>]*>[\\S\\s]*?(<(?:embed|EMBED)[^>]*src=[^>]*>)[\\S\\s]*?<\/(?:object|OBJECT)>", "gim");
			while ((_matchs = _regLoad.exec(tempContent)) != _NULL) {
				_source = _matchs[0];
				_embed = _matchs[1];
				_html = getHtmlByExt(_source, _embed);
				content = content.replace(_source, _html);
			}

			_regLoad = new RegExp("<(?:embed|EMBED)[^>]*src=[^>]*(?:\/?>|><\/(?:embed|EMBED)>)", "gim");
			while ((_matchs = _regLoad.exec(tempContent)) != _NULL) {
				_source = _matchs[0];
				_embed = _matchs[0];
				_html = getHtmlByExt(_source, _embed);
				content = content.replace(_source, _html);
			}

			content = content.replace(/<xxembed/i, "<embed");
			return content;
		}
	}
	
	function getHtmlByExt(source, embed) {
		var _attrs = Trex.Util.getAllAttributesFromEmbed(embed);
		var _url = _attrs['src'];
		var _width = _attrs['width'].isPercent()?_attrs['width']:(_attrs['width'] || " ").parsePx();
		var _height = _attrs['height'].isPercent()?_attrs['height']:(_attrs['height'] || " ").parsePx();
		if(parseInt(_width, 10) === 0 || parseInt(_height, 10) ===0) {
			var _size = getDefaultSizeByUrl(_url);
			_width = _size.width;
			_height = _size.height;
		}
		
		/* make new embed source */
		var _newEmbedSrc = "<embed";
		for( var name in _attrs ){
            if (_attrs.hasOwnProperty(name)) {
                _newEmbedSrc += " " + name + "=\""+_attrs[name]+"\"";
            }
		}
		_newEmbedSrc += ">";
		
		/* If source has 'object' then it is needed to add 'object' TAG */
		var arr = source.split(embed);
		source = arr[0] + _newEmbedSrc;
		for( var i = 1; i < arr.length; i++){
			source += arr[i];
		} 
		
		var _prev = getPreviewByUrl(_url);
		return "<img src=\"" + _prev.imageSrc + "\" width=\"" + _width + "\" height=\"" + _height + "\" border=\"0\" class=\"tx-entry-embed txc-media" + _prev.className + "\" ld=\"" + encodeURIComponent(source) + "\"/>";
	}
	
	function getSourceByExt(html) {
		var _attrs = Trex.Util.getAllAttributes(html);
		var _longdesc = _attrs['ld'];
		if(!_longdesc || _longdesc.length == 0) {
			return "";
		}
		var _width = _attrs['width'];
		var _height = _attrs['height'];
		var _source = decodeURIComponent(_longdesc);
		
		var _embed = _source;
		if(_source.indexOf("object") > -1 || _source.indexOf("OBJECT") > -1) {
			var _matchs;
			var _regLoad = new RegExp("<(?:embed|EMBED)[^>]*src=[^>]*(?:\/?>|><\/(?:embed|EMBED)>)", "gim");
			while ((_matchs = _regLoad.exec(_source)) != _NULL) {
				_embed = _matchs[0];
			}
		}
		
		_attrs = Trex.Util.getAllAttributes(_embed);
		var _url = _attrs['src'];
		var _size = getDefaultSizeByUrl(_url);
		if(isNaN(_width)) {
			_source = Trex.String.changeAttribute(_source, "width", _width, _size.width);
		} else {
			_source = Trex.String.changeAttribute(_source, "width", _width, _width);
		}
		if(isNaN(_height)) {
			_source = Trex.String.changeAttribute(_source, "height", _height, _size.height);
		} else {
			_source = Trex.String.changeAttribute(_source, "height", _height, _height);
		}
		return _source;
	}
	
    function getTvPotKey(url) {
        return (url.match(/http:\/\/tvpot\.daum\.net\/v\/(.{23})/) || [])[1];
    }

    function getYouTubeMovieKey(url) {
        return (url.match(/(?:http:\/\/)?(?:www\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=)?(.+)/) || [])[1];
    }

	function getDefaultSizeByUrl(url) {
		var _width, _height;
		if(url.indexOf("api.bloggernews.media.daum.net/static/recombox1") > -1) {
			_width = 400;
			_height = 80;
		} else if(url.indexOf("flvs.daum.net/flvPlayer") > -1) {
			_width = 502;
			_height = 399;
        } else if(url.indexOf('youtube') != -1 || url.indexOf('youtu.be') != -1 || url.indexOf('tvpot.daum.net') != -1) {
            var size = TrexConfig.get('size');
            if (size.contentWidth > 640) {
                _width = 640;
                _height = 360;
            } else {
                _width = 560;
                _height = 315;
            }
            // else 853x480
		} else {
			var _ext = url.split(".").pop().split("?")[0].toLowerCase();
			switch (_ext) {
				case "mp3":
				case "wma":
				case "asf":
				case "asx":
				case "m4a":				
					_width = 280;
					_height = 45;
					break;
				case "mpg":
				case "mpeg":
				case "wmv":
				case "avi":
				case "mp4":
				case "mkv":								
					_width = 320;
					_height = 285;
					break;
				default:
					_width = 400;
					_height = 300;
					break;
			}
		}
		return {
			width: _width,
			height: _height
		};
	}
	
	function getPreviewByUrl(url) {
		var _class = "";
		var _image = "";
		if(url.indexOf("api.bloggernews.media.daum.net/static/recombox1") > -1) {
			_class = "";
			_image = TXMSG("@media.prev.url");
		} else if(url.indexOf("flvs.daum.net/flvPlayer") > -1) {
			_class = " txc-media-tvpot";
			_image = TXMSG("@media.prev.url.tvpot");
		} else {
			var _ext = url.split(".").pop().split("?")[0].toLowerCase();
			switch (_ext) {
				case "mp3":
				case "wma":
				case "asf":
				case "asx":
					_class = " txc-media-wmp";
					_image = TXMSG("@media.prev.url.wmp");
					break;
				case "mpg":
				case "mpeg":
				case "wmv":
				case "avi":
					_class = " txc-media-wmp";
					_image = TXMSG("@media.prev.url.wmp");
					break;
				default:
					_class = "";
					_image = TXMSG("@media.prev.url");
					break;
			}
		}
		return {
			className: _class,
			imageSrc: _image
		};
	}
	
})();

// TODO change message!
TrexMessage.addMsg({
	'@canvas.unload.message': "\uc791\uc131\ud558\uc2e0 \ub0b4\uc6a9\uc774 \uc800\uc7a5\ub418\uc9c0 \uc54a\uc558\uc2b5\ub2c8\ub2e4. \ud398\uc774\uc9c0\ub97c \ub5a0\ub098\uc2dc\uaca0\uc2b5\ub2c8\uae4c?",
	'@canvas.unload.message.at.modify': "\uc791\uc131\ud558\uc2e0 \ub0b4\uc6a9\uc774 \uc800\uc7a5\ub418\uc9c0 \uc54a\uc558\uc2b5\ub2c8\ub2e4. \ud398\uc774\uc9c0\ub97c \ub5a0\ub098\uc2dc\uaca0\uc2b5\ub2c8\uae4c?"
});

Trex.install("editor.isDisableUnloadHandler & editor.setDisableUnloadHandler", function(editor) {
    var _beforeUnloadCheck = _TRUE;
    editor.isDisableUnloadHandler = function() {
        return _beforeUnloadCheck;
    };
    editor.setDisableUnloadHandler = function() {
        _beforeUnloadCheck = _FALSE;
    };
    editor.setEnableUnloadHandler = function() {
        _beforeUnloadCheck = _TRUE;
    };
});
	
Trex.module("observing beforeunload event",
	function(editor, toolbar, sidebar, canvas, config) {
		var _evConfig = config.events;
		var _validator = new Trex.Validator();
		$tx.observe(window, 'beforeunload', function(ev) {
			if (editor.isDisableUnloadHandler()) {
				if (_evConfig.preventUnload) {
					canvas.fireJobs(Trex.Ev.__CANVAS_BEFORE_UNLOAD);
					if (_validator.exists(canvas.getContent())) { //NOTE: \uc791\uc131\ud55c \uae00\uc774 \uc788\uc744 \uacbd\uc6b0\uc5d0\ub9cc \ud655\uc778
						ev.returnValue = TXMSG("@canvas.unload.message");
						return TXMSG("@canvas.unload.message");
					}
				}
			}
		}, _FALSE);
	}
);
	
/**
 * @fileoverview
 * \uc5d0\ub514\ud130\uc758 \uc774\ubbf8\uc9c0\ub97c \uc120\ud0dd\uc2dc \ud234\ubc14\uc758 align icon\uc744 \ubcc0\uacbd\uc2dc\ud0a4\ub294 module
 */

TrexMessage.addMsg({
	'@align.image.align.center': "\uac00\uc6b4\ub370\uc815\ub82c",
	'@align.image.align.full': "\uc624\ub978\ucabd\uae00\ud750\ub984",
	'@align.image.align.left': "\uc67c\ucabd\uc815\ub82c",
	'@align.image.align.right': "\uc67c\ucabd\uae00\ud750\ub984",
	'@align.text.align.center': "\uac00\uc6b4\ub370\uc815\ub82c (Ctrl+.)",
	'@align.text.align.full': "\uc591\ucabd\uc815\ub82c",
	'@align.text.align.left': "\uc67c\ucabd\uc815\ub82c (Ctrl+,)",
	'@align.text.align.right': "\uc624\ub978\ucabd\uc815\ub82c (Ctrl+/)"
});

Trex.module("Register an eventhandler in order to change align icons upon toolbar when user click a specific image or not.",
	function(editor, toolbar, sidebar, canvas){
		var _imageAlignModeClass = "tx-selected-image";
		var _alignset = [	
			toolbar.tools['alignleft'], toolbar.tools['aligncenter'], toolbar.tools['alignright'], toolbar.tools['alignfull']	
		];
		var _excludes = Trex.__EXCLUDE_IMG;
			
		var _changeButton = function(kind) {
			var _exec = function(tool, kind, title){
				if (!tool) {
					return;
				}
				var _elList = _NULL;
				var _elIcon = _NULL;	
				if(!_elList) {
					_elList = $tom.find(tool.button.elButton, "li");
				}
				if(!_elIcon) {
					_elIcon = $tx(tool.button.elIcon);
				}	
				_elIcon.title = title;
				if(kind == "image") {
					if(!$tx.hasClassName(_elList, _imageAlignModeClass)) {
						$tx.addClassName(_elList, _imageAlignModeClass);
					}
					tool.imageAlignMode = _TRUE;
				} else {
					if($tx.hasClassName(_elList, _imageAlignModeClass)) {
						$tx.removeClassName(_elList, _imageAlignModeClass);
					}
					tool.imageAlignMode = _FALSE;
				}
			};
			_exec(_alignset[0], kind, kind=="image" ? TXMSG("@align.image.align.left") : TXMSG("@align.text.align.left"));
			_exec(_alignset[1], kind, kind=="image" ? TXMSG("@align.image.align.center") : TXMSG("@align.text.align.center"));
			_exec(_alignset[2], kind, kind=="image" ? TXMSG("@align.image.align.right") : TXMSG("@align.text.align.right"));
			_exec(_alignset[3], kind, kind=="image" ? TXMSG("@align.image.align.full") : TXMSG("@align.text.align.full"));
		};

		canvas.observeJob(Trex.Ev.__CANVAS_SELECT_ITEM, function(){
			var el;
			if($tom.kindOf(canvas.getProcessor().getControlByAreaSelection(), 'table')){
				_changeButton("image");
			}
			if($tom.kindOf(el = canvas.getProcessor().getControlByAreaSelection(), 'img')){
				var matched = Trex.Util.getMatchedClassName(el, _excludes);
				if(matched||$tom.find(el, 'button')){
					_changeButton("text");
				}else {
					_changeButton("image");
				}

			}
        });
        canvas.observeJob(Trex.Ev.__CANVAS_UNSELECT_ITEM, function(){
			_changeButton("text");
        });

	}
);


// NOTE \uc804\uccb4\uc801\uc73c\ub85c refactoring \ud544\uc694
Trex.module("make padding area inside Canvas with editor width",
	function(editor, toolbar, sidebar, canvas) {
        var _wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
        if (!_wysiwygPanel) {
            return;
        }
        var _elWysiwyg = _wysiwygPanel.el;

        var SCROLL_WIDTH = 16;
        var REQUIRED_MINIMUM_PADDING = 28;
        var BORDER_OF_CANVAS = 2;

        var _elLeftSpace;
        var _elRightSpace;
        var _elLeftSpaceChild;
        var _elRightSpaceChild;

		var sizeConfig = canvas.getSizeConfig();
		var currentCanvasWidth = canvas.getContainerWidth();
		var contentWidth = sizeConfig.contentWidth.toNumber();
        var contentPadding = sizeConfig.contentPadding.toNumber();
		var fixedContentWidth = (currentCanvasWidth > contentWidth);	// canvas.js: _sizeConfig.contentWidth = _sizeConfig.wrapWidth \uc640 \uc5bd\ud78c \ubb38\uc81c\uc784.

        //\ubc30\uacbd\uc774 \uc801\uc6a9\ub418\uc5c8\uc744 \uacbd\uc6b0 \uc0ac\uc774\uc988\ub97c \ubcc0\uacbd\ud55c\ub2e4.
        canvas.observeJob('canvas.apply.background', function(data) {
        	adjustCanvasPadding({
                top: (data && data.topLeftHeight)? data.topLeftHeight.parsePx(): 0,
                right: (data && data.midRightWidth)? data.midRightWidth.parsePx(): 0,
                bottom: (data && data.botLeftHeight)? data.botLeftHeight.parsePx(): 0,
                left: (data && data.midLeftWidth)? data.midLeftWidth.parsePx(): 0
            });
        });

        //NOTE: \uba54\uc77c, \ud3b8\uc9c0\uc9c0\uac00 \uc801\uc6a9\ub418\uc5c8\uc744 \uc5d0\ub514\ud130 \uc601\uc5ed\uc758 \ud328\ub529\uc744 \uc870\uc815\ud55c\ub2e4.
        canvas.observeJob('canvas.apply.letterpaper', function(data) {
        	adjustCanvasPadding({
                top: (data && data.topHeight)? data.topHeight.parsePx(): 0,
                right: (data && (data.midColor || data.midUrl))? contentPadding: 0,
                bottom: (data && data.botHeight)? data.botHeight.parsePx(): 0,
                left: (data && (data.midColor || data.midUrl))? contentPadding: 0
            });
        });

        // contentWidth\uac00 \uc9c0\uc815\ub41c \uacbd\uc6b0\ub9cc, \ud328\ub529\uc744 \uc870\uc815\ud560 \ud544\uc694\uac00 \uc788\ub2e4.
        if(fixedContentWidth) {

            // iframe\uc774 \ub85c\ub529\ub418\uba74 \ud328\ub529\uc601\uc5ed\uc744 \ucd94\uac00\ud55c\ub2e4.
            canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function() {
                adjustCanvasPadding();
                createGuideArea();
                updatePaddingSpace();
            });
    
            //\ubaa8\ub4dc\ub97c \ubcc0\uacbd\ud558\uc600\uc744 \uacbd\uc6b0 \ud328\ub529\uc601\uc5ed \ucc98\ub9ac
            canvas.observeJob(Trex.Ev.__CANVAS_MODE_CHANGE, function() {
            	adjustGuidAreaPosition();
            	updatePaddingSpace();
            });
    		
    		//\uc5d0\ub514\ud130 \ub798\ud37c\uc758 \ub108\ube44\uac00 \ubcc0\ud558\uc600\uc744 \uacbd\uc6b0 \ud328\ub529\uc601\uc5ed\uc758 \uc704\uce58\ub97c \uc870\uc808\ud55c\ub2e4.
            canvas.observeJob(Trex.Ev.__CANVAS_WRAP_WIDTH_CHANGE, onCanvasWidthChanged);
            canvas.observeJob(Trex.Ev.__CANVAS_NORMAL_SCREEN_CHANGE, onCanvasWidthChanged);
            canvas.observeJob(Trex.Ev.__CANVAS_FULL_SCREEN_CHANGE, onCanvasWidthChanged);


            // \uc544\ub798 \ucf54\ub4dc\uc758 \ud544\uc694\uc131\uc740 \ud655\uc778 \ud544\uc694
            if (!$tx.msie_nonstd) {
                if ($tx.gecko) {
                    $tx.setStyle(_elWysiwyg, {
                        overflowX: 'auto',
                        overflowY: 'auto'
                    });
                } else if ($tx.chrome){
                    $tx.setStyle(_elWysiwyg.contentDocument.documentElement, {
                        overflowX: 'auto',
                        overflowY: 'auto'
                    });
                } else {
                    $tx.setStyle(_elWysiwyg, {
                        overflowX: 'auto',
                        overflowY: 'scroll'
                    });
                }
            }
        }

		canvas.getCanvasGuideSize = function(){
			return calculdateGuideArea().leftWidth.parsePx();
		};
        
        function adjustCanvasPadding(skinStyle) {
        	_wysiwygPanel.addStyle(calculdateCanvasPadding(skinStyle));
        }

        //iframe \ud328\ub529\uacfc \ud328\ub529\uc601\uc5ed\uc758 \uc0ac\uc774\uc988\ub97c \uacc4\uc0b0\ud55c\ub2e4.
        function calculdateCanvasPadding(skinStyle) {
        	var canvasPadding = {};
        	var direction = ['top', 'bottom', 'left', 'right'];
        	
        	for (var i = 0; i < direction.length; i++) {
        		var key = direction[i];
        		canvasPadding[key] = (skinStyle && skinStyle[key]) || contentPadding;
        	}
            
            if (fixedContentWidth) {
            	canvasPadding.left = Math.max(Math.ceil(getGuideAreaWidth()), 0);
            	canvasPadding.right = Math.max(Math.floor(getGuideAreaWidth()), 0);	// for quirks mode

            	return {
            		width: contentWidth.toPx(),
            		paddingLeft: "0",
            		paddingRight: "0",
            		paddingTop: canvasPadding.top.toPx(),
            		paddingBottom: canvasPadding.bottom.toPx(),
            		marginLeft: canvasPadding.left.toPx(),
            		marginRight: canvasPadding.right.toPx()
            	};
            } else {
            	return {
            		paddingTop: canvasPadding.top.toPx(),
            		paddingRight: canvasPadding.right.toPx(),
            		paddingBottom: canvasPadding.bottom.toPx(),
            		paddingLeft: canvasPadding.left.toPx()
            	};
            }
        }

        function getGuideAreaWidth() {
        	return (currentCanvasWidth - contentWidth - BORDER_OF_CANVAS - SCROLL_WIDTH) / 2;
        }
        
        function calculdateGuideArea() {
			var _guideAreaWidth = getGuideAreaWidth();
            if(_guideAreaWidth < REQUIRED_MINIMUM_PADDING) {
                return {
                    leftWidth: '0',
                    rightWidth: '0',
                    rightPos: '0'
                };
            } else {
                return { 
                    leftWidth: Math.ceil(_guideAreaWidth - contentPadding).toPx(),
					rightWidth: Math.max(0, (Math.floor(_guideAreaWidth - contentPadding))).toPx(),
                    rightPos: (contentWidth + Math.ceil(_guideAreaWidth + contentPadding)).toPx()
                };
            }
        }
        
        function isGuideAreaCreated() {
        	return _elLeftSpace && _elRightSpace;
        }

		var queuedJob;
        function onCanvasWidthChanged() {
        	// for quirks mode
    		clearTimeout(queuedJob);
        	queuedJob = setTimeout(function() {
        		currentCanvasWidth = canvas.getContainerWidth();
        		adjustPanelPandding();
        	}, 4);
        }

        function adjustPanelPandding() {
        	adjustCanvasPadding();
            adjustGuidAreaPosition();
            updatePaddingSpace();
        }
        
        function createGuideArea() {
	        var canvasTextColor = canvas.getStyleConfig().color;
	        
            _elLeftSpace = tx.div({ className: "tx-wysiwyg-padding" });
            _elLeftSpaceChild = tx.div({
            	className: "tx-wysiwyg-padding-divL",
                style: {
                    borderColor: canvasTextColor
                }
            });

            _elRightSpace = tx.div({ className: "tx-wysiwyg-padding" });
            _elRightSpaceChild = tx.div({
            	className: "tx-wysiwyg-padding-divR",
                style: {
                	borderColor: canvasTextColor
                }
            });

    		var _elHolder = canvas.wysiwygEl;
            _elLeftSpace.appendChild(_elLeftSpaceChild);
            _elHolder.insertBefore(_elLeftSpace, _elWysiwyg);
            _elRightSpace.appendChild(_elRightSpaceChild);
            _elHolder.insertBefore(_elRightSpace, _elWysiwyg);
            
            adjustGuidAreaPosition();
        }
        
        function adjustGuidAreaPosition() {
            if (isGuideAreaCreated()) {
                var _guideAreaSizes = calculdateGuideArea();
                
                $tx.setStyle(_elLeftSpace, {
                    width: _guideAreaSizes.leftWidth
                });
                $tx.setStyle(_elRightSpace, {
                    width: _guideAreaSizes.rightWidth,
                    left: _guideAreaSizes.rightPos
                });
    
                var enoughSpaceForGuideArea = _guideAreaSizes.leftWidth.parsePx() > REQUIRED_MINIMUM_PADDING;
                var showGuideArea = canvas.getConfig().showGuideArea;
                var guideAreaBorder = enoughSpaceForGuideArea && showGuideArea ? "1px solid" : "0 none";
                	
                $tx.setStyle(_elLeftSpaceChild, {
                    borderRight: guideAreaBorder,
                    borderBottom: guideAreaBorder
                });
                $tx.setStyle(_elRightSpaceChild, {
                    borderLeft: guideAreaBorder,
                    borderBottom: guideAreaBorder
                });
            }
        }
        
        function updatePaddingSpace() {
        	if (isGuideAreaCreated()) {
            	if (canvas.mode == Trex.Canvas.__WYSIWYG_MODE) {
    				$tx.show(_elLeftSpace);
    				$tx.show(_elRightSpace);
                } else {
    				$tx.hide(_elLeftSpace);
    				$tx.hide(_elRightSpace);
                }
        	}
        }
    }
);


Trex.module("Register an eventhandler in order to resize block and edit search results & some images in wysiwig panel.",
	function(editor, toolbar, sidebar, canvas) {
		
		if ($tx.msie_nonstd) {
			var _blockResizeHandler = function(element) {
				if (element.onresizestart == _NULL) {
					element.onresizestart = function() {
						return _FALSE;
					};
				}
			};
			canvas.observeElement({ tag: "img", klass: "tx-unresizable" }, _blockResizeHandler);
			canvas.observeElement({ tag: "img", klass: "tx-entry-attach" }, _blockResizeHandler);
			canvas.observeElement({ tag: "img", klass: "txc-footnote" }, _blockResizeHandler);
			canvas.observeElement({ tag: "iframe", klass: "txc-map" }, _blockResizeHandler); 
		}
		
		var _blockSelectHandler;
		if ($tx.msie_nonstd) {
			_blockSelectHandler = function(element) {
				element.setAttribute("unselectable", "on");
				$A(element.getElementsByTagName("*")).each(function(child) {
					if (child.nodeName.charAt(0) != "/") {
						child.setAttribute("unselectable", "on");
					}
				});
				var _processor = canvas.getProcessor();
				_processor.selectControl(element);
			};
		} else {
			_blockSelectHandler = function(element) {
				var _processor = canvas.getProcessor();
				_processor.selectControl(element);
				throw $stop;
			};
		}
		canvas.observeElement({ tag: "button" }, _blockSelectHandler);
		canvas.observeElement({ tag: "img" }, function(element) {
			var _button = $tom.find(element, 'button');
			if(_button) {
				_blockSelectHandler(_button);
				throw $stop;
			} 
		});
	}
);	


Trex.module("in order to save history for image resizing on IE",
	function(editor, toolbar, sidebar, canvas/*, config*/){
		var _history = canvas.history;
		var _prevImageStatus = {};
		var _imageNode = _NULL;
		 
		canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEDOWN, function(ev){
			var node = $tx.element(ev);
			if ( node && node.tagName && node.tagName.toLowerCase() == "img" ){
				_imageNode = node;
				_prevImageStatus = $tom.getPosition(node);
			}
		});
	
		canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEUP, function() {
			if ( _imageNode ) {
				var isChanged = _FALSE;
				try {
					var _curImageStatus = $tom.getPosition(_imageNode);
					for(var _name in _curImageStatus ){
						if ( _curImageStatus[_name] != _prevImageStatus[_name] ){
							isChanged = _TRUE;
						}					
					}
					if ( isChanged ){
						_history.saveHistory();
					}
				} catch(e){
				} finally{
					_imageNode = _NULL;	
				}
			}
		});
	}
);

Trex.module("Add layer to display notice message on editor area before editing", //NOTE: #FTDUEDTR-18
	function (editor, toolbar, sidebar, canvas, config) {
		if (config.initializedMessage) {
			canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function () {
				var _initializedId = config.initializedId;
				var _noticeDiv = tx.div({ id:"tx-canvas-notice"+_initializedId, className:"tx-canvas-notice"}, config.initializedMessage);
				var txLoading = $tx("tx_loading"+_initializedId);
				var txLoadingParent = txLoading.parentNode;
				txLoadingParent.insertBefore(_noticeDiv, txLoading);

				var disappeared = false;
				var _noticeDivHandler = function () {
					if (!disappeared && $tx("tx-canvas-notice"+_initializedId)) {
						disappeared = true;
                        txLoadingParent.removeChild(_noticeDiv);
						canvas.focus();
					}
				};

				setTimeout(function () {
					$tx.observe(canvas.getPanel('html').getWindow(), 'focus', _noticeDivHandler);
				}, 30);
				$tx.observe(_noticeDiv, "click", _noticeDivHandler);
				canvas.observeJob(Trex.Ev.__CANVAS_DATA_INITIALIZE, _noticeDivHandler);
				toolbar.observeJob(Trex.Ev.__TOOL_CLICK, _noticeDivHandler);
			});
		}
	}
);


Trex.module('register drag and drop attacher on canvas', function(editor, toolbar, sidebar, canvas, config){
    if (!_WIN.FileReader || !config.canvas.dropZone.use) {
        return;
    }

    var dropZone = new Trex.DropZone(editor, sidebar, canvas, config.canvas.dropZone);
    editor.getDropZone = function(){
        return dropZone;
    };
});

Trex.register("filter > dropzone",
    function(editor) {
        function toRegExp(str){
            return str.replace(/([\\^$(){}[\]+*?.])/g,'\\$1');
        }

        function removeWaiting(_content) {
            return _content.replace(getHTMLWaitingRegExp(),'').replace(getSourceWaitingRegExp(), '');
        }

        function getHTMLWaitingRegExp() {
            return RegExp('<img[^>]*'+toRegExp(Trex.__WAITING_IMG_SRC)+'[^>]*id=[\'"](.*)[\'"][^>]*>','g')
        }

        function getSourceWaitingRegExp() {
            return RegExp('\\[Uploading:([a-zA-Z\\d_]*)\\]', 'g');
        }

        function changeWaitingSourceToHTML(contents) {
            if (!editor.hasOwnProperty('getDropZone')) {
                return contents;
            }
            var dropZone = editor.getDropZone();

            return contents.replace(getSourceWaitingRegExp(), function(match, p1, offset) {
                var imgContents = dropZone.getTempImageContents(p1);
                if(imgContents == _NULL) {
                    return dropZone.createIndicator(p1);
                }
                var _entry = _attachBox.getEntries().find(function(entry) {
                    return (entry.data.dispElId == p1);
                });
                _entry && _entry.setExistStage(true);
                return imgContents;
            })
        }

        var _attachBox = editor.getAttachBox();
        var _docparser = editor.getDocParser();
        _docparser.registerFilter(
            'filter/dropzone', {
                'source@load': function(contents){
                    return removeWaiting(contents);
                },
                'html@load': function(contents){
                    return removeWaiting(contents);
                },
                'source4save': function(contents){
                    contents = changeWaitingSourceToHTML(contents);
                    return removeWaiting(contents);
                },
                'html4save': function(contents){
                    return removeWaiting(contents);
                },
                'text4save': function(contents){
                    return contents;
                },
                'html2text': function(contents) {
                    return removeWaiting(contents);
                },
                'source2text': function(contents) {
                    return removeWaiting(contents);
                },
                'source2html': function(contents){
                    return changeWaitingSourceToHTML(contents);
                },
                'html2source': function(contents){
                    if (!editor.hasOwnProperty('getDropZone')) {
                        return contents;
                    }
                    return contents.replace(getHTMLWaitingRegExp(), function(match, p1, offset) {
                        return '[Uploading:'+p1+']';
                    });
                }
            });
})

Trex.MarkupTemplate.add('module.dropZone',
        '<div style="display: table; left:0px; top:0px; width:0px; height:0px; z-index:9999; border-spacing:6px; position:absolute;">\
        <div style="display:table-row">\
        <div style="background-color:white; border:4px dashed #cfcfcf; display:table-cell; opacity: .8; vertical-align:middle">\
        <div style="font-size: 40px; color:#cfcfcf; text-align:center;">\uc5ec\uae30\uc5d0 \ud30c\uc77c \ub193\uae30</div></div></div></div>');

Trex.DropZone = Trex.Class.create({
    initialize: function(editor, sidebar, canvas, config) {
        this.editor = editor;
        this.sidebar = sidebar;
        this.canvas = canvas;
        this.config = config;

        this.useFileUpload = config.useFileUpload;
        this.useImageUpload = config.useImageUpload;

        this.dataType = ["text/html", "text/uri-list", "text/plain", "Files"];

        this.imgContents = {};

        this.cover = this._createCover();
        this.coverShow = _FALSE;
        this._canvasObserveJobs();
    },
    _createCover: function() {
        var cover = Trex.MarkupTemplate.get("module.dropZone").evaluateAsDom({});
        return cover;
    },
    _canvasObserveJobs: function() {
        var self = this;

        var debounceHideDragArea = $tx.debounce(function() {
            self.hideDragArea();
        }, 100);

        var dragOverHandler = function(ev) {
            if(self._checkDragType(ev) != -1) {
                self.showDragArea();

                debounceHideDragArea();
            }
        };

        this.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_DRAGOVER, dragOverHandler);
        $tx.observe(_WIN, "dragover", dragOverHandler);
        $tx.observe(_WIN, "drop", function(ev) {
            self._checkDragType(ev);
        });

        $tx.observe(this.cover, "drop", function(ev) {
            self._dropHandler(ev);
        });

        this.canvas.observeJob(Trex.Ev.__CANVAS_MODE_CHANGE, function(from, to) {
            if (from == to) return;

            if (to == Trex.Canvas.__WYSIWYG_MODE) {
                self.imgContents = {};
            }
        });
    },
    _checkDragType: function(ev) {
        var dataType = this.dataType;
        var dt = ev.dataTransfer || _NULL;

        var typeIndex = -1;

        if (this.canvas.isWYSIWYG() && dt) {
            $A(dt.types).each(function(type) {
                var index = dataType.indexOf(type);

                if (index < typeIndex || typeIndex == -1) {
                    $tx.stop(ev);
                    typeIndex = index;
                }
            });
        }

        return typeIndex;
    },
    showDragArea: function() {
        if(this.coverShow) {
            return;
        }

        var _iframe = this.canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE).el;
        var _iframeRect = $tx.getOffset(_iframe);

        $tom.applyStyles(this.cover, {left: _iframeRect.left.toPx(),
                                      top: _iframeRect.top.toPx(),
                                      width: (_iframeRect.right - _iframeRect.left).toPx(),
                                      height: (_iframeRect.bottom - _iframeRect.top).toPx()});
        $tom.insertNext(this.cover, _DOC.body);


        this.coverShow = _TRUE;
    },
    hideDragArea: function() {
        $tom.remove(this.cover);
        this.coverShow = _FALSE;
    },
    _dropHandler: function(ev) {
        var typeIndex = this._checkDragType(ev);

        if (typeIndex != -1) {
            var processor = this.canvas.getProcessor();
            if (processor.savedRange) {
                processor.savedRange.select();
            }

            this.hideDragArea();
            this.canvas.getProcessor().getAreaSelection().reset();

            var type = this.dataType[typeIndex];

            var dt = ev.dataTransfer;
            if (type == "Files") {
                this.attachFiles($A(dt.files));
            } else {
                this.attachHtml(dt.getData(type));
            }
            $tx.stop(ev);
        }
    },
    attachFiles: function(files) {
        if (!files || !files.length) {
            return;
        }
        var self = this;
        var overfiles = [];
        var overfile;

        files.each(function(file){
            if (self.useImageUpload && file.type && file.type.split('/')[0].toUpperCase() == 'IMAGE') {
                overfile = self.attachImage(file);
            } else if (self.useFileUpload) {
                overfile = self.attachFile(file);
            }

            if (overfile) {
                overfiles.push(overfile);
            }
        });

        this.alertMessage(overfiles);
    },
    attachFile: function(file) {
    },
    attachImage: function(file) {
        var self = this;
        var _indicatorId = this.insertIndicator();

        var reader = new FileReader();
        $tx.observe(reader, 'loadend', function(e) {
            var data = {};
            data.imageurl = this.result;
            self._execAttach(data, _indicatorId);
        });
        reader.readAsDataURL(file);
    },
    attachHtml: function(data) {
        var paster = this.editor.getPaster();

        paster.pasteHTML(data);
    },
    insertIndicator: function() {
        var _indicatorID = Trex.Util.getDispElId();

        this.canvas.getProcessor().pasteContent(this.createIndicator(_indicatorID), _TRUE);
        return _indicatorID;
    },
    createIndicator:function(id) {
        return '<img src='+Trex.__WAITING_IMG_SRC+' width=16 height=16 id='+id+'>';
    },
    _getIndicator:function(id) {
        if (this.canvas.isWYSIWYG()) {
            var wysiwygDoc = this.canvas.getCurrentPanel().getDocument();
            var indicator = $tom.collect(wysiwygDoc, "#" + id);

            return indicator;
        }
        return _NULL;
    },
    _removeIndicator: function(id){
        if (!id || id == "") {
            return;
        }
        if (this.canvas.isWYSIWYG()) {
            var indicator = this._getIndicator(id);

            if (indicator) {
                goog.dom.removeNode(indicator);
            }
        } else {
            this.imgContents[id] = "";
        }
    },
    _execAttach: function(data, replaceNodeId) {
        var self = this;
        if (data.hasOwnProperty('imageurl')) {

            this.canvas.execute(function(processor) {
                var _img = _DOC.createElement('img');
                _img.src = data.imageurl;
                $tom.addStyles(_img, {'clear':'none', 'float': 'none'});

                if (self.canvas.isWYSIWYG()) {
                    var replaceNode = self._getIndicator(replaceNodeId);

                    if (replaceNode) {
                        goog.dom.replaceNode(_img, replaceNode);
                    }
                }
                else {
                    self.imgContents[replaceNodeId] = goog.dom.getOuterHtml(_img);
                }
            });
        }
    },
    getTempImageContents:function(id) {
        return this.imgContents[id] || _NULL;
    },
    alertMessage: function(overfiles) {
        if (!overfiles || overfiles.length == 0) {
            return;
        }

        var msg = [];
        msg.push('check your files\n');

        var overfile;
        for (var i=0;i< overfiles.length; i++) {
            overfile = overfiles[i];
            msg.push("\n" + overfile.name);
            if(overfile.size) {
                msg.push(" (" + overfile.size.toByteUnit() + ")");
            }
        }
        this.alertTimeout(msg.join(""));
    },
    alertTimeout: function(msg) {
        setTimeout(function(){
            alert( msg );
        },1);
    }
})
/*jslint onevar: false, nomen: false*/
/*global Trex, TrexMessage, TXMSG, $tom, $tx, _FALSE, _NULL, _TRUE */
Trex.MarkupTemplate.add('table.col.resize.dragger', '<div class="tx-table-col-resize-dragger" style="position:absolute; overflow:hidden; top: 0; left: 0; width: 3px; height: 100%; cursor:col-resize;"><\/div>');
Trex.MarkupTemplate.add('table.row.resize.dragger', '<div class="tx-table-row-resize-dragger" style="position:absolute; overflow:hidden; top: 0; left: 0; width: 100%; height: 3px; cursor:row-resize;"><\/div>');

TrexMessage.addMsg({
	'@table.noselect.alert': "\ud14c\uc774\ube14\uc744 \uc120\ud0dd\ud558\uc2e0 \ud6c4 \uc0ac\uc6a9\uac00\ub2a5\ud569\ub2c8\ub2e4."
});

Trex.Table = {};
Trex.module("table selector", function (editor, toolbar, sidebar, canvas, config) {
	var initDragger;
	initDragger = function (canvas) {
		var colDragger, rowDragger, wysiwygEl;
		colDragger = Trex.MarkupTemplate.get("table.col.resize.dragger").evaluateAsDom({});
		rowDragger = Trex.MarkupTemplate.get("table.row.resize.dragger").evaluateAsDom({});
		wysiwygEl = canvas.wysiwygEl;
		$tom.insertFirst(wysiwygEl, colDragger);
		$tom.insertFirst(wysiwygEl, rowDragger);
		$tx.hide(colDragger);
		$tx.hide(rowDragger);
	};
    canvas.observeJob(Trex.Ev.__CANVAS_PANEL_BACKSPACE_TABLE, function(node) {
        $tom.remove(node);
        //var rng = goog.dom.Range.createFromNodeContents(node, true);
        //rng.select();
    });
	canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function () {
		var tableSelect, tableMerge, tableInsert, tableDelete, tableBorder, tableTemplateLoader, tableResize;
	
		tableSelect = new Trex.Table.Selector(editor, config);
		tableMerge = new Trex.Table.Merge(editor, config);
		tableInsert = new Trex.Table.Insert(editor, config);
		tableDelete = new Trex.Table.Delete(editor, config);
		tableBorder = new Trex.Table.Border(editor, config);
		tableResize = new Trex.Table.Resize(editor, config);
		tableTemplateLoader = new Trex.Table.TemplateLoader();

		initDragger(canvas);
		
		var wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
		var processor = wysiwygPanel.getProcessor();
		/**
		 * selectCellByCaret
		 * \uce90\ub7ff\uc758 \uc704\uce58\uc5d0 \ud574\ub2f9\ud558\ub294 cell \uc744 \uc120\ud0dd\ud55c\ub2e4.
		 */
		var selectCellByCaret = function () {
			var node, td;
			if (tableSelect.getSelected().isValid() === _FALSE) {
				node = processor.getNode();
				td = Trex.TableUtil.getClosestByTagNames(["td", "th"], node);
				if (td) {
					tableSelect.selectByTd(td, td);
				}
			}
		};
		/**
		 * table \uc744 \uc120\ud0dd\ud558\uba74 advanced \uac00 \uc5f4\ub9bc.
		 * //CHECK: 
		 * table \ubc84\ud2bc\ub4e4\uc758 \uc704\uce58\uac00 advanced \ub77c\uace0 \uac00\uc815\ud558\uace0 \uc788\uc74c.
		 */
		canvas.observeElement({
			tag: 'table'
		}, function (elem) {
			if (toolbar.tools.advanced) {
				toolbar.tools.advanced.forceOpen();
			}
		});
		/**
		 * border \ub97c \uc801\uc6a9\ud558\uae30 \uc704\ud55c 4\uac00\uc9c0 \uc635\uc158\uac12.
		 */
		var borderProperty = {
			range: "all",
			color: "",
			height: 1,
			type: "solid"
		};
		var setDefaultBorderProperty = function () {
			var tool = toolbar.tools.cellslinecolor;
			if (tool) {
				borderProperty.color = tool.config.defaultcolor;
			}
		};
		setDefaultBorderProperty();
		
		var alertFromNoSelect = function () {
			alert(TXMSG('@table.noselect.alert'));
		};
		
		processor.table = {
			/**
			 * getTdArr
			 * \uc120\ud0dd\ud55c cell \ub4e4\uc758 array. 
			 * //CHECK: getSelectedCells ?
			 * \uc9c0\uae08\ubcf4\ub2c8 \uc774\ub984\uc774 \ub9c8\uc74c\uc5d0 \ub4e4\uc9c0 \uc54a\ub124...
			 * @return {Array}
			 */
			getTdArr: function () {
				return tableSelect.getSelectedTdArr();
			},
			/**
			 * isDuringSelection
			 * \uc120\ud0dd\uc744 \ud558\uace0 \uc788\ub294 \uc911\uc778\uc9c0 \uc5ec\ubd80(\uc120\ud0dd\uc744 \uc704\ud55c \ub4dc\ub798\uadf8 \uc911).
			 * @return {boolean}
			 */
			isDuringSelection: function () {
				return tableSelect.isDuringSelection();
			},
			
			execute: function (fn, noCaretSelect) {
				if (! noCaretSelect) {
					selectCellByCaret();
				}
				if (tableSelect.getSelected().isValid()) {
					fn();
					canvas.history.saveHistory();
				} else {
					alertFromNoSelect();
				}
			},
			
			merge: function () {
				this.execute(function () {
					tableMerge.merge(tableSelect);
				}, _TRUE);
			},
			resetMerge: function () {
				this.execute(function () {
					tableMerge.resetMerge(tableSelect);
				});
			},
			insertRowAbove: function () {
				this.execute(function () {
					tableInsert.insertRowAbove(tableSelect);
				});
			},
			insertRowBelow: function () {
				this.execute(function () {
					tableInsert.insertRowBelow(tableSelect);
				});
			},
			insertColLeft: function () {
				this.execute(function () {
					tableInsert.insertColLeft(tableSelect);
				});
			},
			insertColRight: function () {
				this.execute(function () {
					tableInsert.insertColRight(tableSelect);
				});
			},
			deleteRow: function () {
				this.execute(function () {
					tableDelete.deleteRow(tableSelect);
				});
			},
			deleteCol: function () {
				this.execute(function () {
					tableDelete.deleteCol(tableSelect);
				});
			},
			
			setBorderRange: function (outlineType) {
				borderProperty.range = outlineType;
			},
			setBorderColor: function (color) {
				borderProperty.color = color;
				toolbar.fireJobs(Trex.Ev.__TOOL_CELL_LINE_CHANGE, {
					color: color
				});
			},
			setBorderHeight: function (height) {
				borderProperty.height = height;
				toolbar.fireJobs(Trex.Ev.__TOOL_CELL_LINE_CHANGE, {
					height: height
				});
			},
			setBorderType: function (type) {
				borderProperty.type = type;
				toolbar.fireJobs(Trex.Ev.__TOOL_CELL_LINE_CHANGE, {
					type: type
				});
			},
			setNoBorder: function () {
				var self = this;
				this.execute(function () {
					tableBorder.setTableSelect(tableSelect);
					tableBorder.setBorderRange("all");
					tableBorder.changeBorderColor(self.getTdArr(), "");
					tableBorder.changeBorderHeight(self.getTdArr(), "0");
					tableBorder.changeBorderType(self.getTdArr(), "none");
				});
			},
			setBorderButtons: function (color, height, type) {
				var tool;
				tool = toolbar.tools.cellslinecolor;
				if (tool) {
					tool.execute(color);
				}
				tool = toolbar.tools.cellslineheight;
				if (tool) {
					tool.execute(height);
				}
				tool = toolbar.tools.cellslinestyle;
				if (tool) {
					tool.execute(type);
				}
			},
			getBorderProperty: function () {
				return {
					color: borderProperty.color,
					height: borderProperty.height,
					type: borderProperty.type
				};
			},
			applyBorder: function () {
				var self = this;
				this.execute(function () {
					tableBorder.setTableSelect(tableSelect);
					tableBorder.setBorderRange(borderProperty.range);
					tableBorder.changeBorderColor(self.getTdArr(), borderProperty.color);
					tableBorder.changeBorderHeight(self.getTdArr(), borderProperty.height);
					tableBorder.changeBorderType(self.getTdArr(), borderProperty.type);
					self.addBorderHistory();
				});
			},
			addBorderHistory: function () {
				var tool;
				tool = toolbar.tools.cellslinepreview;
				if (tool) {
					tool.addBorderHistory(borderProperty);
				}
			},

			tableBackground: function (value) {
				var self = this;
				value = value || 'transparent';
				this.execute(function () {
					var style, tdArr, i, len;
					style = {
						"backgroundColor": value
					};
					tdArr = self.getTdArr();
					len = tdArr.length;
					for (i = 0; i < len; i += 1) {
						$tx.setStyle(tdArr[i], style);
					}
					tableSelect.reset();
				});
			},
			
			setTemplateStyle: function (table, templateIndex) {
				if (table) {
					var self = this;
					tableTemplateLoader.getTemplate(templateIndex, function(template) {
						template.apply(table);
						self._applyTemplateOutline(table, template.templateData);
						tableSelect.reset();
					});
				} else {
					alertFromNoSelect();
				}
			},
            /**
             * \ud14c\uc774\ube14 \ud15c\ud50c\ub9bf\uc744 \uc801\uc6a9\ud574\ub3c4 \ud14c\ub450\ub9ac\uc5d0 \ub300\ud55c \uc815\ud655\ud55c \uc801\uc6a9\uc774 \ub418\uc9c0\uc54a\uc544 \ud770\uc0c9 \ud639\uc740 none\uc758 \uc0c1\ud0dc\uac00 \ub41c\ub2e4.
             * \uc774\ub97c \ubcf4\uc644\ud558\uae30 \uc704\ud574\uc11c \ud14c\uc774\ube14 \uae30\ubcf8 \uae30\ub2a5\uc744 \uc774\uc6a9\ud574\uc11c \ud14c\ub450\ub9ac\ub97c \uc7ac\uc124\uc815 \ud55c\ub2e4.
             *
             * @param table
             * @param templateData
             * @private
             */
            _applyTemplateOutline: function(table, templateData) {
                var item = templateData;
                var self = this;
                var outlineBorder = {
                    top: this._parseBorderStyle(item.firstRow.borderTop),
                    right: this._parseBorderStyle(item.lastCol.borderRight || item.common.borderRight),
                    bottom: this._parseBorderStyle(item.lastRow.borderBottom || item.common.borderBottom),
                    left: this._parseBorderStyle(item.firstCol.borderLeft)
                };

                var tableMatrixer = new Trex.Tool.Table.TableCellMatrixer(table);
                var tdMatrix = tableMatrixer.getTdMatrix();
                var rowSize = tableMatrixer.getRowSize();
                var colSize = tableMatrixer.getColSize();

                if (tdMatrix && tdMatrix.length) {
                    tableSelect.selectByTd(tdMatrix[0][0], tdMatrix[rowSize-1][colSize-1]);
                    tableBorder.setTableSelect(tableSelect);

                    var direction = ['top', 'right', 'bottom', 'left'];
                    direction.each(function(dir){
                        tableBorder.setBorderRange(dir);
                        tableBorder.changeBorderColor(self.getTdArr(), outlineBorder[dir]['color']);
                        tableBorder.changeBorderHeight(self.getTdArr(), outlineBorder[dir]['height']);
                        tableBorder.changeBorderType(self.getTdArr(), outlineBorder[dir]['type']);
                    });
                }
            },
            /**
             * border style\uc744 \ud30c\uc2f1\ud574\uc11c object\ub85c \ubc18\ud658\ud55c\ub2e4.
             *
             * ex1. "1px solid red"
             * ex2. "none"
             *
             * @param styleString
             * @returns {object}
             * @private
             */
            _parseBorderStyle: function(styleString) {
                styleString = styleString.trim().toLowerCase();
                if (styleString === 'none') {
                    return {
                        height: 'none',
                        type: 'solid',
                        color: 'transparent'
                    };
                } else {
                    var parts = styleString.split(' ');
                    if (parts.length != 3) {
                        parts = ['1px', 'solid', '#000'];
                    }
                    return {
                        height: parts[0].parsePx() || 1,
                        type: parts[1],
                        color: parts[2]
                    };
                }
            },
            /**
             *
             * @param {Object} data
             * @param {Boolean=} isDifference
             */
            resize: function(data, isDifference){
                this.execute(function () {
                    if(data.width != null)
                        tableResize.resize(tableSelect,'WIDTH', data.width, isDifference);
                    if(data.height != null)
                        tableResize.resize(tableSelect, 'HEIGHT', data.height, isDifference);
                });
            }
		};
		
		toolbar.fireJobs(Trex.Ev.__TOOL_CELL_LINE_CHANGE, {
			color: borderProperty.color,
			height: borderProperty.height,
			type: borderProperty.type,
			fromInit: _TRUE
		});
		
		toolbar.observeJob(Trex.Ev.__TOOL_CLICK, function (identity) {
			if ([
				"fontfamily",
				"fontsize",
				"bold",
				"underline",
				"italic",
				"strike",
				"forecolor",
				"backcolor",
	            "indent",
	            "outdent",
				"alignleft",
				"aligncenter",
				"alignright",
				"alignfull",
				"mergecells",
				"splitcells",
				"insertcells",
				"deletecells",
				"cellsoutline",
				"cellslinecolor",
				"cellslineheight",
				"cellslinestyle",
				"cellslinepreview",
				"tablebackcolor",
				"tabletemplate",
				"tableresize",
				"tablevalign"
			].contains(identity) === _FALSE) {
				tableSelect.reset();
			}
			if (identity === "tablebackcolor") {
				selectCellByCaret();
			}
		});
	});
});

/*jslint nomen: false*/
/*global Trex, $tom, $tx, _FALSE, _NULL, _TRUE */
Trex.Table.Selector = Trex.Class.create({
	SELECTED_CLASS_NAME: "tx_table_selected_cell",
	SELECTED_CSS_TEXT: "{background:#D8E9FD !important;background:rgba(179, 212, 253, 0.5) !important;}",
	initialize: function (editor, config) {
        this.config = config.toolbar.table;
		this.canvas = editor.getCanvas();
		this.wysiwygPanel = this.canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
		this.htmlBody = this.getHtmlBody();
		this.isDragging = _FALSE;
		this.isSelectMode = _FALSE;
		this.currentTable = _NULL;
		this.currentTd = _NULL;
		this.paintedTdArr = [];
		this.startCellBoundary = new Trex.TableUtil.Boundary();
		this.endCellBoundary = this.startCellBoundary;
		this.selectedBoundary = new Trex.TableUtil.Boundary();
		this.tableIndexer = _NULL;

		this.selectModeKeyObserver = new (Trex.Class.create({$mixins: [Trex.I.KeyObservable], initialize: function(){}}));
		this.normalModeKeyObserver = new (Trex.Class.create({$mixins: [Trex.I.KeyObservable], initialize: function(){}}));

		this.applyCss();
		this.observeEvent();
	},
	/**
	 * @private
	 * @return {Element}
	 */
	getHtmlBody: function () {
		var doc;
		doc = this.wysiwygPanel.getDocument();
		return doc.body;
	},
	/**
	 * @private
	 */
	applyCss: function () {
		var doc;
		doc = this.wysiwygPanel.getDocument();
		$tx.applyCSSText(doc, "." + this.SELECTED_CLASS_NAME + this.SELECTED_CSS_TEXT);
	},
	/**
	 * @private
	 * @param {Element} body
	 */
	observeEvent: function () {
		var self;
		self = this;
		this.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEDOWN, function (e) {
			var elem;
			elem = $tx.element(e);
			self.onmousedown(elem);
		});
		$tx.observe(this.htmlBody, "mousemove", function (e) {
			var elem;
			elem = $tx.element(e);
			self.onmousemove(elem);
		});
		this.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEUP, function (e) {
			self.onmouseup();
		});
        var _tempWinTop; // #FTDUEDTR-1426
        try {
            _tempWinTop = _WIN.top;
            var _tempWinDoc = _tempWinTop.document;
        } catch(e) {
            _tempWinTop = _WIN;
        }
		$tx.observe(_tempWinTop, "mouseup", function (e) {
			self.onmouseup();
		});
		this.canvas.observeJob(Trex.Ev.__CANVAS_PANEL_KEYDOWN, function (e) {
			if (self.isDragging) {
				$tx.stop(e);
				self.reset();
			} else {
				self.onkeydown(e);
			}
		});
		
		this.canvas.observeJob(Trex.Ev.__CANVAS_DATA_INITIALIZE, function (mode) {
			if (mode === Trex.Canvas.__WYSIWYG_MODE) {
				self.clearSelected();
			}
		});

        function getTdFromElement(elem){
            var td, isTxInfo;
            if (self.canvas.config.readonly === _FALSE) {
                td = Trex.TableUtil.getClosestByTagNames(["td", "th"], elem);
                isTxInfo = $tom.find(td, ".txc-info");
                if (td && !isTxInfo) {
                    return td
                }
            }
            return _NULL;
        }
        this.config.cellSelect&&this.config.cellSelect.hotKeyUse&&this.canvas.observeKey(this.config.cellSelect.hotKey, function (e){
            var elem, td;
            elem = self.canvas.getProcessor().getNode();
            td = getTdFromElement(elem);
            if(!td) return;
            $tx.stop(e);
            self.isSelectMode = _TRUE;
            self.selectStart(td);
            self.applySelected();
            Trex.TableUtil.collapseCaret(self.wysiwygPanel, elem);
        }, _TRUE);

        function selectByArrowKey(f){
            var b = self.tableIndexer.getBoundary(self.currentTd);
            var pos = f(b);
            var elem = self.tableIndexer.getTd(pos.top, pos.left);
            if(!elem) return;
            self.selectEnd(elem);
            self.applySelected();
            Trex.TableUtil.collapseCaret(self.wysiwygPanel, elem);

        }
        //\ufffd\ufffd\ufffd\ufffd \u022d\ufffd\ufffd\u01e5
        this.selectModeKeyObserver.observeKey({
            keyCode: 37
        }, function(e){
            selectByArrowKey(function(pos){
                return {top:pos.top, left:pos.left - 1}
            });
        });
        //\ufffd\ufffd \u022d\ufffd\ufffd\u01e5
        this.selectModeKeyObserver.observeKey({
            keyCode: 38
        }, function(e){
            selectByArrowKey(function(pos){
                return {top:pos.top - 1, left:pos.left}
            });
        });
        //\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \u022d\ufffd\ufffd\u01e5
        this.selectModeKeyObserver.observeKey({
            keyCode: 39
        }, function(e){
            selectByArrowKey(function(pos){
                return {top:pos.top, left:pos.right+1};
            });
        });
        //\ufffd\u01b7\ufffd \u022d\ufffd\ufffd\u01e5
        this.selectModeKeyObserver.observeKey({
            keyCode: 40
        }, function(e){
            selectByArrowKey(function(pos){
                return {top:pos.bottom+1, left:pos.left};
            });
        });
        //esc\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd table\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\u5fe1\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\u00b4\ufffd.
        this.selectModeKeyObserver.observeKey({
            keyCode: 27
        }, function(e){
            self.reset();
        });
        //del\u0170\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd.
        this.selectModeKeyObserver.observeKey({
            keyCode: 46
        }, function(e){
            self.deleteContents();
        });
        //ctrl + shiftKey + m \u01e5\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\u0474\ufffd.
        this.selectModeKeyObserver.observeKey({
            ctrlKey: _TRUE,
            shiftKey: _TRUE,
            keyCode: 77
        }, function(e){
            self.canvas.execute(function(processor){
                if(processor.table)
                    processor.table.merge(self)
            });
        });
        //ctrl + shiftKey + s \u01e5\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\u0474\ufffd.
        this.selectModeKeyObserver.observeKey({
            ctrlKey: _TRUE,
            shiftKey: _TRUE,
            keyCode: 83
        }, function(e){
            self.canvas.execute(function(processor){
                if(processor.table)
                    processor.table.resetMerge(self);
            });
        });

        //shift + \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \u022d\ufffd\ufffd\u01e5
        this.selectModeKeyObserver.observeKey({
            shiftKey: _TRUE,
            keyCode: 39
        }, function(e){
            self.selectRow(self.currentTd, 'RIGHT');
            self.applySelected();
            Trex.TableUtil.collapseCaret(self.wysiwygPanel, self.currentTd);
        });

        //shift + \ufffd\ufffd\ufffd\ufffd \u022d\ufffd\ufffd\u01e5
        this.selectModeKeyObserver.observeKey({
            shiftKey: _TRUE,
            keyCode: 37
        }, function(e){
            self.selectRow(self.currentTd, 'LEFT');
            self.applySelected();
            Trex.TableUtil.collapseCaret(self.wysiwygPanel, self.currentTd);
        });

        //shift + \ufffd\ufffd\ufffd\ufffd \u022d\ufffd\ufffd\u01e5
        this.selectModeKeyObserver.observeKey({
            shiftKey: _TRUE,
            keyCode: 38
        }, function(e){
            self.selectCol(self.currentTd, 'TOP');
            self.applySelected();
            Trex.TableUtil.collapseCaret(self.wysiwygPanel, self.currentTd);
        });

        //shift + \ufffd\u01b7\ufffd\ufffd\ufffd \u022d\ufffd\ufffd\u01e5
        this.selectModeKeyObserver.observeKey({
            shiftKey: _TRUE,
            keyCode: 40
        }, function(e){
            self.selectCol(self.currentTd, 'BOTTOM');
            self.applySelected();
            Trex.TableUtil.collapseCaret(self.wysiwygPanel, self.currentTd);
        });

        //ctrl + \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \u022d\ufffd\ufffd\u01e5
        this.selectModeKeyObserver.observeKey({
            ctrlKey: _TRUE,
            keyCode: 39
        }, function(e){
            self.canvas.getProcessor().table.resize({width: 5}, _TRUE);
        });
        //ctrl + \ufffd\ufffd\ufffd\ufffd \u022d\ufffd\ufffd\u01e5
        this.selectModeKeyObserver.observeKey({
            ctrlKey: _TRUE,
            keyCode: 37
        }, function(e){
            self.canvas.getProcessor().table.resize({width: -5}, _TRUE);
        });
        //ctrl + \ufffd\ufffd\ufffd\ufffd \u022d\ufffd\ufffd\u01e5
        this.selectModeKeyObserver.observeKey({
            ctrlKey: _TRUE,
            keyCode: 38
        }, function(e){
            self.canvas.getProcessor().table.resize({height: -5}, _TRUE);
        });
        //ctrl + \ufffd\u01b7\ufffd\ufffd\ufffd \u022d\ufffd\ufffd\u01e5
        this.selectModeKeyObserver.observeKey({
            ctrlKey: _TRUE,
            keyCode: 40
        }, function(e){
            self.canvas.getProcessor().table.resize({height: 5}, _TRUE);
        });
        //ctrl + a
        this.selectModeKeyObserver.observeKey({
            ctrlKey: _TRUE,
            keyCode: 65
        }, function(e){
            self.selectTable();
            self.applySelected();
            Trex.TableUtil.collapseCaret(self.wysiwygPanel, self.currentTd);
        });

        //ie9\ufffd\u033b\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd.
        function collapseTableAround(isStart){
            var rng = self.canvas.getProcessor().getRange();
            rng[(isStart?'setEndBefore':'setEndAfter')](self.currentTable);
            rng.collapse(_FALSE);
            goog.dom.Range.createFromBrowserRange(rng).select();
        }

        /**
         * @desc \ufffd\ufffd\ufffd\u01b7\ufffd \ufffd\ufffd\u01b0\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd td\ufffd\ufffd\ufffd\ufffd \ufffd\u0335\ufffd\ufffd\ufffd \ufffd\u07fb\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u03ff\ufffd \ufffd\u07fb\ufffd\ufffd\u03f8\ufffd true\ufffd\ufffd \ufffd\ufffd\u022f\ufffd\u0474\ufffd.
         * @param {Node} preNode
         * @returns {boolean}
         */
        function shouldFixCaret(preNode){
            var rng = self.canvas.getProcessor().getRange();
            rng.collapse(_FALSE);
            var _node = rng.startContainer;
            if(_node.nodeType == 3) _node = _node.parentElement;
            var pre = getTdFromElement(preNode);
            var cur = getTdFromElement(_node);
            return cur && cur !== pre && isSameTable(cur, pre);
        }

        /**
         * isSameTable
         * @desc \ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\u033a\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd\ufffd\ufffd\u03b8\ufffd \u022e\ufffd\ufffd\ufffd\u0474\ufffd.
         * @param {Node} n1
         * @param {Node} n2
         * @returns {boolean}
         */
        function isSameTable(n1, n2){
            return $tom.ancestor(n1, 'table') === $tom.ancestor(n2, 'table')
        }

        //normalMode
        $tx.webkit&&this.normalModeKeyObserver.observeKey({
            keyCode:38
        }, function(e){
            var elem, td;
            elem = self.canvas.getProcessor().getNode();
            td = getTdFromElement(elem);
            if(!td) return;
            setTimeout(function(){
                if(shouldFixCaret(elem)){
                    $tx.stop(e);
                    if(!self.currentTable){
                        self.setTable(td);
                    }
                    var b = self.tableIndexer.getBoundary(td);
                    td = self.tableIndexer.getTd(b.top-1, b.left);
                    if(!td){
                        collapseTableAround(_TRUE);
                    }else
                        Trex.TableUtil.collapseLastCaret(self.wysiwygPanel, td);
                }
            },0);
        });
        $tx.webkit&&this.normalModeKeyObserver.observeKey({
            keyCode:40
        }, function(e){
            var elem, td;
            elem = self.canvas.getProcessor().getNode();
            td = getTdFromElement(elem);
            if(!td) return;
            setTimeout(function(){
                if(shouldFixCaret(elem)){
                    $tx.stop(e);
                    if(!self.currentTable){
                        self.setTable(td);
                    }
                    var b = self.tableIndexer.getBoundary(td);
                    td = self.tableIndexer.getTd(b.bottom+1, b.left);
                    if(!td){
                        collapseTableAround(_FALSE);
                    }else
                        Trex.TableUtil.collapseCaret(self.wysiwygPanel, td);
                }
            },0);
        });

	},
	/**
	 * @private
	 * @param {Element} elem
	 */
	onmousedown: function (elem) {
		var td, isTxInfo;
		this.reset();
		if (this.canvas.config.readonly === _FALSE) {
			td = Trex.TableUtil.getClosestByTagNames(["td", "th"], elem);
			isTxInfo = $tom.find(td, ".txc-info");
			if (td && !isTxInfo ) {
				this.selectStart(td);
				this.turnOnDragging();
			}
		}
	},
	/**
	 * @private
	 * @param {Element} elem
	 */
	onmousemove: function (elem) {
		var td, table, notSelected, el;
        var _p = this.canvas.getProcessor();
        if(_p.getAreaSelection().isResizing||($tx.msie&&$tx.msie_ver>=11&&(el = _p.getControl())&&$tom.kindOf(el, 'img,table'))){
            this.turnOffDragging();
            return;
        }
		if (this.isDragging) {
			td = Trex.TableUtil.getClosestByTagNames(["td", "th"], elem);
			if (td) {
				table = Trex.TableUtil.getClosestByTagNames(["table"], td);
				if (table === this.currentTable && td !== this.currentTd) {
					this.isSelectMode = _TRUE;
					this.selectEnd(td);
					this.applySelected();
					Trex.TableUtil.collapseCaret(this.wysiwygPanel, elem);
				}
			} else {
				notSelected = (this.endCellBoundary === this.startCellBoundary);
				if (this.currentTd && notSelected) {
					this.selectEnd(this.currentTd);
					this.applySelected();
					Trex.TableUtil.collapseCaret(this.wysiwygPanel, elem);
				}
			}
		}
	},
	/**
	 * @private
	 */
	onmouseup: function () {
		if (this.isDragging) {
			this.turnOffDragging();
		}
	},
	/**
	 * @private
	 */
	onkeydown: function (e) {
        var keyCode = e.keyCode;
        var ctrlKey = e.ctrlKey;
        var shiftKey = e.shiftKey;

        if (this.isSelectMode){
            //\u01e5 hotkey
            $tx.stop(e);
            this.selectModeKeyObserver.fireKeys(e);
        }else if (ctrlKey === _FALSE) {
            this.normalModeKeyObserver.fireKeys(e, _TRUE);
            this.reset();

        }
	},

    deleteContents: function(){
        var selectedTdArr, len, i;
        selectedTdArr = this.getSelectedTdArr();
        len = selectedTdArr.length;
        for (i = 0; i < len; i += 1) {
            Trex.TableUtil.emptyTd(selectedTdArr[i]);
        }
    },
    /**
     * @private
     * @param {Element} td
     */
    setTable : function (td) {
        this.currentTable = Trex.TableUtil.getClosestByTagNames(["table"], td);
        this.tableIndexer = new Trex.TableUtil.Indexer(this.currentTable);
    },
	/**
	 * @private
	 * @param {Element} td
	 */
	selectStart: function (td) {
        this.setTable(td);
		this.startCellBoundary = this.tableIndexer.getBoundary(td);
		this.endCellBoundary = this.startCellBoundary;
		this.currentTd = td;
	},
	/**
	 * @private
	 * @param {Element} td
	 */
	selectEnd: function (td) {
		this.endCellBoundary = this.tableIndexer.getBoundary(td);
		this.currentTd = td;
	},
    /**
     * selectStart\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\u01fe\ufffd\ufffd \ufffd\u0474\ufffd.
     * @param {Element} td
     * @param {String} mode
     */
    selectRow: function(td, mode){
        this.currentTd = td;
        var b = this.tableIndexer.getBoundary(td);
        var start = _NULL,  end= _NULL;
        if(mode == 'RIGHT'){
            end = this.tableIndexer.getTd(b.top, this.tableIndexer.getColSize()-1);
        }else if(mode == 'LEFT'){
            end = this.tableIndexer.getTd(b.top, 0);
        }else {
            start = this.tableIndexer.getTd(b.top, 0);
            end = this.tableIndexer.getTd(b.top, this.tableIndexer.getColSize()-1);
            this.startCellBoundary = this.tableIndexer.getBoundary(start);
        }
        this.endCellBoundary = this.tableIndexer.getBoundary(end);
        this.currentTd = end;
    },
    /**
     * selectStart\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\u01fe\ufffd\ufffd \ufffd\u0474\ufffd.
     * @param {Element} td
     * @param {String} mode
     */
    selectCol: function(td, mode){
        this.currentTd = td;
        var b = this.tableIndexer.getBoundary(td);
        var start = _NULL,  end= _NULL;
        if(mode == 'BOTTOM'){
            end = this.tableIndexer.getTd(this.tableIndexer.getRowSize()-1, b.left);
        }else if(mode == 'TOP'){
            end = this.tableIndexer.getTd(0, b.left);
        }else {
            start = this.tableIndexer.getTd(0, b.left);
            end = this.tableIndexer.getTd(this.tableIndexer.getRowSize()-1, b.left);
            this.startCellBoundary = this.tableIndexer.getBoundary(start);
        }

        this.endCellBoundary = this.tableIndexer.getBoundary(end);
        this.currentTd = end;
    },
    /**
     * selectStart\ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\u01fe\ufffd\ufffd \ufffd\u0474\ufffd.
     */
    selectTable: function(){
        var start = this.tableIndexer.getTd(0, 0);
        var end = this.tableIndexer.getTd(this.tableIndexer.getRowSize()-1, this.tableIndexer.getColSize()-1);
        this.startCellBoundary = this.tableIndexer.getBoundary(start);
        this.endCellBoundary = this.tableIndexer.getBoundary(end);
        this.currentTd = end;
    },

	/**
	 * @private
	 */
	applySelected: function () {
		this.calculateSelectedBoundary();
		this.extendSelectedBoundary();
		this.paint();
	},
	/**
	 * @private
	 */
	calculateSelectedBoundary: function () {
		this.selectedBoundary = new Trex.TableUtil.Boundary();
		this.selectedBoundary.merge(this.startCellBoundary);
		this.selectedBoundary.merge(this.endCellBoundary);
	},
	/**
	 * @private
	 */
	extendSelectedBoundary: function () {
		var needExtend;
		needExtend = this.selectedBoundary.isValid();
		while (needExtend) {
			needExtend = this.oneTimeExtendBoundary();
		}
	},
	/**
	 * @private
	 * @return {boolean} wasExtended
	 */
	oneTimeExtendBoundary: function () {
		var selectedTdArr, i, len, extendedBoundary, wasExtended;
		selectedTdArr = this.tableIndexer.getTdArr(this.selectedBoundary);
		len = selectedTdArr.length;
		for (i = 0; i < len; i += 1) {
			extendedBoundary = this.tableIndexer.getBoundary(selectedTdArr[i]);
			wasExtended = this.selectedBoundary.merge(extendedBoundary);
			if (wasExtended) {
				return _TRUE;
			}
		}
		return _FALSE;
	},
	/**
	 * @private
	 */
	paint: function () {
		var tdArrToSelect, tdArrToUnselect;
		tdArrToSelect = this.tableIndexer.getTdArr(this.selectedBoundary);
		tdArrToUnselect = Array.prototype.without.apply(this.paintedTdArr, tdArrToSelect);
		
		this.paintSelected(tdArrToSelect);
		this.eraseSelected(tdArrToUnselect);
	},
	/**
	 * @private
	 * @param {Array} tdArr
	 */
	paintSelected: function (tdArr) {
		var self;
		self = this;
		this.paintedTdArr = [];
		tdArr.each(function (td) {
			$tx.addClassName(td, self.SELECTED_CLASS_NAME);
			self.paintedTdArr.push(td);
		});
	},
	/**
	 * @private
	 * @param {Array} tdArr
	 */
	eraseSelected: function (tdArr) {
		this.removeClassName(tdArr);
		this.paintedTdArr = Array.prototype.without.apply(this.paintedTdArr, tdArr);
	},
	/**
	 * @private
	 * @param {Array} tdArr
	 */
	removeClassName: function (tdArr) {
		var self;
		self = this;
		tdArr.each(function (td) {
			var removeAttrResult;
			$tx.removeClassName(td, self.SELECTED_CLASS_NAME);
			if (td.className === "") {
				removeAttrResult = td.removeAttribute("class");
				if (removeAttrResult === _FALSE) { //for IE6, IE7.
					td.removeAttribute("className");
				}
			}
		});
	},
	/**
	 * @private
	 */
	clearSelected: function () {
		var tdArr;
		tdArr = $tom.collectAll(this.htmlBody, "." + this.SELECTED_CLASS_NAME);
		this.removeClassName(tdArr);
		this.paintedTdArr = [];
	},
	/**
	 * @private
	 */
	resetBoundary: function () {
		this.startCellBoundary = new Trex.TableUtil.Boundary();
		this.endCellBoundary = this.startCellBoundary;
		this.selectedBoundary = new Trex.TableUtil.Boundary();
	},
	/**
	 * @private
	 */
	turnOnDragging: function () {
		this.isDragging = _TRUE;
	},
	/**
	 * @private
	 */
	turnOffDragging: function () {
		this.isDragging = _FALSE;
	},
	/**
	 * @private
	 */
	resetDragging: function () {
		this.isDragging = _FALSE;
	},
    resetSelectMode: function(){
        this.isSelectMode = _FALSE;
    },
    resetData: function(){
        this.currentTable = _NULL;
        this.currentTd = _NULL;
    },
	/**
	 * isDuringSelection
	 * @return {boolean} isDragging
	 */
	isDuringSelection: function () {
		return this.isDragging;
	},
	/**
	 * getIndexer
	 * @return {Trex.TableUtil.Indexer} indexer
	 */
	getIndexer: function () {
		return this.tableIndexer;
	},
	/**
	 * getSelected
	 * @return {Trex.TableUtil.Boundary} boundary
	 */
	getSelected: function () {
		return this.selectedBoundary;
	},
	/**
	 * getSelectedTdArr
	 * @return {Array} tddArr
	 */
	getSelectedTdArr: function () {
		if (this.selectedBoundary.isValid()) {
			return this.tableIndexer.getTdArr(this.selectedBoundary);
		}
		return [];
	},
	/**
	 * selectByBoundary
	 * @param {Trex.TableUtil.Boundary} boundary
	 */
	selectByBoundary: function (boundary) {
		this.resetBoundary();
		this.selectedBoundary = boundary;
		this.paint();
	},
	/**
	 * selectByTd
	 * @param {Element} startTd
	 * @param {Element} endTd
	 */
	selectByTd: function (startTd, endTd) {
		this.selectStart(startTd);
		this.selectEnd(endTd);
		this.applySelected();
	},
	/**
	 * reset
	 */
	reset: function () {
		this.clearSelected();
		this.resetBoundary();
		this.resetDragging();
		this.resetSelectMode();
		this.resetData();
		this.reloadIndexer();
	},
	/**
	 * reloadIndexer
	 */
	reloadIndexer: function () {
		if (this.tableIndexer) {
			this.tableIndexer.reload();
		}
	},
	/**
	 * getSizeOfSelected
	 * @return {Object} size(width,height)
	 */
	getSizeOfSelected: function () {
		var selectedTdArr, firstTd, lastTd, firstTdPosition, lastTdPosition;
		selectedTdArr = this.getSelectedTdArr();
		if (0 < selectedTdArr.length) {
			firstTd = selectedTdArr[0];
			lastTd = selectedTdArr[selectedTdArr.length - 1];
			firstTdPosition = $tom.getPosition(firstTd);
			lastTdPosition = $tom.getPosition(lastTd);
			return {
				width: lastTdPosition.x + lastTdPosition.width - firstTdPosition.x,
				height: lastTdPosition.y + lastTdPosition.height - firstTdPosition.y
			};
		}
		return {
			width: 0,
			height: 0
		};
	}
});

/*jslint nomen: false*/
/*global Trex, $tom, $tx, _FALSE, _NULL, _TRUE, TXMSG */
TrexMessage.addMsg({
    '@table.merge.confirm': '\uc140\uc744 \ubcd1\ud569\ud558\uba74 \ub9e8 \uc704\ucabd \uc140\uc5d0 \uc788\ub294 \uac12\ub9cc \ub0a8\uace0 \ub098\uba38\uc9c0 \uac12\uc740 \uc783\uac8c \ub429\ub2c8\ub2e4.',
    '@table.merge.more.select.cells': '\ub450 \uac1c \uc774\uc0c1\uc758 \uc140\uc744 \uc120\ud0dd\ud574\uc8fc\uc138\uc694.'
});

Trex.Table.Merge = Trex.Class.create({
	initialize: function (editor/*, config*/) {
		var canvas;
		canvas = editor.getCanvas();
		
		this.wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
	},
	/**
	 * merge
	 * @param {Trex.Table.Selector} tableSelector
	 */
	merge: function (tableSelector) {
		var tdArr, td, selectedSize;
		tableSelector.reloadIndexer();
		tdArr = tableSelector.getSelectedTdArr();
		if (1 < tdArr.length) {
            var isExistContent = this.isExistContents(tdArr, 1);// 0\ubc88\uc9f8\ub294 merge\uc2dc \ub0a8\uaca8\uc9c0\ub294 \ub370\uc774\ud130\uc774\ubbc0\ub85c \ubb34\uc2dc\ud55c\ub2e4.
            if (isExistContent && confirm(TXMSG('@table.merge.confirm')) == _FALSE) {
                return;
            }

			selectedSize = tableSelector.getSizeOfSelected();
			td = tdArr[0];
			
			this.deleteCellForMerge(tdArr);
			this.extendCellForMerge(td, tableSelector, selectedSize);

			tableSelector.reset();
			tableSelector.selectByTd(td, td);
			Trex.TableUtil.collapseCaret(this.wysiwygPanel, td);
		} else {
			alert(TXMSG('@table.merge.more.select.cells'));
		}
	},
    isExistContents: function(tdArr, startIndex) {
        startIndex = startIndex || 0;// default 0
        var flag = _TRUE;
        for(var i= startIndex, max=tdArr.length; i<max; i++) {
            var entry = tdArr[i] || "";
            var html = entry.innerHTML.trim().toLowerCase().replace(/(&nbsp;|\s)/g, '');
            var equalBogusType1 = (html == "<p></p>"),// &nbsp; \ub294 \uce58\ud658\ud558\ubbc0\ub85c \uc874\uc7ac\ud560 \uc218 \uc5c6\uc74c
                equalBogusType2 = (html == "<p><br></p>"),
                equalEmpty = (html == "");

            if (equalBogusType1 || equalBogusType2 || equalEmpty) {
                flag = _FALSE;
                break;
            }
        }
        return flag;
    },
	/**
	 * @private
	 * @param {Array} tdArr
	 */
	deleteCellForMerge: function (tdArr) {
		var data, trimedData, i, len;
		data = tdArr[0].innerHTML;
		len = tdArr.length;
		for (i = 1; i < len; i += 1) {
			trimedData = data.replace(Trex.__WORD_JOINER_REGEXP, "").trim();
			if (trimedData === "" || trimedData === "&nbsp;") {
				data = tdArr[i].innerHTML;
			}
			$tom.remove(tdArr[i]);
		}
		tdArr[0].innerHTML = data;
	},
	/**
	 * @private
	 * @param {Element} td
	 * @param {Trex.Table.Selector} tableSelector
	 * @param {Object} selectedSize
	 */
	extendCellForMerge: function (td, tableSelector, selectedSize) {
		var selectedBoundary;
		selectedBoundary = tableSelector.getSelected();
		td.colSpan = selectedBoundary.right - selectedBoundary.left + 1;
		td.rowSpan = selectedBoundary.bottom - selectedBoundary.top + 1;
		if (td.style.width) {
			$tom.setWidth(td, selectedSize.width + "px");
		}
		if (td.style.height) {
			$tom.setHeight(td, selectedSize.height + "px");
		}
	},
	/**
	 * resetMerge
	 * @param {Trex.Table.Selector} tableSelector
	 */
	resetMerge: function (tableSelector) {
		//TODO.azki cancel -> reset \uc73c\ub85c \ubc14\uafc0\uae4c!?
		var colResult, rowResult;
		tableSelector.reloadIndexer();
		colResult = this.splitCol(tableSelector);
		tableSelector.reloadIndexer();
		rowResult = this.splitRow(tableSelector);
		if (colResult === _FALSE && rowResult === _FALSE) {
			alert("\uc774\ubbf8 \ud569\uccd0\uc9c4 \uc140\ub9cc \ubd84\ud560 \uac00\ub2a5\ud569\ub2c8\ub2e4.");
		} else {
			tableSelector.reloadIndexer();
		}
	},
	/**
	 * @private
	 * @param {Trex.Table.Selector} tableSelector
	 * @return {boolean} changed
	 */
	splitCol: function (tableSelector) {
		var changed, tdArr, td, i, len, splitTdResult;
		changed = _FALSE;
		tdArr = tableSelector.getSelectedTdArr();
		len = tdArr.length;
		if (0 < len) {
			for (i = 0; i < len; i += 1) {
				td = tdArr[i];
				splitTdResult = this.splitTdByColSpan(td);
				changed = changed || splitTdResult;
			}
		}
		return changed;
	},
	/**
	 * @private
	 * @param {Trex.Table.Selector} tableSelector
	 * @return {boolean} changed
	 */
	splitRow: function (tableSelector) {
		var changed, tdArr, td, i, len, splitTdResult;
		changed = _FALSE;
		tdArr = tableSelector.getSelectedTdArr();
		len = tdArr.length;
		if (0 < len) {
			for (i = 0; i < len; i += 1) {
				td = tdArr[i];
				splitTdResult = this.splitTdByRowSpan(td);
				changed = changed || splitTdResult;
			}
		}
		return changed;
	},
	/**
	 * @private
	 * @param {Element} td
	 * @return {boolean} changed
	 */
	splitTdByColSpan: function (td) {
		var newTdCount, newTd, changed;
		newTdCount = td.colSpan - 1;
		changed = 0 < newTdCount;
		Trex.TableUtil.splitWidthByColSpan(td);
		td.colSpan = 1;
		while (0 < newTdCount) {
			newTd = Trex.TableUtil.cloneNodeForEmptyTd(td);
			//TODO.azki set border top/left.
			$tom.insertNext(newTd, td);
			newTdCount -= 1;
		}
		return changed;
	},
	/**
	 * @private
	 * @param {Element} td
	 * @return {boolean} changed
	 */
	splitTdByRowSpan: function (td) {
		var changed, newTdCount;
		newTdCount = td.rowSpan - 1;
		changed = 0 < newTdCount;
		Trex.TableUtil.splitHeightByRowSpan(td);
		while (0 < newTdCount) {
			this.splitTdOneByOne(td);
			newTdCount -= 1;
		}
		return changed;
	},
	/**
	 * @private
	 * @param {Element} td
	 */
	splitTdOneByOne: function (td) {
		var trForInsert, tdForInsert, newTd;
		trForInsert = this.getTrForInsert(td);
		tdForInsert = this.getTdForInsert(td, trForInsert);
		newTd = Trex.TableUtil.cloneNodeForEmptyTd(td);
		newTd.rowSpan = 1;
		td.rowSpan -= 1;
		if (tdForInsert) {
			$tom.insertAt(newTd, tdForInsert);
		} else {
			$tom.append(trForInsert, newTd);
		}
	},
	/**
	 * @private
	 * @param {Element} td
	 */
	getTrForInsert: function (td) {
		var i, len, trForInsert;
		trForInsert = $tom.parent(td);
		len = td.rowSpan - 1;
		for (i = 0; i < len; i += 1) {
			trForInsert = $tom.next(trForInsert, "tr");
		}
		return trForInsert;
	},
	/**
	 * @private
	 * @param {Element} td
	 * @param {Element} trForInsert
	 */
	getTdForInsert: function (td, trForInsert) {
		var tableIndexer, currentBoundary, colForInsert, cells, len, i, cell, cellBoundary;
		tableIndexer = Trex.TableUtil.getTableIndexerFromTd(td);
		currentBoundary = tableIndexer.getBoundary(td);
		colForInsert = currentBoundary.left;
		cells = trForInsert.cells;
		len = cells.length;
		for (i = 0; i < len; i += 1) {
			cell = cells[i];
			cellBoundary = tableIndexer.getBoundary(cell);
			if (colForInsert <= cellBoundary.left) {
				return cell;
			}
		}
		return _NULL;
	}
});

/*jslint nomen: false*/
/*global Trex, $tom, $tx, _FALSE, _NULL, _TRUE */
Trex.Table.Insert = Trex.Class.create({
	COL_DIRECTION: {
		LEFT: "left",
		RIGHT: "right"
	},
	
	initialize: function (editor/*, config*/) {
		var canvas;
		canvas = editor.getCanvas();
		
		this.wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
	},
	/**
	 * insertRowAbove
	 * @param {Trex.Table.Selector} tableSelector
	 */
	insertRowAbove: function (tableSelector) {
		var boundary, indexer;
		tableSelector.reloadIndexer();
		boundary = tableSelector.getSelected();
		if (boundary.isValid()) {
			indexer = tableSelector.getIndexer();
			this.insertRowAboveByBoundary(boundary, indexer);
			tableSelector.reset();
		}
	},
	/**
	 * @private
	 * @param {Trex.TableUtil.Boundary} boundary
	 * @param {Trex.TableUtil.Indexer} indexer
	 */
	insertRowAboveByBoundary: function (boundary, indexer) {
		var table, rowCount, insertIndex, tdArrAtBoundaryLine, tdArrForClone;
		table = indexer.table;
		rowCount = boundary.bottom - boundary.top + 1;
		insertIndex = boundary.top;
		tdArrAtBoundaryLine = indexer.getTdArr(new Trex.TableUtil.Boundary({
			top: boundary.top,
			right: indexer.getColSize() - 1,
			bottom: boundary.top,
			left: 0
		}));
		tdArrForClone = indexer.getTdArrHasTop(boundary.top);
		this.addRow(table, rowCount, insertIndex, tdArrAtBoundaryLine, tdArrForClone);
	},
	/**
	 * addRow
	 * @param {Element} table
	 * @param {number} rowCount
	 * @param {number} insertIndex
	 * @param {Array} tdArrAtBoundaryLine
	 * @param {Array} tdArrForClone
	 */
	addRow: function (table, rowCount, insertIndex, tdArrAtBoundaryLine, tdArrForClone) {
		var fn, i, tr_closure;
		fn = function (td) {
			var newTd;
			if (tdArrForClone.contains(td)) {
				newTd = Trex.TableUtil.cloneNodeForEmptyTd(td);
				Trex.TableUtil.splitHeightByRowSpan(newTd);
				//TODO.azki left / top \ubcf4\ub354 \uc138\ud305\uc774 \ud544\uc694\ud560\uc9c0\ub3c4.?
				newTd.rowSpan = 1;
				tr_closure.appendChild(newTd); //tr_closure is closure variable.
			} else {
				td.rowSpan += 1;
			}
		};
		for (i = 0; i < rowCount; i += 1) {
			tr_closure = table.insertRow(insertIndex);
			tdArrAtBoundaryLine.each(fn);
		}
	},
	/**
	 * insertRowBelow
	 * @param {Trex.Table.Selector} tableSelector
	 */
	insertRowBelow: function (tableSelector) {
		var boundary, indexer;
		tableSelector.reloadIndexer();
		boundary = tableSelector.getSelected();
		if (boundary.isValid()) {
			indexer = tableSelector.getIndexer();
			this.insertRowBelowByBoundary(boundary, indexer);
			tableSelector.reset();
		}
	},
	/**
	 * @private
	 * @param {Trex.TableUtil.Boundary} boundary
	 * @param {Trex.TableUtil.Indexer} indexer
	 */
	insertRowBelowByBoundary: function (boundary, indexer) {
		var table, rowCount, insertIndex, tdArrAtBoundaryLine, tdArrForClone;
		table = indexer.table;
		rowCount = boundary.bottom - boundary.top + 1;
		insertIndex = boundary.bottom + 1;
		tdArrAtBoundaryLine = indexer.getTdArr(new Trex.TableUtil.Boundary({
			top: boundary.bottom,
			right: indexer.getColSize() - 1,
			bottom: boundary.bottom,
			left: 0
		}));
		tdArrForClone = indexer.getTdArrHasBottom(boundary.bottom);
		this.addRow(table, rowCount, insertIndex, tdArrAtBoundaryLine, tdArrForClone);
	},
	/**
	 * insertColLeft
	 * @param {Trex.Table.Selector} tableSelector
	 */
	insertColLeft: function (tableSelector) {
		var boundary, indexer;
		tableSelector.reloadIndexer();
		boundary = tableSelector.getSelected();
		if (boundary.isValid()) {
			indexer = tableSelector.getIndexer();
			this.insertColLeftByBoundary(boundary, indexer);
			tableSelector.reset();
		}
	},
	/**
	 * @private
	 * @param {Trex.TableUtil.Boundary} boundary
	 * @param {Trex.TableUtil.Indexer} indexer
	 */
	insertColLeftByBoundary: function (boundary, indexer) {
		var colCount, tdArrAtBoundaryLine, tdArrForClone;
		colCount = boundary.right - boundary.left + 1;
		tdArrAtBoundaryLine = indexer.getTdArr(new Trex.TableUtil.Boundary({
			top: 0,
			right: boundary.left,
			bottom: indexer.getRowSize() - 1,
			left: boundary.left
		}));
		tdArrForClone = indexer.getTdArrHasLeft(boundary.left);
		this.addCol(colCount, tdArrAtBoundaryLine, tdArrForClone, this.COL_DIRECTION.LEFT);
	},
	/**
	 * addCol
	 * @param {number} colCount
	 * @param {Array} tdArrAtBoundaryLine
	 * @param {Array} tdArrForClone
	 * @param {Trex.Table.Insert.COL_DIRECTION} direction
	 */
	addCol: function (colCount, tdArrAtBoundaryLine, tdArrForClone, direction) {
		var self, fn, i;
		self = this;
		fn = function (td) {
			var newTd;
			if (tdArrForClone.contains(td)) {
				newTd = Trex.TableUtil.cloneNodeForEmptyTd(td);
				Trex.TableUtil.splitWidthByColSpan(newTd);
				//TODO.azki left / top \ubcf4\ub354 \uc138\ud305\uc774 \ud544\uc694\ud560\uc9c0\ub3c4.?
				newTd.colSpan = 1;
				if (direction === self.COL_DIRECTION.LEFT) {
					$tom.insertAt(newTd, td);
				} else {
					$tom.insertNext(newTd, td);
				}
			} else {
				td.colSpan += 1;
			}
		};
		for (i = 0; i < colCount; i += 1) {
			tdArrAtBoundaryLine.each(fn);
		}
	},
	/**
	 * insertColRight
	 * @param {Trex.Table.Selector} tableSelector
	 */
	insertColRight: function (tableSelector) {
		var boundary, indexer;
		tableSelector.reloadIndexer();
		boundary = tableSelector.getSelected();
		if (boundary.isValid()) {
			indexer = tableSelector.getIndexer();
			this.insertColRightByBoundary(boundary, indexer);
			tableSelector.reset();
		}
	},
	/**
	 * @private
	 * @param {Trex.TableUtil.Boundary} boundary
	 * @param {Trex.TableUtil.Indexer} indexer
	 */
	insertColRightByBoundary: function (boundary, indexer) {
		var colCount, tdArrAtBoundaryLine, tdArrForClone;
		colCount = boundary.right - boundary.left + 1;
		tdArrAtBoundaryLine = indexer.getTdArr(new Trex.TableUtil.Boundary({
			top: 0,
			right: boundary.right,
			bottom: indexer.getRowSize() - 1,
			left: boundary.right
		}));
		tdArrForClone = indexer.getTdArrHasRight(boundary.right);
		this.addCol(colCount, tdArrAtBoundaryLine, tdArrForClone, this.COL_DIRECTION.RIGHT);
	}
});

/*jslint nomen: false*/
/*global Trex, $tom, $tx, _FALSE, _NULL, _TRUE */
Trex.Table.Delete = Trex.Class.create({
	initialize: function (editor/*, config*/) {
		var canvas;
		canvas = editor.getCanvas();
		
		this.wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
	},
	/**
	 * deleteRow
	 * @param {Trex.Table.Selector} tableSelector
	 */
	deleteRow: function (tableSelector) {
		var boundary;
		boundary = tableSelector.getSelected();
		if (boundary.isValid()) {
			this.deleteRowOneByOne(tableSelector);
			tableSelector.reset();
			this.deleteEmptyTableByTableSelector(tableSelector);
		}
	},
	/**
	 * @private
	 * @param {Trex.Table.Selector} tableSelector
	 */
	deleteRowOneByOne: function (tableSelector) {
		var deleteStartIndex, count, boundary, indexer;
		boundary = tableSelector.getSelected();
		deleteStartIndex = boundary.top;
		count = boundary.bottom - boundary.top + 1;
		while (0 < count) {
			tableSelector.reloadIndexer();
			indexer = tableSelector.getIndexer();
			this.deleteRowByIndex(indexer, deleteStartIndex);
			count -= 1;
		}
		if (deleteStartIndex === 0) {
			this.drawTopBorder(tableSelector);
		}
	},
	drawTopBorder: function (tableSelector) {
		var indexer, tdArr, len, i, td;
		tableSelector.reloadIndexer();
		indexer = tableSelector.getIndexer();
		tdArr = indexer.getTdArrHasTop(0);
		len = tdArr.length;
		for (i = 0; i < len; i += 1) {
			td = tdArr[i];
			if (td.style.borderTop === "" && td.style.borderBottom !== "") {
				td.style.borderTop = td.style.borderBottom;
			}
		}
	},
	/**
	 * @private
	 * @param {Trex.TableUtil.Indexer} indexer
	 * @param {number} index
	 */
	deleteRowByIndex: function (indexer, index) {
		var tdArr, hasTopTdArr, len, tr;
		tdArr = this.getTdArrByRowIndex(indexer, index);
		hasTopTdArr = this.getTdArrByHasTop(indexer, index);
		len = tdArr.length;
		if (0 < len) {
			tr = $tom.parent(tdArr[0]);
			this.deleteTdInDeleteRow(tdArr, hasTopTdArr, tr, indexer);
			$tom.remove(tr);
		}
	},
	/**
	 * @private
	 * @param {Trex.TableUtil.Indexer} indexer
	 * @param {number} index
	 */
	getTdArrByRowIndex: function (indexer, index) {
		return indexer.getTdArr(new Trex.TableUtil.Boundary({
			top: index,
			right: indexer.getColSize() - 1,
			bottom: index,
			left: 0
		}));
	},
	/**
	 * @private
	 * @param {Trex.TableUtil.Indexer} indexer
	 * @param {number} index
	 */
	getTdArrByHasTop: function (indexer, index) {
		return indexer.getTdArrHasTop(index);
	},
	/**
	 * 
	 * @param {Array} tdArr
	 * @param {Array} hasTopTdArr
	 * @param {Element} tr
	 * @param {Trex.TableUtil.Indexer} indexer
	 */
	deleteTdInDeleteRow: function (tdArr, hasTopTdArr, tr, indexer) {
		var len, i, td;
		len = tdArr.length;
		for (i = 0; i < len; i += 1) {
			td = tdArr[i];
			if (1 < td.rowSpan) {
				td.rowSpan -= 1;
				this.reduceHeightAsRow(td, tr);
				if (hasTopTdArr.contains(td)) {
					this.shiftRowOfTd(td, indexer);
				}
			} else {
				$tom.remove(td);
			}
		}
	},
	reduceHeightAsRow: function (td, tr) {
		var styleHeight, newHeight;
		if (td.style.height) {
			styleHeight = parseInt(td.style.height, 10);
			newHeight = styleHeight - tr.offsetHeight;
			if (0 < newHeight) {
				$tom.setStyles(td, {
					height: newHeight + "px"
				}, _TRUE);
			}
		}
	},
	/**
	 * @private
	 * @param {Eelement} td
	 * @param {Trex.TableUtil.Indexer} indexer
	 */
	shiftRowOfTd: function (td, indexer) {
		var tr, trForInsert, tdForInsert;
		tr = $tom.parent(td);
		trForInsert = $tom.next(tr, "tr");
		tdForInsert = this.getTdForInsert(td, trForInsert, indexer);
		if (tdForInsert) {
			$tom.insertAt(td, tdForInsert);
		} else {
			$tom.append(trForInsert, td);
		}
	},
	/**
	 * @private
	 * @param {Element} td
	 * @param {Element} trForInsert
	 * @param {Trex.TableUtil.Indexer} indexer
	 */
	getTdForInsert: function (td, trForInsert, indexer) {
		var currentBoundary, colForInsert, cells, len, i, cell, cellBoundary;
		currentBoundary = indexer.getBoundary(td);
		colForInsert = currentBoundary.left;
		cells = trForInsert.cells;
		len = cells.length;
		for (i = 0; i < len; i += 1) {
			cell = cells[i];
			cellBoundary = indexer.getBoundary(cell);
			if (colForInsert <= cellBoundary.left) {
				return cell;
			}
		}
		return _NULL;
	},
	/**
	 * @private
	 * @param {Trex.Table.Selector} tableSelector
	 */
	deleteEmptyTableByTableSelector: function (tableSelector) {
		var indexer, table;
		indexer = tableSelector.getIndexer();
		table = indexer.table;
		if (table.rows.length === 0) {
			$tom.remove(table);
		}
	},
	/**
	 * deleteCol
	 * @param {Trex.Table.Selector} tableSelector
	 */
	deleteCol: function (tableSelector) {
		var boundary;
		boundary = tableSelector.getSelected();
		if (boundary.isValid()) {
			this.deleteColOneByOne(tableSelector);
			tableSelector.reset();
			this.deleteEmptyTableByTableSelector(tableSelector);
		}
	},
	/**
	 * @private
	 * @param {Trex.Table.Selector} tableSelector
	 */
	deleteColOneByOne: function (tableSelector) {
		var deleteStartIndex, count, boundary, indexer;
		boundary = tableSelector.getSelected();
		deleteStartIndex = boundary.left;
		count = boundary.right - boundary.left + 1;
		while (0 < count) {
			tableSelector.reloadIndexer();
			indexer = tableSelector.getIndexer();
			this.deleteColByIndex(indexer, deleteStartIndex);
			count -= 1;
		}
		if (deleteStartIndex === 0) {
			this.drawLeftBorder(tableSelector);
		}
	},
	drawLeftBorder: function (tableSelector) {
		var indexer, tdArr, len, i, td;
		tableSelector.reloadIndexer();
		indexer = tableSelector.getIndexer();
		tdArr = indexer.getTdArrHasLeft(0);
		len = tdArr.length;
		for (i = 0; i < len; i += 1) {
			td = tdArr[i];
			if (td.style.borderLeft === "" && td.style.borderRight !== "") {
				td.style.borderLeft = td.style.borderRight;
			}
		}
	},
	/**
	 * @private
	 * @param {Trex.TableUtil.Indexer} indexer
	 * @param {number} index
	 */
	deleteColByIndex: function (indexer, index) {
		var tdArr, len, i, td;
		tdArr = this.getTdArrByColIndex(indexer, index);
		len = tdArr.length;
		for (i = 0; i < len; i += 1) {
			td = tdArr[i];
			if (1 < td.colSpan) {
				td.colSpan -= 1;
				//TODO.azki width \uc870\uc808..?
			} else {
				$tom.remove(td);
			}
		}
	},
	getTdArrByColIndex: function (indexer, index) {
		return indexer.getTdArr(new Trex.TableUtil.Boundary({
			top: 0,
			right: index,
			bottom: indexer.getRowSize() - 1,
			left: index
		}));
	}
});

/**
 * Created by sungwon on 14. 6. 13.
 */

Trex.Table.Resize = Trex.Class.create({
    TYPE: {
        WIDTH: 'WIDTH',
        HEIGHT: 'HEIGHT'
    },
    initialize: function (editor/*, config*/) {
        var canvas;
        canvas = editor.getCanvas();
        /**
         * @private
         * @type {Trex.Canvas}
         */
        this.canvas = canvas;
        /**
         * @private
         * @type {Trex.Canvas.WysiwygPanel}
         */
        this.wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
    },
    /**
     *
     * @param {Trex.Table.Selector} select
     * @param {String} type
     * @param {Number} d
     * @param {Boolean=} isDifference
     */
    resize: function(select, type, d, isDifference){
        var els = _NULL;
        if(type == this.TYPE.WIDTH){
            els = this._makeTDArrWidth(select);
        }else {
            els = this._makeTDArrHeight(select);
        }
        if(els.expandElement == 0 ){
            return;
        }
        if(type == this.TYPE.WIDTH){
            this._resizeWidth(els.expandElement, d, isDifference);
            this._resizeTableWidth(select.currentTable);
        }else {
            this._resizeHeight(els.expandElement, d, isDifference)
            this._deleteTableHeight(select.currentTable)
        }
    },
    /**
     * @param {Number} start
     * @param {Number} end
     * @param {Number} step
     * @private
     */
    _range: function(start, end, step){
        var res = [];
        var pos = start;
        while(start<=pos&&pos<=end){
            res.push(pos);
            pos += step;
        }
        return res;
    },
    /**
     * @private
     * @param {Trex.Table.Selector} select
     * @return {Object}
     */
    _makeTDArrWidth : function(select){
        var curBoundery = select.getSelected();
        var indexer = select.getIndexer();

        var expandElement = indexer.getTdArrCol.apply(indexer, this._range(curBoundery.left,curBoundery.right,1));
        var contractElement = [];
        return {expandElement: expandElement, contractElement:contractElement}
    },
    /**
     * @private
     * @param {Trex.Table.Selector} select
     * @return {Object}
     */
    _makeTDArrHeight : function(select){
        var curBoundery = select.getSelected();
        var indexer = select.getIndexer();

        var expandElement = indexer.getTdArrRow.apply(indexer, this._range(curBoundery.top,curBoundery.bottom,1));
        var contractElement = [];
        return {expandElement: expandElement, contractElement:contractElement}
    },
    /**
     *
     * @param {Array} tds
     * @param {Number} d
     * @param {Boolean=} isDifference
     * @private
     */
    _resizeWidth: function(tds, d, isDifference){
        var MIN_WIDTH = 10;
        if (tds) {
            for (var i = 0; i < tds.length; i++) {
                tds[i].style.width = Math.max((isDifference?this._getTdWidth(tds[i]):0) + (d*tds[i].colSpan||1),MIN_WIDTH).toPx();
            }
        }
    },
    /**
     *
     * @param {Element} table
     * @private
     */
    _resizeTableWidth: function(table) {
        if(!table || !table.rows) return;
        var movingWidth = Math.min(this._getTableWidth(table), this.canvas.getSizeConfig().contentWidth);
        table.width = movingWidth.toPx();
        table.style.width = movingWidth.toPx();
    },
    /**
     *
     * @param {Element} table
     * @returns {Number}
     * @private
     */
    _getTableWidth: function(table){
        if(!table || !table.rows) return 0;
        var res = 0;
        var self = this;
        Array.prototype.each.call(table.rows[0].children,function(td){
            res+=self._getTdWidth(td);
        });
        return res;
    },
    /**
     *
     * @param {Element} td
     * @return {Number}
     * @private
     */
    _getTdWidth: function(td){
        var width = td.width||td.style.width;
        if(width.indexOf("%")!=-1)
            return td.offsetWidth;
        else
            return parseInt(width,10);
    },

    /**
     *
     * @param {Array} tds
     * @param {Number} d
     * @param {Boolean=} isDifference
     * @private
     */
    _resizeHeight: function(tds, d, isDifference){
        var MIN_HEIGHT = 20;
        if (tds) {
            for (var i = 0; i < tds.length; i++) {
                tds[i].style.height = (Math.max(parseInt((isDifference?tds[i].style.height:0),10) + (d*tds[i].rowSpan||1), MIN_HEIGHT)).toPx();
            }
        }
    },
    _deleteTableHeight: function(table){
        table.height = '';
        table.style.height = '';
    }

});


Trex.Table.Border = Trex.Class.create({
	$const: {
			BORDER_STYLE:"1px solid #ccc"
	},
	initialize: function(editor, config){
		var canvas;
		canvas = editor.getCanvas();
		
		this.wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
		this.borderRange = "all";
		this.borderColor = "#4174D9";
		this.tableSelect = _NULL;
		this.selectedBoundary = _NULL;
		
	},
	
	setBorderRange: function(value){
		this.borderRange = value;
	},

	setTableSelect: function(tableSelect){
		this.tableSelect = tableSelect;
		this.selectedBoundary = tableSelect.getSelected();
	},
	
	changeTopBorderStyle: function(tdArr, styleType, value){
		var style = {};
		var boundary = this.selectedBoundary;
		var borderStyle, tdArray ; 
		var indexer = this.tableSelect.getIndexer();
		var tempBoundary;
		
		if (boundary.top == 0){
			borderStyle = "borderTop" + styleType; 
			tempBoundary = new Trex.TableUtil.Boundary({
				"top": boundary.top,
				"bottom": boundary.top,
				"left": boundary.left,
				"right": boundary.right
			});
			
		} else {
			borderStyle = "borderBottom" + styleType; 
			tempBoundary = new Trex.TableUtil.Boundary({
				"top" : boundary.top-1,
				"bottom" : boundary.top-1,
				"left" : boundary.left,
				"right" : boundary.right
			});
			
		}
		
		tdArray = indexer.getTdArr(tempBoundary); 
		style[borderStyle] = value;
		
		for(var i=0; i< tdArray.length; i++){
			$tx.setStyle(tdArray[i], style);
		}		
	},
	
	changeBottomBorderStyle: function(tdArr, styleType, value){
		var style = {};
		var boundary = this.selectedBoundary;
		var borderStyle, tdArray, tempBoundary ; 
		var indexer = this.tableSelect.getIndexer();
		
		borderStyle = "borderBottom" + styleType; 
		tempBoundary = new Trex.TableUtil.Boundary({
			"top" : boundary.bottom,
			"bottom" : boundary.bottom,
			"left" : boundary.left,
			"right" : boundary.right
		});
	
		tdArray = indexer.getTdArr(tempBoundary); 
		style[borderStyle] = value;
		
		for(var i=0; i< tdArray.length; i++){
			$tx.setStyle(tdArray[i], style);
		}	
	},
	
	changeLeftBorderStyle: function(tdArr, styleType, value){
		var style = {};
		var boundary = this.selectedBoundary;
		var borderStyle, tdArray ; 
		var indexer = this.tableSelect.getIndexer();
		var tempBoundary;
		
		if (boundary.left == 0){
			borderStyle = "borderLeft" + styleType; 
			tempBoundary = new Trex.TableUtil.Boundary({
				"top": boundary.top,
				"bottom": boundary.bottom,
				"left": boundary.left,
				"right": boundary.left
			});
			
		} else {
			borderStyle = "borderRight" + styleType; 
			tempBoundary = new Trex.TableUtil.Boundary({
				"top" : boundary.top,
				"bottom" : boundary.bottom,
				"left" : boundary.left-1,
				"right" : boundary.left-1
			});
			
		}
		
		tdArray = indexer.getTdArr(tempBoundary); 
		style[borderStyle] = value;
		
		for(var i=0; i< tdArray.length; i++){
			$tx.setStyle(tdArray[i], style);
		}
	},
	
	changeRightBorderStyle: function(tdArr, styleType, value){
		var style = {};
		var boundary = this.selectedBoundary;
		var borderStyle, tdArray ; 
		var indexer = this.tableSelect.getIndexer();
		var tempBoundary;
		
		borderStyle = "borderRight" + styleType; 
		tempBoundary = new Trex.TableUtil.Boundary({
			"top" : boundary.top,
			"bottom" : boundary.bottom,
			"left" : boundary.right,
			"right" : boundary.right
		});
		
		tdArray = indexer.getTdArr(tempBoundary); 
		style[borderStyle] = value;
		
		for(var i=0; i< tdArray.length; i++){
			$tx.setStyle(tdArray[i], style);
		}
	},
	
	changeInBorderStyle: function(tdArr, styleType, value){
		var colStyle = {};
		var rowStyle = {};
		var boundary = this.selectedBoundary;
		var colTdArray, rowTdArray, colBorderStyle, rowBorderStyle;
		var colBoundary, rowBoundary; 
		var indexer = this.tableSelect.getIndexer();
	
		colBorderStyle = "borderBottom" + styleType; 
		colBoundary = new Trex.TableUtil.Boundary({
			"top" : boundary.top,
			"bottom" : boundary.bottom - 1 ,
			"left" : boundary.left,
			"right" : boundary.right
		});
		colTdArray = indexer.getTdArr(colBoundary); 
		colStyle[colBorderStyle] = value;
		
		for(var i=0; i< colTdArray.length; i++){
			$tx.setStyle(colTdArray[i], colStyle);
		}
		
		rowBorderStyle = "borderRight" + styleType; 
		rowBoundary = new Trex.TableUtil.Boundary({
			"top" : boundary.top,
			"bottom" : boundary.bottom,
			"left" : boundary.left,
			"right" : boundary.right-1
		});
		rowTdArray = indexer.getTdArr(rowBoundary); 
		rowStyle[rowBorderStyle] = value;
		
		for(var i=0; i< rowTdArray.length; i++){
			$tx.setStyle(rowTdArray[i], rowStyle);
		}
	},
	
	changeOutBorderStyle: function(tdArr, styleType, value){
		this.changeTopBorderStyle( tdArr, styleType, value );
		this.changeBottomBorderStyle( tdArr, styleType, value );
		this.changeLeftBorderStyle( tdArr, styleType, value );
		this.changeRightBorderStyle( tdArr, styleType, value );
	},
	
	changeNoneBorderStyle: function(tdArr, styleType, value){
		
	
	},
	
	changeBorderStyle: function( tdArr, styleType, value ){
		
		var borderRange = this.borderRange;
		switch(borderRange){
			case "top":
				this.changeTopBorderStyle( tdArr, styleType, value );
				break;
			case "bottom":
				this.changeBottomBorderStyle( tdArr, styleType, value );
				break;
			case "left":
				this.changeLeftBorderStyle( tdArr, styleType, value );
				break;
			case "right": 
				this.changeRightBorderStyle( tdArr, styleType, value );
				break;
			case "in": 
				this.changeInBorderStyle( tdArr, styleType, value );
				break;
			case "out":
				this.changeOutBorderStyle( tdArr, styleType, value ); 
				break;
			case "all":
				this.changeInBorderStyle( tdArr, styleType, value );
				this.changeOutBorderStyle( tdArr, styleType, value );
				break;
			case "none":
				this.changeInBorderStyle( tdArr, styleType, value );
				this.changeOutBorderStyle( tdArr, styleType, value );
				break;
			default:
				break;
		}
	},
	changeBorderColor: function(tdArr, value){
		if (value != _NULL) {
			this.borderColor = value;
		}
		this.changeBorderStyle(tdArr, "Color", this.borderColor);
	},
	changeBorderType: function(tdArr, value){
		this.changeBorderStyle(tdArr, "Style", value );
		this.changeBorderColor(tdArr);
	},
	changeBorderHeight: function(tdArr, value){
		var width = value.toPx();
		this.changeBorderStyle( tdArr, "Width", width ); 
		this.changeBorderColor(tdArr);
	}
	
});

(function() {

    Trex.Table.TemplateLoader = Trex.Class.create({
        initialize: function() {
            this.templateList = _NULL;
        },
        getTemplate: function(index, callback) {
            if (isNaN(index)) {
                return;
            }

            if (this.templateList) {
                callback(new TableTemplate(this.templateList[index]));
            } else {
                var self = this;
                this.loadTemplate(function (templateList) {
                    self.templateList = templateList;
                    callback(new TableTemplate(self.templateList[index]));
                });
            }
        },
        loadTemplate: function(onLoadComplete) {
            var url = this.getJSBasePath() + "trex/modules/table/async/template_data.js";
            if (EditorJSLoader.getOption('environment') == 'development') {
                url += '?dummy=' + (new Date()).getTime();
            }
            EditorJSLoader.asyncLoadModule({
                url: TrexConfig.getUrl(url),
                callback: function() {
                    var templateList = getTableTemplateList();
                    onLoadComplete(templateList);
                }
            });
        },
        getJSBasePath: function() {
            var basePath;
            try {
                basePath = EditorJSLoader.getJSBasePath("editor.js");
            } catch (e) {
                basePath = EditorJSLoader.getJSBasePath();
            }
            return basePath;
        }
    });


    var TableTemplate = Trex.Class.create({
        initialize: function(templateData) {
            this.templateData = templateData;
        },
        apply: function(table) {
            var tableMatrixer = new Trex.Tool.Table.TableCellMatrixer(table);
            var tdMatrix = tableMatrixer.getTdMatrix();
            var self = this;

            for (var i = 0; i < tdMatrix.length; i++) {
                for (var j = 0; j < tdMatrix[i].length; j++) {
                    self.setCellStyle(tdMatrix[i][j], {
                        isEvenRow: (i % 2) == 1,
                        isFirstRow: i == 0,
                        isLastRow: i == tdMatrix.length - 1,
                        isFirstCol: j == 0,
                        isLastCol: (j == tdMatrix[i].length - 1)
                    });
                }
            }
        },
        setCellStyle: function(elTd, truthMap) {
            var t = this.templateData;
            var style = Object.extend({}, t['common']);
            Object.extend(style, (truthMap.isEvenRow) ? t['evenRow'] : t['oddRow']);
            Object.extend(style, (truthMap.isFirstRow) ? t['firstRow'] : (truthMap.isLastRow) ? t['lastRow'] : {});
            Object.extend(style, (truthMap.isLastCol) ? t['lastCol'] : {});
            Object.extend(style, (truthMap.isFirstCol) ? t['firstCol'] : {});
            txlib.setStyle(elTd, style);
        }
    });
})();
Trex.MarkupTemplate.add('module.areaselect',
    '<div class="tx-area-selection" contenteditable="false" style="visibility:hidden;position:absolute;z-index:999;display: block; left: 0px;line-height:1; top: 0px; width: 0px; height: 0px;">' +
    '<div class="tx-area-move-holder" style="display:none;visibility:visible;position: absolute; z-index: 1000; line-height: 1; cursor:move; top: -4px; left: -5px; border:1px solid #FFFFFF;width:8px;height:8px;background-color: #000000;"></div>' +
    '<div class="tx-area-holder-sw" style="visibility:visible;position: absolute; z-index: 1000; line-height: 1; bottom: -4px; left: -5px; border:1px solid #000000;width:5px;height:5px;border-right:0;border-top:0;"></div>' +
    '<div class="tx-area-holder-sw" style="visibility:visible;position: absolute; z-index: 1000; line-height: 1; top: -4px; right: -3px; border:1px solid #000000;width:5px;height:5px;border-left:0;border-bottom:0;"></div>' +
    '<div class="tx-area-holder" style="visibility:visible;position: absolute; z-index: 1000; line-height: 1; cursor:nw-resize; bottom: -4px; right: -5px; border:1px solid #000000;width:8px;height:8px;background-color: #FFFFFF;"></div>' +
    '<div class="tx-area-selection-info" style="visibility:visible;display:none;position: absolute; z-index:1002; line-height: 1;bottom: 10px; right: 5px; background-color:#000000;font-size:12px;color:#FFFFFF;padding: 3px">0x0</div>' +
    '</div>');

/**
 * @desc Area \ubaa8\ub4c8
 * @type {{}}
 */
Trex.Area = {};

Trex.Area.BrowserSelect = Trex.Class.create({
    initialize: function(editor){
        this._canvas = editor.getCanvas();
        this._panel = this._canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
        this._doc = this._panel.getDocument();
        this._win = this._panel.getWindow();
        this._isSelect = _FALSE;
    },
    select:function(element){
        if(!element)
            return;
        var _p;
        if((_p = this._canvas.getProcessor()).getControl() !== element)
            _p.selectControl(element);
        this._isSelect = _TRUE;
        this._canvas.fireJobs(Trex.Ev.__CANVAS_SELECT_ITEM);
    },
    update:function(element){},
    reset:function(){
        if(this.isSelect())
            this._canvas.fireJobs(Trex.Ev.__CANVAS_UNSELECT_ITEM);
        this._isSelect = _FALSE;
    },
    isSelect: function(){
        return this._isSelect;
    },
    getTarget:function(){
        return this._canvas.getProcessor().getControl();
    }
});

Trex.Area.Select = Trex.Class.create({
    /**
     * @type {_NULL|HTMLElement}
     * @private
     */
    _target: _NULL,
    /**
     * @type {HTMLElement}
     * @private
     */
    _selectElement: _NULL,
    _isSelect:_FALSE,
    initialize: function(editor){
        this._canvas = editor.getCanvas();
        this._panel = this._canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
        this._doc = this._panel.getDocument();
        this._win = this._panel.getWindow();
        this._selectElement = this._makeElement();
    },
    _getCanvas: function(){
        return this._canvas;
    },
    _getPanel: function(){
        return this._panel;
    },
    _getWindow: function(){
        return this._win;

    },
    _getDocument: function(){
        return this._doc;
    },
    /**
     * @param {HTMLElement} element
     * @returns {{left: number, right: number, top: number, bottom:number, width: number, height:number}}
     * @private
     */
    _getPosition: function(element){
        var of = $tx.getOffset(element);
        var width = of.right - of.left;
        var height = of.bottom - of.top;
        of.width = width;
        of.height = height;
        return of;
    },

    /**
     * @param {{}} style
     * @private
     */
    _setSelectStyle: function(style){
        $tx.setStyle(this._selectElement, style);
    },

    /**
     * @param {number} width
     * @param {number} height
     * @private
     */
    _setSelectInfo: function(width, height){
        var INFO_MIN_WIDTH = 100;
        var INFO_MIN_HEIGHT = 50;
        var info = $tom.collect(this._selectElement,'.tx-area-selection-info');
        info.innerHTML = (width|0) + 'x' + (height|0);
        if(width < INFO_MIN_WIDTH || height < INFO_MIN_HEIGHT){
            $tx.setStyle(info, {
                right: '',
                left: (width + 10).toPx()
            });
        }else {
            $tx.setStyle(info, {
                right: '5px',
                left: ''
            });
        }
    },

    /**
     * @param {HTMLElement} element
     * @private
     */
    _makeSelect: function(element){
        if(!element){
            this.reset();
        }else {
            var po = this._getPosition(element);
            $tx.show(this._selectElement);

            this._setSelectStyle({
                top: po.top.toPx(),
                left: po.left.toPx(),
                width: po.width.toPx(),
                height: po.height.toPx()
            });
            this._setSelectInfo(po.width, po.height);
        }
    },
    _makeElement: function(){
        var sel= Trex.MarkupTemplate.get("module.areaselect").evaluateAsDom({});
        $tx.setOpacity($tom.collect(sel,'.tx-area-selection-info'),0.7);
        return sel;
    },
    isSelect: function(){
        return this._isSelect;
    },
    /**
     *
     * @param element
     */
    select: function(element){
        if(!element)
            return;
        var self = this;
        if ($tom.kindOf(element, "img")){
            self._canvas.getProcessor().createGoogFromNodeContents(element).select();
        }
        this._target = element;
        $tom.insertNext(this._selectElement,this._doc.body);
        this._isSelect = _TRUE;
        this._makeSelect(element);
        this._canvas.fireJobs(Trex.Ev.__CANVAS_SELECT_ITEM);
    },
    update: function(element){
        this._makeSelect(element||this._target);
    },
    reset: function(){
        if(this.isSelect())
            this._canvas.fireJobs(Trex.Ev.__CANVAS_UNSELECT_ITEM);
        this._isSelect = _FALSE;
        $tom.remove(this._selectElement);
        this._target = _NULL;
    },
    getTarget: function(){
        return this._target;
    },
    getOrigin: function(){
        return this;
    }

});

Trex.Area.Resize = Trex.Class.create({
    _mouseData : {
        downPoint:[0,0],
        targetOffset: _NULL,
        moveTarget: _NULL
    },
    /**
     * @desc 'NONE' \uc77c\ubc18 'DRAG' \ub4dc\ub798\uadf8 \uc911
     */
    _state : 'NONE',
    /**
     * @param {Trex.Area.Select} select
     */
    $mixins: [Trex.I.point],
    initialize: function(select){
        this._select = select;
        this._holer = $tom.collect(this.getOrigin()._selectElement,'.tx-area-holder');
        this._info = $tom.collect(this.getOrigin()._selectElement,'.tx-area-selection-info');
        this._state = 'NONE';
        this._canvas = this.getOrigin()._getCanvas();
        /**
         * @type {Trex.Canvas.WysiwygPanel}
         * @private
         */
        this._panel = this.getOrigin()._getPanel();
        /**
         * @type {HTMLDocument}
         * @private
         */
        this._doc = this.getOrigin()._getDocument();
        /**
         * @type {Window}
         * @private
         */
        this._win = this.getOrigin()._getWindow();
        this._observeEvent();
    },
    _observeEvent: function(){
        var self = this;
        $tx.observe(this._holer, 'mousedown',function(e){
            self._mousedown(e);

        }, false);
        $tx.observe(this._holer, 'mouseup',function(e){
            self._mouseup(e);
        }, false);
        $tx.observe(this._holer, 'mousemove',function(e){
            self._mousemove(e);
        }, false);
        $tx.observe(_DOC.body, 'mouseup',function(e){
            self._mouseup(e);
        }, false);
        $tx.observe(_DOC.body, 'mousemove',function(e){
            self._mousemove(e);
        }, false);


        this._canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEMOVE, function(e){
            self._mousemove(e);
        });
        this._canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEUP, function(e){
            self._mouseup(e);
        });
    },
    _mousedown: function(e){
        if(this._state === 'NONE'){
            this._changeState('DRAG');
            this._mouseData.downPoint = this._getPointByEvent(e);
            var offset = $tx.getOffset(this._select.getTarget());
            this._mouseData.targetOffset = offset;
            var el = this._select.getTarget().cloneNode(_TRUE);
            $tx.setStyle(el,{
                position: 'absolute',
                top: offset.top.toPx(),
                left: offset.left.toPx(),
                zIndex: 998
            });
            $tx.setOpacity(el, 0.3);
            $tom.insertNext(el,this._doc.body);
            this._mouseData.moveTarget = el;
            $tx.stop(e);
        }
    },
    _mouseup: function(e){
        if(this._state === 'DRAG'){
            var isRatio = _FALSE;
            if(e.shiftKey== true){
                isRatio = _TRUE;
            }
            this._changeState('NONE');
            $tom.remove(this._mouseData.moveTarget);
            this._resize(this._select.getTarget(), isRatio? this._ratio(this._mouseData.targetOffset,this._getPointByEvent(e)):this._getPointByEvent(e));
            this._mouseData.moveTarget = _NULL;
            $tx.hide(this._info);
            this.update();
            $tx.stop(e);
            this._canvas.history.saveHistory();
        }
    },
    _mousemove: function(e){
        if(this._state === 'DRAG'){
            $tx.show(this._info);
            var isRatio = _FALSE;
            if(e.shiftKey== true){
                isRatio = _TRUE;
            }
            this._resize(this._mouseData.moveTarget, isRatio? this._ratio(this._mouseData.targetOffset,this._getPointByEvent(e)):this._getPointByEvent(e));
            this.update(this._mouseData.moveTarget);
            $tx.stop(e);
        }
    },
    _ratio: function(offset, point){
        var p = this._subtractPoint(point, this._mouseData.downPoint);
        var r = (offset.right-offset.left)/(offset.bottom - offset.top);
        var isW = _FALSE;
        if(p[0] < 1/r*p[1]){
            isW = _TRUE;
        }
        return this._addPoint(this._mouseData.downPoint,[isW?p[0]:r*p[1], isW?1/r*p[0]:p[1]]);
    },
    _resize: function(el, point){
        if(!el) return;
        var p = this._subtractPoint(point, this._mouseData.downPoint);
        this._setWidth(el, p[0]);
        this._setHeight(el, p[1]);
    },
    _setWidth: function(el, d){
        var elw = this._mouseData.targetOffset.right - this._mouseData.targetOffset.left;
        var width = (Math.min(Math.max(elw + d,10), this._canvas.getSizeConfig().contentWidth)).toPx();
        el.width = width;
        el.style.width = width;
    },
    _setHeight: function(el, d){
        var elh = this._mouseData.targetOffset.bottom - this._mouseData.targetOffset.top;
        var height = (Math.max(elh + d, 10)).toPx();
        el.height = height;
        el.style.height = height;
    },
    /**
     * @param mode
     * @private
     */
    _changeState: function(mode){
        if(!['NONE', 'READY', 'DRAG'].contains(mode)) return;
        this._state = mode;
    },
    isSelect: function(){
        return this._select.isSelect();
    },
    select: function(element){
        this._select.select(element);
        $tx.show(this._holer);
    },
    update: function(element){
        this._select.update(element);
    },
    reset: function(){
        this._select.reset();
        $tx.hide(this._info);
        $tx.hide(this._holer);
    },
    getTarget: function(){
        return this._select.getTarget();
    },
    getOrigin: function(){
        return this._select.getOrigin();
    }
});

Trex.Area.Move = Trex.Class.create({
    _mouseData : {
        downPoint:[0,0],
        targetOffset: _NULL,
        moveTarget: _NULL
    },
    /**
     * @desc 'NONE' \uc77c\ubc18 'DRAG' \ub4dc\ub798\uadf8 \uc911
     */
    _state : 'NONE',
    /**
     * @param {Trex.Area.Select} select
     */
    $mixins: [Trex.I.point],
    initialize: function(select){
        this._select = select;
        this._holer = $tom.collect(this.getOrigin()._selectElement,'.tx-area-move-holder');
        this._state = 'NONE';
        this._canvas = this.getOrigin()._getCanvas();
        /**
         * @type {Trex.Canvas.WysiwygPanel}
         * @private
         */
        this._panel = this.getOrigin()._getPanel();
        /**
         * @type {HTMLDocument}
         * @private
         */
        this._doc = this.getOrigin()._getDocument();
        /**
         * @type {Window}
         * @private
         */
        this._win = this.getOrigin()._getWindow();
        this._observeEvent();
    },
    _observeEvent: function(){
        var self = this;
        $tx.observe(this._holer, 'mousedown',function(e){
            self._mousedown(e);

        }, false);
        $tx.observe(this._holer, 'mouseup',function(e){
            self._mouseup(e);
        }, false);
        $tx.observe(this._holer, 'mousemove',function(e){
            self._mousemove(e);
        }, false);
        $tx.observe(_DOC.body, 'mouseup',function(e){
            self._mouseup(e);
        }, false);
        /*$tx.observe(_DOC.body, 'mousemove',function(e){
            self._mousemove(e);
        }, false);*/

        this._canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEMOVE, function(e){
            self._mousemove(e);
        });
        this._canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEUP, function(e){
            self._mouseup(e);
        });
    },
    _mousedown: function(e){
        if(this._state === 'NONE'){
            this._changeState('DRAG');
            this._mouseData.downPoint = this._getPointByEvent(e);
            var offset = $tx.getOffset(this._select.getTarget());
            this._mouseData.targetOffset = offset;
            var el = this._select.getTarget().cloneNode(_TRUE);
            $tx.setStyle(el,{
                position: 'absolute',
                top: offset.top.toPx(),
                left: offset.left.toPx(),
                zIndex: 998
            });
            $tx.setOpacity(el, 0.3);
            $tom.insertNext(el,this._doc.body);
            this._mouseData.moveTarget = el;
            $tx.stop(e);
        }
    },
    _mouseup: function(e){
        if(this._state === 'DRAG'){
            this._changeState('NONE');
            var isDuplicate = _FALSE;
            if(e.ctrlKey == _TRUE){
                isDuplicate = _TRUE;
            }
            $tom.remove(this._mouseData.moveTarget);
            if(!isDuplicate){
                this._move(this._select.getTarget(),this._getPointByEvent(e));
                //ie \ubb38\uc81c element \uc704\uce58 \ubcc0\uacbd\uc804\uc758 \uc704\uce58\ub97c \uac00\uc838\uc628\ub2e4.
                setTimeout(this.select.bind(this, this._select.getTarget()), 35);
            }else {
                var cl = this._select.getTarget().cloneNode(true);
                this._move(cl,this._getPointByEvent(e));
                //ie \ubb38\uc81c element \uc704\uce58 \ubcc0\uacbd\uc804\uc758 \uc704\uce58\ub97c \uac00\uc838\uc628\ub2e4.
                setTimeout(this.select.bind(this,cl),35);
            }
            this._mouseData.moveTarget = _NULL;
            $tx.stop(e);
            this._canvas.history.saveHistory();
        }
    },
    _mousemove: function(e){
        if(this._state === 'DRAG'){
            this._moving(this._mouseData.moveTarget,this._getPointByEvent(e));
            this.update(this._mouseData.moveTarget);
            $tx.stop(e);
        }
    },
    _moving: function(element, point){
        $tx.setStyle(element,{
            position: 'absolute',
            left: (point[0]+10).toPx(),
            top: (point[1]+10).toPx()
        });
        var p = this._canvas.getProcessor();
        this._canvas.focus();
        p.moveSelection(point[0], point[1]);
    },
    _move: function(element, point){
        var p = this._canvas.getProcessor();
        this._canvas.focus();
        try {
            var _node = p.getNode();
            if(!$tom.findAncestor(_node, function(node){
                return node.tagName === 'BODY';
            }, function(node){
                return !node;
            } )){
                p.selectControl(element);
                return;
            }
            p.pasteNode(element);
            p.selectControl(element);
        }catch(e){
            
        }


    },

    /**
     * @param mode
     * @private
     */
    _changeState: function(mode){
        if(!['NONE', 'READY', 'DRAG'].contains(mode)) return;
        this._state = mode;
    },
    isSelect: function(){
        return this._select.isSelect();
    },
    select: function(element){
        this._select.select(element);
        $tx.show(this._holer);
    },
    update: function(element){
        this._select.update(element);
    },
    reset: function(){
        this._select.reset();
        $tx.hide(this._holer);
    },
    getTarget: function(){
        return this._select.getTarget();
    },
    getOrigin: function(){
        return this._select.getOrigin();
    }
});

Trex.Area.Control = Trex.Class.create({
    $mixins: [Trex.I.KeyObservable],
    initialize: function(select){
        this._select = select;
        this._canvas = select._canvas;
        this._observeEvent();

    },
    _observeEvent: function(){
        var self = this;
        this.observeKey({
            keyCode: 46
        },  function(e){
                if(self.isSelect()){
                    $tom.remove(self._select.getTarget());
                    self.reset();
                    $tx.stop(e);
                }
            }
        );
        this.observeKey({
                keyCode: 8
            },  function(e){
                if(self.isSelect()){
                    $tom.remove(self._select.getTarget());
                    self.reset();
                    $tx.stop(e);
                }
            }
        );
        this._canvas.observeJob(Trex.Ev.__CANVAS_PANEL_KEYDOWN, function(e){
            if(/^(16|17|18|46|8)$/.test(e.keyCode)){
                self.fireKeys(e, _TRUE);
            }else {
                self.reset();
            }
        });

    },
    getTarget: function(){
        return this._select.getTarget();
    },
    isSelect: function(){
        return this._select.isSelect();
    },
    select: function(element){
        this._select.select(element);
    },
    update: function(element){
        this._select.update(element);
    },
    reset: function(){
        this._select.reset();
    },
    getOrigin: function(){
        return this._select.getOrigin();
    }

});

Trex.module("area select", function(editor, toolbar, sidebar, canvas, config){
    canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function(doc) {
        var _processor = canvas.getProcessor(Trex.Canvas.__WYSIWYG_MODE);
        var select;
        if($tx.msie){
            select = new Trex.Area.BrowserSelect(editor);
        }else {
            select = new Trex.Area.Control(new Trex.Area.Resize(new Trex.Area.Select(editor)));
            if (_DOC.caretPositionFromPoint || _DOC.caretRangeFromPoint) {
                select = new Trex.Area.Move(select)
            }
        }
        _processor.getAreaSelection = function(){
            return select;
        };
        var _excludes = Trex.__EXCLUDE_IMG;
        var mousedownel = _NULL, mouseup, mousedown;
        if($tx.msie) {
            // ie\uc5d0\uc11c\ub9cc isResizeing\uc744 \uc0ac\uc6a9\ud55c\ub2e4. ie\uc778 \uacbd\uc6b0 \ub9ac\uc0ac\uc774\uc988 \uc5ec\ubd80\ub97c \ud655\uc778\ud558\uae30 \uc5b4\ub835\ub2e4.
            select.isResizing = false;
            function resizestart(ev) {
                var el = $tx.element(ev);
                if($tom.kindOf(el, 'img,table')){
                    select.isResizing = true;
                }
            }
            function resizeend(ev) {
                var el = $tx.element(ev);
                if($tom.kindOf(el, 'img,table')){
                    select.isResizing = false;
                }
            }
            $tx.observe(doc.body, "resizestart", resizestart);
            $tx.observe(doc.body, "resizeend", resizeend);
            mousedown = function mousedown(e) {
                var el = $tx.element(e);
                mousedownel = el;
                if ($tom.kindOf(el, 'table')&&el!==select.getTarget()) {
                    $tx.stop(e);
                }else {
                    select.reset();
                }
            };
            mouseup = function mouseup(e) {
                var el = $tx.element(e);
                if (el != mousedownel || !$tom.kindOf(el, 'img')) {
                    select.reset();
                    mousedownel = _NULL;
                    return;
                }
                if($tom.kindOf(el, 'img,table')&&!Trex.Util.getMatchedClassName(el, _excludes))
                    select.select(el);
            };
        }else {
            mousedown = function mousedown(e) {
                var el = $tx.element(e);
                mousedownel = el;
                if ($tom.kindOf(el, 'img,table')&&!Trex.Util.getMatchedClassName(el, _excludes)) {
                    $tx.stop(e);
                }else {
                    select.reset();
                }
            };
            mouseup = function mouseup(e) {
                var el = $tx.element(e);
                if (el != mousedownel || (!$tom.kindOf(el, 'img') && !_processor.isCollapsed())) {
                    select.reset();
                    mousedownel = _NULL;
                    return;
                }
                if($tom.kindOf(el, 'img,table')&&!Trex.Util.getMatchedClassName(el, _excludes)&&!$tom.find(el, 'button'))
                    select.select(el);
            };
        }
        canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEDOWN, mousedown);
        canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEUP, mouseup);
        canvas.observeJob(Trex.Ev.__CANVAS_SELECT_ITEM, function(){
            var googRange = canvas.getProcessor().createGoogFromNodeContents(select.getTarget());
            if (googRange) {
                canvas.fireJobs(Trex.Ev.__CANVAS_PANEL_QUERY_STATUS, googRange);
            }
        });
        canvas.observeJob(Trex.Ev.__CANVAS_PANEL_SCROLLING, function(e){
            select.update();
        });

        $tx.observe(_DOC.body, "mousedown", function(ev) {
            select.reset();
        });
        toolbar.observeJob(Trex.Ev.__TOOL_CLICK, function (identity) {
            if(/align(center|full|left|right)/.test(identity) && $tom.kindOf(select.getTarget(), 'table,img')){
            }
            else {
                select.reset();
            }

        });

    });

});
/**
 * Created by sungwon on 14. 7. 21.
 */
Trex.module("page up & down", function(editor, toolbar, sidebar, canvas, config) {
    canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function(doc) {
        function exeHandler(){
            moveScroll();
        }
        function moveScroll(){
            var top = (_WIN.pageYOffset || _DOC.documentElement.scrollTop) - (_DOC.documentElement.clientTop||0);
            var left = (_WIN.pageXOffset || _DOC.documentElement.scrollLeft) - (_DOC.documentElement.clientLeft||0);

            function fixscroll(e){
                window.scrollTo(left, top);
            }

            $tx.observe(_WIN, 'scroll', fixscroll);

            setTimeout(function(){
                $tx.stopObserving(_WIN, 'scroll', fixscroll);
            },30);

        }
        $tx.observe(doc, 'keydown', function(e){
            if(/^(33|34)$/.test(e.keyCode)){
                exeHandler();
            }

        });

    });
});
Trex.Table.Dragger = Trex.Class.create({
    EDGE_TYPE: {
        TOP: "EDGE_TOP",
        BOTTOM: "EDGE_BOTTOM",
        LEFT: "EDGE_LEFT",
        RIGHT: "EDGE_RIGHT",
        NONE: "NONE"
    },
    $mixins: [Trex.I.point],
    initialize: function(editor, config){
        /**
         * @type {Trex.Editor.canvas}
         * @private
         */
        this._canvas = editor.canvas;
        /**
         * @type {Trex.Canvas.WysiwygPanel}
         * @private
         */
        this._panel = this._canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
        /**
         * @type {HTMLDocument}
         * @private
         */
        this._doc = this._panel.getDocument();
        /**
         * @type {Window}
         * @private
         */
        this._win = this._panel.getWindow();
        /**
         * @type {*}
         * @private
         */
        this._config = config;
        /**
         * @type {HTMLElement}
         * @private
         */
        this._colGuide = $tom.collect(this._canvas.wysiwygEl, ".tx-table-col-resize-dragger");
        /**
         * @type {HTMLElement}
         * @private
         */
        this._rowGuide = $tom.collect(this._canvas.wysiwygEl, ".tx-table-row-resize-dragger");
        /**
         * @type {Object}
         * @private
         */
        this._mouseData = {
            downPoint: [0,0],
            moveTd: _NULL,
            downType: this.EDGE_TYPE.NONE,
            downTd: _NULL
        };
        this._observeEvent();
        /**
         * @desc NONE: \uc77c\ubc18, READY: \ub4dc\ub798\uadf8 \uc804, DRAG: \ub4dc\ub798\uadf8 \uc911
         * @type {string}
         * @private
         */
        this._state = 'NONE';
        this._MINWIDTH = 10;
        this._MINHEIGHT = 20;
    },
    mousedown: function(e){
        if(this._state =='NONE'){
            var td = this._mouseData.moveTd;
            if(!td||!td.parentNode) return;
            var point = this._getPointByEvent(e);
            if(this._getType(td,point)=='NONE') return;
            $tx.stop(e);
            this._setMouseDownData(td, point);
            this._changeState('READY');
        }

    },
    mousemove: function(e){
        var point = this._getPointByEvent(e);
        if(this._state =='NONE'){
            if(this._canvas.getProcessor().table.isDuringSelection()) return;
            var td = this._getTdByEvent(e);
            this._mouseData.moveTd= td;
            var type = this._getType(td, point);
            this._makeGuide(type, this._state, point);
        }
        if(this._state == 'READY'){
            if(this._distancePoint(this._mouseData.downPoint, point) > 6){
                this._changeState('DRAG');
            }
            this._makeGuide(this._mouseData.downType, this._state, point);
        }
        if(this._state == 'DRAG'){
            var tdArr = this._makeTDArr(this._mouseData.downTd, this._mouseData.downType, $tom.find(this._mouseData.downTd, 'table'));
            var p = this._calMinMaxPoint(tdArr, point,this._mouseData.downType);
            this._makeGuide(this._mouseData.downType, this._state, p);
        }

    },
    mouseup: function(ev){
        var sel = this._canvas.getProcessor().getAreaSelection();
        if(this._state == 'DRAG'){
            sel.reset();
            var tdArr = this._makeTDArr(this._mouseData.downTd, this._mouseData.downType, $tom.find(this._mouseData.downTd, 'table'));
            var point = this._getPointByEvent(ev);
            this._resize(tdArr, point, this._mouseData.downType)
        }

        if(this._state == 'READY' ){
            var el;
            el = $tom.find(this._mouseData.downTd, 'table');
            if(!el) {
                sel.reset();
                return;
            }
            sel.select(el);
            $tx.stop(ev);

        }

        if(this._state != 'NONE'){
            this._changeState('NONE');
            this._makeGuide(this.EDGE_TYPE.NONE, 'NONE', this._getPointByEvent(ev));
            this._setMouseDownData(_NULL, [0,0]);
        }

    },
    _observeEvent: function(){
        var self = this;
        $tx.observe(_DOC.body, "mouseup", function(ev) {
            if(!self._canvas.isWYSIWYG()) return;
            self.mouseup(ev);
        });
        this._canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEUP, function(ev){
            self.mouseup(ev);
        });
        this._canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEMOVE, function(ev){
            self.mousemove(ev);
        });
        this._canvas.observeJob(Trex.Ev.__CANVAS_PANEL_MOUSEDOWN, function(ev){
            self.mousedown(ev);
        });
        $tx.observe(this._rowGuide, "mousedown", function(ev) {
            self.mousedown(ev);
            if(self._state != 'DRAG'){
                if(self._mouseData.moveTd)
                    Trex.TableUtil.collapseCaret(self._panel, self._mouseData.moveTd);
            }
        });
        $tx.observe(this._colGuide, "mousedown", function(ev) {
            self.mousedown(ev);
            if(self._state != 'DRAG'){
                if(self._mouseData.moveTd)
                    Trex.TableUtil.collapseCaret(self._panel, self._mouseData.moveTd);
            }
        });
        $tx.observe(this._rowGuide, "mouseup", function(ev) {
            self.mouseup(ev);
        });
        $tx.observe(this._colGuide, "mouseup", function(ev) {
            self.mouseup(ev);
        });
    },
    /**
     * @param mode
     * @private
     */
    _changeState: function(mode){
        if(!['NONE', 'READY', 'DRAG'].contains(mode)) return;
        this._state = mode;
    },
    /**
     *
     * @private
     * @param {String} type
     * @param {HTMLElement} table
     * @param {HTMLElement} td
     */
    _makeTDArr: function(td, type, table){
        var indexer = new Trex.TableUtil.Indexer(table);
        var curBoundery = indexer.getBoundary(td);
        var expandElements = [],contractElements = [];
        var mapping = {
            EDGE_TOP: function(){expandElements = indexer.getTdArrHasBottom(curBoundery.top - 1)},
            EDGE_BOTTOM: function(){expandElements = indexer.getTdArrHasTop(curBoundery.bottom)},
            EDGE_LEFT: function(){
                if (curBoundery.left > 0) {
                    expandElements = indexer.getTdArrHasRight(curBoundery.left - 1);
                    contractElements = indexer.getTdArrHasLeft(curBoundery.left);
                }
            },
            EDGE_RIGHT: function(){
                expandElements = indexer.getTdArrHasRight(curBoundery.right);
                if (curBoundery.right < indexer.getColSize() - 1) {
                    contractElements = indexer.getTdArrHasLeft(curBoundery.right + 1);
                }
            }

        };
        mapping[type]();
        return {
            expandElements: expandElements,
            contractElements: contractElements
        }
    },
    /**
     * @param {String} type
     * @returns {HTMLElement}
     * @private
     */
    _getGuide : function(type) {
        switch (type) {
            case this.EDGE_TYPE.LEFT:
            case this.EDGE_TYPE.RIGHT:
                return this._colGuide;
            case this.EDGE_TYPE.TOP:
            case this.EDGE_TYPE.BOTTOM:
                return this._rowGuide;
                break;
        }
        return _NULL;
    },
    /**
     * @param {HTMLElement} guide
     * @param {Object} style
     * @private
     */
    _setGuideStyle: function(guide, style) {
        $tx.setStyle(guide, style);
    },
    /**
     *
     * @param {String} type
     * @param {String} state
     * @param {[]} point
     * @private
     */
    _makeGuide: function(type, state, point){
        $tx.hide(this._colGuide);
        $tx.hide(this._rowGuide);
        var g = this._getGuide(type);
        if(!g) return;
        var style = {
            "border": "1px dotted #81aFFC",
            "background":""
        };
        var mapping = {
            READY: function(g){
                style.border = "1px dotted #F5A9A9"
                $tx.setOpacity(g, 1);
            },
            DRAG: function(g){
                $tx.setOpacity(g, 1);
            },
            NONE: function(g){
                style.border = "1px dotted #CCC"
                $tx.setOpacity(g, 0.5);
            }
        };

        $tx.show(g);
        if(g == this._colGuide){
            style['left'] = (point[0]-(this._win.pageXOffset || this._doc.documentElement.scrollLeft)).toPx();
            style['width'] = "2px";
            style['height'] = this._panel.el.clientHeight.toPx();
            style['background'] = "";
        }else {
            style['top'] = (point[1]-(this._win.pageYOffset || this._doc.documentElement.scrollTop)).toPx();
            style['width'] = this._panel.el.clientWidth.toPx();
            style['height'] = "2px";
            style['background'] = "";
        }
        mapping[state](g);
        this._setGuideStyle(g, style);
    },

    /**
     *
     * @param {[]} point
     * @param {HTMLElement} node
     * @returns {string}
     * @private
     */
    _getType : function(node, point){
        var edgeType = this.EDGE_TYPE.NONE;
        if(!node) return edgeType;
        var MAX_SELECTION = 5;
        var rect = $tx.getOffset(node);
        if ((point[0] - rect.left) < MAX_SELECTION && node.cellIndex != 0) {
            edgeType = this.EDGE_TYPE.LEFT;
        }
        else if ((rect.right - MAX_SELECTION) < point[0]) {
            edgeType = this.EDGE_TYPE.RIGHT;
        }
        else if ((point[1] - rect.top) < MAX_SELECTION && node.parentNode.rowIndex != 0) {
            edgeType = this.EDGE_TYPE.TOP;
        }
        else if ((rect.bottom - MAX_SELECTION) < point[1]) {
            edgeType = this.EDGE_TYPE.BOTTOM;
        }
        return edgeType;
    },
    /**
     * @param {HTMLElement} node
     * @param {[]} point
     * @private
     */
    _setMouseDownData: function(node,point){
        this._mouseData.downPoint = point;
        this._mouseData.downTd = node;
        this._mouseData.downType = this._getType(node, point);
    },
    /**
     * @param {Event} e
     * @return {HTMLElement}
     * @private
     */
    _getTdByEvent: function(e){
        var td = $tom.find($tx.element(e), "td");
        if(!td || $tom.find(td, ".txc-info")) return _NULL;
        return td
    },
    /**
     * @param {[]} array
     * @param {String} type
     * @return {Number}
     * @private
     */
    _minimum: function (array, type) {
        var t = '', min = 0;
        var self = this;
        this._switch(type, function(){
            t = 'width';
            min = self._MINWIDTH;
        }, function(){
            t = 'height';
            min = self._MINHEIGHT;
        });
        var res = array.findAll(function(td){
            return !!td
        }).map(function(td){
            return Trex.TableUtil.getCellOffset(td)[t];
        });
        return (Math.min.apply(Math, res) - min)||0;
    },
    /**
     * @param {String} type
     * @param {Function} wfn
     * @param {Function} hfn
     * @private
     */
    _switch: function(type, wfn, hfn){
        switch (type) {
            case this.EDGE_TYPE.LEFT:
            case this.EDGE_TYPE.RIGHT:
                wfn();
                break;
            case this.EDGE_TYPE.TOP:
            case this.EDGE_TYPE.BOTTOM:
                hfn();
                break;
        }
    },
    /**
     * @param {{expandElements:Array,contractElements:Array}} tdArr
     * @param {Number[]} point
     * @param {String} type
     * @return {Number[]}
     * @private
     */
    _calMinMaxPoint: function (tdArr, point, type){
        var min = this._minimum(tdArr.expandElements, type);
        var max = this._minimum(tdArr.contractElements, type);
        var subPoint = this._subtractPoint(point, this._mouseData.downPoint);
        var x = 0;
        var y = 0;
        this._switch(type, function(){
            x = Math.min(Math.max(subPoint[0] + min, 0), max+min) - min;
        }, function(){
            y = Math.min(Math.max(subPoint[1] + min, 0), max+min) - min;
        });
        return this._addPoint(this._mouseData.downPoint, [x,y]);
    },
    /**
     * @param {HTMLElement} td
     * @returns {Number}
     * @private
     */
    _getTdWidth: function(td){
        return Trex.TableUtil.getCellOffset(td).width;
    },

    /**
     * @param {HTMLElement} td
     * @returns {Number}
     * @private
     */
    _getTdHeight: function(td) {
        return Trex.TableUtil.getCellOffset(td).height;
    },

    /**
     *
     * @param {{expandElements:Array, contractElements:Array}} tdArr
     * @param {String} type
     * @param {Number[]} point
     * @private
     */
    _resize: function(tdArr, point, type){
        var self = this;
        var p = this._subtractPoint(this._calMinMaxPoint(tdArr, point, type), this._mouseData.downPoint);

        this._switch(type, function(){
            self._resizeWidth(tdArr, p[0]);
        }, function(){
            self._resizeHeight(tdArr, p[1]);
        });
        this._canvas.history.saveHistory();

    },
    /**
     * @param {{expandElements:Array, contractElements:Array}} tdArr
     * @param {Number} d
     * @private
     */
    _resizeWidth: function(tdArr, d) {
        var self = this;
        var e = tdArr.expandElements.map(function(td){
           return self._getTdWidth(td);
        });
        var c = tdArr.contractElements.map(function(td){
            return self._getTdWidth(td);
        });
        tdArr.expandElements.each(function(td, i){
            var v = (e[i] + d).toPx();
            td.style.width = v;
            td.width = v;
        });
        tdArr.contractElements.each(function(td,i){
            var v = (c[i] - d).toPx();
            td.style.width = v;
            td.width = v;
        });
        if(tdArr.contractElements.length == 0){
            var table = $tom.find(tdArr.expandElements[0],'table');
            this._resizeTableWidth(table,d)
        }
    },
    _resizeTableWidth: function(table, d) {
        var tableWidth = (Math.min(table.offsetWidth + d, this._canvas.getSizeConfig().contentWidth)).toPx();
        table.width = tableWidth;
        table.style.width = tableWidth;
    },
    _resizeHeight: function(tdArr, d){
        var self = this;
        var e = tdArr.expandElements.map(function(td){
            return self._getTdHeight(td);
        });
        var c = tdArr.contractElements.map(function(td){
            return self._getTdHeight(td);
        });
        tdArr.expandElements.each(function(td, i){
            var v = (e[i] + d).toPx();
            td.style.height = v;
            td.height = v;
        });
        tdArr.contractElements.each(function(td,i){
            var v = (c[i] - d).toPx();
            td.style.height = v;
            td.height = v;
        });
    }
});

Trex.module("table resize dragger", function(editor, toolbar, sidebar, canvas) {
    canvas.observeJob(Trex.Ev.__IFRAME_LOAD_COMPLETE, function() {
        new Trex.Table.Dragger(editor);
    });
});

/**
 * Created by sungwon on 14. 5. 9.
 */
TrexConfig.add(
    {canvas: {exitEditor:{
        desc:'\uc5d0\ub514\ud130 \uc601\uc5ed : \uc5d0\ub514\ud130 \uc601\uc5ed\uc5d0\uc11c \ube60\uc838 \ub098\uc624\uc2dc\ub824\uba74 Shift+ESC\ud0a4\ub97c \ub204\ub974\uc138\uc694',
        hotKey: {
            shiftKey: true,
            keyCode:27
        },
        nextElement: null
    }}}, null);
Trex.module("exit Editor", function(editor, toolbar, sidebar, canvas, config) {
    var _wysiwygPanel = canvas.getPanel(Trex.Canvas.__WYSIWYG_MODE);
    var _elWysiwyg = _wysiwygPanel.el;
    var _config = config.canvas.exitEditor;
    function isSearchElement(searchElement){
        return !($tx.getStyle(searchElement,'display') == 'none'||
            $tx.getStyle(searchElement,'visibility') == 'hidden' ||
            searchElement.tagName.toLowerCase() === 'input' && searchElement.type == 'hidden'||
            searchElement.tagName.toLowerCase() === 'a' && (searchElement.href||'').trim() == ''||
            searchElement.offsetLeft <= 0);
    }
    function execHandler(e){
        try{
            if(_config.nextElement){
                _config.nextElement.focus();
                return;
            }
            var el = _elWysiwyg;
            var pattern = 'button,a,input,select,object';
            var searchElement = null;
            var els = null;
            do{
                var next = $tom.nextContent(el,'#element');
                if($tom.kindOf(next, pattern)){
                    searchElement = next;
                }else {
                    els = $tom.descendants(next, pattern);
                    searchElement = els.find(isSearchElement);
                }
                if(searchElement){
                    if(!isSearchElement(searchElement))
                        searchElement = null;
                }
                el = next;
            }while(!searchElement&&el);
            if(searchElement)
                searchElement.focus();
            else
                canvas.getProcessor().blur();
        }catch(e){
            canvas.getProcessor().blur();
        }
    }

    _elWysiwyg.title = _config.desc;

    canvas.observeKey(_config.hotKey, function(ev){
        $tx.stop(ev);
        execHandler(ev);
    });
});
!function(){
    // config.canvas.autolink \uac12\uc744 true\ub85c \uc124\uc815\ud55c\ub2e4.
    var canvasConfig = TrexConfig.get('canvas');
    canvasConfig.autolink = _TRUE;
}();

Trex.module('paste anchor controller', function(editor, toolbar, sidebar, canvas, config) {
    Trex.Paste.AutolinkConverter = Trex.Class.create({
        initialize: function(){
            this.patternSpace = /\s/;
            this.patternUrl = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/i;
            this.patternLikeIP = /^[\d\.]+$/;
            this.patternIPv4 = /^(\d{2,3})\.(\d{2,3})\.(\d{1,3})\.(\d{1,3})$/;
            this.patternAnchor = /^<a\s+[^>]*>(.+)<\/a>$/i;
        },
        isContainSpace: function(str) {
            return this.patternSpace.test(str.trim());
        },
        isValidUrl: function(str) {
            return !!this.checkValidUrl(str);
        },
        checkValidUrl: function(str) {
            var trimString = str.trim();
            var result = this.parseUrl(trimString);
            var host = (result && result.host) || '';
            var hostSplitDot = host.split('.');
            var hostSplitDotLength = hostSplitDot.length;
            var mayBeIpHost = this.patternLikeIP.test(host);

            if (mayBeIpHost) {
                // IP\ud615\uc2dd\uc73c\ub85c \uc22b\uc790\ub85c\ub9cc \uad6c\uc131\ub41c host\ub294 scheme\uc758 \uc720\ubb34\uc640 \uc0c1\uad00\uc5c6\uc774 \uc0ac\uc6a9\ud558\ub3c4\ub85d \ud55c\ub2e4.
                var ipHost = this.patternIPv4.exec(host);
                if (ipHost && ipHost.length == 5 && ipHost[1] < 256 && ipHost[2] < 256 && ipHost[3] < 256 && ipHost[4] < 256) {
                    return result;
                }
            } else {
                if (result.scheme && hostSplitDotLength >= 2) {
                    // scheme \uc774 \uc788\uc73c\uba74 host\ub294 1\ucc28\ub9cc \uc815\uc758\ub418\uc5b4\ub3c4 \uc0ac\uc6a9 \uac00\ub2a5\ud558\ub2e4.
                    return result;
                } else if (!result.scheme && hostSplitDotLength > 2) {
                    // scheme \uc774 \uc5c6\ub2e4\uba74 host\ub294 2\ucc28\uc774\uc0c1 \uc815\uc758\ub418\uc5b4\uc57c \uc0ac\uc6a9 \uac00\ub2a5\ud558\ub2e4.
                    return result;
                }
            }

            return _FALSE;
        },
        isAnchorTag: function(str) {
            return this.patternAnchor.test(str.trim());
        },
        parseAnchor: function(anchorStr) {
            var matched = anchorStr.match(this.patternAnchor);
            if (matched && matched.length == 2) {
                return matched[1];
            }
            return _NULL;
        },
        parseUrl: function(str) {
            var parseResult = this.patternUrl.exec(str.trim());
            var result = {};
            if (parseResult) {
                result = {
                    'url': parseResult[0],
                    'scheme': parseResult[1],
                    'slash': parseResult[2],
                    'host': parseResult[3],
                    'port': parseResult[4],
                    'path': parseResult[5],
                    'query': parseResult[6],
                    'hash': parseResult[7]
                };
            }
            return result;
        }
    });

    var cleaner = editor.getPasteCleaner();
    var paster = editor.getPaster();
    var autolinkConverter = new Trex.Paste.AutolinkConverter();

    cleaner.addFilter('autolink.control', function(html) {
        var mode = paster.getMode();
        // paste HTML \ubaa8\ub4dc\uc778 \uacbd\uc6b0\uc5d0\ub9cc \ub3d9\uc791\ud55c\ub2e4.
        if (mode != Trex.Paste.MODE_HTML) {
            return html;
        }

        $tx.msie && (html = html.replace(/<meta[^>]*>/gi, ''));// IE\uc5d0\uc11c \uac04\ud639 \ubd88\ud544\uc694\ud55c meta\uac12\uc744 \ud3ec\ud568\ud558\uae30\ub3c4 \ud55c\ub2e4.
        html = html.trim();

        if (config.toolbar.paste.autolink === _TRUE) {
            // \ubb38\uc790\uc5f4 \ub0b4 \uacf5\ubc31\uc774 \uc5c6\uc5b4\uc57c\ub9cc \ud55c\ub2e4.
            if (autolinkConverter.isContainSpace(html) == _FALSE) {
                var result = autolinkConverter.checkValidUrl(html);
                if (result) {
                    var linkUrl = html;
                    if (!result.scheme) {
                        linkUrl = 'http://' + html;
                    }
                    html = ['<a target="_blank" href="', linkUrl, '" class="tx-link">', decodeURIComponent(html), '</a>'].join('');
                }
            }
        } else if (config.toolbar.paste.autolink === _FALSE) {
            if (autolinkConverter.isAnchorTag(html)) {
                var urlText = autolinkConverter.parseAnchor(html);
                if (urlText) {
                    html = urlText;
                }
            }
        } else {
            // null, undefined\ub294 \ube0c\ub77c\uc6b0\uc800 \uae30\ubcf8 \ubaa8\ub4dc\ub85c \ub3d9\uc791\ud558\uac8c \ub41c\ub2e4.
        }
        return html;
    });
});
if (typeof Editor !== "undefined") Editor.version = "7.5.11-2-ga008ba5";
try {
    EditorJSLoader.readyState = 'complete';
    EditorJSLoader.finish();
} catch(e) {
}
})();
